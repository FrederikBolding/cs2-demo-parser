/*eslint-disable block-scoped-var, id-length, no-control-regex, no-magic-numbers, no-prototype-builtins, no-redeclare, no-shadow, no-var, sort-vars*/
(function(global, factory) { /* global define, require, module */

    /* AMD */ if (typeof define === 'function' && define.amd)
        define(["protobufjs/minimal"], factory);

    /* CommonJS */ else if (typeof require === 'function' && typeof module === 'object' && module && module.exports)
        module.exports = factory(require("protobufjs/minimal"));

})(this, function($protobuf) {
    "use strict";

    // Common aliases
    var $Reader = $protobuf.Reader, $Writer = $protobuf.Writer, $util = $protobuf.util;
    
    // Exported root namespace
    var $root = $protobuf.roots["default"] || ($protobuf.roots["default"] = {});
    
    /**
     * P2P_Messages enum.
     * @exports P2P_Messages
     * @enum {number}
     * @property {number} p2p_TextMessage=256 p2p_TextMessage value
     * @property {number} p2p_Voice=257 p2p_Voice value
     * @property {number} p2p_Ping=258 p2p_Ping value
     * @property {number} p2p_VRAvatarPosition=259 p2p_VRAvatarPosition value
     * @property {number} p2p_WatchSynchronization=260 p2p_WatchSynchronization value
     */
    $root.P2P_Messages = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[256] = "p2p_TextMessage"] = 256;
        values[valuesById[257] = "p2p_Voice"] = 257;
        values[valuesById[258] = "p2p_Ping"] = 258;
        values[valuesById[259] = "p2p_VRAvatarPosition"] = 259;
        values[valuesById[260] = "p2p_WatchSynchronization"] = 260;
        return values;
    })();
    
    $root.CP2P_TextMessage = (function() {
    
        /**
         * Properties of a CP2P_TextMessage.
         * @exports ICP2P_TextMessage
         * @interface ICP2P_TextMessage
         * @property {Uint8Array|null} [text] CP2P_TextMessage text
         */
    
        /**
         * Constructs a new CP2P_TextMessage.
         * @exports CP2P_TextMessage
         * @classdesc Represents a CP2P_TextMessage.
         * @implements ICP2P_TextMessage
         * @constructor
         * @param {ICP2P_TextMessage=} [properties] Properties to set
         */
        function CP2P_TextMessage(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CP2P_TextMessage text.
         * @member {Uint8Array} text
         * @memberof CP2P_TextMessage
         * @instance
         */
        CP2P_TextMessage.prototype.text = $util.newBuffer([]);
    
        /**
         * Creates a new CP2P_TextMessage instance using the specified properties.
         * @function create
         * @memberof CP2P_TextMessage
         * @static
         * @param {ICP2P_TextMessage=} [properties] Properties to set
         * @returns {CP2P_TextMessage} CP2P_TextMessage instance
         */
        CP2P_TextMessage.create = function create(properties) {
            return new CP2P_TextMessage(properties);
        };
    
        /**
         * Encodes the specified CP2P_TextMessage message. Does not implicitly {@link CP2P_TextMessage.verify|verify} messages.
         * @function encode
         * @memberof CP2P_TextMessage
         * @static
         * @param {ICP2P_TextMessage} message CP2P_TextMessage message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CP2P_TextMessage.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.text != null && Object.hasOwnProperty.call(message, "text"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.text);
            return writer;
        };
    
        /**
         * Encodes the specified CP2P_TextMessage message, length delimited. Does not implicitly {@link CP2P_TextMessage.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CP2P_TextMessage
         * @static
         * @param {ICP2P_TextMessage} message CP2P_TextMessage message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CP2P_TextMessage.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CP2P_TextMessage message from the specified reader or buffer.
         * @function decode
         * @memberof CP2P_TextMessage
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CP2P_TextMessage} CP2P_TextMessage
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CP2P_TextMessage.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CP2P_TextMessage();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.text = reader.bytes();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CP2P_TextMessage message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CP2P_TextMessage
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CP2P_TextMessage} CP2P_TextMessage
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CP2P_TextMessage.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CP2P_TextMessage message.
         * @function verify
         * @memberof CP2P_TextMessage
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CP2P_TextMessage.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.text != null && message.hasOwnProperty("text"))
                if (!(message.text && typeof message.text.length === "number" || $util.isString(message.text)))
                    return "text: buffer expected";
            return null;
        };
    
        /**
         * Creates a CP2P_TextMessage message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CP2P_TextMessage
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CP2P_TextMessage} CP2P_TextMessage
         */
        CP2P_TextMessage.fromObject = function fromObject(object) {
            if (object instanceof $root.CP2P_TextMessage)
                return object;
            var message = new $root.CP2P_TextMessage();
            if (object.text != null)
                if (typeof object.text === "string")
                    $util.base64.decode(object.text, message.text = $util.newBuffer($util.base64.length(object.text)), 0);
                else if (object.text.length >= 0)
                    message.text = object.text;
            return message;
        };
    
        /**
         * Creates a plain object from a CP2P_TextMessage message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CP2P_TextMessage
         * @static
         * @param {CP2P_TextMessage} message CP2P_TextMessage
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CP2P_TextMessage.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                if (options.bytes === String)
                    object.text = "";
                else {
                    object.text = [];
                    if (options.bytes !== Array)
                        object.text = $util.newBuffer(object.text);
                }
            if (message.text != null && message.hasOwnProperty("text"))
                object.text = options.bytes === String ? $util.base64.encode(message.text, 0, message.text.length) : options.bytes === Array ? Array.prototype.slice.call(message.text) : message.text;
            return object;
        };
    
        /**
         * Converts this CP2P_TextMessage to JSON.
         * @function toJSON
         * @memberof CP2P_TextMessage
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CP2P_TextMessage.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * Gets the default type url for CP2P_TextMessage
         * @function getTypeUrl
         * @memberof CP2P_TextMessage
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        CP2P_TextMessage.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/CP2P_TextMessage";
        };
    
        return CP2P_TextMessage;
    })();
    
    $root.CSteam_Voice_Encoding = (function() {
    
        /**
         * Properties of a CSteam_Voice_Encoding.
         * @exports ICSteam_Voice_Encoding
         * @interface ICSteam_Voice_Encoding
         * @property {Uint8Array|null} [voiceData] CSteam_Voice_Encoding voiceData
         */
    
        /**
         * Constructs a new CSteam_Voice_Encoding.
         * @exports CSteam_Voice_Encoding
         * @classdesc Represents a CSteam_Voice_Encoding.
         * @implements ICSteam_Voice_Encoding
         * @constructor
         * @param {ICSteam_Voice_Encoding=} [properties] Properties to set
         */
        function CSteam_Voice_Encoding(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CSteam_Voice_Encoding voiceData.
         * @member {Uint8Array} voiceData
         * @memberof CSteam_Voice_Encoding
         * @instance
         */
        CSteam_Voice_Encoding.prototype.voiceData = $util.newBuffer([]);
    
        /**
         * Creates a new CSteam_Voice_Encoding instance using the specified properties.
         * @function create
         * @memberof CSteam_Voice_Encoding
         * @static
         * @param {ICSteam_Voice_Encoding=} [properties] Properties to set
         * @returns {CSteam_Voice_Encoding} CSteam_Voice_Encoding instance
         */
        CSteam_Voice_Encoding.create = function create(properties) {
            return new CSteam_Voice_Encoding(properties);
        };
    
        /**
         * Encodes the specified CSteam_Voice_Encoding message. Does not implicitly {@link CSteam_Voice_Encoding.verify|verify} messages.
         * @function encode
         * @memberof CSteam_Voice_Encoding
         * @static
         * @param {ICSteam_Voice_Encoding} message CSteam_Voice_Encoding message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CSteam_Voice_Encoding.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.voiceData != null && Object.hasOwnProperty.call(message, "voiceData"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.voiceData);
            return writer;
        };
    
        /**
         * Encodes the specified CSteam_Voice_Encoding message, length delimited. Does not implicitly {@link CSteam_Voice_Encoding.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CSteam_Voice_Encoding
         * @static
         * @param {ICSteam_Voice_Encoding} message CSteam_Voice_Encoding message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CSteam_Voice_Encoding.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CSteam_Voice_Encoding message from the specified reader or buffer.
         * @function decode
         * @memberof CSteam_Voice_Encoding
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CSteam_Voice_Encoding} CSteam_Voice_Encoding
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CSteam_Voice_Encoding.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CSteam_Voice_Encoding();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.voiceData = reader.bytes();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CSteam_Voice_Encoding message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CSteam_Voice_Encoding
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CSteam_Voice_Encoding} CSteam_Voice_Encoding
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CSteam_Voice_Encoding.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CSteam_Voice_Encoding message.
         * @function verify
         * @memberof CSteam_Voice_Encoding
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CSteam_Voice_Encoding.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.voiceData != null && message.hasOwnProperty("voiceData"))
                if (!(message.voiceData && typeof message.voiceData.length === "number" || $util.isString(message.voiceData)))
                    return "voiceData: buffer expected";
            return null;
        };
    
        /**
         * Creates a CSteam_Voice_Encoding message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CSteam_Voice_Encoding
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CSteam_Voice_Encoding} CSteam_Voice_Encoding
         */
        CSteam_Voice_Encoding.fromObject = function fromObject(object) {
            if (object instanceof $root.CSteam_Voice_Encoding)
                return object;
            var message = new $root.CSteam_Voice_Encoding();
            if (object.voiceData != null)
                if (typeof object.voiceData === "string")
                    $util.base64.decode(object.voiceData, message.voiceData = $util.newBuffer($util.base64.length(object.voiceData)), 0);
                else if (object.voiceData.length >= 0)
                    message.voiceData = object.voiceData;
            return message;
        };
    
        /**
         * Creates a plain object from a CSteam_Voice_Encoding message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CSteam_Voice_Encoding
         * @static
         * @param {CSteam_Voice_Encoding} message CSteam_Voice_Encoding
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CSteam_Voice_Encoding.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                if (options.bytes === String)
                    object.voiceData = "";
                else {
                    object.voiceData = [];
                    if (options.bytes !== Array)
                        object.voiceData = $util.newBuffer(object.voiceData);
                }
            if (message.voiceData != null && message.hasOwnProperty("voiceData"))
                object.voiceData = options.bytes === String ? $util.base64.encode(message.voiceData, 0, message.voiceData.length) : options.bytes === Array ? Array.prototype.slice.call(message.voiceData) : message.voiceData;
            return object;
        };
    
        /**
         * Converts this CSteam_Voice_Encoding to JSON.
         * @function toJSON
         * @memberof CSteam_Voice_Encoding
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CSteam_Voice_Encoding.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * Gets the default type url for CSteam_Voice_Encoding
         * @function getTypeUrl
         * @memberof CSteam_Voice_Encoding
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        CSteam_Voice_Encoding.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/CSteam_Voice_Encoding";
        };
    
        return CSteam_Voice_Encoding;
    })();
    
    $root.CP2P_Voice = (function() {
    
        /**
         * Properties of a CP2P_Voice.
         * @exports ICP2P_Voice
         * @interface ICP2P_Voice
         * @property {ICMsgVoiceAudio|null} [audio] CP2P_Voice audio
         * @property {number|null} [broadcastGroup] CP2P_Voice broadcastGroup
         */
    
        /**
         * Constructs a new CP2P_Voice.
         * @exports CP2P_Voice
         * @classdesc Represents a CP2P_Voice.
         * @implements ICP2P_Voice
         * @constructor
         * @param {ICP2P_Voice=} [properties] Properties to set
         */
        function CP2P_Voice(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CP2P_Voice audio.
         * @member {ICMsgVoiceAudio|null|undefined} audio
         * @memberof CP2P_Voice
         * @instance
         */
        CP2P_Voice.prototype.audio = null;
    
        /**
         * CP2P_Voice broadcastGroup.
         * @member {number} broadcastGroup
         * @memberof CP2P_Voice
         * @instance
         */
        CP2P_Voice.prototype.broadcastGroup = 0;
    
        /**
         * Creates a new CP2P_Voice instance using the specified properties.
         * @function create
         * @memberof CP2P_Voice
         * @static
         * @param {ICP2P_Voice=} [properties] Properties to set
         * @returns {CP2P_Voice} CP2P_Voice instance
         */
        CP2P_Voice.create = function create(properties) {
            return new CP2P_Voice(properties);
        };
    
        /**
         * Encodes the specified CP2P_Voice message. Does not implicitly {@link CP2P_Voice.verify|verify} messages.
         * @function encode
         * @memberof CP2P_Voice
         * @static
         * @param {ICP2P_Voice} message CP2P_Voice message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CP2P_Voice.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.audio != null && Object.hasOwnProperty.call(message, "audio"))
                $root.CMsgVoiceAudio.encode(message.audio, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.broadcastGroup != null && Object.hasOwnProperty.call(message, "broadcastGroup"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.broadcastGroup);
            return writer;
        };
    
        /**
         * Encodes the specified CP2P_Voice message, length delimited. Does not implicitly {@link CP2P_Voice.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CP2P_Voice
         * @static
         * @param {ICP2P_Voice} message CP2P_Voice message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CP2P_Voice.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CP2P_Voice message from the specified reader or buffer.
         * @function decode
         * @memberof CP2P_Voice
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CP2P_Voice} CP2P_Voice
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CP2P_Voice.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CP2P_Voice();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.audio = $root.CMsgVoiceAudio.decode(reader, reader.uint32());
                        break;
                    }
                case 2: {
                        message.broadcastGroup = reader.uint32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CP2P_Voice message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CP2P_Voice
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CP2P_Voice} CP2P_Voice
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CP2P_Voice.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CP2P_Voice message.
         * @function verify
         * @memberof CP2P_Voice
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CP2P_Voice.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.audio != null && message.hasOwnProperty("audio")) {
                var error = $root.CMsgVoiceAudio.verify(message.audio);
                if (error)
                    return "audio." + error;
            }
            if (message.broadcastGroup != null && message.hasOwnProperty("broadcastGroup"))
                if (!$util.isInteger(message.broadcastGroup))
                    return "broadcastGroup: integer expected";
            return null;
        };
    
        /**
         * Creates a CP2P_Voice message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CP2P_Voice
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CP2P_Voice} CP2P_Voice
         */
        CP2P_Voice.fromObject = function fromObject(object) {
            if (object instanceof $root.CP2P_Voice)
                return object;
            var message = new $root.CP2P_Voice();
            if (object.audio != null) {
                if (typeof object.audio !== "object")
                    throw TypeError(".CP2P_Voice.audio: object expected");
                message.audio = $root.CMsgVoiceAudio.fromObject(object.audio);
            }
            if (object.broadcastGroup != null)
                message.broadcastGroup = object.broadcastGroup >>> 0;
            return message;
        };
    
        /**
         * Creates a plain object from a CP2P_Voice message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CP2P_Voice
         * @static
         * @param {CP2P_Voice} message CP2P_Voice
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CP2P_Voice.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.audio = null;
                object.broadcastGroup = 0;
            }
            if (message.audio != null && message.hasOwnProperty("audio"))
                object.audio = $root.CMsgVoiceAudio.toObject(message.audio, options);
            if (message.broadcastGroup != null && message.hasOwnProperty("broadcastGroup"))
                object.broadcastGroup = message.broadcastGroup;
            return object;
        };
    
        /**
         * Converts this CP2P_Voice to JSON.
         * @function toJSON
         * @memberof CP2P_Voice
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CP2P_Voice.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * Gets the default type url for CP2P_Voice
         * @function getTypeUrl
         * @memberof CP2P_Voice
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        CP2P_Voice.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/CP2P_Voice";
        };
    
        /**
         * Handler_Flags enum.
         * @name CP2P_Voice.Handler_Flags
         * @enum {number}
         * @property {number} Played_Audio=1 Played_Audio value
         */
        CP2P_Voice.Handler_Flags = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[1] = "Played_Audio"] = 1;
            return values;
        })();
    
        return CP2P_Voice;
    })();
    
    $root.CP2P_Ping = (function() {
    
        /**
         * Properties of a CP2P_Ping.
         * @exports ICP2P_Ping
         * @interface ICP2P_Ping
         * @property {number|Long} sendTime CP2P_Ping sendTime
         * @property {boolean} isReply CP2P_Ping isReply
         */
    
        /**
         * Constructs a new CP2P_Ping.
         * @exports CP2P_Ping
         * @classdesc Represents a CP2P_Ping.
         * @implements ICP2P_Ping
         * @constructor
         * @param {ICP2P_Ping=} [properties] Properties to set
         */
        function CP2P_Ping(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CP2P_Ping sendTime.
         * @member {number|Long} sendTime
         * @memberof CP2P_Ping
         * @instance
         */
        CP2P_Ping.prototype.sendTime = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
        /**
         * CP2P_Ping isReply.
         * @member {boolean} isReply
         * @memberof CP2P_Ping
         * @instance
         */
        CP2P_Ping.prototype.isReply = false;
    
        /**
         * Creates a new CP2P_Ping instance using the specified properties.
         * @function create
         * @memberof CP2P_Ping
         * @static
         * @param {ICP2P_Ping=} [properties] Properties to set
         * @returns {CP2P_Ping} CP2P_Ping instance
         */
        CP2P_Ping.create = function create(properties) {
            return new CP2P_Ping(properties);
        };
    
        /**
         * Encodes the specified CP2P_Ping message. Does not implicitly {@link CP2P_Ping.verify|verify} messages.
         * @function encode
         * @memberof CP2P_Ping
         * @static
         * @param {ICP2P_Ping} message CP2P_Ping message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CP2P_Ping.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.sendTime);
            writer.uint32(/* id 2, wireType 0 =*/16).bool(message.isReply);
            return writer;
        };
    
        /**
         * Encodes the specified CP2P_Ping message, length delimited. Does not implicitly {@link CP2P_Ping.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CP2P_Ping
         * @static
         * @param {ICP2P_Ping} message CP2P_Ping message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CP2P_Ping.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CP2P_Ping message from the specified reader or buffer.
         * @function decode
         * @memberof CP2P_Ping
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CP2P_Ping} CP2P_Ping
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CP2P_Ping.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CP2P_Ping();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.sendTime = reader.uint64();
                        break;
                    }
                case 2: {
                        message.isReply = reader.bool();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("sendTime"))
                throw $util.ProtocolError("missing required 'sendTime'", { instance: message });
            if (!message.hasOwnProperty("isReply"))
                throw $util.ProtocolError("missing required 'isReply'", { instance: message });
            return message;
        };
    
        /**
         * Decodes a CP2P_Ping message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CP2P_Ping
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CP2P_Ping} CP2P_Ping
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CP2P_Ping.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CP2P_Ping message.
         * @function verify
         * @memberof CP2P_Ping
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CP2P_Ping.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.sendTime) && !(message.sendTime && $util.isInteger(message.sendTime.low) && $util.isInteger(message.sendTime.high)))
                return "sendTime: integer|Long expected";
            if (typeof message.isReply !== "boolean")
                return "isReply: boolean expected";
            return null;
        };
    
        /**
         * Creates a CP2P_Ping message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CP2P_Ping
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CP2P_Ping} CP2P_Ping
         */
        CP2P_Ping.fromObject = function fromObject(object) {
            if (object instanceof $root.CP2P_Ping)
                return object;
            var message = new $root.CP2P_Ping();
            if (object.sendTime != null)
                if ($util.Long)
                    (message.sendTime = $util.Long.fromValue(object.sendTime)).unsigned = true;
                else if (typeof object.sendTime === "string")
                    message.sendTime = parseInt(object.sendTime, 10);
                else if (typeof object.sendTime === "number")
                    message.sendTime = object.sendTime;
                else if (typeof object.sendTime === "object")
                    message.sendTime = new $util.LongBits(object.sendTime.low >>> 0, object.sendTime.high >>> 0).toNumber(true);
            if (object.isReply != null)
                message.isReply = Boolean(object.isReply);
            return message;
        };
    
        /**
         * Creates a plain object from a CP2P_Ping message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CP2P_Ping
         * @static
         * @param {CP2P_Ping} message CP2P_Ping
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CP2P_Ping.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.sendTime = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.sendTime = options.longs === String ? "0" : 0;
                object.isReply = false;
            }
            if (message.sendTime != null && message.hasOwnProperty("sendTime"))
                if (typeof message.sendTime === "number")
                    object.sendTime = options.longs === String ? String(message.sendTime) : message.sendTime;
                else
                    object.sendTime = options.longs === String ? $util.Long.prototype.toString.call(message.sendTime) : options.longs === Number ? new $util.LongBits(message.sendTime.low >>> 0, message.sendTime.high >>> 0).toNumber(true) : message.sendTime;
            if (message.isReply != null && message.hasOwnProperty("isReply"))
                object.isReply = message.isReply;
            return object;
        };
    
        /**
         * Converts this CP2P_Ping to JSON.
         * @function toJSON
         * @memberof CP2P_Ping
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CP2P_Ping.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * Gets the default type url for CP2P_Ping
         * @function getTypeUrl
         * @memberof CP2P_Ping
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        CP2P_Ping.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/CP2P_Ping";
        };
    
        return CP2P_Ping;
    })();
    
    $root.CP2P_VRAvatarPosition = (function() {
    
        /**
         * Properties of a CP2P_VRAvatarPosition.
         * @exports ICP2P_VRAvatarPosition
         * @interface ICP2P_VRAvatarPosition
         * @property {Array.<CP2P_VRAvatarPosition.ICOrientation>|null} [bodyParts] CP2P_VRAvatarPosition bodyParts
         * @property {number|null} [hatId] CP2P_VRAvatarPosition hatId
         * @property {number|null} [sceneId] CP2P_VRAvatarPosition sceneId
         * @property {number|null} [worldScale] CP2P_VRAvatarPosition worldScale
         */
    
        /**
         * Constructs a new CP2P_VRAvatarPosition.
         * @exports CP2P_VRAvatarPosition
         * @classdesc Represents a CP2P_VRAvatarPosition.
         * @implements ICP2P_VRAvatarPosition
         * @constructor
         * @param {ICP2P_VRAvatarPosition=} [properties] Properties to set
         */
        function CP2P_VRAvatarPosition(properties) {
            this.bodyParts = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CP2P_VRAvatarPosition bodyParts.
         * @member {Array.<CP2P_VRAvatarPosition.ICOrientation>} bodyParts
         * @memberof CP2P_VRAvatarPosition
         * @instance
         */
        CP2P_VRAvatarPosition.prototype.bodyParts = $util.emptyArray;
    
        /**
         * CP2P_VRAvatarPosition hatId.
         * @member {number} hatId
         * @memberof CP2P_VRAvatarPosition
         * @instance
         */
        CP2P_VRAvatarPosition.prototype.hatId = 0;
    
        /**
         * CP2P_VRAvatarPosition sceneId.
         * @member {number} sceneId
         * @memberof CP2P_VRAvatarPosition
         * @instance
         */
        CP2P_VRAvatarPosition.prototype.sceneId = 0;
    
        /**
         * CP2P_VRAvatarPosition worldScale.
         * @member {number} worldScale
         * @memberof CP2P_VRAvatarPosition
         * @instance
         */
        CP2P_VRAvatarPosition.prototype.worldScale = 0;
    
        /**
         * Creates a new CP2P_VRAvatarPosition instance using the specified properties.
         * @function create
         * @memberof CP2P_VRAvatarPosition
         * @static
         * @param {ICP2P_VRAvatarPosition=} [properties] Properties to set
         * @returns {CP2P_VRAvatarPosition} CP2P_VRAvatarPosition instance
         */
        CP2P_VRAvatarPosition.create = function create(properties) {
            return new CP2P_VRAvatarPosition(properties);
        };
    
        /**
         * Encodes the specified CP2P_VRAvatarPosition message. Does not implicitly {@link CP2P_VRAvatarPosition.verify|verify} messages.
         * @function encode
         * @memberof CP2P_VRAvatarPosition
         * @static
         * @param {ICP2P_VRAvatarPosition} message CP2P_VRAvatarPosition message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CP2P_VRAvatarPosition.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.bodyParts != null && message.bodyParts.length)
                for (var i = 0; i < message.bodyParts.length; ++i)
                    $root.CP2P_VRAvatarPosition.COrientation.encode(message.bodyParts[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.hatId != null && Object.hasOwnProperty.call(message, "hatId"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.hatId);
            if (message.sceneId != null && Object.hasOwnProperty.call(message, "sceneId"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.sceneId);
            if (message.worldScale != null && Object.hasOwnProperty.call(message, "worldScale"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.worldScale);
            return writer;
        };
    
        /**
         * Encodes the specified CP2P_VRAvatarPosition message, length delimited. Does not implicitly {@link CP2P_VRAvatarPosition.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CP2P_VRAvatarPosition
         * @static
         * @param {ICP2P_VRAvatarPosition} message CP2P_VRAvatarPosition message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CP2P_VRAvatarPosition.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CP2P_VRAvatarPosition message from the specified reader or buffer.
         * @function decode
         * @memberof CP2P_VRAvatarPosition
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CP2P_VRAvatarPosition} CP2P_VRAvatarPosition
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CP2P_VRAvatarPosition.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CP2P_VRAvatarPosition();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        if (!(message.bodyParts && message.bodyParts.length))
                            message.bodyParts = [];
                        message.bodyParts.push($root.CP2P_VRAvatarPosition.COrientation.decode(reader, reader.uint32()));
                        break;
                    }
                case 2: {
                        message.hatId = reader.int32();
                        break;
                    }
                case 3: {
                        message.sceneId = reader.int32();
                        break;
                    }
                case 4: {
                        message.worldScale = reader.int32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CP2P_VRAvatarPosition message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CP2P_VRAvatarPosition
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CP2P_VRAvatarPosition} CP2P_VRAvatarPosition
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CP2P_VRAvatarPosition.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CP2P_VRAvatarPosition message.
         * @function verify
         * @memberof CP2P_VRAvatarPosition
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CP2P_VRAvatarPosition.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.bodyParts != null && message.hasOwnProperty("bodyParts")) {
                if (!Array.isArray(message.bodyParts))
                    return "bodyParts: array expected";
                for (var i = 0; i < message.bodyParts.length; ++i) {
                    var error = $root.CP2P_VRAvatarPosition.COrientation.verify(message.bodyParts[i]);
                    if (error)
                        return "bodyParts." + error;
                }
            }
            if (message.hatId != null && message.hasOwnProperty("hatId"))
                if (!$util.isInteger(message.hatId))
                    return "hatId: integer expected";
            if (message.sceneId != null && message.hasOwnProperty("sceneId"))
                if (!$util.isInteger(message.sceneId))
                    return "sceneId: integer expected";
            if (message.worldScale != null && message.hasOwnProperty("worldScale"))
                if (!$util.isInteger(message.worldScale))
                    return "worldScale: integer expected";
            return null;
        };
    
        /**
         * Creates a CP2P_VRAvatarPosition message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CP2P_VRAvatarPosition
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CP2P_VRAvatarPosition} CP2P_VRAvatarPosition
         */
        CP2P_VRAvatarPosition.fromObject = function fromObject(object) {
            if (object instanceof $root.CP2P_VRAvatarPosition)
                return object;
            var message = new $root.CP2P_VRAvatarPosition();
            if (object.bodyParts) {
                if (!Array.isArray(object.bodyParts))
                    throw TypeError(".CP2P_VRAvatarPosition.bodyParts: array expected");
                message.bodyParts = [];
                for (var i = 0; i < object.bodyParts.length; ++i) {
                    if (typeof object.bodyParts[i] !== "object")
                        throw TypeError(".CP2P_VRAvatarPosition.bodyParts: object expected");
                    message.bodyParts[i] = $root.CP2P_VRAvatarPosition.COrientation.fromObject(object.bodyParts[i]);
                }
            }
            if (object.hatId != null)
                message.hatId = object.hatId | 0;
            if (object.sceneId != null)
                message.sceneId = object.sceneId | 0;
            if (object.worldScale != null)
                message.worldScale = object.worldScale | 0;
            return message;
        };
    
        /**
         * Creates a plain object from a CP2P_VRAvatarPosition message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CP2P_VRAvatarPosition
         * @static
         * @param {CP2P_VRAvatarPosition} message CP2P_VRAvatarPosition
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CP2P_VRAvatarPosition.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.bodyParts = [];
            if (options.defaults) {
                object.hatId = 0;
                object.sceneId = 0;
                object.worldScale = 0;
            }
            if (message.bodyParts && message.bodyParts.length) {
                object.bodyParts = [];
                for (var j = 0; j < message.bodyParts.length; ++j)
                    object.bodyParts[j] = $root.CP2P_VRAvatarPosition.COrientation.toObject(message.bodyParts[j], options);
            }
            if (message.hatId != null && message.hasOwnProperty("hatId"))
                object.hatId = message.hatId;
            if (message.sceneId != null && message.hasOwnProperty("sceneId"))
                object.sceneId = message.sceneId;
            if (message.worldScale != null && message.hasOwnProperty("worldScale"))
                object.worldScale = message.worldScale;
            return object;
        };
    
        /**
         * Converts this CP2P_VRAvatarPosition to JSON.
         * @function toJSON
         * @memberof CP2P_VRAvatarPosition
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CP2P_VRAvatarPosition.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * Gets the default type url for CP2P_VRAvatarPosition
         * @function getTypeUrl
         * @memberof CP2P_VRAvatarPosition
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        CP2P_VRAvatarPosition.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/CP2P_VRAvatarPosition";
        };
    
        CP2P_VRAvatarPosition.COrientation = (function() {
    
            /**
             * Properties of a COrientation.
             * @memberof CP2P_VRAvatarPosition
             * @interface ICOrientation
             * @property {ICMsgVector|null} [pos] COrientation pos
             * @property {ICMsgQAngle|null} [ang] COrientation ang
             */
    
            /**
             * Constructs a new COrientation.
             * @memberof CP2P_VRAvatarPosition
             * @classdesc Represents a COrientation.
             * @implements ICOrientation
             * @constructor
             * @param {CP2P_VRAvatarPosition.ICOrientation=} [properties] Properties to set
             */
            function COrientation(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * COrientation pos.
             * @member {ICMsgVector|null|undefined} pos
             * @memberof CP2P_VRAvatarPosition.COrientation
             * @instance
             */
            COrientation.prototype.pos = null;
    
            /**
             * COrientation ang.
             * @member {ICMsgQAngle|null|undefined} ang
             * @memberof CP2P_VRAvatarPosition.COrientation
             * @instance
             */
            COrientation.prototype.ang = null;
    
            /**
             * Creates a new COrientation instance using the specified properties.
             * @function create
             * @memberof CP2P_VRAvatarPosition.COrientation
             * @static
             * @param {CP2P_VRAvatarPosition.ICOrientation=} [properties] Properties to set
             * @returns {CP2P_VRAvatarPosition.COrientation} COrientation instance
             */
            COrientation.create = function create(properties) {
                return new COrientation(properties);
            };
    
            /**
             * Encodes the specified COrientation message. Does not implicitly {@link CP2P_VRAvatarPosition.COrientation.verify|verify} messages.
             * @function encode
             * @memberof CP2P_VRAvatarPosition.COrientation
             * @static
             * @param {CP2P_VRAvatarPosition.ICOrientation} message COrientation message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            COrientation.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.pos != null && Object.hasOwnProperty.call(message, "pos"))
                    $root.CMsgVector.encode(message.pos, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.ang != null && Object.hasOwnProperty.call(message, "ang"))
                    $root.CMsgQAngle.encode(message.ang, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };
    
            /**
             * Encodes the specified COrientation message, length delimited. Does not implicitly {@link CP2P_VRAvatarPosition.COrientation.verify|verify} messages.
             * @function encodeDelimited
             * @memberof CP2P_VRAvatarPosition.COrientation
             * @static
             * @param {CP2P_VRAvatarPosition.ICOrientation} message COrientation message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            COrientation.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a COrientation message from the specified reader or buffer.
             * @function decode
             * @memberof CP2P_VRAvatarPosition.COrientation
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {CP2P_VRAvatarPosition.COrientation} COrientation
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            COrientation.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CP2P_VRAvatarPosition.COrientation();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.pos = $root.CMsgVector.decode(reader, reader.uint32());
                            break;
                        }
                    case 2: {
                            message.ang = $root.CMsgQAngle.decode(reader, reader.uint32());
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a COrientation message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof CP2P_VRAvatarPosition.COrientation
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {CP2P_VRAvatarPosition.COrientation} COrientation
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            COrientation.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a COrientation message.
             * @function verify
             * @memberof CP2P_VRAvatarPosition.COrientation
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            COrientation.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.pos != null && message.hasOwnProperty("pos")) {
                    var error = $root.CMsgVector.verify(message.pos);
                    if (error)
                        return "pos." + error;
                }
                if (message.ang != null && message.hasOwnProperty("ang")) {
                    var error = $root.CMsgQAngle.verify(message.ang);
                    if (error)
                        return "ang." + error;
                }
                return null;
            };
    
            /**
             * Creates a COrientation message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof CP2P_VRAvatarPosition.COrientation
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {CP2P_VRAvatarPosition.COrientation} COrientation
             */
            COrientation.fromObject = function fromObject(object) {
                if (object instanceof $root.CP2P_VRAvatarPosition.COrientation)
                    return object;
                var message = new $root.CP2P_VRAvatarPosition.COrientation();
                if (object.pos != null) {
                    if (typeof object.pos !== "object")
                        throw TypeError(".CP2P_VRAvatarPosition.COrientation.pos: object expected");
                    message.pos = $root.CMsgVector.fromObject(object.pos);
                }
                if (object.ang != null) {
                    if (typeof object.ang !== "object")
                        throw TypeError(".CP2P_VRAvatarPosition.COrientation.ang: object expected");
                    message.ang = $root.CMsgQAngle.fromObject(object.ang);
                }
                return message;
            };
    
            /**
             * Creates a plain object from a COrientation message. Also converts values to other types if specified.
             * @function toObject
             * @memberof CP2P_VRAvatarPosition.COrientation
             * @static
             * @param {CP2P_VRAvatarPosition.COrientation} message COrientation
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            COrientation.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.pos = null;
                    object.ang = null;
                }
                if (message.pos != null && message.hasOwnProperty("pos"))
                    object.pos = $root.CMsgVector.toObject(message.pos, options);
                if (message.ang != null && message.hasOwnProperty("ang"))
                    object.ang = $root.CMsgQAngle.toObject(message.ang, options);
                return object;
            };
    
            /**
             * Converts this COrientation to JSON.
             * @function toJSON
             * @memberof CP2P_VRAvatarPosition.COrientation
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            COrientation.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            /**
             * Gets the default type url for COrientation
             * @function getTypeUrl
             * @memberof CP2P_VRAvatarPosition.COrientation
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            COrientation.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/CP2P_VRAvatarPosition.COrientation";
            };
    
            return COrientation;
        })();
    
        return CP2P_VRAvatarPosition;
    })();
    
    $root.CP2P_WatchSynchronization = (function() {
    
        /**
         * Properties of a CP2P_WatchSynchronization.
         * @exports ICP2P_WatchSynchronization
         * @interface ICP2P_WatchSynchronization
         * @property {number|null} [demoTick] CP2P_WatchSynchronization demoTick
         * @property {boolean|null} [paused] CP2P_WatchSynchronization paused
         * @property {number|Long|null} [tvListenVoiceIndices] CP2P_WatchSynchronization tvListenVoiceIndices
         * @property {number|null} [dotaSpectatorMode] CP2P_WatchSynchronization dotaSpectatorMode
         * @property {boolean|null} [dotaSpectatorWatchingBroadcaster] CP2P_WatchSynchronization dotaSpectatorWatchingBroadcaster
         * @property {number|null} [dotaSpectatorHeroIndex] CP2P_WatchSynchronization dotaSpectatorHeroIndex
         * @property {number|null} [dotaSpectatorAutospeed] CP2P_WatchSynchronization dotaSpectatorAutospeed
         * @property {number|null} [dotaReplaySpeed] CP2P_WatchSynchronization dotaReplaySpeed
         */
    
        /**
         * Constructs a new CP2P_WatchSynchronization.
         * @exports CP2P_WatchSynchronization
         * @classdesc Represents a CP2P_WatchSynchronization.
         * @implements ICP2P_WatchSynchronization
         * @constructor
         * @param {ICP2P_WatchSynchronization=} [properties] Properties to set
         */
        function CP2P_WatchSynchronization(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CP2P_WatchSynchronization demoTick.
         * @member {number} demoTick
         * @memberof CP2P_WatchSynchronization
         * @instance
         */
        CP2P_WatchSynchronization.prototype.demoTick = 0;
    
        /**
         * CP2P_WatchSynchronization paused.
         * @member {boolean} paused
         * @memberof CP2P_WatchSynchronization
         * @instance
         */
        CP2P_WatchSynchronization.prototype.paused = false;
    
        /**
         * CP2P_WatchSynchronization tvListenVoiceIndices.
         * @member {number|Long} tvListenVoiceIndices
         * @memberof CP2P_WatchSynchronization
         * @instance
         */
        CP2P_WatchSynchronization.prototype.tvListenVoiceIndices = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
        /**
         * CP2P_WatchSynchronization dotaSpectatorMode.
         * @member {number} dotaSpectatorMode
         * @memberof CP2P_WatchSynchronization
         * @instance
         */
        CP2P_WatchSynchronization.prototype.dotaSpectatorMode = 0;
    
        /**
         * CP2P_WatchSynchronization dotaSpectatorWatchingBroadcaster.
         * @member {boolean} dotaSpectatorWatchingBroadcaster
         * @memberof CP2P_WatchSynchronization
         * @instance
         */
        CP2P_WatchSynchronization.prototype.dotaSpectatorWatchingBroadcaster = false;
    
        /**
         * CP2P_WatchSynchronization dotaSpectatorHeroIndex.
         * @member {number} dotaSpectatorHeroIndex
         * @memberof CP2P_WatchSynchronization
         * @instance
         */
        CP2P_WatchSynchronization.prototype.dotaSpectatorHeroIndex = 0;
    
        /**
         * CP2P_WatchSynchronization dotaSpectatorAutospeed.
         * @member {number} dotaSpectatorAutospeed
         * @memberof CP2P_WatchSynchronization
         * @instance
         */
        CP2P_WatchSynchronization.prototype.dotaSpectatorAutospeed = 0;
    
        /**
         * CP2P_WatchSynchronization dotaReplaySpeed.
         * @member {number} dotaReplaySpeed
         * @memberof CP2P_WatchSynchronization
         * @instance
         */
        CP2P_WatchSynchronization.prototype.dotaReplaySpeed = 0;
    
        /**
         * Creates a new CP2P_WatchSynchronization instance using the specified properties.
         * @function create
         * @memberof CP2P_WatchSynchronization
         * @static
         * @param {ICP2P_WatchSynchronization=} [properties] Properties to set
         * @returns {CP2P_WatchSynchronization} CP2P_WatchSynchronization instance
         */
        CP2P_WatchSynchronization.create = function create(properties) {
            return new CP2P_WatchSynchronization(properties);
        };
    
        /**
         * Encodes the specified CP2P_WatchSynchronization message. Does not implicitly {@link CP2P_WatchSynchronization.verify|verify} messages.
         * @function encode
         * @memberof CP2P_WatchSynchronization
         * @static
         * @param {ICP2P_WatchSynchronization} message CP2P_WatchSynchronization message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CP2P_WatchSynchronization.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.demoTick != null && Object.hasOwnProperty.call(message, "demoTick"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.demoTick);
            if (message.paused != null && Object.hasOwnProperty.call(message, "paused"))
                writer.uint32(/* id 2, wireType 0 =*/16).bool(message.paused);
            if (message.tvListenVoiceIndices != null && Object.hasOwnProperty.call(message, "tvListenVoiceIndices"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.tvListenVoiceIndices);
            if (message.dotaSpectatorMode != null && Object.hasOwnProperty.call(message, "dotaSpectatorMode"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.dotaSpectatorMode);
            if (message.dotaSpectatorWatchingBroadcaster != null && Object.hasOwnProperty.call(message, "dotaSpectatorWatchingBroadcaster"))
                writer.uint32(/* id 5, wireType 0 =*/40).bool(message.dotaSpectatorWatchingBroadcaster);
            if (message.dotaSpectatorHeroIndex != null && Object.hasOwnProperty.call(message, "dotaSpectatorHeroIndex"))
                writer.uint32(/* id 6, wireType 0 =*/48).int32(message.dotaSpectatorHeroIndex);
            if (message.dotaSpectatorAutospeed != null && Object.hasOwnProperty.call(message, "dotaSpectatorAutospeed"))
                writer.uint32(/* id 7, wireType 0 =*/56).int32(message.dotaSpectatorAutospeed);
            if (message.dotaReplaySpeed != null && Object.hasOwnProperty.call(message, "dotaReplaySpeed"))
                writer.uint32(/* id 8, wireType 0 =*/64).int32(message.dotaReplaySpeed);
            return writer;
        };
    
        /**
         * Encodes the specified CP2P_WatchSynchronization message, length delimited. Does not implicitly {@link CP2P_WatchSynchronization.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CP2P_WatchSynchronization
         * @static
         * @param {ICP2P_WatchSynchronization} message CP2P_WatchSynchronization message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CP2P_WatchSynchronization.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CP2P_WatchSynchronization message from the specified reader or buffer.
         * @function decode
         * @memberof CP2P_WatchSynchronization
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CP2P_WatchSynchronization} CP2P_WatchSynchronization
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CP2P_WatchSynchronization.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CP2P_WatchSynchronization();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.demoTick = reader.int32();
                        break;
                    }
                case 2: {
                        message.paused = reader.bool();
                        break;
                    }
                case 3: {
                        message.tvListenVoiceIndices = reader.uint64();
                        break;
                    }
                case 4: {
                        message.dotaSpectatorMode = reader.int32();
                        break;
                    }
                case 5: {
                        message.dotaSpectatorWatchingBroadcaster = reader.bool();
                        break;
                    }
                case 6: {
                        message.dotaSpectatorHeroIndex = reader.int32();
                        break;
                    }
                case 7: {
                        message.dotaSpectatorAutospeed = reader.int32();
                        break;
                    }
                case 8: {
                        message.dotaReplaySpeed = reader.int32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CP2P_WatchSynchronization message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CP2P_WatchSynchronization
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CP2P_WatchSynchronization} CP2P_WatchSynchronization
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CP2P_WatchSynchronization.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CP2P_WatchSynchronization message.
         * @function verify
         * @memberof CP2P_WatchSynchronization
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CP2P_WatchSynchronization.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.demoTick != null && message.hasOwnProperty("demoTick"))
                if (!$util.isInteger(message.demoTick))
                    return "demoTick: integer expected";
            if (message.paused != null && message.hasOwnProperty("paused"))
                if (typeof message.paused !== "boolean")
                    return "paused: boolean expected";
            if (message.tvListenVoiceIndices != null && message.hasOwnProperty("tvListenVoiceIndices"))
                if (!$util.isInteger(message.tvListenVoiceIndices) && !(message.tvListenVoiceIndices && $util.isInteger(message.tvListenVoiceIndices.low) && $util.isInteger(message.tvListenVoiceIndices.high)))
                    return "tvListenVoiceIndices: integer|Long expected";
            if (message.dotaSpectatorMode != null && message.hasOwnProperty("dotaSpectatorMode"))
                if (!$util.isInteger(message.dotaSpectatorMode))
                    return "dotaSpectatorMode: integer expected";
            if (message.dotaSpectatorWatchingBroadcaster != null && message.hasOwnProperty("dotaSpectatorWatchingBroadcaster"))
                if (typeof message.dotaSpectatorWatchingBroadcaster !== "boolean")
                    return "dotaSpectatorWatchingBroadcaster: boolean expected";
            if (message.dotaSpectatorHeroIndex != null && message.hasOwnProperty("dotaSpectatorHeroIndex"))
                if (!$util.isInteger(message.dotaSpectatorHeroIndex))
                    return "dotaSpectatorHeroIndex: integer expected";
            if (message.dotaSpectatorAutospeed != null && message.hasOwnProperty("dotaSpectatorAutospeed"))
                if (!$util.isInteger(message.dotaSpectatorAutospeed))
                    return "dotaSpectatorAutospeed: integer expected";
            if (message.dotaReplaySpeed != null && message.hasOwnProperty("dotaReplaySpeed"))
                if (!$util.isInteger(message.dotaReplaySpeed))
                    return "dotaReplaySpeed: integer expected";
            return null;
        };
    
        /**
         * Creates a CP2P_WatchSynchronization message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CP2P_WatchSynchronization
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CP2P_WatchSynchronization} CP2P_WatchSynchronization
         */
        CP2P_WatchSynchronization.fromObject = function fromObject(object) {
            if (object instanceof $root.CP2P_WatchSynchronization)
                return object;
            var message = new $root.CP2P_WatchSynchronization();
            if (object.demoTick != null)
                message.demoTick = object.demoTick | 0;
            if (object.paused != null)
                message.paused = Boolean(object.paused);
            if (object.tvListenVoiceIndices != null)
                if ($util.Long)
                    (message.tvListenVoiceIndices = $util.Long.fromValue(object.tvListenVoiceIndices)).unsigned = true;
                else if (typeof object.tvListenVoiceIndices === "string")
                    message.tvListenVoiceIndices = parseInt(object.tvListenVoiceIndices, 10);
                else if (typeof object.tvListenVoiceIndices === "number")
                    message.tvListenVoiceIndices = object.tvListenVoiceIndices;
                else if (typeof object.tvListenVoiceIndices === "object")
                    message.tvListenVoiceIndices = new $util.LongBits(object.tvListenVoiceIndices.low >>> 0, object.tvListenVoiceIndices.high >>> 0).toNumber(true);
            if (object.dotaSpectatorMode != null)
                message.dotaSpectatorMode = object.dotaSpectatorMode | 0;
            if (object.dotaSpectatorWatchingBroadcaster != null)
                message.dotaSpectatorWatchingBroadcaster = Boolean(object.dotaSpectatorWatchingBroadcaster);
            if (object.dotaSpectatorHeroIndex != null)
                message.dotaSpectatorHeroIndex = object.dotaSpectatorHeroIndex | 0;
            if (object.dotaSpectatorAutospeed != null)
                message.dotaSpectatorAutospeed = object.dotaSpectatorAutospeed | 0;
            if (object.dotaReplaySpeed != null)
                message.dotaReplaySpeed = object.dotaReplaySpeed | 0;
            return message;
        };
    
        /**
         * Creates a plain object from a CP2P_WatchSynchronization message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CP2P_WatchSynchronization
         * @static
         * @param {CP2P_WatchSynchronization} message CP2P_WatchSynchronization
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CP2P_WatchSynchronization.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.demoTick = 0;
                object.paused = false;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.tvListenVoiceIndices = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.tvListenVoiceIndices = options.longs === String ? "0" : 0;
                object.dotaSpectatorMode = 0;
                object.dotaSpectatorWatchingBroadcaster = false;
                object.dotaSpectatorHeroIndex = 0;
                object.dotaSpectatorAutospeed = 0;
                object.dotaReplaySpeed = 0;
            }
            if (message.demoTick != null && message.hasOwnProperty("demoTick"))
                object.demoTick = message.demoTick;
            if (message.paused != null && message.hasOwnProperty("paused"))
                object.paused = message.paused;
            if (message.tvListenVoiceIndices != null && message.hasOwnProperty("tvListenVoiceIndices"))
                if (typeof message.tvListenVoiceIndices === "number")
                    object.tvListenVoiceIndices = options.longs === String ? String(message.tvListenVoiceIndices) : message.tvListenVoiceIndices;
                else
                    object.tvListenVoiceIndices = options.longs === String ? $util.Long.prototype.toString.call(message.tvListenVoiceIndices) : options.longs === Number ? new $util.LongBits(message.tvListenVoiceIndices.low >>> 0, message.tvListenVoiceIndices.high >>> 0).toNumber(true) : message.tvListenVoiceIndices;
            if (message.dotaSpectatorMode != null && message.hasOwnProperty("dotaSpectatorMode"))
                object.dotaSpectatorMode = message.dotaSpectatorMode;
            if (message.dotaSpectatorWatchingBroadcaster != null && message.hasOwnProperty("dotaSpectatorWatchingBroadcaster"))
                object.dotaSpectatorWatchingBroadcaster = message.dotaSpectatorWatchingBroadcaster;
            if (message.dotaSpectatorHeroIndex != null && message.hasOwnProperty("dotaSpectatorHeroIndex"))
                object.dotaSpectatorHeroIndex = message.dotaSpectatorHeroIndex;
            if (message.dotaSpectatorAutospeed != null && message.hasOwnProperty("dotaSpectatorAutospeed"))
                object.dotaSpectatorAutospeed = message.dotaSpectatorAutospeed;
            if (message.dotaReplaySpeed != null && message.hasOwnProperty("dotaReplaySpeed"))
                object.dotaReplaySpeed = message.dotaReplaySpeed;
            return object;
        };
    
        /**
         * Converts this CP2P_WatchSynchronization to JSON.
         * @function toJSON
         * @memberof CP2P_WatchSynchronization
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CP2P_WatchSynchronization.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * Gets the default type url for CP2P_WatchSynchronization
         * @function getTypeUrl
         * @memberof CP2P_WatchSynchronization
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        CP2P_WatchSynchronization.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/CP2P_WatchSynchronization";
        };
    
        return CP2P_WatchSynchronization;
    })();
    
    /**
     * CLC_Messages enum.
     * @exports CLC_Messages
     * @enum {number}
     * @property {number} clc_ClientInfo=20 clc_ClientInfo value
     * @property {number} clc_Move=21 clc_Move value
     * @property {number} clc_VoiceData=22 clc_VoiceData value
     * @property {number} clc_BaselineAck=23 clc_BaselineAck value
     * @property {number} clc_ListenEvents=24 clc_ListenEvents value
     * @property {number} clc_RespondCvarValue=25 clc_RespondCvarValue value
     * @property {number} clc_FileCRCCheck=26 clc_FileCRCCheck value
     * @property {number} clc_LoadingProgress=27 clc_LoadingProgress value
     * @property {number} clc_SplitPlayerConnect=28 clc_SplitPlayerConnect value
     * @property {number} clc_ClientMessage=29 clc_ClientMessage value
     * @property {number} clc_SplitPlayerDisconnect=30 clc_SplitPlayerDisconnect value
     * @property {number} clc_ServerStatus=31 clc_ServerStatus value
     * @property {number} clc_ServerPing=32 clc_ServerPing value
     * @property {number} clc_RequestPause=33 clc_RequestPause value
     * @property {number} clc_CmdKeyValues=34 clc_CmdKeyValues value
     * @property {number} clc_RconServerDetails=35 clc_RconServerDetails value
     * @property {number} clc_HltvReplay=36 clc_HltvReplay value
     */
    $root.CLC_Messages = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[20] = "clc_ClientInfo"] = 20;
        values[valuesById[21] = "clc_Move"] = 21;
        values[valuesById[22] = "clc_VoiceData"] = 22;
        values[valuesById[23] = "clc_BaselineAck"] = 23;
        values[valuesById[24] = "clc_ListenEvents"] = 24;
        values[valuesById[25] = "clc_RespondCvarValue"] = 25;
        values[valuesById[26] = "clc_FileCRCCheck"] = 26;
        values[valuesById[27] = "clc_LoadingProgress"] = 27;
        values[valuesById[28] = "clc_SplitPlayerConnect"] = 28;
        values[valuesById[29] = "clc_ClientMessage"] = 29;
        values[valuesById[30] = "clc_SplitPlayerDisconnect"] = 30;
        values[valuesById[31] = "clc_ServerStatus"] = 31;
        values[valuesById[32] = "clc_ServerPing"] = 32;
        values[valuesById[33] = "clc_RequestPause"] = 33;
        values[valuesById[34] = "clc_CmdKeyValues"] = 34;
        values[valuesById[35] = "clc_RconServerDetails"] = 35;
        values[valuesById[36] = "clc_HltvReplay"] = 36;
        return values;
    })();
    
    /**
     * SVC_Messages enum.
     * @exports SVC_Messages
     * @enum {number}
     * @property {number} svc_ServerInfo=40 svc_ServerInfo value
     * @property {number} svc_FlattenedSerializer=41 svc_FlattenedSerializer value
     * @property {number} svc_ClassInfo=42 svc_ClassInfo value
     * @property {number} svc_SetPause=43 svc_SetPause value
     * @property {number} svc_CreateStringTable=44 svc_CreateStringTable value
     * @property {number} svc_UpdateStringTable=45 svc_UpdateStringTable value
     * @property {number} svc_VoiceInit=46 svc_VoiceInit value
     * @property {number} svc_VoiceData=47 svc_VoiceData value
     * @property {number} svc_Print=48 svc_Print value
     * @property {number} svc_Sounds=49 svc_Sounds value
     * @property {number} svc_SetView=50 svc_SetView value
     * @property {number} svc_ClearAllStringTables=51 svc_ClearAllStringTables value
     * @property {number} svc_CmdKeyValues=52 svc_CmdKeyValues value
     * @property {number} svc_BSPDecal=53 svc_BSPDecal value
     * @property {number} svc_SplitScreen=54 svc_SplitScreen value
     * @property {number} svc_PacketEntities=55 svc_PacketEntities value
     * @property {number} svc_Prefetch=56 svc_Prefetch value
     * @property {number} svc_Menu=57 svc_Menu value
     * @property {number} svc_GetCvarValue=58 svc_GetCvarValue value
     * @property {number} svc_StopSound=59 svc_StopSound value
     * @property {number} svc_PeerList=60 svc_PeerList value
     * @property {number} svc_PacketReliable=61 svc_PacketReliable value
     * @property {number} svc_HLTVStatus=62 svc_HLTVStatus value
     * @property {number} svc_ServerSteamID=63 svc_ServerSteamID value
     * @property {number} svc_FullFrameSplit=70 svc_FullFrameSplit value
     * @property {number} svc_RconServerDetails=71 svc_RconServerDetails value
     * @property {number} svc_UserMessage=72 svc_UserMessage value
     * @property {number} svc_HltvReplay=73 svc_HltvReplay value
     * @property {number} svc_Broadcast_Command=74 svc_Broadcast_Command value
     * @property {number} svc_HltvFixupOperatorStatus=75 svc_HltvFixupOperatorStatus value
     */
    $root.SVC_Messages = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[40] = "svc_ServerInfo"] = 40;
        values[valuesById[41] = "svc_FlattenedSerializer"] = 41;
        values[valuesById[42] = "svc_ClassInfo"] = 42;
        values[valuesById[43] = "svc_SetPause"] = 43;
        values[valuesById[44] = "svc_CreateStringTable"] = 44;
        values[valuesById[45] = "svc_UpdateStringTable"] = 45;
        values[valuesById[46] = "svc_VoiceInit"] = 46;
        values[valuesById[47] = "svc_VoiceData"] = 47;
        values[valuesById[48] = "svc_Print"] = 48;
        values[valuesById[49] = "svc_Sounds"] = 49;
        values[valuesById[50] = "svc_SetView"] = 50;
        values[valuesById[51] = "svc_ClearAllStringTables"] = 51;
        values[valuesById[52] = "svc_CmdKeyValues"] = 52;
        values[valuesById[53] = "svc_BSPDecal"] = 53;
        values[valuesById[54] = "svc_SplitScreen"] = 54;
        values[valuesById[55] = "svc_PacketEntities"] = 55;
        values[valuesById[56] = "svc_Prefetch"] = 56;
        values[valuesById[57] = "svc_Menu"] = 57;
        values[valuesById[58] = "svc_GetCvarValue"] = 58;
        values[valuesById[59] = "svc_StopSound"] = 59;
        values[valuesById[60] = "svc_PeerList"] = 60;
        values[valuesById[61] = "svc_PacketReliable"] = 61;
        values[valuesById[62] = "svc_HLTVStatus"] = 62;
        values[valuesById[63] = "svc_ServerSteamID"] = 63;
        values[valuesById[70] = "svc_FullFrameSplit"] = 70;
        values[valuesById[71] = "svc_RconServerDetails"] = 71;
        values[valuesById[72] = "svc_UserMessage"] = 72;
        values[valuesById[73] = "svc_HltvReplay"] = 73;
        values[valuesById[74] = "svc_Broadcast_Command"] = 74;
        values[valuesById[75] = "svc_HltvFixupOperatorStatus"] = 75;
        return values;
    })();
    
    /**
     * VoiceDataFormat_t enum.
     * @exports VoiceDataFormat_t
     * @enum {number}
     * @property {number} VOICEDATA_FORMAT_STEAM=0 VOICEDATA_FORMAT_STEAM value
     * @property {number} VOICEDATA_FORMAT_ENGINE=1 VOICEDATA_FORMAT_ENGINE value
     * @property {number} VOICEDATA_FORMAT_OPUS=2 VOICEDATA_FORMAT_OPUS value
     */
    $root.VoiceDataFormat_t = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "VOICEDATA_FORMAT_STEAM"] = 0;
        values[valuesById[1] = "VOICEDATA_FORMAT_ENGINE"] = 1;
        values[valuesById[2] = "VOICEDATA_FORMAT_OPUS"] = 2;
        return values;
    })();
    
    /**
     * RequestPause_t enum.
     * @exports RequestPause_t
     * @enum {number}
     * @property {number} RP_PAUSE=0 RP_PAUSE value
     * @property {number} RP_UNPAUSE=1 RP_UNPAUSE value
     * @property {number} RP_TOGGLEPAUSE=2 RP_TOGGLEPAUSE value
     */
    $root.RequestPause_t = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "RP_PAUSE"] = 0;
        values[valuesById[1] = "RP_UNPAUSE"] = 1;
        values[valuesById[2] = "RP_TOGGLEPAUSE"] = 2;
        return values;
    })();
    
    /**
     * PrefetchType enum.
     * @exports PrefetchType
     * @enum {number}
     * @property {number} PFT_SOUND=0 PFT_SOUND value
     */
    $root.PrefetchType = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "PFT_SOUND"] = 0;
        return values;
    })();
    
    /**
     * ESplitScreenMessageType enum.
     * @exports ESplitScreenMessageType
     * @enum {number}
     * @property {number} MSG_SPLITSCREEN_ADDUSER=0 MSG_SPLITSCREEN_ADDUSER value
     * @property {number} MSG_SPLITSCREEN_REMOVEUSER=1 MSG_SPLITSCREEN_REMOVEUSER value
     */
    $root.ESplitScreenMessageType = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "MSG_SPLITSCREEN_ADDUSER"] = 0;
        values[valuesById[1] = "MSG_SPLITSCREEN_REMOVEUSER"] = 1;
        return values;
    })();
    
    /**
     * EQueryCvarValueStatus enum.
     * @exports EQueryCvarValueStatus
     * @enum {number}
     * @property {number} eQueryCvarValueStatus_ValueIntact=0 eQueryCvarValueStatus_ValueIntact value
     * @property {number} eQueryCvarValueStatus_CvarNotFound=1 eQueryCvarValueStatus_CvarNotFound value
     * @property {number} eQueryCvarValueStatus_NotACvar=2 eQueryCvarValueStatus_NotACvar value
     * @property {number} eQueryCvarValueStatus_CvarProtected=3 eQueryCvarValueStatus_CvarProtected value
     */
    $root.EQueryCvarValueStatus = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "eQueryCvarValueStatus_ValueIntact"] = 0;
        values[valuesById[1] = "eQueryCvarValueStatus_CvarNotFound"] = 1;
        values[valuesById[2] = "eQueryCvarValueStatus_NotACvar"] = 2;
        values[valuesById[3] = "eQueryCvarValueStatus_CvarProtected"] = 3;
        return values;
    })();
    
    /**
     * DIALOG_TYPE enum.
     * @exports DIALOG_TYPE
     * @enum {number}
     * @property {number} DIALOG_MSG=0 DIALOG_MSG value
     * @property {number} DIALOG_MENU=1 DIALOG_MENU value
     * @property {number} DIALOG_TEXT=2 DIALOG_TEXT value
     * @property {number} DIALOG_ENTRY=3 DIALOG_ENTRY value
     * @property {number} DIALOG_ASKCONNECT=4 DIALOG_ASKCONNECT value
     */
    $root.DIALOG_TYPE = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "DIALOG_MSG"] = 0;
        values[valuesById[1] = "DIALOG_MENU"] = 1;
        values[valuesById[2] = "DIALOG_TEXT"] = 2;
        values[valuesById[3] = "DIALOG_ENTRY"] = 3;
        values[valuesById[4] = "DIALOG_ASKCONNECT"] = 4;
        return values;
    })();
    
    /**
     * SVC_Messages_LowFrequency enum.
     * @exports SVC_Messages_LowFrequency
     * @enum {number}
     * @property {number} svc_dummy=600 svc_dummy value
     */
    $root.SVC_Messages_LowFrequency = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[600] = "svc_dummy"] = 600;
        return values;
    })();
    
    /**
     * Bidirectional_Messages enum.
     * @exports Bidirectional_Messages
     * @enum {number}
     * @property {number} bi_RebroadcastGameEvent=16 bi_RebroadcastGameEvent value
     * @property {number} bi_RebroadcastSource=17 bi_RebroadcastSource value
     * @property {number} bi_GameEvent=18 bi_GameEvent value
     */
    $root.Bidirectional_Messages = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[16] = "bi_RebroadcastGameEvent"] = 16;
        values[valuesById[17] = "bi_RebroadcastSource"] = 17;
        values[valuesById[18] = "bi_GameEvent"] = 18;
        return values;
    })();
    
    /**
     * Bidirectional_Messages_LowFrequency enum.
     * @exports Bidirectional_Messages_LowFrequency
     * @enum {number}
     * @property {number} bi_RelayInfo=700 bi_RelayInfo value
     * @property {number} bi_RelayPacket=701 bi_RelayPacket value
     */
    $root.Bidirectional_Messages_LowFrequency = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[700] = "bi_RelayInfo"] = 700;
        values[valuesById[701] = "bi_RelayPacket"] = 701;
        return values;
    })();
    
    /**
     * ReplayEventType_t enum.
     * @exports ReplayEventType_t
     * @enum {number}
     * @property {number} REPLAY_EVENT_CANCEL=0 REPLAY_EVENT_CANCEL value
     * @property {number} REPLAY_EVENT_DEATH=1 REPLAY_EVENT_DEATH value
     * @property {number} REPLAY_EVENT_GENERIC=2 REPLAY_EVENT_GENERIC value
     * @property {number} REPLAY_EVENT_STUCK_NEED_FULL_UPDATE=3 REPLAY_EVENT_STUCK_NEED_FULL_UPDATE value
     * @property {number} REPLAY_EVENT_VICTORY=4 REPLAY_EVENT_VICTORY value
     */
    $root.ReplayEventType_t = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "REPLAY_EVENT_CANCEL"] = 0;
        values[valuesById[1] = "REPLAY_EVENT_DEATH"] = 1;
        values[valuesById[2] = "REPLAY_EVENT_GENERIC"] = 2;
        values[valuesById[3] = "REPLAY_EVENT_STUCK_NEED_FULL_UPDATE"] = 3;
        values[valuesById[4] = "REPLAY_EVENT_VICTORY"] = 4;
        return values;
    })();
    
    $root.CCLCMsg_ClientInfo = (function() {
    
        /**
         * Properties of a CCLCMsg_ClientInfo.
         * @exports ICCLCMsg_ClientInfo
         * @interface ICCLCMsg_ClientInfo
         * @property {number|null} [sendTableCrc] CCLCMsg_ClientInfo sendTableCrc
         * @property {number|null} [serverCount] CCLCMsg_ClientInfo serverCount
         * @property {boolean|null} [isHltv] CCLCMsg_ClientInfo isHltv
         * @property {number|null} [friendsId] CCLCMsg_ClientInfo friendsId
         * @property {string|null} [friendsName] CCLCMsg_ClientInfo friendsName
         */
    
        /**
         * Constructs a new CCLCMsg_ClientInfo.
         * @exports CCLCMsg_ClientInfo
         * @classdesc Represents a CCLCMsg_ClientInfo.
         * @implements ICCLCMsg_ClientInfo
         * @constructor
         * @param {ICCLCMsg_ClientInfo=} [properties] Properties to set
         */
        function CCLCMsg_ClientInfo(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CCLCMsg_ClientInfo sendTableCrc.
         * @member {number} sendTableCrc
         * @memberof CCLCMsg_ClientInfo
         * @instance
         */
        CCLCMsg_ClientInfo.prototype.sendTableCrc = 0;
    
        /**
         * CCLCMsg_ClientInfo serverCount.
         * @member {number} serverCount
         * @memberof CCLCMsg_ClientInfo
         * @instance
         */
        CCLCMsg_ClientInfo.prototype.serverCount = 0;
    
        /**
         * CCLCMsg_ClientInfo isHltv.
         * @member {boolean} isHltv
         * @memberof CCLCMsg_ClientInfo
         * @instance
         */
        CCLCMsg_ClientInfo.prototype.isHltv = false;
    
        /**
         * CCLCMsg_ClientInfo friendsId.
         * @member {number} friendsId
         * @memberof CCLCMsg_ClientInfo
         * @instance
         */
        CCLCMsg_ClientInfo.prototype.friendsId = 0;
    
        /**
         * CCLCMsg_ClientInfo friendsName.
         * @member {string} friendsName
         * @memberof CCLCMsg_ClientInfo
         * @instance
         */
        CCLCMsg_ClientInfo.prototype.friendsName = "";
    
        /**
         * Creates a new CCLCMsg_ClientInfo instance using the specified properties.
         * @function create
         * @memberof CCLCMsg_ClientInfo
         * @static
         * @param {ICCLCMsg_ClientInfo=} [properties] Properties to set
         * @returns {CCLCMsg_ClientInfo} CCLCMsg_ClientInfo instance
         */
        CCLCMsg_ClientInfo.create = function create(properties) {
            return new CCLCMsg_ClientInfo(properties);
        };
    
        /**
         * Encodes the specified CCLCMsg_ClientInfo message. Does not implicitly {@link CCLCMsg_ClientInfo.verify|verify} messages.
         * @function encode
         * @memberof CCLCMsg_ClientInfo
         * @static
         * @param {ICCLCMsg_ClientInfo} message CCLCMsg_ClientInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CCLCMsg_ClientInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.sendTableCrc != null && Object.hasOwnProperty.call(message, "sendTableCrc"))
                writer.uint32(/* id 1, wireType 5 =*/13).fixed32(message.sendTableCrc);
            if (message.serverCount != null && Object.hasOwnProperty.call(message, "serverCount"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.serverCount);
            if (message.isHltv != null && Object.hasOwnProperty.call(message, "isHltv"))
                writer.uint32(/* id 3, wireType 0 =*/24).bool(message.isHltv);
            if (message.friendsId != null && Object.hasOwnProperty.call(message, "friendsId"))
                writer.uint32(/* id 5, wireType 0 =*/40).uint32(message.friendsId);
            if (message.friendsName != null && Object.hasOwnProperty.call(message, "friendsName"))
                writer.uint32(/* id 6, wireType 2 =*/50).string(message.friendsName);
            return writer;
        };
    
        /**
         * Encodes the specified CCLCMsg_ClientInfo message, length delimited. Does not implicitly {@link CCLCMsg_ClientInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CCLCMsg_ClientInfo
         * @static
         * @param {ICCLCMsg_ClientInfo} message CCLCMsg_ClientInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CCLCMsg_ClientInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CCLCMsg_ClientInfo message from the specified reader or buffer.
         * @function decode
         * @memberof CCLCMsg_ClientInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CCLCMsg_ClientInfo} CCLCMsg_ClientInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CCLCMsg_ClientInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CCLCMsg_ClientInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.sendTableCrc = reader.fixed32();
                        break;
                    }
                case 2: {
                        message.serverCount = reader.uint32();
                        break;
                    }
                case 3: {
                        message.isHltv = reader.bool();
                        break;
                    }
                case 5: {
                        message.friendsId = reader.uint32();
                        break;
                    }
                case 6: {
                        message.friendsName = reader.string();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CCLCMsg_ClientInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CCLCMsg_ClientInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CCLCMsg_ClientInfo} CCLCMsg_ClientInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CCLCMsg_ClientInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CCLCMsg_ClientInfo message.
         * @function verify
         * @memberof CCLCMsg_ClientInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CCLCMsg_ClientInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.sendTableCrc != null && message.hasOwnProperty("sendTableCrc"))
                if (!$util.isInteger(message.sendTableCrc))
                    return "sendTableCrc: integer expected";
            if (message.serverCount != null && message.hasOwnProperty("serverCount"))
                if (!$util.isInteger(message.serverCount))
                    return "serverCount: integer expected";
            if (message.isHltv != null && message.hasOwnProperty("isHltv"))
                if (typeof message.isHltv !== "boolean")
                    return "isHltv: boolean expected";
            if (message.friendsId != null && message.hasOwnProperty("friendsId"))
                if (!$util.isInteger(message.friendsId))
                    return "friendsId: integer expected";
            if (message.friendsName != null && message.hasOwnProperty("friendsName"))
                if (!$util.isString(message.friendsName))
                    return "friendsName: string expected";
            return null;
        };
    
        /**
         * Creates a CCLCMsg_ClientInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CCLCMsg_ClientInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CCLCMsg_ClientInfo} CCLCMsg_ClientInfo
         */
        CCLCMsg_ClientInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.CCLCMsg_ClientInfo)
                return object;
            var message = new $root.CCLCMsg_ClientInfo();
            if (object.sendTableCrc != null)
                message.sendTableCrc = object.sendTableCrc >>> 0;
            if (object.serverCount != null)
                message.serverCount = object.serverCount >>> 0;
            if (object.isHltv != null)
                message.isHltv = Boolean(object.isHltv);
            if (object.friendsId != null)
                message.friendsId = object.friendsId >>> 0;
            if (object.friendsName != null)
                message.friendsName = String(object.friendsName);
            return message;
        };
    
        /**
         * Creates a plain object from a CCLCMsg_ClientInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CCLCMsg_ClientInfo
         * @static
         * @param {CCLCMsg_ClientInfo} message CCLCMsg_ClientInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CCLCMsg_ClientInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.sendTableCrc = 0;
                object.serverCount = 0;
                object.isHltv = false;
                object.friendsId = 0;
                object.friendsName = "";
            }
            if (message.sendTableCrc != null && message.hasOwnProperty("sendTableCrc"))
                object.sendTableCrc = message.sendTableCrc;
            if (message.serverCount != null && message.hasOwnProperty("serverCount"))
                object.serverCount = message.serverCount;
            if (message.isHltv != null && message.hasOwnProperty("isHltv"))
                object.isHltv = message.isHltv;
            if (message.friendsId != null && message.hasOwnProperty("friendsId"))
                object.friendsId = message.friendsId;
            if (message.friendsName != null && message.hasOwnProperty("friendsName"))
                object.friendsName = message.friendsName;
            return object;
        };
    
        /**
         * Converts this CCLCMsg_ClientInfo to JSON.
         * @function toJSON
         * @memberof CCLCMsg_ClientInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CCLCMsg_ClientInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * Gets the default type url for CCLCMsg_ClientInfo
         * @function getTypeUrl
         * @memberof CCLCMsg_ClientInfo
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        CCLCMsg_ClientInfo.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/CCLCMsg_ClientInfo";
        };
    
        return CCLCMsg_ClientInfo;
    })();
    
    $root.CCLCMsg_Move = (function() {
    
        /**
         * Properties of a CCLCMsg_Move.
         * @exports ICCLCMsg_Move
         * @interface ICCLCMsg_Move
         * @property {Uint8Array|null} [data] CCLCMsg_Move data
         * @property {number|null} [commandNumber] CCLCMsg_Move commandNumber
         * @property {number|null} [numCommands] CCLCMsg_Move numCommands
         */
    
        /**
         * Constructs a new CCLCMsg_Move.
         * @exports CCLCMsg_Move
         * @classdesc Represents a CCLCMsg_Move.
         * @implements ICCLCMsg_Move
         * @constructor
         * @param {ICCLCMsg_Move=} [properties] Properties to set
         */
        function CCLCMsg_Move(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CCLCMsg_Move data.
         * @member {Uint8Array} data
         * @memberof CCLCMsg_Move
         * @instance
         */
        CCLCMsg_Move.prototype.data = $util.newBuffer([]);
    
        /**
         * CCLCMsg_Move commandNumber.
         * @member {number} commandNumber
         * @memberof CCLCMsg_Move
         * @instance
         */
        CCLCMsg_Move.prototype.commandNumber = 0;
    
        /**
         * CCLCMsg_Move numCommands.
         * @member {number} numCommands
         * @memberof CCLCMsg_Move
         * @instance
         */
        CCLCMsg_Move.prototype.numCommands = 0;
    
        /**
         * Creates a new CCLCMsg_Move instance using the specified properties.
         * @function create
         * @memberof CCLCMsg_Move
         * @static
         * @param {ICCLCMsg_Move=} [properties] Properties to set
         * @returns {CCLCMsg_Move} CCLCMsg_Move instance
         */
        CCLCMsg_Move.create = function create(properties) {
            return new CCLCMsg_Move(properties);
        };
    
        /**
         * Encodes the specified CCLCMsg_Move message. Does not implicitly {@link CCLCMsg_Move.verify|verify} messages.
         * @function encode
         * @memberof CCLCMsg_Move
         * @static
         * @param {ICCLCMsg_Move} message CCLCMsg_Move message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CCLCMsg_Move.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.data != null && Object.hasOwnProperty.call(message, "data"))
                writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.data);
            if (message.commandNumber != null && Object.hasOwnProperty.call(message, "commandNumber"))
                writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.commandNumber);
            if (message.numCommands != null && Object.hasOwnProperty.call(message, "numCommands"))
                writer.uint32(/* id 5, wireType 0 =*/40).uint32(message.numCommands);
            return writer;
        };
    
        /**
         * Encodes the specified CCLCMsg_Move message, length delimited. Does not implicitly {@link CCLCMsg_Move.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CCLCMsg_Move
         * @static
         * @param {ICCLCMsg_Move} message CCLCMsg_Move message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CCLCMsg_Move.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CCLCMsg_Move message from the specified reader or buffer.
         * @function decode
         * @memberof CCLCMsg_Move
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CCLCMsg_Move} CCLCMsg_Move
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CCLCMsg_Move.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CCLCMsg_Move();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 3: {
                        message.data = reader.bytes();
                        break;
                    }
                case 4: {
                        message.commandNumber = reader.uint32();
                        break;
                    }
                case 5: {
                        message.numCommands = reader.uint32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CCLCMsg_Move message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CCLCMsg_Move
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CCLCMsg_Move} CCLCMsg_Move
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CCLCMsg_Move.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CCLCMsg_Move message.
         * @function verify
         * @memberof CCLCMsg_Move
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CCLCMsg_Move.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.data != null && message.hasOwnProperty("data"))
                if (!(message.data && typeof message.data.length === "number" || $util.isString(message.data)))
                    return "data: buffer expected";
            if (message.commandNumber != null && message.hasOwnProperty("commandNumber"))
                if (!$util.isInteger(message.commandNumber))
                    return "commandNumber: integer expected";
            if (message.numCommands != null && message.hasOwnProperty("numCommands"))
                if (!$util.isInteger(message.numCommands))
                    return "numCommands: integer expected";
            return null;
        };
    
        /**
         * Creates a CCLCMsg_Move message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CCLCMsg_Move
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CCLCMsg_Move} CCLCMsg_Move
         */
        CCLCMsg_Move.fromObject = function fromObject(object) {
            if (object instanceof $root.CCLCMsg_Move)
                return object;
            var message = new $root.CCLCMsg_Move();
            if (object.data != null)
                if (typeof object.data === "string")
                    $util.base64.decode(object.data, message.data = $util.newBuffer($util.base64.length(object.data)), 0);
                else if (object.data.length >= 0)
                    message.data = object.data;
            if (object.commandNumber != null)
                message.commandNumber = object.commandNumber >>> 0;
            if (object.numCommands != null)
                message.numCommands = object.numCommands >>> 0;
            return message;
        };
    
        /**
         * Creates a plain object from a CCLCMsg_Move message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CCLCMsg_Move
         * @static
         * @param {CCLCMsg_Move} message CCLCMsg_Move
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CCLCMsg_Move.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if (options.bytes === String)
                    object.data = "";
                else {
                    object.data = [];
                    if (options.bytes !== Array)
                        object.data = $util.newBuffer(object.data);
                }
                object.commandNumber = 0;
                object.numCommands = 0;
            }
            if (message.data != null && message.hasOwnProperty("data"))
                object.data = options.bytes === String ? $util.base64.encode(message.data, 0, message.data.length) : options.bytes === Array ? Array.prototype.slice.call(message.data) : message.data;
            if (message.commandNumber != null && message.hasOwnProperty("commandNumber"))
                object.commandNumber = message.commandNumber;
            if (message.numCommands != null && message.hasOwnProperty("numCommands"))
                object.numCommands = message.numCommands;
            return object;
        };
    
        /**
         * Converts this CCLCMsg_Move to JSON.
         * @function toJSON
         * @memberof CCLCMsg_Move
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CCLCMsg_Move.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * Gets the default type url for CCLCMsg_Move
         * @function getTypeUrl
         * @memberof CCLCMsg_Move
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        CCLCMsg_Move.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/CCLCMsg_Move";
        };
    
        return CCLCMsg_Move;
    })();
    
    $root.CMsgVoiceAudio = (function() {
    
        /**
         * Properties of a CMsgVoiceAudio.
         * @exports ICMsgVoiceAudio
         * @interface ICMsgVoiceAudio
         * @property {VoiceDataFormat_t|null} [format] CMsgVoiceAudio format
         * @property {Uint8Array|null} [voiceData] CMsgVoiceAudio voiceData
         * @property {number|null} [sequenceBytes] CMsgVoiceAudio sequenceBytes
         * @property {number|null} [sectionNumber] CMsgVoiceAudio sectionNumber
         * @property {number|null} [sampleRate] CMsgVoiceAudio sampleRate
         * @property {number|null} [uncompressedSampleOffset] CMsgVoiceAudio uncompressedSampleOffset
         * @property {number|null} [numPackets] CMsgVoiceAudio numPackets
         * @property {Array.<number>|null} [packetOffsets] CMsgVoiceAudio packetOffsets
         * @property {number|null} [voiceLevel] CMsgVoiceAudio voiceLevel
         */
    
        /**
         * Constructs a new CMsgVoiceAudio.
         * @exports CMsgVoiceAudio
         * @classdesc Represents a CMsgVoiceAudio.
         * @implements ICMsgVoiceAudio
         * @constructor
         * @param {ICMsgVoiceAudio=} [properties] Properties to set
         */
        function CMsgVoiceAudio(properties) {
            this.packetOffsets = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CMsgVoiceAudio format.
         * @member {VoiceDataFormat_t} format
         * @memberof CMsgVoiceAudio
         * @instance
         */
        CMsgVoiceAudio.prototype.format = 0;
    
        /**
         * CMsgVoiceAudio voiceData.
         * @member {Uint8Array} voiceData
         * @memberof CMsgVoiceAudio
         * @instance
         */
        CMsgVoiceAudio.prototype.voiceData = $util.newBuffer([]);
    
        /**
         * CMsgVoiceAudio sequenceBytes.
         * @member {number} sequenceBytes
         * @memberof CMsgVoiceAudio
         * @instance
         */
        CMsgVoiceAudio.prototype.sequenceBytes = 0;
    
        /**
         * CMsgVoiceAudio sectionNumber.
         * @member {number} sectionNumber
         * @memberof CMsgVoiceAudio
         * @instance
         */
        CMsgVoiceAudio.prototype.sectionNumber = 0;
    
        /**
         * CMsgVoiceAudio sampleRate.
         * @member {number} sampleRate
         * @memberof CMsgVoiceAudio
         * @instance
         */
        CMsgVoiceAudio.prototype.sampleRate = 0;
    
        /**
         * CMsgVoiceAudio uncompressedSampleOffset.
         * @member {number} uncompressedSampleOffset
         * @memberof CMsgVoiceAudio
         * @instance
         */
        CMsgVoiceAudio.prototype.uncompressedSampleOffset = 0;
    
        /**
         * CMsgVoiceAudio numPackets.
         * @member {number} numPackets
         * @memberof CMsgVoiceAudio
         * @instance
         */
        CMsgVoiceAudio.prototype.numPackets = 0;
    
        /**
         * CMsgVoiceAudio packetOffsets.
         * @member {Array.<number>} packetOffsets
         * @memberof CMsgVoiceAudio
         * @instance
         */
        CMsgVoiceAudio.prototype.packetOffsets = $util.emptyArray;
    
        /**
         * CMsgVoiceAudio voiceLevel.
         * @member {number} voiceLevel
         * @memberof CMsgVoiceAudio
         * @instance
         */
        CMsgVoiceAudio.prototype.voiceLevel = 0;
    
        /**
         * Creates a new CMsgVoiceAudio instance using the specified properties.
         * @function create
         * @memberof CMsgVoiceAudio
         * @static
         * @param {ICMsgVoiceAudio=} [properties] Properties to set
         * @returns {CMsgVoiceAudio} CMsgVoiceAudio instance
         */
        CMsgVoiceAudio.create = function create(properties) {
            return new CMsgVoiceAudio(properties);
        };
    
        /**
         * Encodes the specified CMsgVoiceAudio message. Does not implicitly {@link CMsgVoiceAudio.verify|verify} messages.
         * @function encode
         * @memberof CMsgVoiceAudio
         * @static
         * @param {ICMsgVoiceAudio} message CMsgVoiceAudio message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CMsgVoiceAudio.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.format != null && Object.hasOwnProperty.call(message, "format"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.format);
            if (message.voiceData != null && Object.hasOwnProperty.call(message, "voiceData"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.voiceData);
            if (message.sequenceBytes != null && Object.hasOwnProperty.call(message, "sequenceBytes"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.sequenceBytes);
            if (message.sectionNumber != null && Object.hasOwnProperty.call(message, "sectionNumber"))
                writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.sectionNumber);
            if (message.sampleRate != null && Object.hasOwnProperty.call(message, "sampleRate"))
                writer.uint32(/* id 5, wireType 0 =*/40).uint32(message.sampleRate);
            if (message.uncompressedSampleOffset != null && Object.hasOwnProperty.call(message, "uncompressedSampleOffset"))
                writer.uint32(/* id 6, wireType 0 =*/48).uint32(message.uncompressedSampleOffset);
            if (message.numPackets != null && Object.hasOwnProperty.call(message, "numPackets"))
                writer.uint32(/* id 7, wireType 0 =*/56).uint32(message.numPackets);
            if (message.packetOffsets != null && message.packetOffsets.length) {
                writer.uint32(/* id 8, wireType 2 =*/66).fork();
                for (var i = 0; i < message.packetOffsets.length; ++i)
                    writer.uint32(message.packetOffsets[i]);
                writer.ldelim();
            }
            if (message.voiceLevel != null && Object.hasOwnProperty.call(message, "voiceLevel"))
                writer.uint32(/* id 9, wireType 5 =*/77).float(message.voiceLevel);
            return writer;
        };
    
        /**
         * Encodes the specified CMsgVoiceAudio message, length delimited. Does not implicitly {@link CMsgVoiceAudio.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CMsgVoiceAudio
         * @static
         * @param {ICMsgVoiceAudio} message CMsgVoiceAudio message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CMsgVoiceAudio.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CMsgVoiceAudio message from the specified reader or buffer.
         * @function decode
         * @memberof CMsgVoiceAudio
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CMsgVoiceAudio} CMsgVoiceAudio
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CMsgVoiceAudio.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgVoiceAudio();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.format = reader.int32();
                        break;
                    }
                case 2: {
                        message.voiceData = reader.bytes();
                        break;
                    }
                case 3: {
                        message.sequenceBytes = reader.int32();
                        break;
                    }
                case 4: {
                        message.sectionNumber = reader.uint32();
                        break;
                    }
                case 5: {
                        message.sampleRate = reader.uint32();
                        break;
                    }
                case 6: {
                        message.uncompressedSampleOffset = reader.uint32();
                        break;
                    }
                case 7: {
                        message.numPackets = reader.uint32();
                        break;
                    }
                case 8: {
                        if (!(message.packetOffsets && message.packetOffsets.length))
                            message.packetOffsets = [];
                        if ((tag & 7) === 2) {
                            var end2 = reader.uint32() + reader.pos;
                            while (reader.pos < end2)
                                message.packetOffsets.push(reader.uint32());
                        } else
                            message.packetOffsets.push(reader.uint32());
                        break;
                    }
                case 9: {
                        message.voiceLevel = reader.float();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CMsgVoiceAudio message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CMsgVoiceAudio
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CMsgVoiceAudio} CMsgVoiceAudio
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CMsgVoiceAudio.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CMsgVoiceAudio message.
         * @function verify
         * @memberof CMsgVoiceAudio
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CMsgVoiceAudio.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.format != null && message.hasOwnProperty("format"))
                switch (message.format) {
                default:
                    return "format: enum value expected";
                case 0:
                case 1:
                case 2:
                    break;
                }
            if (message.voiceData != null && message.hasOwnProperty("voiceData"))
                if (!(message.voiceData && typeof message.voiceData.length === "number" || $util.isString(message.voiceData)))
                    return "voiceData: buffer expected";
            if (message.sequenceBytes != null && message.hasOwnProperty("sequenceBytes"))
                if (!$util.isInteger(message.sequenceBytes))
                    return "sequenceBytes: integer expected";
            if (message.sectionNumber != null && message.hasOwnProperty("sectionNumber"))
                if (!$util.isInteger(message.sectionNumber))
                    return "sectionNumber: integer expected";
            if (message.sampleRate != null && message.hasOwnProperty("sampleRate"))
                if (!$util.isInteger(message.sampleRate))
                    return "sampleRate: integer expected";
            if (message.uncompressedSampleOffset != null && message.hasOwnProperty("uncompressedSampleOffset"))
                if (!$util.isInteger(message.uncompressedSampleOffset))
                    return "uncompressedSampleOffset: integer expected";
            if (message.numPackets != null && message.hasOwnProperty("numPackets"))
                if (!$util.isInteger(message.numPackets))
                    return "numPackets: integer expected";
            if (message.packetOffsets != null && message.hasOwnProperty("packetOffsets")) {
                if (!Array.isArray(message.packetOffsets))
                    return "packetOffsets: array expected";
                for (var i = 0; i < message.packetOffsets.length; ++i)
                    if (!$util.isInteger(message.packetOffsets[i]))
                        return "packetOffsets: integer[] expected";
            }
            if (message.voiceLevel != null && message.hasOwnProperty("voiceLevel"))
                if (typeof message.voiceLevel !== "number")
                    return "voiceLevel: number expected";
            return null;
        };
    
        /**
         * Creates a CMsgVoiceAudio message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CMsgVoiceAudio
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CMsgVoiceAudio} CMsgVoiceAudio
         */
        CMsgVoiceAudio.fromObject = function fromObject(object) {
            if (object instanceof $root.CMsgVoiceAudio)
                return object;
            var message = new $root.CMsgVoiceAudio();
            switch (object.format) {
            default:
                if (typeof object.format === "number") {
                    message.format = object.format;
                    break;
                }
                break;
            case "VOICEDATA_FORMAT_STEAM":
            case 0:
                message.format = 0;
                break;
            case "VOICEDATA_FORMAT_ENGINE":
            case 1:
                message.format = 1;
                break;
            case "VOICEDATA_FORMAT_OPUS":
            case 2:
                message.format = 2;
                break;
            }
            if (object.voiceData != null)
                if (typeof object.voiceData === "string")
                    $util.base64.decode(object.voiceData, message.voiceData = $util.newBuffer($util.base64.length(object.voiceData)), 0);
                else if (object.voiceData.length >= 0)
                    message.voiceData = object.voiceData;
            if (object.sequenceBytes != null)
                message.sequenceBytes = object.sequenceBytes | 0;
            if (object.sectionNumber != null)
                message.sectionNumber = object.sectionNumber >>> 0;
            if (object.sampleRate != null)
                message.sampleRate = object.sampleRate >>> 0;
            if (object.uncompressedSampleOffset != null)
                message.uncompressedSampleOffset = object.uncompressedSampleOffset >>> 0;
            if (object.numPackets != null)
                message.numPackets = object.numPackets >>> 0;
            if (object.packetOffsets) {
                if (!Array.isArray(object.packetOffsets))
                    throw TypeError(".CMsgVoiceAudio.packetOffsets: array expected");
                message.packetOffsets = [];
                for (var i = 0; i < object.packetOffsets.length; ++i)
                    message.packetOffsets[i] = object.packetOffsets[i] >>> 0;
            }
            if (object.voiceLevel != null)
                message.voiceLevel = Number(object.voiceLevel);
            return message;
        };
    
        /**
         * Creates a plain object from a CMsgVoiceAudio message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CMsgVoiceAudio
         * @static
         * @param {CMsgVoiceAudio} message CMsgVoiceAudio
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CMsgVoiceAudio.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.packetOffsets = [];
            if (options.defaults) {
                object.format = options.enums === String ? "VOICEDATA_FORMAT_STEAM" : 0;
                if (options.bytes === String)
                    object.voiceData = "";
                else {
                    object.voiceData = [];
                    if (options.bytes !== Array)
                        object.voiceData = $util.newBuffer(object.voiceData);
                }
                object.sequenceBytes = 0;
                object.sectionNumber = 0;
                object.sampleRate = 0;
                object.uncompressedSampleOffset = 0;
                object.numPackets = 0;
                object.voiceLevel = 0;
            }
            if (message.format != null && message.hasOwnProperty("format"))
                object.format = options.enums === String ? $root.VoiceDataFormat_t[message.format] === undefined ? message.format : $root.VoiceDataFormat_t[message.format] : message.format;
            if (message.voiceData != null && message.hasOwnProperty("voiceData"))
                object.voiceData = options.bytes === String ? $util.base64.encode(message.voiceData, 0, message.voiceData.length) : options.bytes === Array ? Array.prototype.slice.call(message.voiceData) : message.voiceData;
            if (message.sequenceBytes != null && message.hasOwnProperty("sequenceBytes"))
                object.sequenceBytes = message.sequenceBytes;
            if (message.sectionNumber != null && message.hasOwnProperty("sectionNumber"))
                object.sectionNumber = message.sectionNumber;
            if (message.sampleRate != null && message.hasOwnProperty("sampleRate"))
                object.sampleRate = message.sampleRate;
            if (message.uncompressedSampleOffset != null && message.hasOwnProperty("uncompressedSampleOffset"))
                object.uncompressedSampleOffset = message.uncompressedSampleOffset;
            if (message.numPackets != null && message.hasOwnProperty("numPackets"))
                object.numPackets = message.numPackets;
            if (message.packetOffsets && message.packetOffsets.length) {
                object.packetOffsets = [];
                for (var j = 0; j < message.packetOffsets.length; ++j)
                    object.packetOffsets[j] = message.packetOffsets[j];
            }
            if (message.voiceLevel != null && message.hasOwnProperty("voiceLevel"))
                object.voiceLevel = options.json && !isFinite(message.voiceLevel) ? String(message.voiceLevel) : message.voiceLevel;
            return object;
        };
    
        /**
         * Converts this CMsgVoiceAudio to JSON.
         * @function toJSON
         * @memberof CMsgVoiceAudio
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CMsgVoiceAudio.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * Gets the default type url for CMsgVoiceAudio
         * @function getTypeUrl
         * @memberof CMsgVoiceAudio
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        CMsgVoiceAudio.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/CMsgVoiceAudio";
        };
    
        return CMsgVoiceAudio;
    })();
    
    $root.CCLCMsg_VoiceData = (function() {
    
        /**
         * Properties of a CCLCMsg_VoiceData.
         * @exports ICCLCMsg_VoiceData
         * @interface ICCLCMsg_VoiceData
         * @property {ICMsgVoiceAudio|null} [audio] CCLCMsg_VoiceData audio
         * @property {number|Long|null} [xuid] CCLCMsg_VoiceData xuid
         * @property {number|null} [tick] CCLCMsg_VoiceData tick
         */
    
        /**
         * Constructs a new CCLCMsg_VoiceData.
         * @exports CCLCMsg_VoiceData
         * @classdesc Represents a CCLCMsg_VoiceData.
         * @implements ICCLCMsg_VoiceData
         * @constructor
         * @param {ICCLCMsg_VoiceData=} [properties] Properties to set
         */
        function CCLCMsg_VoiceData(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CCLCMsg_VoiceData audio.
         * @member {ICMsgVoiceAudio|null|undefined} audio
         * @memberof CCLCMsg_VoiceData
         * @instance
         */
        CCLCMsg_VoiceData.prototype.audio = null;
    
        /**
         * CCLCMsg_VoiceData xuid.
         * @member {number|Long} xuid
         * @memberof CCLCMsg_VoiceData
         * @instance
         */
        CCLCMsg_VoiceData.prototype.xuid = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
        /**
         * CCLCMsg_VoiceData tick.
         * @member {number} tick
         * @memberof CCLCMsg_VoiceData
         * @instance
         */
        CCLCMsg_VoiceData.prototype.tick = 0;
    
        /**
         * Creates a new CCLCMsg_VoiceData instance using the specified properties.
         * @function create
         * @memberof CCLCMsg_VoiceData
         * @static
         * @param {ICCLCMsg_VoiceData=} [properties] Properties to set
         * @returns {CCLCMsg_VoiceData} CCLCMsg_VoiceData instance
         */
        CCLCMsg_VoiceData.create = function create(properties) {
            return new CCLCMsg_VoiceData(properties);
        };
    
        /**
         * Encodes the specified CCLCMsg_VoiceData message. Does not implicitly {@link CCLCMsg_VoiceData.verify|verify} messages.
         * @function encode
         * @memberof CCLCMsg_VoiceData
         * @static
         * @param {ICCLCMsg_VoiceData} message CCLCMsg_VoiceData message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CCLCMsg_VoiceData.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.audio != null && Object.hasOwnProperty.call(message, "audio"))
                $root.CMsgVoiceAudio.encode(message.audio, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.xuid != null && Object.hasOwnProperty.call(message, "xuid"))
                writer.uint32(/* id 2, wireType 1 =*/17).fixed64(message.xuid);
            if (message.tick != null && Object.hasOwnProperty.call(message, "tick"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.tick);
            return writer;
        };
    
        /**
         * Encodes the specified CCLCMsg_VoiceData message, length delimited. Does not implicitly {@link CCLCMsg_VoiceData.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CCLCMsg_VoiceData
         * @static
         * @param {ICCLCMsg_VoiceData} message CCLCMsg_VoiceData message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CCLCMsg_VoiceData.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CCLCMsg_VoiceData message from the specified reader or buffer.
         * @function decode
         * @memberof CCLCMsg_VoiceData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CCLCMsg_VoiceData} CCLCMsg_VoiceData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CCLCMsg_VoiceData.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CCLCMsg_VoiceData();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.audio = $root.CMsgVoiceAudio.decode(reader, reader.uint32());
                        break;
                    }
                case 2: {
                        message.xuid = reader.fixed64();
                        break;
                    }
                case 3: {
                        message.tick = reader.uint32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CCLCMsg_VoiceData message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CCLCMsg_VoiceData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CCLCMsg_VoiceData} CCLCMsg_VoiceData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CCLCMsg_VoiceData.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CCLCMsg_VoiceData message.
         * @function verify
         * @memberof CCLCMsg_VoiceData
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CCLCMsg_VoiceData.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.audio != null && message.hasOwnProperty("audio")) {
                var error = $root.CMsgVoiceAudio.verify(message.audio);
                if (error)
                    return "audio." + error;
            }
            if (message.xuid != null && message.hasOwnProperty("xuid"))
                if (!$util.isInteger(message.xuid) && !(message.xuid && $util.isInteger(message.xuid.low) && $util.isInteger(message.xuid.high)))
                    return "xuid: integer|Long expected";
            if (message.tick != null && message.hasOwnProperty("tick"))
                if (!$util.isInteger(message.tick))
                    return "tick: integer expected";
            return null;
        };
    
        /**
         * Creates a CCLCMsg_VoiceData message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CCLCMsg_VoiceData
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CCLCMsg_VoiceData} CCLCMsg_VoiceData
         */
        CCLCMsg_VoiceData.fromObject = function fromObject(object) {
            if (object instanceof $root.CCLCMsg_VoiceData)
                return object;
            var message = new $root.CCLCMsg_VoiceData();
            if (object.audio != null) {
                if (typeof object.audio !== "object")
                    throw TypeError(".CCLCMsg_VoiceData.audio: object expected");
                message.audio = $root.CMsgVoiceAudio.fromObject(object.audio);
            }
            if (object.xuid != null)
                if ($util.Long)
                    (message.xuid = $util.Long.fromValue(object.xuid)).unsigned = false;
                else if (typeof object.xuid === "string")
                    message.xuid = parseInt(object.xuid, 10);
                else if (typeof object.xuid === "number")
                    message.xuid = object.xuid;
                else if (typeof object.xuid === "object")
                    message.xuid = new $util.LongBits(object.xuid.low >>> 0, object.xuid.high >>> 0).toNumber();
            if (object.tick != null)
                message.tick = object.tick >>> 0;
            return message;
        };
    
        /**
         * Creates a plain object from a CCLCMsg_VoiceData message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CCLCMsg_VoiceData
         * @static
         * @param {CCLCMsg_VoiceData} message CCLCMsg_VoiceData
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CCLCMsg_VoiceData.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.audio = null;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.xuid = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.xuid = options.longs === String ? "0" : 0;
                object.tick = 0;
            }
            if (message.audio != null && message.hasOwnProperty("audio"))
                object.audio = $root.CMsgVoiceAudio.toObject(message.audio, options);
            if (message.xuid != null && message.hasOwnProperty("xuid"))
                if (typeof message.xuid === "number")
                    object.xuid = options.longs === String ? String(message.xuid) : message.xuid;
                else
                    object.xuid = options.longs === String ? $util.Long.prototype.toString.call(message.xuid) : options.longs === Number ? new $util.LongBits(message.xuid.low >>> 0, message.xuid.high >>> 0).toNumber() : message.xuid;
            if (message.tick != null && message.hasOwnProperty("tick"))
                object.tick = message.tick;
            return object;
        };
    
        /**
         * Converts this CCLCMsg_VoiceData to JSON.
         * @function toJSON
         * @memberof CCLCMsg_VoiceData
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CCLCMsg_VoiceData.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * Gets the default type url for CCLCMsg_VoiceData
         * @function getTypeUrl
         * @memberof CCLCMsg_VoiceData
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        CCLCMsg_VoiceData.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/CCLCMsg_VoiceData";
        };
    
        return CCLCMsg_VoiceData;
    })();
    
    $root.CCLCMsg_BaselineAck = (function() {
    
        /**
         * Properties of a CCLCMsg_BaselineAck.
         * @exports ICCLCMsg_BaselineAck
         * @interface ICCLCMsg_BaselineAck
         * @property {number|null} [baselineTick] CCLCMsg_BaselineAck baselineTick
         * @property {number|null} [baselineNr] CCLCMsg_BaselineAck baselineNr
         */
    
        /**
         * Constructs a new CCLCMsg_BaselineAck.
         * @exports CCLCMsg_BaselineAck
         * @classdesc Represents a CCLCMsg_BaselineAck.
         * @implements ICCLCMsg_BaselineAck
         * @constructor
         * @param {ICCLCMsg_BaselineAck=} [properties] Properties to set
         */
        function CCLCMsg_BaselineAck(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CCLCMsg_BaselineAck baselineTick.
         * @member {number} baselineTick
         * @memberof CCLCMsg_BaselineAck
         * @instance
         */
        CCLCMsg_BaselineAck.prototype.baselineTick = 0;
    
        /**
         * CCLCMsg_BaselineAck baselineNr.
         * @member {number} baselineNr
         * @memberof CCLCMsg_BaselineAck
         * @instance
         */
        CCLCMsg_BaselineAck.prototype.baselineNr = 0;
    
        /**
         * Creates a new CCLCMsg_BaselineAck instance using the specified properties.
         * @function create
         * @memberof CCLCMsg_BaselineAck
         * @static
         * @param {ICCLCMsg_BaselineAck=} [properties] Properties to set
         * @returns {CCLCMsg_BaselineAck} CCLCMsg_BaselineAck instance
         */
        CCLCMsg_BaselineAck.create = function create(properties) {
            return new CCLCMsg_BaselineAck(properties);
        };
    
        /**
         * Encodes the specified CCLCMsg_BaselineAck message. Does not implicitly {@link CCLCMsg_BaselineAck.verify|verify} messages.
         * @function encode
         * @memberof CCLCMsg_BaselineAck
         * @static
         * @param {ICCLCMsg_BaselineAck} message CCLCMsg_BaselineAck message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CCLCMsg_BaselineAck.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.baselineTick != null && Object.hasOwnProperty.call(message, "baselineTick"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.baselineTick);
            if (message.baselineNr != null && Object.hasOwnProperty.call(message, "baselineNr"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.baselineNr);
            return writer;
        };
    
        /**
         * Encodes the specified CCLCMsg_BaselineAck message, length delimited. Does not implicitly {@link CCLCMsg_BaselineAck.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CCLCMsg_BaselineAck
         * @static
         * @param {ICCLCMsg_BaselineAck} message CCLCMsg_BaselineAck message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CCLCMsg_BaselineAck.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CCLCMsg_BaselineAck message from the specified reader or buffer.
         * @function decode
         * @memberof CCLCMsg_BaselineAck
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CCLCMsg_BaselineAck} CCLCMsg_BaselineAck
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CCLCMsg_BaselineAck.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CCLCMsg_BaselineAck();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.baselineTick = reader.int32();
                        break;
                    }
                case 2: {
                        message.baselineNr = reader.int32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CCLCMsg_BaselineAck message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CCLCMsg_BaselineAck
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CCLCMsg_BaselineAck} CCLCMsg_BaselineAck
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CCLCMsg_BaselineAck.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CCLCMsg_BaselineAck message.
         * @function verify
         * @memberof CCLCMsg_BaselineAck
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CCLCMsg_BaselineAck.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.baselineTick != null && message.hasOwnProperty("baselineTick"))
                if (!$util.isInteger(message.baselineTick))
                    return "baselineTick: integer expected";
            if (message.baselineNr != null && message.hasOwnProperty("baselineNr"))
                if (!$util.isInteger(message.baselineNr))
                    return "baselineNr: integer expected";
            return null;
        };
    
        /**
         * Creates a CCLCMsg_BaselineAck message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CCLCMsg_BaselineAck
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CCLCMsg_BaselineAck} CCLCMsg_BaselineAck
         */
        CCLCMsg_BaselineAck.fromObject = function fromObject(object) {
            if (object instanceof $root.CCLCMsg_BaselineAck)
                return object;
            var message = new $root.CCLCMsg_BaselineAck();
            if (object.baselineTick != null)
                message.baselineTick = object.baselineTick | 0;
            if (object.baselineNr != null)
                message.baselineNr = object.baselineNr | 0;
            return message;
        };
    
        /**
         * Creates a plain object from a CCLCMsg_BaselineAck message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CCLCMsg_BaselineAck
         * @static
         * @param {CCLCMsg_BaselineAck} message CCLCMsg_BaselineAck
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CCLCMsg_BaselineAck.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.baselineTick = 0;
                object.baselineNr = 0;
            }
            if (message.baselineTick != null && message.hasOwnProperty("baselineTick"))
                object.baselineTick = message.baselineTick;
            if (message.baselineNr != null && message.hasOwnProperty("baselineNr"))
                object.baselineNr = message.baselineNr;
            return object;
        };
    
        /**
         * Converts this CCLCMsg_BaselineAck to JSON.
         * @function toJSON
         * @memberof CCLCMsg_BaselineAck
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CCLCMsg_BaselineAck.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * Gets the default type url for CCLCMsg_BaselineAck
         * @function getTypeUrl
         * @memberof CCLCMsg_BaselineAck
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        CCLCMsg_BaselineAck.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/CCLCMsg_BaselineAck";
        };
    
        return CCLCMsg_BaselineAck;
    })();
    
    $root.CCLCMsg_ListenEvents = (function() {
    
        /**
         * Properties of a CCLCMsg_ListenEvents.
         * @exports ICCLCMsg_ListenEvents
         * @interface ICCLCMsg_ListenEvents
         * @property {Array.<number>|null} [eventMask] CCLCMsg_ListenEvents eventMask
         */
    
        /**
         * Constructs a new CCLCMsg_ListenEvents.
         * @exports CCLCMsg_ListenEvents
         * @classdesc Represents a CCLCMsg_ListenEvents.
         * @implements ICCLCMsg_ListenEvents
         * @constructor
         * @param {ICCLCMsg_ListenEvents=} [properties] Properties to set
         */
        function CCLCMsg_ListenEvents(properties) {
            this.eventMask = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CCLCMsg_ListenEvents eventMask.
         * @member {Array.<number>} eventMask
         * @memberof CCLCMsg_ListenEvents
         * @instance
         */
        CCLCMsg_ListenEvents.prototype.eventMask = $util.emptyArray;
    
        /**
         * Creates a new CCLCMsg_ListenEvents instance using the specified properties.
         * @function create
         * @memberof CCLCMsg_ListenEvents
         * @static
         * @param {ICCLCMsg_ListenEvents=} [properties] Properties to set
         * @returns {CCLCMsg_ListenEvents} CCLCMsg_ListenEvents instance
         */
        CCLCMsg_ListenEvents.create = function create(properties) {
            return new CCLCMsg_ListenEvents(properties);
        };
    
        /**
         * Encodes the specified CCLCMsg_ListenEvents message. Does not implicitly {@link CCLCMsg_ListenEvents.verify|verify} messages.
         * @function encode
         * @memberof CCLCMsg_ListenEvents
         * @static
         * @param {ICCLCMsg_ListenEvents} message CCLCMsg_ListenEvents message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CCLCMsg_ListenEvents.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.eventMask != null && message.eventMask.length)
                for (var i = 0; i < message.eventMask.length; ++i)
                    writer.uint32(/* id 1, wireType 5 =*/13).fixed32(message.eventMask[i]);
            return writer;
        };
    
        /**
         * Encodes the specified CCLCMsg_ListenEvents message, length delimited. Does not implicitly {@link CCLCMsg_ListenEvents.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CCLCMsg_ListenEvents
         * @static
         * @param {ICCLCMsg_ListenEvents} message CCLCMsg_ListenEvents message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CCLCMsg_ListenEvents.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CCLCMsg_ListenEvents message from the specified reader or buffer.
         * @function decode
         * @memberof CCLCMsg_ListenEvents
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CCLCMsg_ListenEvents} CCLCMsg_ListenEvents
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CCLCMsg_ListenEvents.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CCLCMsg_ListenEvents();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        if (!(message.eventMask && message.eventMask.length))
                            message.eventMask = [];
                        if ((tag & 7) === 2) {
                            var end2 = reader.uint32() + reader.pos;
                            while (reader.pos < end2)
                                message.eventMask.push(reader.fixed32());
                        } else
                            message.eventMask.push(reader.fixed32());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CCLCMsg_ListenEvents message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CCLCMsg_ListenEvents
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CCLCMsg_ListenEvents} CCLCMsg_ListenEvents
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CCLCMsg_ListenEvents.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CCLCMsg_ListenEvents message.
         * @function verify
         * @memberof CCLCMsg_ListenEvents
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CCLCMsg_ListenEvents.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.eventMask != null && message.hasOwnProperty("eventMask")) {
                if (!Array.isArray(message.eventMask))
                    return "eventMask: array expected";
                for (var i = 0; i < message.eventMask.length; ++i)
                    if (!$util.isInteger(message.eventMask[i]))
                        return "eventMask: integer[] expected";
            }
            return null;
        };
    
        /**
         * Creates a CCLCMsg_ListenEvents message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CCLCMsg_ListenEvents
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CCLCMsg_ListenEvents} CCLCMsg_ListenEvents
         */
        CCLCMsg_ListenEvents.fromObject = function fromObject(object) {
            if (object instanceof $root.CCLCMsg_ListenEvents)
                return object;
            var message = new $root.CCLCMsg_ListenEvents();
            if (object.eventMask) {
                if (!Array.isArray(object.eventMask))
                    throw TypeError(".CCLCMsg_ListenEvents.eventMask: array expected");
                message.eventMask = [];
                for (var i = 0; i < object.eventMask.length; ++i)
                    message.eventMask[i] = object.eventMask[i] >>> 0;
            }
            return message;
        };
    
        /**
         * Creates a plain object from a CCLCMsg_ListenEvents message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CCLCMsg_ListenEvents
         * @static
         * @param {CCLCMsg_ListenEvents} message CCLCMsg_ListenEvents
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CCLCMsg_ListenEvents.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.eventMask = [];
            if (message.eventMask && message.eventMask.length) {
                object.eventMask = [];
                for (var j = 0; j < message.eventMask.length; ++j)
                    object.eventMask[j] = message.eventMask[j];
            }
            return object;
        };
    
        /**
         * Converts this CCLCMsg_ListenEvents to JSON.
         * @function toJSON
         * @memberof CCLCMsg_ListenEvents
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CCLCMsg_ListenEvents.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * Gets the default type url for CCLCMsg_ListenEvents
         * @function getTypeUrl
         * @memberof CCLCMsg_ListenEvents
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        CCLCMsg_ListenEvents.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/CCLCMsg_ListenEvents";
        };
    
        return CCLCMsg_ListenEvents;
    })();
    
    $root.CCLCMsg_RespondCvarValue = (function() {
    
        /**
         * Properties of a CCLCMsg_RespondCvarValue.
         * @exports ICCLCMsg_RespondCvarValue
         * @interface ICCLCMsg_RespondCvarValue
         * @property {number|null} [cookie] CCLCMsg_RespondCvarValue cookie
         * @property {number|null} [statusCode] CCLCMsg_RespondCvarValue statusCode
         * @property {string|null} [name] CCLCMsg_RespondCvarValue name
         * @property {string|null} [value] CCLCMsg_RespondCvarValue value
         */
    
        /**
         * Constructs a new CCLCMsg_RespondCvarValue.
         * @exports CCLCMsg_RespondCvarValue
         * @classdesc Represents a CCLCMsg_RespondCvarValue.
         * @implements ICCLCMsg_RespondCvarValue
         * @constructor
         * @param {ICCLCMsg_RespondCvarValue=} [properties] Properties to set
         */
        function CCLCMsg_RespondCvarValue(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CCLCMsg_RespondCvarValue cookie.
         * @member {number} cookie
         * @memberof CCLCMsg_RespondCvarValue
         * @instance
         */
        CCLCMsg_RespondCvarValue.prototype.cookie = 0;
    
        /**
         * CCLCMsg_RespondCvarValue statusCode.
         * @member {number} statusCode
         * @memberof CCLCMsg_RespondCvarValue
         * @instance
         */
        CCLCMsg_RespondCvarValue.prototype.statusCode = 0;
    
        /**
         * CCLCMsg_RespondCvarValue name.
         * @member {string} name
         * @memberof CCLCMsg_RespondCvarValue
         * @instance
         */
        CCLCMsg_RespondCvarValue.prototype.name = "";
    
        /**
         * CCLCMsg_RespondCvarValue value.
         * @member {string} value
         * @memberof CCLCMsg_RespondCvarValue
         * @instance
         */
        CCLCMsg_RespondCvarValue.prototype.value = "";
    
        /**
         * Creates a new CCLCMsg_RespondCvarValue instance using the specified properties.
         * @function create
         * @memberof CCLCMsg_RespondCvarValue
         * @static
         * @param {ICCLCMsg_RespondCvarValue=} [properties] Properties to set
         * @returns {CCLCMsg_RespondCvarValue} CCLCMsg_RespondCvarValue instance
         */
        CCLCMsg_RespondCvarValue.create = function create(properties) {
            return new CCLCMsg_RespondCvarValue(properties);
        };
    
        /**
         * Encodes the specified CCLCMsg_RespondCvarValue message. Does not implicitly {@link CCLCMsg_RespondCvarValue.verify|verify} messages.
         * @function encode
         * @memberof CCLCMsg_RespondCvarValue
         * @static
         * @param {ICCLCMsg_RespondCvarValue} message CCLCMsg_RespondCvarValue message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CCLCMsg_RespondCvarValue.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.cookie != null && Object.hasOwnProperty.call(message, "cookie"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.cookie);
            if (message.statusCode != null && Object.hasOwnProperty.call(message, "statusCode"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.statusCode);
            if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.name);
            if (message.value != null && Object.hasOwnProperty.call(message, "value"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.value);
            return writer;
        };
    
        /**
         * Encodes the specified CCLCMsg_RespondCvarValue message, length delimited. Does not implicitly {@link CCLCMsg_RespondCvarValue.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CCLCMsg_RespondCvarValue
         * @static
         * @param {ICCLCMsg_RespondCvarValue} message CCLCMsg_RespondCvarValue message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CCLCMsg_RespondCvarValue.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CCLCMsg_RespondCvarValue message from the specified reader or buffer.
         * @function decode
         * @memberof CCLCMsg_RespondCvarValue
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CCLCMsg_RespondCvarValue} CCLCMsg_RespondCvarValue
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CCLCMsg_RespondCvarValue.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CCLCMsg_RespondCvarValue();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.cookie = reader.int32();
                        break;
                    }
                case 2: {
                        message.statusCode = reader.int32();
                        break;
                    }
                case 3: {
                        message.name = reader.string();
                        break;
                    }
                case 4: {
                        message.value = reader.string();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CCLCMsg_RespondCvarValue message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CCLCMsg_RespondCvarValue
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CCLCMsg_RespondCvarValue} CCLCMsg_RespondCvarValue
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CCLCMsg_RespondCvarValue.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CCLCMsg_RespondCvarValue message.
         * @function verify
         * @memberof CCLCMsg_RespondCvarValue
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CCLCMsg_RespondCvarValue.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.cookie != null && message.hasOwnProperty("cookie"))
                if (!$util.isInteger(message.cookie))
                    return "cookie: integer expected";
            if (message.statusCode != null && message.hasOwnProperty("statusCode"))
                if (!$util.isInteger(message.statusCode))
                    return "statusCode: integer expected";
            if (message.name != null && message.hasOwnProperty("name"))
                if (!$util.isString(message.name))
                    return "name: string expected";
            if (message.value != null && message.hasOwnProperty("value"))
                if (!$util.isString(message.value))
                    return "value: string expected";
            return null;
        };
    
        /**
         * Creates a CCLCMsg_RespondCvarValue message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CCLCMsg_RespondCvarValue
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CCLCMsg_RespondCvarValue} CCLCMsg_RespondCvarValue
         */
        CCLCMsg_RespondCvarValue.fromObject = function fromObject(object) {
            if (object instanceof $root.CCLCMsg_RespondCvarValue)
                return object;
            var message = new $root.CCLCMsg_RespondCvarValue();
            if (object.cookie != null)
                message.cookie = object.cookie | 0;
            if (object.statusCode != null)
                message.statusCode = object.statusCode | 0;
            if (object.name != null)
                message.name = String(object.name);
            if (object.value != null)
                message.value = String(object.value);
            return message;
        };
    
        /**
         * Creates a plain object from a CCLCMsg_RespondCvarValue message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CCLCMsg_RespondCvarValue
         * @static
         * @param {CCLCMsg_RespondCvarValue} message CCLCMsg_RespondCvarValue
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CCLCMsg_RespondCvarValue.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.cookie = 0;
                object.statusCode = 0;
                object.name = "";
                object.value = "";
            }
            if (message.cookie != null && message.hasOwnProperty("cookie"))
                object.cookie = message.cookie;
            if (message.statusCode != null && message.hasOwnProperty("statusCode"))
                object.statusCode = message.statusCode;
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
            if (message.value != null && message.hasOwnProperty("value"))
                object.value = message.value;
            return object;
        };
    
        /**
         * Converts this CCLCMsg_RespondCvarValue to JSON.
         * @function toJSON
         * @memberof CCLCMsg_RespondCvarValue
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CCLCMsg_RespondCvarValue.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * Gets the default type url for CCLCMsg_RespondCvarValue
         * @function getTypeUrl
         * @memberof CCLCMsg_RespondCvarValue
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        CCLCMsg_RespondCvarValue.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/CCLCMsg_RespondCvarValue";
        };
    
        return CCLCMsg_RespondCvarValue;
    })();
    
    $root.CCLCMsg_FileCRCCheck = (function() {
    
        /**
         * Properties of a CCLCMsg_FileCRCCheck.
         * @exports ICCLCMsg_FileCRCCheck
         * @interface ICCLCMsg_FileCRCCheck
         * @property {number|null} [codePath] CCLCMsg_FileCRCCheck codePath
         * @property {string|null} [path] CCLCMsg_FileCRCCheck path
         * @property {number|null} [codeFilename] CCLCMsg_FileCRCCheck codeFilename
         * @property {string|null} [filename] CCLCMsg_FileCRCCheck filename
         * @property {number|null} [crc] CCLCMsg_FileCRCCheck crc
         */
    
        /**
         * Constructs a new CCLCMsg_FileCRCCheck.
         * @exports CCLCMsg_FileCRCCheck
         * @classdesc Represents a CCLCMsg_FileCRCCheck.
         * @implements ICCLCMsg_FileCRCCheck
         * @constructor
         * @param {ICCLCMsg_FileCRCCheck=} [properties] Properties to set
         */
        function CCLCMsg_FileCRCCheck(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CCLCMsg_FileCRCCheck codePath.
         * @member {number} codePath
         * @memberof CCLCMsg_FileCRCCheck
         * @instance
         */
        CCLCMsg_FileCRCCheck.prototype.codePath = 0;
    
        /**
         * CCLCMsg_FileCRCCheck path.
         * @member {string} path
         * @memberof CCLCMsg_FileCRCCheck
         * @instance
         */
        CCLCMsg_FileCRCCheck.prototype.path = "";
    
        /**
         * CCLCMsg_FileCRCCheck codeFilename.
         * @member {number} codeFilename
         * @memberof CCLCMsg_FileCRCCheck
         * @instance
         */
        CCLCMsg_FileCRCCheck.prototype.codeFilename = 0;
    
        /**
         * CCLCMsg_FileCRCCheck filename.
         * @member {string} filename
         * @memberof CCLCMsg_FileCRCCheck
         * @instance
         */
        CCLCMsg_FileCRCCheck.prototype.filename = "";
    
        /**
         * CCLCMsg_FileCRCCheck crc.
         * @member {number} crc
         * @memberof CCLCMsg_FileCRCCheck
         * @instance
         */
        CCLCMsg_FileCRCCheck.prototype.crc = 0;
    
        /**
         * Creates a new CCLCMsg_FileCRCCheck instance using the specified properties.
         * @function create
         * @memberof CCLCMsg_FileCRCCheck
         * @static
         * @param {ICCLCMsg_FileCRCCheck=} [properties] Properties to set
         * @returns {CCLCMsg_FileCRCCheck} CCLCMsg_FileCRCCheck instance
         */
        CCLCMsg_FileCRCCheck.create = function create(properties) {
            return new CCLCMsg_FileCRCCheck(properties);
        };
    
        /**
         * Encodes the specified CCLCMsg_FileCRCCheck message. Does not implicitly {@link CCLCMsg_FileCRCCheck.verify|verify} messages.
         * @function encode
         * @memberof CCLCMsg_FileCRCCheck
         * @static
         * @param {ICCLCMsg_FileCRCCheck} message CCLCMsg_FileCRCCheck message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CCLCMsg_FileCRCCheck.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.codePath != null && Object.hasOwnProperty.call(message, "codePath"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.codePath);
            if (message.path != null && Object.hasOwnProperty.call(message, "path"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.path);
            if (message.codeFilename != null && Object.hasOwnProperty.call(message, "codeFilename"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.codeFilename);
            if (message.filename != null && Object.hasOwnProperty.call(message, "filename"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.filename);
            if (message.crc != null && Object.hasOwnProperty.call(message, "crc"))
                writer.uint32(/* id 5, wireType 5 =*/45).fixed32(message.crc);
            return writer;
        };
    
        /**
         * Encodes the specified CCLCMsg_FileCRCCheck message, length delimited. Does not implicitly {@link CCLCMsg_FileCRCCheck.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CCLCMsg_FileCRCCheck
         * @static
         * @param {ICCLCMsg_FileCRCCheck} message CCLCMsg_FileCRCCheck message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CCLCMsg_FileCRCCheck.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CCLCMsg_FileCRCCheck message from the specified reader or buffer.
         * @function decode
         * @memberof CCLCMsg_FileCRCCheck
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CCLCMsg_FileCRCCheck} CCLCMsg_FileCRCCheck
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CCLCMsg_FileCRCCheck.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CCLCMsg_FileCRCCheck();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.codePath = reader.int32();
                        break;
                    }
                case 2: {
                        message.path = reader.string();
                        break;
                    }
                case 3: {
                        message.codeFilename = reader.int32();
                        break;
                    }
                case 4: {
                        message.filename = reader.string();
                        break;
                    }
                case 5: {
                        message.crc = reader.fixed32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CCLCMsg_FileCRCCheck message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CCLCMsg_FileCRCCheck
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CCLCMsg_FileCRCCheck} CCLCMsg_FileCRCCheck
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CCLCMsg_FileCRCCheck.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CCLCMsg_FileCRCCheck message.
         * @function verify
         * @memberof CCLCMsg_FileCRCCheck
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CCLCMsg_FileCRCCheck.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.codePath != null && message.hasOwnProperty("codePath"))
                if (!$util.isInteger(message.codePath))
                    return "codePath: integer expected";
            if (message.path != null && message.hasOwnProperty("path"))
                if (!$util.isString(message.path))
                    return "path: string expected";
            if (message.codeFilename != null && message.hasOwnProperty("codeFilename"))
                if (!$util.isInteger(message.codeFilename))
                    return "codeFilename: integer expected";
            if (message.filename != null && message.hasOwnProperty("filename"))
                if (!$util.isString(message.filename))
                    return "filename: string expected";
            if (message.crc != null && message.hasOwnProperty("crc"))
                if (!$util.isInteger(message.crc))
                    return "crc: integer expected";
            return null;
        };
    
        /**
         * Creates a CCLCMsg_FileCRCCheck message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CCLCMsg_FileCRCCheck
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CCLCMsg_FileCRCCheck} CCLCMsg_FileCRCCheck
         */
        CCLCMsg_FileCRCCheck.fromObject = function fromObject(object) {
            if (object instanceof $root.CCLCMsg_FileCRCCheck)
                return object;
            var message = new $root.CCLCMsg_FileCRCCheck();
            if (object.codePath != null)
                message.codePath = object.codePath | 0;
            if (object.path != null)
                message.path = String(object.path);
            if (object.codeFilename != null)
                message.codeFilename = object.codeFilename | 0;
            if (object.filename != null)
                message.filename = String(object.filename);
            if (object.crc != null)
                message.crc = object.crc >>> 0;
            return message;
        };
    
        /**
         * Creates a plain object from a CCLCMsg_FileCRCCheck message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CCLCMsg_FileCRCCheck
         * @static
         * @param {CCLCMsg_FileCRCCheck} message CCLCMsg_FileCRCCheck
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CCLCMsg_FileCRCCheck.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.codePath = 0;
                object.path = "";
                object.codeFilename = 0;
                object.filename = "";
                object.crc = 0;
            }
            if (message.codePath != null && message.hasOwnProperty("codePath"))
                object.codePath = message.codePath;
            if (message.path != null && message.hasOwnProperty("path"))
                object.path = message.path;
            if (message.codeFilename != null && message.hasOwnProperty("codeFilename"))
                object.codeFilename = message.codeFilename;
            if (message.filename != null && message.hasOwnProperty("filename"))
                object.filename = message.filename;
            if (message.crc != null && message.hasOwnProperty("crc"))
                object.crc = message.crc;
            return object;
        };
    
        /**
         * Converts this CCLCMsg_FileCRCCheck to JSON.
         * @function toJSON
         * @memberof CCLCMsg_FileCRCCheck
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CCLCMsg_FileCRCCheck.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * Gets the default type url for CCLCMsg_FileCRCCheck
         * @function getTypeUrl
         * @memberof CCLCMsg_FileCRCCheck
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        CCLCMsg_FileCRCCheck.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/CCLCMsg_FileCRCCheck";
        };
    
        return CCLCMsg_FileCRCCheck;
    })();
    
    $root.CCLCMsg_LoadingProgress = (function() {
    
        /**
         * Properties of a CCLCMsg_LoadingProgress.
         * @exports ICCLCMsg_LoadingProgress
         * @interface ICCLCMsg_LoadingProgress
         * @property {number|null} [progress] CCLCMsg_LoadingProgress progress
         */
    
        /**
         * Constructs a new CCLCMsg_LoadingProgress.
         * @exports CCLCMsg_LoadingProgress
         * @classdesc Represents a CCLCMsg_LoadingProgress.
         * @implements ICCLCMsg_LoadingProgress
         * @constructor
         * @param {ICCLCMsg_LoadingProgress=} [properties] Properties to set
         */
        function CCLCMsg_LoadingProgress(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CCLCMsg_LoadingProgress progress.
         * @member {number} progress
         * @memberof CCLCMsg_LoadingProgress
         * @instance
         */
        CCLCMsg_LoadingProgress.prototype.progress = 0;
    
        /**
         * Creates a new CCLCMsg_LoadingProgress instance using the specified properties.
         * @function create
         * @memberof CCLCMsg_LoadingProgress
         * @static
         * @param {ICCLCMsg_LoadingProgress=} [properties] Properties to set
         * @returns {CCLCMsg_LoadingProgress} CCLCMsg_LoadingProgress instance
         */
        CCLCMsg_LoadingProgress.create = function create(properties) {
            return new CCLCMsg_LoadingProgress(properties);
        };
    
        /**
         * Encodes the specified CCLCMsg_LoadingProgress message. Does not implicitly {@link CCLCMsg_LoadingProgress.verify|verify} messages.
         * @function encode
         * @memberof CCLCMsg_LoadingProgress
         * @static
         * @param {ICCLCMsg_LoadingProgress} message CCLCMsg_LoadingProgress message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CCLCMsg_LoadingProgress.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.progress != null && Object.hasOwnProperty.call(message, "progress"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.progress);
            return writer;
        };
    
        /**
         * Encodes the specified CCLCMsg_LoadingProgress message, length delimited. Does not implicitly {@link CCLCMsg_LoadingProgress.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CCLCMsg_LoadingProgress
         * @static
         * @param {ICCLCMsg_LoadingProgress} message CCLCMsg_LoadingProgress message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CCLCMsg_LoadingProgress.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CCLCMsg_LoadingProgress message from the specified reader or buffer.
         * @function decode
         * @memberof CCLCMsg_LoadingProgress
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CCLCMsg_LoadingProgress} CCLCMsg_LoadingProgress
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CCLCMsg_LoadingProgress.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CCLCMsg_LoadingProgress();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.progress = reader.int32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CCLCMsg_LoadingProgress message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CCLCMsg_LoadingProgress
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CCLCMsg_LoadingProgress} CCLCMsg_LoadingProgress
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CCLCMsg_LoadingProgress.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CCLCMsg_LoadingProgress message.
         * @function verify
         * @memberof CCLCMsg_LoadingProgress
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CCLCMsg_LoadingProgress.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.progress != null && message.hasOwnProperty("progress"))
                if (!$util.isInteger(message.progress))
                    return "progress: integer expected";
            return null;
        };
    
        /**
         * Creates a CCLCMsg_LoadingProgress message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CCLCMsg_LoadingProgress
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CCLCMsg_LoadingProgress} CCLCMsg_LoadingProgress
         */
        CCLCMsg_LoadingProgress.fromObject = function fromObject(object) {
            if (object instanceof $root.CCLCMsg_LoadingProgress)
                return object;
            var message = new $root.CCLCMsg_LoadingProgress();
            if (object.progress != null)
                message.progress = object.progress | 0;
            return message;
        };
    
        /**
         * Creates a plain object from a CCLCMsg_LoadingProgress message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CCLCMsg_LoadingProgress
         * @static
         * @param {CCLCMsg_LoadingProgress} message CCLCMsg_LoadingProgress
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CCLCMsg_LoadingProgress.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.progress = 0;
            if (message.progress != null && message.hasOwnProperty("progress"))
                object.progress = message.progress;
            return object;
        };
    
        /**
         * Converts this CCLCMsg_LoadingProgress to JSON.
         * @function toJSON
         * @memberof CCLCMsg_LoadingProgress
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CCLCMsg_LoadingProgress.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * Gets the default type url for CCLCMsg_LoadingProgress
         * @function getTypeUrl
         * @memberof CCLCMsg_LoadingProgress
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        CCLCMsg_LoadingProgress.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/CCLCMsg_LoadingProgress";
        };
    
        return CCLCMsg_LoadingProgress;
    })();
    
    $root.CCLCMsg_SplitPlayerConnect = (function() {
    
        /**
         * Properties of a CCLCMsg_SplitPlayerConnect.
         * @exports ICCLCMsg_SplitPlayerConnect
         * @interface ICCLCMsg_SplitPlayerConnect
         * @property {string|null} [playername] CCLCMsg_SplitPlayerConnect playername
         */
    
        /**
         * Constructs a new CCLCMsg_SplitPlayerConnect.
         * @exports CCLCMsg_SplitPlayerConnect
         * @classdesc Represents a CCLCMsg_SplitPlayerConnect.
         * @implements ICCLCMsg_SplitPlayerConnect
         * @constructor
         * @param {ICCLCMsg_SplitPlayerConnect=} [properties] Properties to set
         */
        function CCLCMsg_SplitPlayerConnect(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CCLCMsg_SplitPlayerConnect playername.
         * @member {string} playername
         * @memberof CCLCMsg_SplitPlayerConnect
         * @instance
         */
        CCLCMsg_SplitPlayerConnect.prototype.playername = "";
    
        /**
         * Creates a new CCLCMsg_SplitPlayerConnect instance using the specified properties.
         * @function create
         * @memberof CCLCMsg_SplitPlayerConnect
         * @static
         * @param {ICCLCMsg_SplitPlayerConnect=} [properties] Properties to set
         * @returns {CCLCMsg_SplitPlayerConnect} CCLCMsg_SplitPlayerConnect instance
         */
        CCLCMsg_SplitPlayerConnect.create = function create(properties) {
            return new CCLCMsg_SplitPlayerConnect(properties);
        };
    
        /**
         * Encodes the specified CCLCMsg_SplitPlayerConnect message. Does not implicitly {@link CCLCMsg_SplitPlayerConnect.verify|verify} messages.
         * @function encode
         * @memberof CCLCMsg_SplitPlayerConnect
         * @static
         * @param {ICCLCMsg_SplitPlayerConnect} message CCLCMsg_SplitPlayerConnect message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CCLCMsg_SplitPlayerConnect.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.playername != null && Object.hasOwnProperty.call(message, "playername"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.playername);
            return writer;
        };
    
        /**
         * Encodes the specified CCLCMsg_SplitPlayerConnect message, length delimited. Does not implicitly {@link CCLCMsg_SplitPlayerConnect.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CCLCMsg_SplitPlayerConnect
         * @static
         * @param {ICCLCMsg_SplitPlayerConnect} message CCLCMsg_SplitPlayerConnect message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CCLCMsg_SplitPlayerConnect.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CCLCMsg_SplitPlayerConnect message from the specified reader or buffer.
         * @function decode
         * @memberof CCLCMsg_SplitPlayerConnect
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CCLCMsg_SplitPlayerConnect} CCLCMsg_SplitPlayerConnect
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CCLCMsg_SplitPlayerConnect.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CCLCMsg_SplitPlayerConnect();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.playername = reader.string();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CCLCMsg_SplitPlayerConnect message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CCLCMsg_SplitPlayerConnect
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CCLCMsg_SplitPlayerConnect} CCLCMsg_SplitPlayerConnect
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CCLCMsg_SplitPlayerConnect.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CCLCMsg_SplitPlayerConnect message.
         * @function verify
         * @memberof CCLCMsg_SplitPlayerConnect
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CCLCMsg_SplitPlayerConnect.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.playername != null && message.hasOwnProperty("playername"))
                if (!$util.isString(message.playername))
                    return "playername: string expected";
            return null;
        };
    
        /**
         * Creates a CCLCMsg_SplitPlayerConnect message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CCLCMsg_SplitPlayerConnect
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CCLCMsg_SplitPlayerConnect} CCLCMsg_SplitPlayerConnect
         */
        CCLCMsg_SplitPlayerConnect.fromObject = function fromObject(object) {
            if (object instanceof $root.CCLCMsg_SplitPlayerConnect)
                return object;
            var message = new $root.CCLCMsg_SplitPlayerConnect();
            if (object.playername != null)
                message.playername = String(object.playername);
            return message;
        };
    
        /**
         * Creates a plain object from a CCLCMsg_SplitPlayerConnect message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CCLCMsg_SplitPlayerConnect
         * @static
         * @param {CCLCMsg_SplitPlayerConnect} message CCLCMsg_SplitPlayerConnect
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CCLCMsg_SplitPlayerConnect.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.playername = "";
            if (message.playername != null && message.hasOwnProperty("playername"))
                object.playername = message.playername;
            return object;
        };
    
        /**
         * Converts this CCLCMsg_SplitPlayerConnect to JSON.
         * @function toJSON
         * @memberof CCLCMsg_SplitPlayerConnect
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CCLCMsg_SplitPlayerConnect.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * Gets the default type url for CCLCMsg_SplitPlayerConnect
         * @function getTypeUrl
         * @memberof CCLCMsg_SplitPlayerConnect
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        CCLCMsg_SplitPlayerConnect.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/CCLCMsg_SplitPlayerConnect";
        };
    
        return CCLCMsg_SplitPlayerConnect;
    })();
    
    $root.CCLCMsg_ClientMessage = (function() {
    
        /**
         * Properties of a CCLCMsg_ClientMessage.
         * @exports ICCLCMsg_ClientMessage
         * @interface ICCLCMsg_ClientMessage
         * @property {number|null} [msgType] CCLCMsg_ClientMessage msgType
         * @property {Uint8Array|null} [data] CCLCMsg_ClientMessage data
         */
    
        /**
         * Constructs a new CCLCMsg_ClientMessage.
         * @exports CCLCMsg_ClientMessage
         * @classdesc Represents a CCLCMsg_ClientMessage.
         * @implements ICCLCMsg_ClientMessage
         * @constructor
         * @param {ICCLCMsg_ClientMessage=} [properties] Properties to set
         */
        function CCLCMsg_ClientMessage(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CCLCMsg_ClientMessage msgType.
         * @member {number} msgType
         * @memberof CCLCMsg_ClientMessage
         * @instance
         */
        CCLCMsg_ClientMessage.prototype.msgType = 0;
    
        /**
         * CCLCMsg_ClientMessage data.
         * @member {Uint8Array} data
         * @memberof CCLCMsg_ClientMessage
         * @instance
         */
        CCLCMsg_ClientMessage.prototype.data = $util.newBuffer([]);
    
        /**
         * Creates a new CCLCMsg_ClientMessage instance using the specified properties.
         * @function create
         * @memberof CCLCMsg_ClientMessage
         * @static
         * @param {ICCLCMsg_ClientMessage=} [properties] Properties to set
         * @returns {CCLCMsg_ClientMessage} CCLCMsg_ClientMessage instance
         */
        CCLCMsg_ClientMessage.create = function create(properties) {
            return new CCLCMsg_ClientMessage(properties);
        };
    
        /**
         * Encodes the specified CCLCMsg_ClientMessage message. Does not implicitly {@link CCLCMsg_ClientMessage.verify|verify} messages.
         * @function encode
         * @memberof CCLCMsg_ClientMessage
         * @static
         * @param {ICCLCMsg_ClientMessage} message CCLCMsg_ClientMessage message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CCLCMsg_ClientMessage.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.msgType != null && Object.hasOwnProperty.call(message, "msgType"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.msgType);
            if (message.data != null && Object.hasOwnProperty.call(message, "data"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.data);
            return writer;
        };
    
        /**
         * Encodes the specified CCLCMsg_ClientMessage message, length delimited. Does not implicitly {@link CCLCMsg_ClientMessage.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CCLCMsg_ClientMessage
         * @static
         * @param {ICCLCMsg_ClientMessage} message CCLCMsg_ClientMessage message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CCLCMsg_ClientMessage.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CCLCMsg_ClientMessage message from the specified reader or buffer.
         * @function decode
         * @memberof CCLCMsg_ClientMessage
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CCLCMsg_ClientMessage} CCLCMsg_ClientMessage
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CCLCMsg_ClientMessage.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CCLCMsg_ClientMessage();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.msgType = reader.int32();
                        break;
                    }
                case 2: {
                        message.data = reader.bytes();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CCLCMsg_ClientMessage message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CCLCMsg_ClientMessage
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CCLCMsg_ClientMessage} CCLCMsg_ClientMessage
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CCLCMsg_ClientMessage.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CCLCMsg_ClientMessage message.
         * @function verify
         * @memberof CCLCMsg_ClientMessage
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CCLCMsg_ClientMessage.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.msgType != null && message.hasOwnProperty("msgType"))
                if (!$util.isInteger(message.msgType))
                    return "msgType: integer expected";
            if (message.data != null && message.hasOwnProperty("data"))
                if (!(message.data && typeof message.data.length === "number" || $util.isString(message.data)))
                    return "data: buffer expected";
            return null;
        };
    
        /**
         * Creates a CCLCMsg_ClientMessage message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CCLCMsg_ClientMessage
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CCLCMsg_ClientMessage} CCLCMsg_ClientMessage
         */
        CCLCMsg_ClientMessage.fromObject = function fromObject(object) {
            if (object instanceof $root.CCLCMsg_ClientMessage)
                return object;
            var message = new $root.CCLCMsg_ClientMessage();
            if (object.msgType != null)
                message.msgType = object.msgType | 0;
            if (object.data != null)
                if (typeof object.data === "string")
                    $util.base64.decode(object.data, message.data = $util.newBuffer($util.base64.length(object.data)), 0);
                else if (object.data.length >= 0)
                    message.data = object.data;
            return message;
        };
    
        /**
         * Creates a plain object from a CCLCMsg_ClientMessage message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CCLCMsg_ClientMessage
         * @static
         * @param {CCLCMsg_ClientMessage} message CCLCMsg_ClientMessage
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CCLCMsg_ClientMessage.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.msgType = 0;
                if (options.bytes === String)
                    object.data = "";
                else {
                    object.data = [];
                    if (options.bytes !== Array)
                        object.data = $util.newBuffer(object.data);
                }
            }
            if (message.msgType != null && message.hasOwnProperty("msgType"))
                object.msgType = message.msgType;
            if (message.data != null && message.hasOwnProperty("data"))
                object.data = options.bytes === String ? $util.base64.encode(message.data, 0, message.data.length) : options.bytes === Array ? Array.prototype.slice.call(message.data) : message.data;
            return object;
        };
    
        /**
         * Converts this CCLCMsg_ClientMessage to JSON.
         * @function toJSON
         * @memberof CCLCMsg_ClientMessage
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CCLCMsg_ClientMessage.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * Gets the default type url for CCLCMsg_ClientMessage
         * @function getTypeUrl
         * @memberof CCLCMsg_ClientMessage
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        CCLCMsg_ClientMessage.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/CCLCMsg_ClientMessage";
        };
    
        return CCLCMsg_ClientMessage;
    })();
    
    $root.CCLCMsg_SplitPlayerDisconnect = (function() {
    
        /**
         * Properties of a CCLCMsg_SplitPlayerDisconnect.
         * @exports ICCLCMsg_SplitPlayerDisconnect
         * @interface ICCLCMsg_SplitPlayerDisconnect
         * @property {number|null} [slot] CCLCMsg_SplitPlayerDisconnect slot
         */
    
        /**
         * Constructs a new CCLCMsg_SplitPlayerDisconnect.
         * @exports CCLCMsg_SplitPlayerDisconnect
         * @classdesc Represents a CCLCMsg_SplitPlayerDisconnect.
         * @implements ICCLCMsg_SplitPlayerDisconnect
         * @constructor
         * @param {ICCLCMsg_SplitPlayerDisconnect=} [properties] Properties to set
         */
        function CCLCMsg_SplitPlayerDisconnect(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CCLCMsg_SplitPlayerDisconnect slot.
         * @member {number} slot
         * @memberof CCLCMsg_SplitPlayerDisconnect
         * @instance
         */
        CCLCMsg_SplitPlayerDisconnect.prototype.slot = 0;
    
        /**
         * Creates a new CCLCMsg_SplitPlayerDisconnect instance using the specified properties.
         * @function create
         * @memberof CCLCMsg_SplitPlayerDisconnect
         * @static
         * @param {ICCLCMsg_SplitPlayerDisconnect=} [properties] Properties to set
         * @returns {CCLCMsg_SplitPlayerDisconnect} CCLCMsg_SplitPlayerDisconnect instance
         */
        CCLCMsg_SplitPlayerDisconnect.create = function create(properties) {
            return new CCLCMsg_SplitPlayerDisconnect(properties);
        };
    
        /**
         * Encodes the specified CCLCMsg_SplitPlayerDisconnect message. Does not implicitly {@link CCLCMsg_SplitPlayerDisconnect.verify|verify} messages.
         * @function encode
         * @memberof CCLCMsg_SplitPlayerDisconnect
         * @static
         * @param {ICCLCMsg_SplitPlayerDisconnect} message CCLCMsg_SplitPlayerDisconnect message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CCLCMsg_SplitPlayerDisconnect.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.slot != null && Object.hasOwnProperty.call(message, "slot"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.slot);
            return writer;
        };
    
        /**
         * Encodes the specified CCLCMsg_SplitPlayerDisconnect message, length delimited. Does not implicitly {@link CCLCMsg_SplitPlayerDisconnect.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CCLCMsg_SplitPlayerDisconnect
         * @static
         * @param {ICCLCMsg_SplitPlayerDisconnect} message CCLCMsg_SplitPlayerDisconnect message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CCLCMsg_SplitPlayerDisconnect.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CCLCMsg_SplitPlayerDisconnect message from the specified reader or buffer.
         * @function decode
         * @memberof CCLCMsg_SplitPlayerDisconnect
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CCLCMsg_SplitPlayerDisconnect} CCLCMsg_SplitPlayerDisconnect
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CCLCMsg_SplitPlayerDisconnect.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CCLCMsg_SplitPlayerDisconnect();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.slot = reader.int32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CCLCMsg_SplitPlayerDisconnect message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CCLCMsg_SplitPlayerDisconnect
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CCLCMsg_SplitPlayerDisconnect} CCLCMsg_SplitPlayerDisconnect
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CCLCMsg_SplitPlayerDisconnect.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CCLCMsg_SplitPlayerDisconnect message.
         * @function verify
         * @memberof CCLCMsg_SplitPlayerDisconnect
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CCLCMsg_SplitPlayerDisconnect.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.slot != null && message.hasOwnProperty("slot"))
                if (!$util.isInteger(message.slot))
                    return "slot: integer expected";
            return null;
        };
    
        /**
         * Creates a CCLCMsg_SplitPlayerDisconnect message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CCLCMsg_SplitPlayerDisconnect
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CCLCMsg_SplitPlayerDisconnect} CCLCMsg_SplitPlayerDisconnect
         */
        CCLCMsg_SplitPlayerDisconnect.fromObject = function fromObject(object) {
            if (object instanceof $root.CCLCMsg_SplitPlayerDisconnect)
                return object;
            var message = new $root.CCLCMsg_SplitPlayerDisconnect();
            if (object.slot != null)
                message.slot = object.slot | 0;
            return message;
        };
    
        /**
         * Creates a plain object from a CCLCMsg_SplitPlayerDisconnect message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CCLCMsg_SplitPlayerDisconnect
         * @static
         * @param {CCLCMsg_SplitPlayerDisconnect} message CCLCMsg_SplitPlayerDisconnect
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CCLCMsg_SplitPlayerDisconnect.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.slot = 0;
            if (message.slot != null && message.hasOwnProperty("slot"))
                object.slot = message.slot;
            return object;
        };
    
        /**
         * Converts this CCLCMsg_SplitPlayerDisconnect to JSON.
         * @function toJSON
         * @memberof CCLCMsg_SplitPlayerDisconnect
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CCLCMsg_SplitPlayerDisconnect.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * Gets the default type url for CCLCMsg_SplitPlayerDisconnect
         * @function getTypeUrl
         * @memberof CCLCMsg_SplitPlayerDisconnect
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        CCLCMsg_SplitPlayerDisconnect.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/CCLCMsg_SplitPlayerDisconnect";
        };
    
        return CCLCMsg_SplitPlayerDisconnect;
    })();
    
    $root.CCLCMsg_ServerStatus = (function() {
    
        /**
         * Properties of a CCLCMsg_ServerStatus.
         * @exports ICCLCMsg_ServerStatus
         * @interface ICCLCMsg_ServerStatus
         * @property {boolean|null} [simplified] CCLCMsg_ServerStatus simplified
         */
    
        /**
         * Constructs a new CCLCMsg_ServerStatus.
         * @exports CCLCMsg_ServerStatus
         * @classdesc Represents a CCLCMsg_ServerStatus.
         * @implements ICCLCMsg_ServerStatus
         * @constructor
         * @param {ICCLCMsg_ServerStatus=} [properties] Properties to set
         */
        function CCLCMsg_ServerStatus(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CCLCMsg_ServerStatus simplified.
         * @member {boolean} simplified
         * @memberof CCLCMsg_ServerStatus
         * @instance
         */
        CCLCMsg_ServerStatus.prototype.simplified = false;
    
        /**
         * Creates a new CCLCMsg_ServerStatus instance using the specified properties.
         * @function create
         * @memberof CCLCMsg_ServerStatus
         * @static
         * @param {ICCLCMsg_ServerStatus=} [properties] Properties to set
         * @returns {CCLCMsg_ServerStatus} CCLCMsg_ServerStatus instance
         */
        CCLCMsg_ServerStatus.create = function create(properties) {
            return new CCLCMsg_ServerStatus(properties);
        };
    
        /**
         * Encodes the specified CCLCMsg_ServerStatus message. Does not implicitly {@link CCLCMsg_ServerStatus.verify|verify} messages.
         * @function encode
         * @memberof CCLCMsg_ServerStatus
         * @static
         * @param {ICCLCMsg_ServerStatus} message CCLCMsg_ServerStatus message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CCLCMsg_ServerStatus.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.simplified != null && Object.hasOwnProperty.call(message, "simplified"))
                writer.uint32(/* id 1, wireType 0 =*/8).bool(message.simplified);
            return writer;
        };
    
        /**
         * Encodes the specified CCLCMsg_ServerStatus message, length delimited. Does not implicitly {@link CCLCMsg_ServerStatus.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CCLCMsg_ServerStatus
         * @static
         * @param {ICCLCMsg_ServerStatus} message CCLCMsg_ServerStatus message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CCLCMsg_ServerStatus.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CCLCMsg_ServerStatus message from the specified reader or buffer.
         * @function decode
         * @memberof CCLCMsg_ServerStatus
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CCLCMsg_ServerStatus} CCLCMsg_ServerStatus
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CCLCMsg_ServerStatus.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CCLCMsg_ServerStatus();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.simplified = reader.bool();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CCLCMsg_ServerStatus message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CCLCMsg_ServerStatus
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CCLCMsg_ServerStatus} CCLCMsg_ServerStatus
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CCLCMsg_ServerStatus.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CCLCMsg_ServerStatus message.
         * @function verify
         * @memberof CCLCMsg_ServerStatus
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CCLCMsg_ServerStatus.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.simplified != null && message.hasOwnProperty("simplified"))
                if (typeof message.simplified !== "boolean")
                    return "simplified: boolean expected";
            return null;
        };
    
        /**
         * Creates a CCLCMsg_ServerStatus message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CCLCMsg_ServerStatus
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CCLCMsg_ServerStatus} CCLCMsg_ServerStatus
         */
        CCLCMsg_ServerStatus.fromObject = function fromObject(object) {
            if (object instanceof $root.CCLCMsg_ServerStatus)
                return object;
            var message = new $root.CCLCMsg_ServerStatus();
            if (object.simplified != null)
                message.simplified = Boolean(object.simplified);
            return message;
        };
    
        /**
         * Creates a plain object from a CCLCMsg_ServerStatus message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CCLCMsg_ServerStatus
         * @static
         * @param {CCLCMsg_ServerStatus} message CCLCMsg_ServerStatus
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CCLCMsg_ServerStatus.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.simplified = false;
            if (message.simplified != null && message.hasOwnProperty("simplified"))
                object.simplified = message.simplified;
            return object;
        };
    
        /**
         * Converts this CCLCMsg_ServerStatus to JSON.
         * @function toJSON
         * @memberof CCLCMsg_ServerStatus
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CCLCMsg_ServerStatus.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * Gets the default type url for CCLCMsg_ServerStatus
         * @function getTypeUrl
         * @memberof CCLCMsg_ServerStatus
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        CCLCMsg_ServerStatus.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/CCLCMsg_ServerStatus";
        };
    
        return CCLCMsg_ServerStatus;
    })();
    
    $root.CCLCMsg_RequestPause = (function() {
    
        /**
         * Properties of a CCLCMsg_RequestPause.
         * @exports ICCLCMsg_RequestPause
         * @interface ICCLCMsg_RequestPause
         * @property {RequestPause_t|null} [pauseType] CCLCMsg_RequestPause pauseType
         * @property {number|null} [pauseGroup] CCLCMsg_RequestPause pauseGroup
         */
    
        /**
         * Constructs a new CCLCMsg_RequestPause.
         * @exports CCLCMsg_RequestPause
         * @classdesc Represents a CCLCMsg_RequestPause.
         * @implements ICCLCMsg_RequestPause
         * @constructor
         * @param {ICCLCMsg_RequestPause=} [properties] Properties to set
         */
        function CCLCMsg_RequestPause(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CCLCMsg_RequestPause pauseType.
         * @member {RequestPause_t} pauseType
         * @memberof CCLCMsg_RequestPause
         * @instance
         */
        CCLCMsg_RequestPause.prototype.pauseType = 0;
    
        /**
         * CCLCMsg_RequestPause pauseGroup.
         * @member {number} pauseGroup
         * @memberof CCLCMsg_RequestPause
         * @instance
         */
        CCLCMsg_RequestPause.prototype.pauseGroup = 0;
    
        /**
         * Creates a new CCLCMsg_RequestPause instance using the specified properties.
         * @function create
         * @memberof CCLCMsg_RequestPause
         * @static
         * @param {ICCLCMsg_RequestPause=} [properties] Properties to set
         * @returns {CCLCMsg_RequestPause} CCLCMsg_RequestPause instance
         */
        CCLCMsg_RequestPause.create = function create(properties) {
            return new CCLCMsg_RequestPause(properties);
        };
    
        /**
         * Encodes the specified CCLCMsg_RequestPause message. Does not implicitly {@link CCLCMsg_RequestPause.verify|verify} messages.
         * @function encode
         * @memberof CCLCMsg_RequestPause
         * @static
         * @param {ICCLCMsg_RequestPause} message CCLCMsg_RequestPause message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CCLCMsg_RequestPause.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.pauseType != null && Object.hasOwnProperty.call(message, "pauseType"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.pauseType);
            if (message.pauseGroup != null && Object.hasOwnProperty.call(message, "pauseGroup"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.pauseGroup);
            return writer;
        };
    
        /**
         * Encodes the specified CCLCMsg_RequestPause message, length delimited. Does not implicitly {@link CCLCMsg_RequestPause.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CCLCMsg_RequestPause
         * @static
         * @param {ICCLCMsg_RequestPause} message CCLCMsg_RequestPause message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CCLCMsg_RequestPause.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CCLCMsg_RequestPause message from the specified reader or buffer.
         * @function decode
         * @memberof CCLCMsg_RequestPause
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CCLCMsg_RequestPause} CCLCMsg_RequestPause
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CCLCMsg_RequestPause.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CCLCMsg_RequestPause();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.pauseType = reader.int32();
                        break;
                    }
                case 2: {
                        message.pauseGroup = reader.int32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CCLCMsg_RequestPause message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CCLCMsg_RequestPause
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CCLCMsg_RequestPause} CCLCMsg_RequestPause
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CCLCMsg_RequestPause.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CCLCMsg_RequestPause message.
         * @function verify
         * @memberof CCLCMsg_RequestPause
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CCLCMsg_RequestPause.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.pauseType != null && message.hasOwnProperty("pauseType"))
                switch (message.pauseType) {
                default:
                    return "pauseType: enum value expected";
                case 0:
                case 1:
                case 2:
                    break;
                }
            if (message.pauseGroup != null && message.hasOwnProperty("pauseGroup"))
                if (!$util.isInteger(message.pauseGroup))
                    return "pauseGroup: integer expected";
            return null;
        };
    
        /**
         * Creates a CCLCMsg_RequestPause message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CCLCMsg_RequestPause
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CCLCMsg_RequestPause} CCLCMsg_RequestPause
         */
        CCLCMsg_RequestPause.fromObject = function fromObject(object) {
            if (object instanceof $root.CCLCMsg_RequestPause)
                return object;
            var message = new $root.CCLCMsg_RequestPause();
            switch (object.pauseType) {
            default:
                if (typeof object.pauseType === "number") {
                    message.pauseType = object.pauseType;
                    break;
                }
                break;
            case "RP_PAUSE":
            case 0:
                message.pauseType = 0;
                break;
            case "RP_UNPAUSE":
            case 1:
                message.pauseType = 1;
                break;
            case "RP_TOGGLEPAUSE":
            case 2:
                message.pauseType = 2;
                break;
            }
            if (object.pauseGroup != null)
                message.pauseGroup = object.pauseGroup | 0;
            return message;
        };
    
        /**
         * Creates a plain object from a CCLCMsg_RequestPause message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CCLCMsg_RequestPause
         * @static
         * @param {CCLCMsg_RequestPause} message CCLCMsg_RequestPause
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CCLCMsg_RequestPause.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.pauseType = options.enums === String ? "RP_PAUSE" : 0;
                object.pauseGroup = 0;
            }
            if (message.pauseType != null && message.hasOwnProperty("pauseType"))
                object.pauseType = options.enums === String ? $root.RequestPause_t[message.pauseType] === undefined ? message.pauseType : $root.RequestPause_t[message.pauseType] : message.pauseType;
            if (message.pauseGroup != null && message.hasOwnProperty("pauseGroup"))
                object.pauseGroup = message.pauseGroup;
            return object;
        };
    
        /**
         * Converts this CCLCMsg_RequestPause to JSON.
         * @function toJSON
         * @memberof CCLCMsg_RequestPause
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CCLCMsg_RequestPause.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * Gets the default type url for CCLCMsg_RequestPause
         * @function getTypeUrl
         * @memberof CCLCMsg_RequestPause
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        CCLCMsg_RequestPause.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/CCLCMsg_RequestPause";
        };
    
        return CCLCMsg_RequestPause;
    })();
    
    $root.CCLCMsg_CmdKeyValues = (function() {
    
        /**
         * Properties of a CCLCMsg_CmdKeyValues.
         * @exports ICCLCMsg_CmdKeyValues
         * @interface ICCLCMsg_CmdKeyValues
         * @property {Uint8Array|null} [data] CCLCMsg_CmdKeyValues data
         */
    
        /**
         * Constructs a new CCLCMsg_CmdKeyValues.
         * @exports CCLCMsg_CmdKeyValues
         * @classdesc Represents a CCLCMsg_CmdKeyValues.
         * @implements ICCLCMsg_CmdKeyValues
         * @constructor
         * @param {ICCLCMsg_CmdKeyValues=} [properties] Properties to set
         */
        function CCLCMsg_CmdKeyValues(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CCLCMsg_CmdKeyValues data.
         * @member {Uint8Array} data
         * @memberof CCLCMsg_CmdKeyValues
         * @instance
         */
        CCLCMsg_CmdKeyValues.prototype.data = $util.newBuffer([]);
    
        /**
         * Creates a new CCLCMsg_CmdKeyValues instance using the specified properties.
         * @function create
         * @memberof CCLCMsg_CmdKeyValues
         * @static
         * @param {ICCLCMsg_CmdKeyValues=} [properties] Properties to set
         * @returns {CCLCMsg_CmdKeyValues} CCLCMsg_CmdKeyValues instance
         */
        CCLCMsg_CmdKeyValues.create = function create(properties) {
            return new CCLCMsg_CmdKeyValues(properties);
        };
    
        /**
         * Encodes the specified CCLCMsg_CmdKeyValues message. Does not implicitly {@link CCLCMsg_CmdKeyValues.verify|verify} messages.
         * @function encode
         * @memberof CCLCMsg_CmdKeyValues
         * @static
         * @param {ICCLCMsg_CmdKeyValues} message CCLCMsg_CmdKeyValues message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CCLCMsg_CmdKeyValues.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.data != null && Object.hasOwnProperty.call(message, "data"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.data);
            return writer;
        };
    
        /**
         * Encodes the specified CCLCMsg_CmdKeyValues message, length delimited. Does not implicitly {@link CCLCMsg_CmdKeyValues.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CCLCMsg_CmdKeyValues
         * @static
         * @param {ICCLCMsg_CmdKeyValues} message CCLCMsg_CmdKeyValues message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CCLCMsg_CmdKeyValues.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CCLCMsg_CmdKeyValues message from the specified reader or buffer.
         * @function decode
         * @memberof CCLCMsg_CmdKeyValues
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CCLCMsg_CmdKeyValues} CCLCMsg_CmdKeyValues
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CCLCMsg_CmdKeyValues.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CCLCMsg_CmdKeyValues();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.data = reader.bytes();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CCLCMsg_CmdKeyValues message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CCLCMsg_CmdKeyValues
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CCLCMsg_CmdKeyValues} CCLCMsg_CmdKeyValues
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CCLCMsg_CmdKeyValues.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CCLCMsg_CmdKeyValues message.
         * @function verify
         * @memberof CCLCMsg_CmdKeyValues
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CCLCMsg_CmdKeyValues.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.data != null && message.hasOwnProperty("data"))
                if (!(message.data && typeof message.data.length === "number" || $util.isString(message.data)))
                    return "data: buffer expected";
            return null;
        };
    
        /**
         * Creates a CCLCMsg_CmdKeyValues message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CCLCMsg_CmdKeyValues
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CCLCMsg_CmdKeyValues} CCLCMsg_CmdKeyValues
         */
        CCLCMsg_CmdKeyValues.fromObject = function fromObject(object) {
            if (object instanceof $root.CCLCMsg_CmdKeyValues)
                return object;
            var message = new $root.CCLCMsg_CmdKeyValues();
            if (object.data != null)
                if (typeof object.data === "string")
                    $util.base64.decode(object.data, message.data = $util.newBuffer($util.base64.length(object.data)), 0);
                else if (object.data.length >= 0)
                    message.data = object.data;
            return message;
        };
    
        /**
         * Creates a plain object from a CCLCMsg_CmdKeyValues message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CCLCMsg_CmdKeyValues
         * @static
         * @param {CCLCMsg_CmdKeyValues} message CCLCMsg_CmdKeyValues
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CCLCMsg_CmdKeyValues.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                if (options.bytes === String)
                    object.data = "";
                else {
                    object.data = [];
                    if (options.bytes !== Array)
                        object.data = $util.newBuffer(object.data);
                }
            if (message.data != null && message.hasOwnProperty("data"))
                object.data = options.bytes === String ? $util.base64.encode(message.data, 0, message.data.length) : options.bytes === Array ? Array.prototype.slice.call(message.data) : message.data;
            return object;
        };
    
        /**
         * Converts this CCLCMsg_CmdKeyValues to JSON.
         * @function toJSON
         * @memberof CCLCMsg_CmdKeyValues
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CCLCMsg_CmdKeyValues.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * Gets the default type url for CCLCMsg_CmdKeyValues
         * @function getTypeUrl
         * @memberof CCLCMsg_CmdKeyValues
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        CCLCMsg_CmdKeyValues.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/CCLCMsg_CmdKeyValues";
        };
    
        return CCLCMsg_CmdKeyValues;
    })();
    
    $root.CCLCMsg_RconServerDetails = (function() {
    
        /**
         * Properties of a CCLCMsg_RconServerDetails.
         * @exports ICCLCMsg_RconServerDetails
         * @interface ICCLCMsg_RconServerDetails
         * @property {Uint8Array|null} [token] CCLCMsg_RconServerDetails token
         */
    
        /**
         * Constructs a new CCLCMsg_RconServerDetails.
         * @exports CCLCMsg_RconServerDetails
         * @classdesc Represents a CCLCMsg_RconServerDetails.
         * @implements ICCLCMsg_RconServerDetails
         * @constructor
         * @param {ICCLCMsg_RconServerDetails=} [properties] Properties to set
         */
        function CCLCMsg_RconServerDetails(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CCLCMsg_RconServerDetails token.
         * @member {Uint8Array} token
         * @memberof CCLCMsg_RconServerDetails
         * @instance
         */
        CCLCMsg_RconServerDetails.prototype.token = $util.newBuffer([]);
    
        /**
         * Creates a new CCLCMsg_RconServerDetails instance using the specified properties.
         * @function create
         * @memberof CCLCMsg_RconServerDetails
         * @static
         * @param {ICCLCMsg_RconServerDetails=} [properties] Properties to set
         * @returns {CCLCMsg_RconServerDetails} CCLCMsg_RconServerDetails instance
         */
        CCLCMsg_RconServerDetails.create = function create(properties) {
            return new CCLCMsg_RconServerDetails(properties);
        };
    
        /**
         * Encodes the specified CCLCMsg_RconServerDetails message. Does not implicitly {@link CCLCMsg_RconServerDetails.verify|verify} messages.
         * @function encode
         * @memberof CCLCMsg_RconServerDetails
         * @static
         * @param {ICCLCMsg_RconServerDetails} message CCLCMsg_RconServerDetails message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CCLCMsg_RconServerDetails.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.token != null && Object.hasOwnProperty.call(message, "token"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.token);
            return writer;
        };
    
        /**
         * Encodes the specified CCLCMsg_RconServerDetails message, length delimited. Does not implicitly {@link CCLCMsg_RconServerDetails.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CCLCMsg_RconServerDetails
         * @static
         * @param {ICCLCMsg_RconServerDetails} message CCLCMsg_RconServerDetails message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CCLCMsg_RconServerDetails.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CCLCMsg_RconServerDetails message from the specified reader or buffer.
         * @function decode
         * @memberof CCLCMsg_RconServerDetails
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CCLCMsg_RconServerDetails} CCLCMsg_RconServerDetails
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CCLCMsg_RconServerDetails.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CCLCMsg_RconServerDetails();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.token = reader.bytes();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CCLCMsg_RconServerDetails message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CCLCMsg_RconServerDetails
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CCLCMsg_RconServerDetails} CCLCMsg_RconServerDetails
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CCLCMsg_RconServerDetails.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CCLCMsg_RconServerDetails message.
         * @function verify
         * @memberof CCLCMsg_RconServerDetails
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CCLCMsg_RconServerDetails.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.token != null && message.hasOwnProperty("token"))
                if (!(message.token && typeof message.token.length === "number" || $util.isString(message.token)))
                    return "token: buffer expected";
            return null;
        };
    
        /**
         * Creates a CCLCMsg_RconServerDetails message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CCLCMsg_RconServerDetails
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CCLCMsg_RconServerDetails} CCLCMsg_RconServerDetails
         */
        CCLCMsg_RconServerDetails.fromObject = function fromObject(object) {
            if (object instanceof $root.CCLCMsg_RconServerDetails)
                return object;
            var message = new $root.CCLCMsg_RconServerDetails();
            if (object.token != null)
                if (typeof object.token === "string")
                    $util.base64.decode(object.token, message.token = $util.newBuffer($util.base64.length(object.token)), 0);
                else if (object.token.length >= 0)
                    message.token = object.token;
            return message;
        };
    
        /**
         * Creates a plain object from a CCLCMsg_RconServerDetails message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CCLCMsg_RconServerDetails
         * @static
         * @param {CCLCMsg_RconServerDetails} message CCLCMsg_RconServerDetails
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CCLCMsg_RconServerDetails.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                if (options.bytes === String)
                    object.token = "";
                else {
                    object.token = [];
                    if (options.bytes !== Array)
                        object.token = $util.newBuffer(object.token);
                }
            if (message.token != null && message.hasOwnProperty("token"))
                object.token = options.bytes === String ? $util.base64.encode(message.token, 0, message.token.length) : options.bytes === Array ? Array.prototype.slice.call(message.token) : message.token;
            return object;
        };
    
        /**
         * Converts this CCLCMsg_RconServerDetails to JSON.
         * @function toJSON
         * @memberof CCLCMsg_RconServerDetails
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CCLCMsg_RconServerDetails.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * Gets the default type url for CCLCMsg_RconServerDetails
         * @function getTypeUrl
         * @memberof CCLCMsg_RconServerDetails
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        CCLCMsg_RconServerDetails.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/CCLCMsg_RconServerDetails";
        };
    
        return CCLCMsg_RconServerDetails;
    })();
    
    $root.CSVCMsg_ServerInfo = (function() {
    
        /**
         * Properties of a CSVCMsg_ServerInfo.
         * @exports ICSVCMsg_ServerInfo
         * @interface ICSVCMsg_ServerInfo
         * @property {number|null} [protocol] CSVCMsg_ServerInfo protocol
         * @property {number|null} [serverCount] CSVCMsg_ServerInfo serverCount
         * @property {boolean|null} [isDedicated] CSVCMsg_ServerInfo isDedicated
         * @property {boolean|null} [isHltv] CSVCMsg_ServerInfo isHltv
         * @property {number|null} [cOs] CSVCMsg_ServerInfo cOs
         * @property {number|null} [maxClients] CSVCMsg_ServerInfo maxClients
         * @property {number|null} [maxClasses] CSVCMsg_ServerInfo maxClasses
         * @property {number|null} [playerSlot] CSVCMsg_ServerInfo playerSlot
         * @property {number|null} [tickInterval] CSVCMsg_ServerInfo tickInterval
         * @property {string|null} [gameDir] CSVCMsg_ServerInfo gameDir
         * @property {string|null} [mapName] CSVCMsg_ServerInfo mapName
         * @property {string|null} [skyName] CSVCMsg_ServerInfo skyName
         * @property {string|null} [hostName] CSVCMsg_ServerInfo hostName
         * @property {string|null} [addonName] CSVCMsg_ServerInfo addonName
         * @property {ICSVCMsg_GameSessionConfiguration|null} [gameSessionConfig] CSVCMsg_ServerInfo gameSessionConfig
         * @property {Uint8Array|null} [gameSessionManifest] CSVCMsg_ServerInfo gameSessionManifest
         */
    
        /**
         * Constructs a new CSVCMsg_ServerInfo.
         * @exports CSVCMsg_ServerInfo
         * @classdesc Represents a CSVCMsg_ServerInfo.
         * @implements ICSVCMsg_ServerInfo
         * @constructor
         * @param {ICSVCMsg_ServerInfo=} [properties] Properties to set
         */
        function CSVCMsg_ServerInfo(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CSVCMsg_ServerInfo protocol.
         * @member {number} protocol
         * @memberof CSVCMsg_ServerInfo
         * @instance
         */
        CSVCMsg_ServerInfo.prototype.protocol = 0;
    
        /**
         * CSVCMsg_ServerInfo serverCount.
         * @member {number} serverCount
         * @memberof CSVCMsg_ServerInfo
         * @instance
         */
        CSVCMsg_ServerInfo.prototype.serverCount = 0;
    
        /**
         * CSVCMsg_ServerInfo isDedicated.
         * @member {boolean} isDedicated
         * @memberof CSVCMsg_ServerInfo
         * @instance
         */
        CSVCMsg_ServerInfo.prototype.isDedicated = false;
    
        /**
         * CSVCMsg_ServerInfo isHltv.
         * @member {boolean} isHltv
         * @memberof CSVCMsg_ServerInfo
         * @instance
         */
        CSVCMsg_ServerInfo.prototype.isHltv = false;
    
        /**
         * CSVCMsg_ServerInfo cOs.
         * @member {number} cOs
         * @memberof CSVCMsg_ServerInfo
         * @instance
         */
        CSVCMsg_ServerInfo.prototype.cOs = 0;
    
        /**
         * CSVCMsg_ServerInfo maxClients.
         * @member {number} maxClients
         * @memberof CSVCMsg_ServerInfo
         * @instance
         */
        CSVCMsg_ServerInfo.prototype.maxClients = 0;
    
        /**
         * CSVCMsg_ServerInfo maxClasses.
         * @member {number} maxClasses
         * @memberof CSVCMsg_ServerInfo
         * @instance
         */
        CSVCMsg_ServerInfo.prototype.maxClasses = 0;
    
        /**
         * CSVCMsg_ServerInfo playerSlot.
         * @member {number} playerSlot
         * @memberof CSVCMsg_ServerInfo
         * @instance
         */
        CSVCMsg_ServerInfo.prototype.playerSlot = -1;
    
        /**
         * CSVCMsg_ServerInfo tickInterval.
         * @member {number} tickInterval
         * @memberof CSVCMsg_ServerInfo
         * @instance
         */
        CSVCMsg_ServerInfo.prototype.tickInterval = 0;
    
        /**
         * CSVCMsg_ServerInfo gameDir.
         * @member {string} gameDir
         * @memberof CSVCMsg_ServerInfo
         * @instance
         */
        CSVCMsg_ServerInfo.prototype.gameDir = "";
    
        /**
         * CSVCMsg_ServerInfo mapName.
         * @member {string} mapName
         * @memberof CSVCMsg_ServerInfo
         * @instance
         */
        CSVCMsg_ServerInfo.prototype.mapName = "";
    
        /**
         * CSVCMsg_ServerInfo skyName.
         * @member {string} skyName
         * @memberof CSVCMsg_ServerInfo
         * @instance
         */
        CSVCMsg_ServerInfo.prototype.skyName = "";
    
        /**
         * CSVCMsg_ServerInfo hostName.
         * @member {string} hostName
         * @memberof CSVCMsg_ServerInfo
         * @instance
         */
        CSVCMsg_ServerInfo.prototype.hostName = "";
    
        /**
         * CSVCMsg_ServerInfo addonName.
         * @member {string} addonName
         * @memberof CSVCMsg_ServerInfo
         * @instance
         */
        CSVCMsg_ServerInfo.prototype.addonName = "";
    
        /**
         * CSVCMsg_ServerInfo gameSessionConfig.
         * @member {ICSVCMsg_GameSessionConfiguration|null|undefined} gameSessionConfig
         * @memberof CSVCMsg_ServerInfo
         * @instance
         */
        CSVCMsg_ServerInfo.prototype.gameSessionConfig = null;
    
        /**
         * CSVCMsg_ServerInfo gameSessionManifest.
         * @member {Uint8Array} gameSessionManifest
         * @memberof CSVCMsg_ServerInfo
         * @instance
         */
        CSVCMsg_ServerInfo.prototype.gameSessionManifest = $util.newBuffer([]);
    
        /**
         * Creates a new CSVCMsg_ServerInfo instance using the specified properties.
         * @function create
         * @memberof CSVCMsg_ServerInfo
         * @static
         * @param {ICSVCMsg_ServerInfo=} [properties] Properties to set
         * @returns {CSVCMsg_ServerInfo} CSVCMsg_ServerInfo instance
         */
        CSVCMsg_ServerInfo.create = function create(properties) {
            return new CSVCMsg_ServerInfo(properties);
        };
    
        /**
         * Encodes the specified CSVCMsg_ServerInfo message. Does not implicitly {@link CSVCMsg_ServerInfo.verify|verify} messages.
         * @function encode
         * @memberof CSVCMsg_ServerInfo
         * @static
         * @param {ICSVCMsg_ServerInfo} message CSVCMsg_ServerInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CSVCMsg_ServerInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.protocol != null && Object.hasOwnProperty.call(message, "protocol"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.protocol);
            if (message.serverCount != null && Object.hasOwnProperty.call(message, "serverCount"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.serverCount);
            if (message.isDedicated != null && Object.hasOwnProperty.call(message, "isDedicated"))
                writer.uint32(/* id 3, wireType 0 =*/24).bool(message.isDedicated);
            if (message.isHltv != null && Object.hasOwnProperty.call(message, "isHltv"))
                writer.uint32(/* id 4, wireType 0 =*/32).bool(message.isHltv);
            if (message.cOs != null && Object.hasOwnProperty.call(message, "cOs"))
                writer.uint32(/* id 6, wireType 0 =*/48).int32(message.cOs);
            if (message.maxClients != null && Object.hasOwnProperty.call(message, "maxClients"))
                writer.uint32(/* id 10, wireType 0 =*/80).int32(message.maxClients);
            if (message.maxClasses != null && Object.hasOwnProperty.call(message, "maxClasses"))
                writer.uint32(/* id 11, wireType 0 =*/88).int32(message.maxClasses);
            if (message.playerSlot != null && Object.hasOwnProperty.call(message, "playerSlot"))
                writer.uint32(/* id 12, wireType 0 =*/96).int32(message.playerSlot);
            if (message.tickInterval != null && Object.hasOwnProperty.call(message, "tickInterval"))
                writer.uint32(/* id 13, wireType 5 =*/109).float(message.tickInterval);
            if (message.gameDir != null && Object.hasOwnProperty.call(message, "gameDir"))
                writer.uint32(/* id 14, wireType 2 =*/114).string(message.gameDir);
            if (message.mapName != null && Object.hasOwnProperty.call(message, "mapName"))
                writer.uint32(/* id 15, wireType 2 =*/122).string(message.mapName);
            if (message.skyName != null && Object.hasOwnProperty.call(message, "skyName"))
                writer.uint32(/* id 16, wireType 2 =*/130).string(message.skyName);
            if (message.hostName != null && Object.hasOwnProperty.call(message, "hostName"))
                writer.uint32(/* id 17, wireType 2 =*/138).string(message.hostName);
            if (message.addonName != null && Object.hasOwnProperty.call(message, "addonName"))
                writer.uint32(/* id 18, wireType 2 =*/146).string(message.addonName);
            if (message.gameSessionConfig != null && Object.hasOwnProperty.call(message, "gameSessionConfig"))
                $root.CSVCMsg_GameSessionConfiguration.encode(message.gameSessionConfig, writer.uint32(/* id 19, wireType 2 =*/154).fork()).ldelim();
            if (message.gameSessionManifest != null && Object.hasOwnProperty.call(message, "gameSessionManifest"))
                writer.uint32(/* id 20, wireType 2 =*/162).bytes(message.gameSessionManifest);
            return writer;
        };
    
        /**
         * Encodes the specified CSVCMsg_ServerInfo message, length delimited. Does not implicitly {@link CSVCMsg_ServerInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CSVCMsg_ServerInfo
         * @static
         * @param {ICSVCMsg_ServerInfo} message CSVCMsg_ServerInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CSVCMsg_ServerInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CSVCMsg_ServerInfo message from the specified reader or buffer.
         * @function decode
         * @memberof CSVCMsg_ServerInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CSVCMsg_ServerInfo} CSVCMsg_ServerInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CSVCMsg_ServerInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CSVCMsg_ServerInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.protocol = reader.int32();
                        break;
                    }
                case 2: {
                        message.serverCount = reader.int32();
                        break;
                    }
                case 3: {
                        message.isDedicated = reader.bool();
                        break;
                    }
                case 4: {
                        message.isHltv = reader.bool();
                        break;
                    }
                case 6: {
                        message.cOs = reader.int32();
                        break;
                    }
                case 10: {
                        message.maxClients = reader.int32();
                        break;
                    }
                case 11: {
                        message.maxClasses = reader.int32();
                        break;
                    }
                case 12: {
                        message.playerSlot = reader.int32();
                        break;
                    }
                case 13: {
                        message.tickInterval = reader.float();
                        break;
                    }
                case 14: {
                        message.gameDir = reader.string();
                        break;
                    }
                case 15: {
                        message.mapName = reader.string();
                        break;
                    }
                case 16: {
                        message.skyName = reader.string();
                        break;
                    }
                case 17: {
                        message.hostName = reader.string();
                        break;
                    }
                case 18: {
                        message.addonName = reader.string();
                        break;
                    }
                case 19: {
                        message.gameSessionConfig = $root.CSVCMsg_GameSessionConfiguration.decode(reader, reader.uint32());
                        break;
                    }
                case 20: {
                        message.gameSessionManifest = reader.bytes();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CSVCMsg_ServerInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CSVCMsg_ServerInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CSVCMsg_ServerInfo} CSVCMsg_ServerInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CSVCMsg_ServerInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CSVCMsg_ServerInfo message.
         * @function verify
         * @memberof CSVCMsg_ServerInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CSVCMsg_ServerInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.protocol != null && message.hasOwnProperty("protocol"))
                if (!$util.isInteger(message.protocol))
                    return "protocol: integer expected";
            if (message.serverCount != null && message.hasOwnProperty("serverCount"))
                if (!$util.isInteger(message.serverCount))
                    return "serverCount: integer expected";
            if (message.isDedicated != null && message.hasOwnProperty("isDedicated"))
                if (typeof message.isDedicated !== "boolean")
                    return "isDedicated: boolean expected";
            if (message.isHltv != null && message.hasOwnProperty("isHltv"))
                if (typeof message.isHltv !== "boolean")
                    return "isHltv: boolean expected";
            if (message.cOs != null && message.hasOwnProperty("cOs"))
                if (!$util.isInteger(message.cOs))
                    return "cOs: integer expected";
            if (message.maxClients != null && message.hasOwnProperty("maxClients"))
                if (!$util.isInteger(message.maxClients))
                    return "maxClients: integer expected";
            if (message.maxClasses != null && message.hasOwnProperty("maxClasses"))
                if (!$util.isInteger(message.maxClasses))
                    return "maxClasses: integer expected";
            if (message.playerSlot != null && message.hasOwnProperty("playerSlot"))
                if (!$util.isInteger(message.playerSlot))
                    return "playerSlot: integer expected";
            if (message.tickInterval != null && message.hasOwnProperty("tickInterval"))
                if (typeof message.tickInterval !== "number")
                    return "tickInterval: number expected";
            if (message.gameDir != null && message.hasOwnProperty("gameDir"))
                if (!$util.isString(message.gameDir))
                    return "gameDir: string expected";
            if (message.mapName != null && message.hasOwnProperty("mapName"))
                if (!$util.isString(message.mapName))
                    return "mapName: string expected";
            if (message.skyName != null && message.hasOwnProperty("skyName"))
                if (!$util.isString(message.skyName))
                    return "skyName: string expected";
            if (message.hostName != null && message.hasOwnProperty("hostName"))
                if (!$util.isString(message.hostName))
                    return "hostName: string expected";
            if (message.addonName != null && message.hasOwnProperty("addonName"))
                if (!$util.isString(message.addonName))
                    return "addonName: string expected";
            if (message.gameSessionConfig != null && message.hasOwnProperty("gameSessionConfig")) {
                var error = $root.CSVCMsg_GameSessionConfiguration.verify(message.gameSessionConfig);
                if (error)
                    return "gameSessionConfig." + error;
            }
            if (message.gameSessionManifest != null && message.hasOwnProperty("gameSessionManifest"))
                if (!(message.gameSessionManifest && typeof message.gameSessionManifest.length === "number" || $util.isString(message.gameSessionManifest)))
                    return "gameSessionManifest: buffer expected";
            return null;
        };
    
        /**
         * Creates a CSVCMsg_ServerInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CSVCMsg_ServerInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CSVCMsg_ServerInfo} CSVCMsg_ServerInfo
         */
        CSVCMsg_ServerInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.CSVCMsg_ServerInfo)
                return object;
            var message = new $root.CSVCMsg_ServerInfo();
            if (object.protocol != null)
                message.protocol = object.protocol | 0;
            if (object.serverCount != null)
                message.serverCount = object.serverCount | 0;
            if (object.isDedicated != null)
                message.isDedicated = Boolean(object.isDedicated);
            if (object.isHltv != null)
                message.isHltv = Boolean(object.isHltv);
            if (object.cOs != null)
                message.cOs = object.cOs | 0;
            if (object.maxClients != null)
                message.maxClients = object.maxClients | 0;
            if (object.maxClasses != null)
                message.maxClasses = object.maxClasses | 0;
            if (object.playerSlot != null)
                message.playerSlot = object.playerSlot | 0;
            if (object.tickInterval != null)
                message.tickInterval = Number(object.tickInterval);
            if (object.gameDir != null)
                message.gameDir = String(object.gameDir);
            if (object.mapName != null)
                message.mapName = String(object.mapName);
            if (object.skyName != null)
                message.skyName = String(object.skyName);
            if (object.hostName != null)
                message.hostName = String(object.hostName);
            if (object.addonName != null)
                message.addonName = String(object.addonName);
            if (object.gameSessionConfig != null) {
                if (typeof object.gameSessionConfig !== "object")
                    throw TypeError(".CSVCMsg_ServerInfo.gameSessionConfig: object expected");
                message.gameSessionConfig = $root.CSVCMsg_GameSessionConfiguration.fromObject(object.gameSessionConfig);
            }
            if (object.gameSessionManifest != null)
                if (typeof object.gameSessionManifest === "string")
                    $util.base64.decode(object.gameSessionManifest, message.gameSessionManifest = $util.newBuffer($util.base64.length(object.gameSessionManifest)), 0);
                else if (object.gameSessionManifest.length >= 0)
                    message.gameSessionManifest = object.gameSessionManifest;
            return message;
        };
    
        /**
         * Creates a plain object from a CSVCMsg_ServerInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CSVCMsg_ServerInfo
         * @static
         * @param {CSVCMsg_ServerInfo} message CSVCMsg_ServerInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CSVCMsg_ServerInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.protocol = 0;
                object.serverCount = 0;
                object.isDedicated = false;
                object.isHltv = false;
                object.cOs = 0;
                object.maxClients = 0;
                object.maxClasses = 0;
                object.playerSlot = -1;
                object.tickInterval = 0;
                object.gameDir = "";
                object.mapName = "";
                object.skyName = "";
                object.hostName = "";
                object.addonName = "";
                object.gameSessionConfig = null;
                if (options.bytes === String)
                    object.gameSessionManifest = "";
                else {
                    object.gameSessionManifest = [];
                    if (options.bytes !== Array)
                        object.gameSessionManifest = $util.newBuffer(object.gameSessionManifest);
                }
            }
            if (message.protocol != null && message.hasOwnProperty("protocol"))
                object.protocol = message.protocol;
            if (message.serverCount != null && message.hasOwnProperty("serverCount"))
                object.serverCount = message.serverCount;
            if (message.isDedicated != null && message.hasOwnProperty("isDedicated"))
                object.isDedicated = message.isDedicated;
            if (message.isHltv != null && message.hasOwnProperty("isHltv"))
                object.isHltv = message.isHltv;
            if (message.cOs != null && message.hasOwnProperty("cOs"))
                object.cOs = message.cOs;
            if (message.maxClients != null && message.hasOwnProperty("maxClients"))
                object.maxClients = message.maxClients;
            if (message.maxClasses != null && message.hasOwnProperty("maxClasses"))
                object.maxClasses = message.maxClasses;
            if (message.playerSlot != null && message.hasOwnProperty("playerSlot"))
                object.playerSlot = message.playerSlot;
            if (message.tickInterval != null && message.hasOwnProperty("tickInterval"))
                object.tickInterval = options.json && !isFinite(message.tickInterval) ? String(message.tickInterval) : message.tickInterval;
            if (message.gameDir != null && message.hasOwnProperty("gameDir"))
                object.gameDir = message.gameDir;
            if (message.mapName != null && message.hasOwnProperty("mapName"))
                object.mapName = message.mapName;
            if (message.skyName != null && message.hasOwnProperty("skyName"))
                object.skyName = message.skyName;
            if (message.hostName != null && message.hasOwnProperty("hostName"))
                object.hostName = message.hostName;
            if (message.addonName != null && message.hasOwnProperty("addonName"))
                object.addonName = message.addonName;
            if (message.gameSessionConfig != null && message.hasOwnProperty("gameSessionConfig"))
                object.gameSessionConfig = $root.CSVCMsg_GameSessionConfiguration.toObject(message.gameSessionConfig, options);
            if (message.gameSessionManifest != null && message.hasOwnProperty("gameSessionManifest"))
                object.gameSessionManifest = options.bytes === String ? $util.base64.encode(message.gameSessionManifest, 0, message.gameSessionManifest.length) : options.bytes === Array ? Array.prototype.slice.call(message.gameSessionManifest) : message.gameSessionManifest;
            return object;
        };
    
        /**
         * Converts this CSVCMsg_ServerInfo to JSON.
         * @function toJSON
         * @memberof CSVCMsg_ServerInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CSVCMsg_ServerInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * Gets the default type url for CSVCMsg_ServerInfo
         * @function getTypeUrl
         * @memberof CSVCMsg_ServerInfo
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        CSVCMsg_ServerInfo.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/CSVCMsg_ServerInfo";
        };
    
        return CSVCMsg_ServerInfo;
    })();
    
    $root.CSVCMsg_ClassInfo = (function() {
    
        /**
         * Properties of a CSVCMsg_ClassInfo.
         * @exports ICSVCMsg_ClassInfo
         * @interface ICSVCMsg_ClassInfo
         * @property {boolean|null} [createOnClient] CSVCMsg_ClassInfo createOnClient
         * @property {Array.<CSVCMsg_ClassInfo.Iclass_t>|null} [classes] CSVCMsg_ClassInfo classes
         */
    
        /**
         * Constructs a new CSVCMsg_ClassInfo.
         * @exports CSVCMsg_ClassInfo
         * @classdesc Represents a CSVCMsg_ClassInfo.
         * @implements ICSVCMsg_ClassInfo
         * @constructor
         * @param {ICSVCMsg_ClassInfo=} [properties] Properties to set
         */
        function CSVCMsg_ClassInfo(properties) {
            this.classes = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CSVCMsg_ClassInfo createOnClient.
         * @member {boolean} createOnClient
         * @memberof CSVCMsg_ClassInfo
         * @instance
         */
        CSVCMsg_ClassInfo.prototype.createOnClient = false;
    
        /**
         * CSVCMsg_ClassInfo classes.
         * @member {Array.<CSVCMsg_ClassInfo.Iclass_t>} classes
         * @memberof CSVCMsg_ClassInfo
         * @instance
         */
        CSVCMsg_ClassInfo.prototype.classes = $util.emptyArray;
    
        /**
         * Creates a new CSVCMsg_ClassInfo instance using the specified properties.
         * @function create
         * @memberof CSVCMsg_ClassInfo
         * @static
         * @param {ICSVCMsg_ClassInfo=} [properties] Properties to set
         * @returns {CSVCMsg_ClassInfo} CSVCMsg_ClassInfo instance
         */
        CSVCMsg_ClassInfo.create = function create(properties) {
            return new CSVCMsg_ClassInfo(properties);
        };
    
        /**
         * Encodes the specified CSVCMsg_ClassInfo message. Does not implicitly {@link CSVCMsg_ClassInfo.verify|verify} messages.
         * @function encode
         * @memberof CSVCMsg_ClassInfo
         * @static
         * @param {ICSVCMsg_ClassInfo} message CSVCMsg_ClassInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CSVCMsg_ClassInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.createOnClient != null && Object.hasOwnProperty.call(message, "createOnClient"))
                writer.uint32(/* id 1, wireType 0 =*/8).bool(message.createOnClient);
            if (message.classes != null && message.classes.length)
                for (var i = 0; i < message.classes.length; ++i)
                    $root.CSVCMsg_ClassInfo.class_t.encode(message.classes[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };
    
        /**
         * Encodes the specified CSVCMsg_ClassInfo message, length delimited. Does not implicitly {@link CSVCMsg_ClassInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CSVCMsg_ClassInfo
         * @static
         * @param {ICSVCMsg_ClassInfo} message CSVCMsg_ClassInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CSVCMsg_ClassInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CSVCMsg_ClassInfo message from the specified reader or buffer.
         * @function decode
         * @memberof CSVCMsg_ClassInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CSVCMsg_ClassInfo} CSVCMsg_ClassInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CSVCMsg_ClassInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CSVCMsg_ClassInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.createOnClient = reader.bool();
                        break;
                    }
                case 2: {
                        if (!(message.classes && message.classes.length))
                            message.classes = [];
                        message.classes.push($root.CSVCMsg_ClassInfo.class_t.decode(reader, reader.uint32()));
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CSVCMsg_ClassInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CSVCMsg_ClassInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CSVCMsg_ClassInfo} CSVCMsg_ClassInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CSVCMsg_ClassInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CSVCMsg_ClassInfo message.
         * @function verify
         * @memberof CSVCMsg_ClassInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CSVCMsg_ClassInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.createOnClient != null && message.hasOwnProperty("createOnClient"))
                if (typeof message.createOnClient !== "boolean")
                    return "createOnClient: boolean expected";
            if (message.classes != null && message.hasOwnProperty("classes")) {
                if (!Array.isArray(message.classes))
                    return "classes: array expected";
                for (var i = 0; i < message.classes.length; ++i) {
                    var error = $root.CSVCMsg_ClassInfo.class_t.verify(message.classes[i]);
                    if (error)
                        return "classes." + error;
                }
            }
            return null;
        };
    
        /**
         * Creates a CSVCMsg_ClassInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CSVCMsg_ClassInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CSVCMsg_ClassInfo} CSVCMsg_ClassInfo
         */
        CSVCMsg_ClassInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.CSVCMsg_ClassInfo)
                return object;
            var message = new $root.CSVCMsg_ClassInfo();
            if (object.createOnClient != null)
                message.createOnClient = Boolean(object.createOnClient);
            if (object.classes) {
                if (!Array.isArray(object.classes))
                    throw TypeError(".CSVCMsg_ClassInfo.classes: array expected");
                message.classes = [];
                for (var i = 0; i < object.classes.length; ++i) {
                    if (typeof object.classes[i] !== "object")
                        throw TypeError(".CSVCMsg_ClassInfo.classes: object expected");
                    message.classes[i] = $root.CSVCMsg_ClassInfo.class_t.fromObject(object.classes[i]);
                }
            }
            return message;
        };
    
        /**
         * Creates a plain object from a CSVCMsg_ClassInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CSVCMsg_ClassInfo
         * @static
         * @param {CSVCMsg_ClassInfo} message CSVCMsg_ClassInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CSVCMsg_ClassInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.classes = [];
            if (options.defaults)
                object.createOnClient = false;
            if (message.createOnClient != null && message.hasOwnProperty("createOnClient"))
                object.createOnClient = message.createOnClient;
            if (message.classes && message.classes.length) {
                object.classes = [];
                for (var j = 0; j < message.classes.length; ++j)
                    object.classes[j] = $root.CSVCMsg_ClassInfo.class_t.toObject(message.classes[j], options);
            }
            return object;
        };
    
        /**
         * Converts this CSVCMsg_ClassInfo to JSON.
         * @function toJSON
         * @memberof CSVCMsg_ClassInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CSVCMsg_ClassInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * Gets the default type url for CSVCMsg_ClassInfo
         * @function getTypeUrl
         * @memberof CSVCMsg_ClassInfo
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        CSVCMsg_ClassInfo.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/CSVCMsg_ClassInfo";
        };
    
        CSVCMsg_ClassInfo.class_t = (function() {
    
            /**
             * Properties of a class_t.
             * @memberof CSVCMsg_ClassInfo
             * @interface Iclass_t
             * @property {number|null} [classId] class_t classId
             * @property {string|null} [className] class_t className
             */
    
            /**
             * Constructs a new class_t.
             * @memberof CSVCMsg_ClassInfo
             * @classdesc Represents a class_t.
             * @implements Iclass_t
             * @constructor
             * @param {CSVCMsg_ClassInfo.Iclass_t=} [properties] Properties to set
             */
            function class_t(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * class_t classId.
             * @member {number} classId
             * @memberof CSVCMsg_ClassInfo.class_t
             * @instance
             */
            class_t.prototype.classId = 0;
    
            /**
             * class_t className.
             * @member {string} className
             * @memberof CSVCMsg_ClassInfo.class_t
             * @instance
             */
            class_t.prototype.className = "";
    
            /**
             * Creates a new class_t instance using the specified properties.
             * @function create
             * @memberof CSVCMsg_ClassInfo.class_t
             * @static
             * @param {CSVCMsg_ClassInfo.Iclass_t=} [properties] Properties to set
             * @returns {CSVCMsg_ClassInfo.class_t} class_t instance
             */
            class_t.create = function create(properties) {
                return new class_t(properties);
            };
    
            /**
             * Encodes the specified class_t message. Does not implicitly {@link CSVCMsg_ClassInfo.class_t.verify|verify} messages.
             * @function encode
             * @memberof CSVCMsg_ClassInfo.class_t
             * @static
             * @param {CSVCMsg_ClassInfo.Iclass_t} message class_t message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            class_t.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.classId != null && Object.hasOwnProperty.call(message, "classId"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.classId);
                if (message.className != null && Object.hasOwnProperty.call(message, "className"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.className);
                return writer;
            };
    
            /**
             * Encodes the specified class_t message, length delimited. Does not implicitly {@link CSVCMsg_ClassInfo.class_t.verify|verify} messages.
             * @function encodeDelimited
             * @memberof CSVCMsg_ClassInfo.class_t
             * @static
             * @param {CSVCMsg_ClassInfo.Iclass_t} message class_t message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            class_t.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a class_t message from the specified reader or buffer.
             * @function decode
             * @memberof CSVCMsg_ClassInfo.class_t
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {CSVCMsg_ClassInfo.class_t} class_t
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            class_t.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CSVCMsg_ClassInfo.class_t();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.classId = reader.int32();
                            break;
                        }
                    case 3: {
                            message.className = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a class_t message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof CSVCMsg_ClassInfo.class_t
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {CSVCMsg_ClassInfo.class_t} class_t
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            class_t.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a class_t message.
             * @function verify
             * @memberof CSVCMsg_ClassInfo.class_t
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            class_t.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.classId != null && message.hasOwnProperty("classId"))
                    if (!$util.isInteger(message.classId))
                        return "classId: integer expected";
                if (message.className != null && message.hasOwnProperty("className"))
                    if (!$util.isString(message.className))
                        return "className: string expected";
                return null;
            };
    
            /**
             * Creates a class_t message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof CSVCMsg_ClassInfo.class_t
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {CSVCMsg_ClassInfo.class_t} class_t
             */
            class_t.fromObject = function fromObject(object) {
                if (object instanceof $root.CSVCMsg_ClassInfo.class_t)
                    return object;
                var message = new $root.CSVCMsg_ClassInfo.class_t();
                if (object.classId != null)
                    message.classId = object.classId | 0;
                if (object.className != null)
                    message.className = String(object.className);
                return message;
            };
    
            /**
             * Creates a plain object from a class_t message. Also converts values to other types if specified.
             * @function toObject
             * @memberof CSVCMsg_ClassInfo.class_t
             * @static
             * @param {CSVCMsg_ClassInfo.class_t} message class_t
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            class_t.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.classId = 0;
                    object.className = "";
                }
                if (message.classId != null && message.hasOwnProperty("classId"))
                    object.classId = message.classId;
                if (message.className != null && message.hasOwnProperty("className"))
                    object.className = message.className;
                return object;
            };
    
            /**
             * Converts this class_t to JSON.
             * @function toJSON
             * @memberof CSVCMsg_ClassInfo.class_t
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            class_t.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            /**
             * Gets the default type url for class_t
             * @function getTypeUrl
             * @memberof CSVCMsg_ClassInfo.class_t
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            class_t.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/CSVCMsg_ClassInfo.class_t";
            };
    
            return class_t;
        })();
    
        return CSVCMsg_ClassInfo;
    })();
    
    $root.CSVCMsg_SetPause = (function() {
    
        /**
         * Properties of a CSVCMsg_SetPause.
         * @exports ICSVCMsg_SetPause
         * @interface ICSVCMsg_SetPause
         * @property {boolean|null} [paused] CSVCMsg_SetPause paused
         */
    
        /**
         * Constructs a new CSVCMsg_SetPause.
         * @exports CSVCMsg_SetPause
         * @classdesc Represents a CSVCMsg_SetPause.
         * @implements ICSVCMsg_SetPause
         * @constructor
         * @param {ICSVCMsg_SetPause=} [properties] Properties to set
         */
        function CSVCMsg_SetPause(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CSVCMsg_SetPause paused.
         * @member {boolean} paused
         * @memberof CSVCMsg_SetPause
         * @instance
         */
        CSVCMsg_SetPause.prototype.paused = false;
    
        /**
         * Creates a new CSVCMsg_SetPause instance using the specified properties.
         * @function create
         * @memberof CSVCMsg_SetPause
         * @static
         * @param {ICSVCMsg_SetPause=} [properties] Properties to set
         * @returns {CSVCMsg_SetPause} CSVCMsg_SetPause instance
         */
        CSVCMsg_SetPause.create = function create(properties) {
            return new CSVCMsg_SetPause(properties);
        };
    
        /**
         * Encodes the specified CSVCMsg_SetPause message. Does not implicitly {@link CSVCMsg_SetPause.verify|verify} messages.
         * @function encode
         * @memberof CSVCMsg_SetPause
         * @static
         * @param {ICSVCMsg_SetPause} message CSVCMsg_SetPause message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CSVCMsg_SetPause.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.paused != null && Object.hasOwnProperty.call(message, "paused"))
                writer.uint32(/* id 1, wireType 0 =*/8).bool(message.paused);
            return writer;
        };
    
        /**
         * Encodes the specified CSVCMsg_SetPause message, length delimited. Does not implicitly {@link CSVCMsg_SetPause.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CSVCMsg_SetPause
         * @static
         * @param {ICSVCMsg_SetPause} message CSVCMsg_SetPause message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CSVCMsg_SetPause.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CSVCMsg_SetPause message from the specified reader or buffer.
         * @function decode
         * @memberof CSVCMsg_SetPause
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CSVCMsg_SetPause} CSVCMsg_SetPause
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CSVCMsg_SetPause.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CSVCMsg_SetPause();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.paused = reader.bool();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CSVCMsg_SetPause message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CSVCMsg_SetPause
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CSVCMsg_SetPause} CSVCMsg_SetPause
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CSVCMsg_SetPause.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CSVCMsg_SetPause message.
         * @function verify
         * @memberof CSVCMsg_SetPause
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CSVCMsg_SetPause.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.paused != null && message.hasOwnProperty("paused"))
                if (typeof message.paused !== "boolean")
                    return "paused: boolean expected";
            return null;
        };
    
        /**
         * Creates a CSVCMsg_SetPause message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CSVCMsg_SetPause
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CSVCMsg_SetPause} CSVCMsg_SetPause
         */
        CSVCMsg_SetPause.fromObject = function fromObject(object) {
            if (object instanceof $root.CSVCMsg_SetPause)
                return object;
            var message = new $root.CSVCMsg_SetPause();
            if (object.paused != null)
                message.paused = Boolean(object.paused);
            return message;
        };
    
        /**
         * Creates a plain object from a CSVCMsg_SetPause message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CSVCMsg_SetPause
         * @static
         * @param {CSVCMsg_SetPause} message CSVCMsg_SetPause
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CSVCMsg_SetPause.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.paused = false;
            if (message.paused != null && message.hasOwnProperty("paused"))
                object.paused = message.paused;
            return object;
        };
    
        /**
         * Converts this CSVCMsg_SetPause to JSON.
         * @function toJSON
         * @memberof CSVCMsg_SetPause
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CSVCMsg_SetPause.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * Gets the default type url for CSVCMsg_SetPause
         * @function getTypeUrl
         * @memberof CSVCMsg_SetPause
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        CSVCMsg_SetPause.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/CSVCMsg_SetPause";
        };
    
        return CSVCMsg_SetPause;
    })();
    
    $root.CSVCMsg_VoiceInit = (function() {
    
        /**
         * Properties of a CSVCMsg_VoiceInit.
         * @exports ICSVCMsg_VoiceInit
         * @interface ICSVCMsg_VoiceInit
         * @property {number|null} [quality] CSVCMsg_VoiceInit quality
         * @property {string|null} [codec] CSVCMsg_VoiceInit codec
         * @property {number|null} [version] CSVCMsg_VoiceInit version
         */
    
        /**
         * Constructs a new CSVCMsg_VoiceInit.
         * @exports CSVCMsg_VoiceInit
         * @classdesc Represents a CSVCMsg_VoiceInit.
         * @implements ICSVCMsg_VoiceInit
         * @constructor
         * @param {ICSVCMsg_VoiceInit=} [properties] Properties to set
         */
        function CSVCMsg_VoiceInit(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CSVCMsg_VoiceInit quality.
         * @member {number} quality
         * @memberof CSVCMsg_VoiceInit
         * @instance
         */
        CSVCMsg_VoiceInit.prototype.quality = 0;
    
        /**
         * CSVCMsg_VoiceInit codec.
         * @member {string} codec
         * @memberof CSVCMsg_VoiceInit
         * @instance
         */
        CSVCMsg_VoiceInit.prototype.codec = "";
    
        /**
         * CSVCMsg_VoiceInit version.
         * @member {number} version
         * @memberof CSVCMsg_VoiceInit
         * @instance
         */
        CSVCMsg_VoiceInit.prototype.version = 0;
    
        /**
         * Creates a new CSVCMsg_VoiceInit instance using the specified properties.
         * @function create
         * @memberof CSVCMsg_VoiceInit
         * @static
         * @param {ICSVCMsg_VoiceInit=} [properties] Properties to set
         * @returns {CSVCMsg_VoiceInit} CSVCMsg_VoiceInit instance
         */
        CSVCMsg_VoiceInit.create = function create(properties) {
            return new CSVCMsg_VoiceInit(properties);
        };
    
        /**
         * Encodes the specified CSVCMsg_VoiceInit message. Does not implicitly {@link CSVCMsg_VoiceInit.verify|verify} messages.
         * @function encode
         * @memberof CSVCMsg_VoiceInit
         * @static
         * @param {ICSVCMsg_VoiceInit} message CSVCMsg_VoiceInit message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CSVCMsg_VoiceInit.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.quality != null && Object.hasOwnProperty.call(message, "quality"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.quality);
            if (message.codec != null && Object.hasOwnProperty.call(message, "codec"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.codec);
            if (message.version != null && Object.hasOwnProperty.call(message, "version"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.version);
            return writer;
        };
    
        /**
         * Encodes the specified CSVCMsg_VoiceInit message, length delimited. Does not implicitly {@link CSVCMsg_VoiceInit.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CSVCMsg_VoiceInit
         * @static
         * @param {ICSVCMsg_VoiceInit} message CSVCMsg_VoiceInit message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CSVCMsg_VoiceInit.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CSVCMsg_VoiceInit message from the specified reader or buffer.
         * @function decode
         * @memberof CSVCMsg_VoiceInit
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CSVCMsg_VoiceInit} CSVCMsg_VoiceInit
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CSVCMsg_VoiceInit.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CSVCMsg_VoiceInit();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.quality = reader.int32();
                        break;
                    }
                case 2: {
                        message.codec = reader.string();
                        break;
                    }
                case 3: {
                        message.version = reader.int32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CSVCMsg_VoiceInit message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CSVCMsg_VoiceInit
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CSVCMsg_VoiceInit} CSVCMsg_VoiceInit
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CSVCMsg_VoiceInit.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CSVCMsg_VoiceInit message.
         * @function verify
         * @memberof CSVCMsg_VoiceInit
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CSVCMsg_VoiceInit.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.quality != null && message.hasOwnProperty("quality"))
                if (!$util.isInteger(message.quality))
                    return "quality: integer expected";
            if (message.codec != null && message.hasOwnProperty("codec"))
                if (!$util.isString(message.codec))
                    return "codec: string expected";
            if (message.version != null && message.hasOwnProperty("version"))
                if (!$util.isInteger(message.version))
                    return "version: integer expected";
            return null;
        };
    
        /**
         * Creates a CSVCMsg_VoiceInit message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CSVCMsg_VoiceInit
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CSVCMsg_VoiceInit} CSVCMsg_VoiceInit
         */
        CSVCMsg_VoiceInit.fromObject = function fromObject(object) {
            if (object instanceof $root.CSVCMsg_VoiceInit)
                return object;
            var message = new $root.CSVCMsg_VoiceInit();
            if (object.quality != null)
                message.quality = object.quality | 0;
            if (object.codec != null)
                message.codec = String(object.codec);
            if (object.version != null)
                message.version = object.version | 0;
            return message;
        };
    
        /**
         * Creates a plain object from a CSVCMsg_VoiceInit message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CSVCMsg_VoiceInit
         * @static
         * @param {CSVCMsg_VoiceInit} message CSVCMsg_VoiceInit
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CSVCMsg_VoiceInit.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.quality = 0;
                object.codec = "";
                object.version = 0;
            }
            if (message.quality != null && message.hasOwnProperty("quality"))
                object.quality = message.quality;
            if (message.codec != null && message.hasOwnProperty("codec"))
                object.codec = message.codec;
            if (message.version != null && message.hasOwnProperty("version"))
                object.version = message.version;
            return object;
        };
    
        /**
         * Converts this CSVCMsg_VoiceInit to JSON.
         * @function toJSON
         * @memberof CSVCMsg_VoiceInit
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CSVCMsg_VoiceInit.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * Gets the default type url for CSVCMsg_VoiceInit
         * @function getTypeUrl
         * @memberof CSVCMsg_VoiceInit
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        CSVCMsg_VoiceInit.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/CSVCMsg_VoiceInit";
        };
    
        return CSVCMsg_VoiceInit;
    })();
    
    $root.CSVCMsg_Print = (function() {
    
        /**
         * Properties of a CSVCMsg_Print.
         * @exports ICSVCMsg_Print
         * @interface ICSVCMsg_Print
         * @property {string|null} [text] CSVCMsg_Print text
         */
    
        /**
         * Constructs a new CSVCMsg_Print.
         * @exports CSVCMsg_Print
         * @classdesc Represents a CSVCMsg_Print.
         * @implements ICSVCMsg_Print
         * @constructor
         * @param {ICSVCMsg_Print=} [properties] Properties to set
         */
        function CSVCMsg_Print(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CSVCMsg_Print text.
         * @member {string} text
         * @memberof CSVCMsg_Print
         * @instance
         */
        CSVCMsg_Print.prototype.text = "";
    
        /**
         * Creates a new CSVCMsg_Print instance using the specified properties.
         * @function create
         * @memberof CSVCMsg_Print
         * @static
         * @param {ICSVCMsg_Print=} [properties] Properties to set
         * @returns {CSVCMsg_Print} CSVCMsg_Print instance
         */
        CSVCMsg_Print.create = function create(properties) {
            return new CSVCMsg_Print(properties);
        };
    
        /**
         * Encodes the specified CSVCMsg_Print message. Does not implicitly {@link CSVCMsg_Print.verify|verify} messages.
         * @function encode
         * @memberof CSVCMsg_Print
         * @static
         * @param {ICSVCMsg_Print} message CSVCMsg_Print message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CSVCMsg_Print.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.text != null && Object.hasOwnProperty.call(message, "text"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.text);
            return writer;
        };
    
        /**
         * Encodes the specified CSVCMsg_Print message, length delimited. Does not implicitly {@link CSVCMsg_Print.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CSVCMsg_Print
         * @static
         * @param {ICSVCMsg_Print} message CSVCMsg_Print message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CSVCMsg_Print.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CSVCMsg_Print message from the specified reader or buffer.
         * @function decode
         * @memberof CSVCMsg_Print
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CSVCMsg_Print} CSVCMsg_Print
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CSVCMsg_Print.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CSVCMsg_Print();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.text = reader.string();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CSVCMsg_Print message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CSVCMsg_Print
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CSVCMsg_Print} CSVCMsg_Print
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CSVCMsg_Print.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CSVCMsg_Print message.
         * @function verify
         * @memberof CSVCMsg_Print
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CSVCMsg_Print.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.text != null && message.hasOwnProperty("text"))
                if (!$util.isString(message.text))
                    return "text: string expected";
            return null;
        };
    
        /**
         * Creates a CSVCMsg_Print message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CSVCMsg_Print
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CSVCMsg_Print} CSVCMsg_Print
         */
        CSVCMsg_Print.fromObject = function fromObject(object) {
            if (object instanceof $root.CSVCMsg_Print)
                return object;
            var message = new $root.CSVCMsg_Print();
            if (object.text != null)
                message.text = String(object.text);
            return message;
        };
    
        /**
         * Creates a plain object from a CSVCMsg_Print message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CSVCMsg_Print
         * @static
         * @param {CSVCMsg_Print} message CSVCMsg_Print
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CSVCMsg_Print.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.text = "";
            if (message.text != null && message.hasOwnProperty("text"))
                object.text = message.text;
            return object;
        };
    
        /**
         * Converts this CSVCMsg_Print to JSON.
         * @function toJSON
         * @memberof CSVCMsg_Print
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CSVCMsg_Print.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * Gets the default type url for CSVCMsg_Print
         * @function getTypeUrl
         * @memberof CSVCMsg_Print
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        CSVCMsg_Print.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/CSVCMsg_Print";
        };
    
        return CSVCMsg_Print;
    })();
    
    $root.CSVCMsg_Sounds = (function() {
    
        /**
         * Properties of a CSVCMsg_Sounds.
         * @exports ICSVCMsg_Sounds
         * @interface ICSVCMsg_Sounds
         * @property {boolean|null} [reliableSound] CSVCMsg_Sounds reliableSound
         * @property {Array.<CSVCMsg_Sounds.Isounddata_t>|null} [sounds] CSVCMsg_Sounds sounds
         */
    
        /**
         * Constructs a new CSVCMsg_Sounds.
         * @exports CSVCMsg_Sounds
         * @classdesc Represents a CSVCMsg_Sounds.
         * @implements ICSVCMsg_Sounds
         * @constructor
         * @param {ICSVCMsg_Sounds=} [properties] Properties to set
         */
        function CSVCMsg_Sounds(properties) {
            this.sounds = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CSVCMsg_Sounds reliableSound.
         * @member {boolean} reliableSound
         * @memberof CSVCMsg_Sounds
         * @instance
         */
        CSVCMsg_Sounds.prototype.reliableSound = false;
    
        /**
         * CSVCMsg_Sounds sounds.
         * @member {Array.<CSVCMsg_Sounds.Isounddata_t>} sounds
         * @memberof CSVCMsg_Sounds
         * @instance
         */
        CSVCMsg_Sounds.prototype.sounds = $util.emptyArray;
    
        /**
         * Creates a new CSVCMsg_Sounds instance using the specified properties.
         * @function create
         * @memberof CSVCMsg_Sounds
         * @static
         * @param {ICSVCMsg_Sounds=} [properties] Properties to set
         * @returns {CSVCMsg_Sounds} CSVCMsg_Sounds instance
         */
        CSVCMsg_Sounds.create = function create(properties) {
            return new CSVCMsg_Sounds(properties);
        };
    
        /**
         * Encodes the specified CSVCMsg_Sounds message. Does not implicitly {@link CSVCMsg_Sounds.verify|verify} messages.
         * @function encode
         * @memberof CSVCMsg_Sounds
         * @static
         * @param {ICSVCMsg_Sounds} message CSVCMsg_Sounds message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CSVCMsg_Sounds.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.reliableSound != null && Object.hasOwnProperty.call(message, "reliableSound"))
                writer.uint32(/* id 1, wireType 0 =*/8).bool(message.reliableSound);
            if (message.sounds != null && message.sounds.length)
                for (var i = 0; i < message.sounds.length; ++i)
                    $root.CSVCMsg_Sounds.sounddata_t.encode(message.sounds[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };
    
        /**
         * Encodes the specified CSVCMsg_Sounds message, length delimited. Does not implicitly {@link CSVCMsg_Sounds.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CSVCMsg_Sounds
         * @static
         * @param {ICSVCMsg_Sounds} message CSVCMsg_Sounds message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CSVCMsg_Sounds.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CSVCMsg_Sounds message from the specified reader or buffer.
         * @function decode
         * @memberof CSVCMsg_Sounds
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CSVCMsg_Sounds} CSVCMsg_Sounds
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CSVCMsg_Sounds.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CSVCMsg_Sounds();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.reliableSound = reader.bool();
                        break;
                    }
                case 2: {
                        if (!(message.sounds && message.sounds.length))
                            message.sounds = [];
                        message.sounds.push($root.CSVCMsg_Sounds.sounddata_t.decode(reader, reader.uint32()));
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CSVCMsg_Sounds message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CSVCMsg_Sounds
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CSVCMsg_Sounds} CSVCMsg_Sounds
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CSVCMsg_Sounds.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CSVCMsg_Sounds message.
         * @function verify
         * @memberof CSVCMsg_Sounds
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CSVCMsg_Sounds.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.reliableSound != null && message.hasOwnProperty("reliableSound"))
                if (typeof message.reliableSound !== "boolean")
                    return "reliableSound: boolean expected";
            if (message.sounds != null && message.hasOwnProperty("sounds")) {
                if (!Array.isArray(message.sounds))
                    return "sounds: array expected";
                for (var i = 0; i < message.sounds.length; ++i) {
                    var error = $root.CSVCMsg_Sounds.sounddata_t.verify(message.sounds[i]);
                    if (error)
                        return "sounds." + error;
                }
            }
            return null;
        };
    
        /**
         * Creates a CSVCMsg_Sounds message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CSVCMsg_Sounds
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CSVCMsg_Sounds} CSVCMsg_Sounds
         */
        CSVCMsg_Sounds.fromObject = function fromObject(object) {
            if (object instanceof $root.CSVCMsg_Sounds)
                return object;
            var message = new $root.CSVCMsg_Sounds();
            if (object.reliableSound != null)
                message.reliableSound = Boolean(object.reliableSound);
            if (object.sounds) {
                if (!Array.isArray(object.sounds))
                    throw TypeError(".CSVCMsg_Sounds.sounds: array expected");
                message.sounds = [];
                for (var i = 0; i < object.sounds.length; ++i) {
                    if (typeof object.sounds[i] !== "object")
                        throw TypeError(".CSVCMsg_Sounds.sounds: object expected");
                    message.sounds[i] = $root.CSVCMsg_Sounds.sounddata_t.fromObject(object.sounds[i]);
                }
            }
            return message;
        };
    
        /**
         * Creates a plain object from a CSVCMsg_Sounds message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CSVCMsg_Sounds
         * @static
         * @param {CSVCMsg_Sounds} message CSVCMsg_Sounds
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CSVCMsg_Sounds.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.sounds = [];
            if (options.defaults)
                object.reliableSound = false;
            if (message.reliableSound != null && message.hasOwnProperty("reliableSound"))
                object.reliableSound = message.reliableSound;
            if (message.sounds && message.sounds.length) {
                object.sounds = [];
                for (var j = 0; j < message.sounds.length; ++j)
                    object.sounds[j] = $root.CSVCMsg_Sounds.sounddata_t.toObject(message.sounds[j], options);
            }
            return object;
        };
    
        /**
         * Converts this CSVCMsg_Sounds to JSON.
         * @function toJSON
         * @memberof CSVCMsg_Sounds
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CSVCMsg_Sounds.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * Gets the default type url for CSVCMsg_Sounds
         * @function getTypeUrl
         * @memberof CSVCMsg_Sounds
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        CSVCMsg_Sounds.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/CSVCMsg_Sounds";
        };
    
        CSVCMsg_Sounds.sounddata_t = (function() {
    
            /**
             * Properties of a sounddata_t.
             * @memberof CSVCMsg_Sounds
             * @interface Isounddata_t
             * @property {number|null} [originX] sounddata_t originX
             * @property {number|null} [originY] sounddata_t originY
             * @property {number|null} [originZ] sounddata_t originZ
             * @property {number|null} [volume] sounddata_t volume
             * @property {number|null} [delayValue] sounddata_t delayValue
             * @property {number|null} [sequenceNumber] sounddata_t sequenceNumber
             * @property {number|null} [entityIndex] sounddata_t entityIndex
             * @property {number|null} [channel] sounddata_t channel
             * @property {number|null} [pitch] sounddata_t pitch
             * @property {number|null} [flags] sounddata_t flags
             * @property {number|null} [soundNum] sounddata_t soundNum
             * @property {number|null} [soundNumHandle] sounddata_t soundNumHandle
             * @property {number|null} [speakerEntity] sounddata_t speakerEntity
             * @property {number|null} [randomSeed] sounddata_t randomSeed
             * @property {number|null} [soundLevel] sounddata_t soundLevel
             * @property {boolean|null} [isSentence] sounddata_t isSentence
             * @property {boolean|null} [isAmbient] sounddata_t isAmbient
             * @property {number|null} [guid] sounddata_t guid
             * @property {number|Long|null} [soundResourceId] sounddata_t soundResourceId
             */
    
            /**
             * Constructs a new sounddata_t.
             * @memberof CSVCMsg_Sounds
             * @classdesc Represents a sounddata_t.
             * @implements Isounddata_t
             * @constructor
             * @param {CSVCMsg_Sounds.Isounddata_t=} [properties] Properties to set
             */
            function sounddata_t(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * sounddata_t originX.
             * @member {number} originX
             * @memberof CSVCMsg_Sounds.sounddata_t
             * @instance
             */
            sounddata_t.prototype.originX = 0;
    
            /**
             * sounddata_t originY.
             * @member {number} originY
             * @memberof CSVCMsg_Sounds.sounddata_t
             * @instance
             */
            sounddata_t.prototype.originY = 0;
    
            /**
             * sounddata_t originZ.
             * @member {number} originZ
             * @memberof CSVCMsg_Sounds.sounddata_t
             * @instance
             */
            sounddata_t.prototype.originZ = 0;
    
            /**
             * sounddata_t volume.
             * @member {number} volume
             * @memberof CSVCMsg_Sounds.sounddata_t
             * @instance
             */
            sounddata_t.prototype.volume = 0;
    
            /**
             * sounddata_t delayValue.
             * @member {number} delayValue
             * @memberof CSVCMsg_Sounds.sounddata_t
             * @instance
             */
            sounddata_t.prototype.delayValue = 0;
    
            /**
             * sounddata_t sequenceNumber.
             * @member {number} sequenceNumber
             * @memberof CSVCMsg_Sounds.sounddata_t
             * @instance
             */
            sounddata_t.prototype.sequenceNumber = 0;
    
            /**
             * sounddata_t entityIndex.
             * @member {number} entityIndex
             * @memberof CSVCMsg_Sounds.sounddata_t
             * @instance
             */
            sounddata_t.prototype.entityIndex = -1;
    
            /**
             * sounddata_t channel.
             * @member {number} channel
             * @memberof CSVCMsg_Sounds.sounddata_t
             * @instance
             */
            sounddata_t.prototype.channel = 0;
    
            /**
             * sounddata_t pitch.
             * @member {number} pitch
             * @memberof CSVCMsg_Sounds.sounddata_t
             * @instance
             */
            sounddata_t.prototype.pitch = 0;
    
            /**
             * sounddata_t flags.
             * @member {number} flags
             * @memberof CSVCMsg_Sounds.sounddata_t
             * @instance
             */
            sounddata_t.prototype.flags = 0;
    
            /**
             * sounddata_t soundNum.
             * @member {number} soundNum
             * @memberof CSVCMsg_Sounds.sounddata_t
             * @instance
             */
            sounddata_t.prototype.soundNum = 0;
    
            /**
             * sounddata_t soundNumHandle.
             * @member {number} soundNumHandle
             * @memberof CSVCMsg_Sounds.sounddata_t
             * @instance
             */
            sounddata_t.prototype.soundNumHandle = 0;
    
            /**
             * sounddata_t speakerEntity.
             * @member {number} speakerEntity
             * @memberof CSVCMsg_Sounds.sounddata_t
             * @instance
             */
            sounddata_t.prototype.speakerEntity = 0;
    
            /**
             * sounddata_t randomSeed.
             * @member {number} randomSeed
             * @memberof CSVCMsg_Sounds.sounddata_t
             * @instance
             */
            sounddata_t.prototype.randomSeed = 0;
    
            /**
             * sounddata_t soundLevel.
             * @member {number} soundLevel
             * @memberof CSVCMsg_Sounds.sounddata_t
             * @instance
             */
            sounddata_t.prototype.soundLevel = 0;
    
            /**
             * sounddata_t isSentence.
             * @member {boolean} isSentence
             * @memberof CSVCMsg_Sounds.sounddata_t
             * @instance
             */
            sounddata_t.prototype.isSentence = false;
    
            /**
             * sounddata_t isAmbient.
             * @member {boolean} isAmbient
             * @memberof CSVCMsg_Sounds.sounddata_t
             * @instance
             */
            sounddata_t.prototype.isAmbient = false;
    
            /**
             * sounddata_t guid.
             * @member {number} guid
             * @memberof CSVCMsg_Sounds.sounddata_t
             * @instance
             */
            sounddata_t.prototype.guid = 0;
    
            /**
             * sounddata_t soundResourceId.
             * @member {number|Long} soundResourceId
             * @memberof CSVCMsg_Sounds.sounddata_t
             * @instance
             */
            sounddata_t.prototype.soundResourceId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
            /**
             * Creates a new sounddata_t instance using the specified properties.
             * @function create
             * @memberof CSVCMsg_Sounds.sounddata_t
             * @static
             * @param {CSVCMsg_Sounds.Isounddata_t=} [properties] Properties to set
             * @returns {CSVCMsg_Sounds.sounddata_t} sounddata_t instance
             */
            sounddata_t.create = function create(properties) {
                return new sounddata_t(properties);
            };
    
            /**
             * Encodes the specified sounddata_t message. Does not implicitly {@link CSVCMsg_Sounds.sounddata_t.verify|verify} messages.
             * @function encode
             * @memberof CSVCMsg_Sounds.sounddata_t
             * @static
             * @param {CSVCMsg_Sounds.Isounddata_t} message sounddata_t message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            sounddata_t.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.originX != null && Object.hasOwnProperty.call(message, "originX"))
                    writer.uint32(/* id 1, wireType 0 =*/8).sint32(message.originX);
                if (message.originY != null && Object.hasOwnProperty.call(message, "originY"))
                    writer.uint32(/* id 2, wireType 0 =*/16).sint32(message.originY);
                if (message.originZ != null && Object.hasOwnProperty.call(message, "originZ"))
                    writer.uint32(/* id 3, wireType 0 =*/24).sint32(message.originZ);
                if (message.volume != null && Object.hasOwnProperty.call(message, "volume"))
                    writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.volume);
                if (message.delayValue != null && Object.hasOwnProperty.call(message, "delayValue"))
                    writer.uint32(/* id 5, wireType 5 =*/45).float(message.delayValue);
                if (message.sequenceNumber != null && Object.hasOwnProperty.call(message, "sequenceNumber"))
                    writer.uint32(/* id 6, wireType 0 =*/48).int32(message.sequenceNumber);
                if (message.entityIndex != null && Object.hasOwnProperty.call(message, "entityIndex"))
                    writer.uint32(/* id 7, wireType 0 =*/56).int32(message.entityIndex);
                if (message.channel != null && Object.hasOwnProperty.call(message, "channel"))
                    writer.uint32(/* id 8, wireType 0 =*/64).int32(message.channel);
                if (message.pitch != null && Object.hasOwnProperty.call(message, "pitch"))
                    writer.uint32(/* id 9, wireType 0 =*/72).int32(message.pitch);
                if (message.flags != null && Object.hasOwnProperty.call(message, "flags"))
                    writer.uint32(/* id 10, wireType 0 =*/80).int32(message.flags);
                if (message.soundNum != null && Object.hasOwnProperty.call(message, "soundNum"))
                    writer.uint32(/* id 11, wireType 0 =*/88).uint32(message.soundNum);
                if (message.soundNumHandle != null && Object.hasOwnProperty.call(message, "soundNumHandle"))
                    writer.uint32(/* id 12, wireType 5 =*/101).fixed32(message.soundNumHandle);
                if (message.speakerEntity != null && Object.hasOwnProperty.call(message, "speakerEntity"))
                    writer.uint32(/* id 13, wireType 0 =*/104).int32(message.speakerEntity);
                if (message.randomSeed != null && Object.hasOwnProperty.call(message, "randomSeed"))
                    writer.uint32(/* id 14, wireType 0 =*/112).int32(message.randomSeed);
                if (message.soundLevel != null && Object.hasOwnProperty.call(message, "soundLevel"))
                    writer.uint32(/* id 15, wireType 0 =*/120).int32(message.soundLevel);
                if (message.isSentence != null && Object.hasOwnProperty.call(message, "isSentence"))
                    writer.uint32(/* id 16, wireType 0 =*/128).bool(message.isSentence);
                if (message.isAmbient != null && Object.hasOwnProperty.call(message, "isAmbient"))
                    writer.uint32(/* id 17, wireType 0 =*/136).bool(message.isAmbient);
                if (message.guid != null && Object.hasOwnProperty.call(message, "guid"))
                    writer.uint32(/* id 18, wireType 0 =*/144).uint32(message.guid);
                if (message.soundResourceId != null && Object.hasOwnProperty.call(message, "soundResourceId"))
                    writer.uint32(/* id 19, wireType 1 =*/153).fixed64(message.soundResourceId);
                return writer;
            };
    
            /**
             * Encodes the specified sounddata_t message, length delimited. Does not implicitly {@link CSVCMsg_Sounds.sounddata_t.verify|verify} messages.
             * @function encodeDelimited
             * @memberof CSVCMsg_Sounds.sounddata_t
             * @static
             * @param {CSVCMsg_Sounds.Isounddata_t} message sounddata_t message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            sounddata_t.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a sounddata_t message from the specified reader or buffer.
             * @function decode
             * @memberof CSVCMsg_Sounds.sounddata_t
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {CSVCMsg_Sounds.sounddata_t} sounddata_t
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            sounddata_t.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CSVCMsg_Sounds.sounddata_t();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.originX = reader.sint32();
                            break;
                        }
                    case 2: {
                            message.originY = reader.sint32();
                            break;
                        }
                    case 3: {
                            message.originZ = reader.sint32();
                            break;
                        }
                    case 4: {
                            message.volume = reader.uint32();
                            break;
                        }
                    case 5: {
                            message.delayValue = reader.float();
                            break;
                        }
                    case 6: {
                            message.sequenceNumber = reader.int32();
                            break;
                        }
                    case 7: {
                            message.entityIndex = reader.int32();
                            break;
                        }
                    case 8: {
                            message.channel = reader.int32();
                            break;
                        }
                    case 9: {
                            message.pitch = reader.int32();
                            break;
                        }
                    case 10: {
                            message.flags = reader.int32();
                            break;
                        }
                    case 11: {
                            message.soundNum = reader.uint32();
                            break;
                        }
                    case 12: {
                            message.soundNumHandle = reader.fixed32();
                            break;
                        }
                    case 13: {
                            message.speakerEntity = reader.int32();
                            break;
                        }
                    case 14: {
                            message.randomSeed = reader.int32();
                            break;
                        }
                    case 15: {
                            message.soundLevel = reader.int32();
                            break;
                        }
                    case 16: {
                            message.isSentence = reader.bool();
                            break;
                        }
                    case 17: {
                            message.isAmbient = reader.bool();
                            break;
                        }
                    case 18: {
                            message.guid = reader.uint32();
                            break;
                        }
                    case 19: {
                            message.soundResourceId = reader.fixed64();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a sounddata_t message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof CSVCMsg_Sounds.sounddata_t
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {CSVCMsg_Sounds.sounddata_t} sounddata_t
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            sounddata_t.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a sounddata_t message.
             * @function verify
             * @memberof CSVCMsg_Sounds.sounddata_t
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            sounddata_t.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.originX != null && message.hasOwnProperty("originX"))
                    if (!$util.isInteger(message.originX))
                        return "originX: integer expected";
                if (message.originY != null && message.hasOwnProperty("originY"))
                    if (!$util.isInteger(message.originY))
                        return "originY: integer expected";
                if (message.originZ != null && message.hasOwnProperty("originZ"))
                    if (!$util.isInteger(message.originZ))
                        return "originZ: integer expected";
                if (message.volume != null && message.hasOwnProperty("volume"))
                    if (!$util.isInteger(message.volume))
                        return "volume: integer expected";
                if (message.delayValue != null && message.hasOwnProperty("delayValue"))
                    if (typeof message.delayValue !== "number")
                        return "delayValue: number expected";
                if (message.sequenceNumber != null && message.hasOwnProperty("sequenceNumber"))
                    if (!$util.isInteger(message.sequenceNumber))
                        return "sequenceNumber: integer expected";
                if (message.entityIndex != null && message.hasOwnProperty("entityIndex"))
                    if (!$util.isInteger(message.entityIndex))
                        return "entityIndex: integer expected";
                if (message.channel != null && message.hasOwnProperty("channel"))
                    if (!$util.isInteger(message.channel))
                        return "channel: integer expected";
                if (message.pitch != null && message.hasOwnProperty("pitch"))
                    if (!$util.isInteger(message.pitch))
                        return "pitch: integer expected";
                if (message.flags != null && message.hasOwnProperty("flags"))
                    if (!$util.isInteger(message.flags))
                        return "flags: integer expected";
                if (message.soundNum != null && message.hasOwnProperty("soundNum"))
                    if (!$util.isInteger(message.soundNum))
                        return "soundNum: integer expected";
                if (message.soundNumHandle != null && message.hasOwnProperty("soundNumHandle"))
                    if (!$util.isInteger(message.soundNumHandle))
                        return "soundNumHandle: integer expected";
                if (message.speakerEntity != null && message.hasOwnProperty("speakerEntity"))
                    if (!$util.isInteger(message.speakerEntity))
                        return "speakerEntity: integer expected";
                if (message.randomSeed != null && message.hasOwnProperty("randomSeed"))
                    if (!$util.isInteger(message.randomSeed))
                        return "randomSeed: integer expected";
                if (message.soundLevel != null && message.hasOwnProperty("soundLevel"))
                    if (!$util.isInteger(message.soundLevel))
                        return "soundLevel: integer expected";
                if (message.isSentence != null && message.hasOwnProperty("isSentence"))
                    if (typeof message.isSentence !== "boolean")
                        return "isSentence: boolean expected";
                if (message.isAmbient != null && message.hasOwnProperty("isAmbient"))
                    if (typeof message.isAmbient !== "boolean")
                        return "isAmbient: boolean expected";
                if (message.guid != null && message.hasOwnProperty("guid"))
                    if (!$util.isInteger(message.guid))
                        return "guid: integer expected";
                if (message.soundResourceId != null && message.hasOwnProperty("soundResourceId"))
                    if (!$util.isInteger(message.soundResourceId) && !(message.soundResourceId && $util.isInteger(message.soundResourceId.low) && $util.isInteger(message.soundResourceId.high)))
                        return "soundResourceId: integer|Long expected";
                return null;
            };
    
            /**
             * Creates a sounddata_t message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof CSVCMsg_Sounds.sounddata_t
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {CSVCMsg_Sounds.sounddata_t} sounddata_t
             */
            sounddata_t.fromObject = function fromObject(object) {
                if (object instanceof $root.CSVCMsg_Sounds.sounddata_t)
                    return object;
                var message = new $root.CSVCMsg_Sounds.sounddata_t();
                if (object.originX != null)
                    message.originX = object.originX | 0;
                if (object.originY != null)
                    message.originY = object.originY | 0;
                if (object.originZ != null)
                    message.originZ = object.originZ | 0;
                if (object.volume != null)
                    message.volume = object.volume >>> 0;
                if (object.delayValue != null)
                    message.delayValue = Number(object.delayValue);
                if (object.sequenceNumber != null)
                    message.sequenceNumber = object.sequenceNumber | 0;
                if (object.entityIndex != null)
                    message.entityIndex = object.entityIndex | 0;
                if (object.channel != null)
                    message.channel = object.channel | 0;
                if (object.pitch != null)
                    message.pitch = object.pitch | 0;
                if (object.flags != null)
                    message.flags = object.flags | 0;
                if (object.soundNum != null)
                    message.soundNum = object.soundNum >>> 0;
                if (object.soundNumHandle != null)
                    message.soundNumHandle = object.soundNumHandle >>> 0;
                if (object.speakerEntity != null)
                    message.speakerEntity = object.speakerEntity | 0;
                if (object.randomSeed != null)
                    message.randomSeed = object.randomSeed | 0;
                if (object.soundLevel != null)
                    message.soundLevel = object.soundLevel | 0;
                if (object.isSentence != null)
                    message.isSentence = Boolean(object.isSentence);
                if (object.isAmbient != null)
                    message.isAmbient = Boolean(object.isAmbient);
                if (object.guid != null)
                    message.guid = object.guid >>> 0;
                if (object.soundResourceId != null)
                    if ($util.Long)
                        (message.soundResourceId = $util.Long.fromValue(object.soundResourceId)).unsigned = false;
                    else if (typeof object.soundResourceId === "string")
                        message.soundResourceId = parseInt(object.soundResourceId, 10);
                    else if (typeof object.soundResourceId === "number")
                        message.soundResourceId = object.soundResourceId;
                    else if (typeof object.soundResourceId === "object")
                        message.soundResourceId = new $util.LongBits(object.soundResourceId.low >>> 0, object.soundResourceId.high >>> 0).toNumber();
                return message;
            };
    
            /**
             * Creates a plain object from a sounddata_t message. Also converts values to other types if specified.
             * @function toObject
             * @memberof CSVCMsg_Sounds.sounddata_t
             * @static
             * @param {CSVCMsg_Sounds.sounddata_t} message sounddata_t
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            sounddata_t.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.originX = 0;
                    object.originY = 0;
                    object.originZ = 0;
                    object.volume = 0;
                    object.delayValue = 0;
                    object.sequenceNumber = 0;
                    object.entityIndex = -1;
                    object.channel = 0;
                    object.pitch = 0;
                    object.flags = 0;
                    object.soundNum = 0;
                    object.soundNumHandle = 0;
                    object.speakerEntity = 0;
                    object.randomSeed = 0;
                    object.soundLevel = 0;
                    object.isSentence = false;
                    object.isAmbient = false;
                    object.guid = 0;
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.soundResourceId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.soundResourceId = options.longs === String ? "0" : 0;
                }
                if (message.originX != null && message.hasOwnProperty("originX"))
                    object.originX = message.originX;
                if (message.originY != null && message.hasOwnProperty("originY"))
                    object.originY = message.originY;
                if (message.originZ != null && message.hasOwnProperty("originZ"))
                    object.originZ = message.originZ;
                if (message.volume != null && message.hasOwnProperty("volume"))
                    object.volume = message.volume;
                if (message.delayValue != null && message.hasOwnProperty("delayValue"))
                    object.delayValue = options.json && !isFinite(message.delayValue) ? String(message.delayValue) : message.delayValue;
                if (message.sequenceNumber != null && message.hasOwnProperty("sequenceNumber"))
                    object.sequenceNumber = message.sequenceNumber;
                if (message.entityIndex != null && message.hasOwnProperty("entityIndex"))
                    object.entityIndex = message.entityIndex;
                if (message.channel != null && message.hasOwnProperty("channel"))
                    object.channel = message.channel;
                if (message.pitch != null && message.hasOwnProperty("pitch"))
                    object.pitch = message.pitch;
                if (message.flags != null && message.hasOwnProperty("flags"))
                    object.flags = message.flags;
                if (message.soundNum != null && message.hasOwnProperty("soundNum"))
                    object.soundNum = message.soundNum;
                if (message.soundNumHandle != null && message.hasOwnProperty("soundNumHandle"))
                    object.soundNumHandle = message.soundNumHandle;
                if (message.speakerEntity != null && message.hasOwnProperty("speakerEntity"))
                    object.speakerEntity = message.speakerEntity;
                if (message.randomSeed != null && message.hasOwnProperty("randomSeed"))
                    object.randomSeed = message.randomSeed;
                if (message.soundLevel != null && message.hasOwnProperty("soundLevel"))
                    object.soundLevel = message.soundLevel;
                if (message.isSentence != null && message.hasOwnProperty("isSentence"))
                    object.isSentence = message.isSentence;
                if (message.isAmbient != null && message.hasOwnProperty("isAmbient"))
                    object.isAmbient = message.isAmbient;
                if (message.guid != null && message.hasOwnProperty("guid"))
                    object.guid = message.guid;
                if (message.soundResourceId != null && message.hasOwnProperty("soundResourceId"))
                    if (typeof message.soundResourceId === "number")
                        object.soundResourceId = options.longs === String ? String(message.soundResourceId) : message.soundResourceId;
                    else
                        object.soundResourceId = options.longs === String ? $util.Long.prototype.toString.call(message.soundResourceId) : options.longs === Number ? new $util.LongBits(message.soundResourceId.low >>> 0, message.soundResourceId.high >>> 0).toNumber() : message.soundResourceId;
                return object;
            };
    
            /**
             * Converts this sounddata_t to JSON.
             * @function toJSON
             * @memberof CSVCMsg_Sounds.sounddata_t
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            sounddata_t.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            /**
             * Gets the default type url for sounddata_t
             * @function getTypeUrl
             * @memberof CSVCMsg_Sounds.sounddata_t
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            sounddata_t.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/CSVCMsg_Sounds.sounddata_t";
            };
    
            return sounddata_t;
        })();
    
        return CSVCMsg_Sounds;
    })();
    
    $root.CSVCMsg_Prefetch = (function() {
    
        /**
         * Properties of a CSVCMsg_Prefetch.
         * @exports ICSVCMsg_Prefetch
         * @interface ICSVCMsg_Prefetch
         * @property {number|null} [soundIndex] CSVCMsg_Prefetch soundIndex
         * @property {PrefetchType|null} [resourceType] CSVCMsg_Prefetch resourceType
         */
    
        /**
         * Constructs a new CSVCMsg_Prefetch.
         * @exports CSVCMsg_Prefetch
         * @classdesc Represents a CSVCMsg_Prefetch.
         * @implements ICSVCMsg_Prefetch
         * @constructor
         * @param {ICSVCMsg_Prefetch=} [properties] Properties to set
         */
        function CSVCMsg_Prefetch(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CSVCMsg_Prefetch soundIndex.
         * @member {number} soundIndex
         * @memberof CSVCMsg_Prefetch
         * @instance
         */
        CSVCMsg_Prefetch.prototype.soundIndex = 0;
    
        /**
         * CSVCMsg_Prefetch resourceType.
         * @member {PrefetchType} resourceType
         * @memberof CSVCMsg_Prefetch
         * @instance
         */
        CSVCMsg_Prefetch.prototype.resourceType = 0;
    
        /**
         * Creates a new CSVCMsg_Prefetch instance using the specified properties.
         * @function create
         * @memberof CSVCMsg_Prefetch
         * @static
         * @param {ICSVCMsg_Prefetch=} [properties] Properties to set
         * @returns {CSVCMsg_Prefetch} CSVCMsg_Prefetch instance
         */
        CSVCMsg_Prefetch.create = function create(properties) {
            return new CSVCMsg_Prefetch(properties);
        };
    
        /**
         * Encodes the specified CSVCMsg_Prefetch message. Does not implicitly {@link CSVCMsg_Prefetch.verify|verify} messages.
         * @function encode
         * @memberof CSVCMsg_Prefetch
         * @static
         * @param {ICSVCMsg_Prefetch} message CSVCMsg_Prefetch message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CSVCMsg_Prefetch.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.soundIndex != null && Object.hasOwnProperty.call(message, "soundIndex"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.soundIndex);
            if (message.resourceType != null && Object.hasOwnProperty.call(message, "resourceType"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.resourceType);
            return writer;
        };
    
        /**
         * Encodes the specified CSVCMsg_Prefetch message, length delimited. Does not implicitly {@link CSVCMsg_Prefetch.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CSVCMsg_Prefetch
         * @static
         * @param {ICSVCMsg_Prefetch} message CSVCMsg_Prefetch message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CSVCMsg_Prefetch.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CSVCMsg_Prefetch message from the specified reader or buffer.
         * @function decode
         * @memberof CSVCMsg_Prefetch
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CSVCMsg_Prefetch} CSVCMsg_Prefetch
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CSVCMsg_Prefetch.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CSVCMsg_Prefetch();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.soundIndex = reader.int32();
                        break;
                    }
                case 2: {
                        message.resourceType = reader.int32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CSVCMsg_Prefetch message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CSVCMsg_Prefetch
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CSVCMsg_Prefetch} CSVCMsg_Prefetch
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CSVCMsg_Prefetch.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CSVCMsg_Prefetch message.
         * @function verify
         * @memberof CSVCMsg_Prefetch
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CSVCMsg_Prefetch.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.soundIndex != null && message.hasOwnProperty("soundIndex"))
                if (!$util.isInteger(message.soundIndex))
                    return "soundIndex: integer expected";
            if (message.resourceType != null && message.hasOwnProperty("resourceType"))
                switch (message.resourceType) {
                default:
                    return "resourceType: enum value expected";
                case 0:
                    break;
                }
            return null;
        };
    
        /**
         * Creates a CSVCMsg_Prefetch message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CSVCMsg_Prefetch
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CSVCMsg_Prefetch} CSVCMsg_Prefetch
         */
        CSVCMsg_Prefetch.fromObject = function fromObject(object) {
            if (object instanceof $root.CSVCMsg_Prefetch)
                return object;
            var message = new $root.CSVCMsg_Prefetch();
            if (object.soundIndex != null)
                message.soundIndex = object.soundIndex | 0;
            switch (object.resourceType) {
            default:
                if (typeof object.resourceType === "number") {
                    message.resourceType = object.resourceType;
                    break;
                }
                break;
            case "PFT_SOUND":
            case 0:
                message.resourceType = 0;
                break;
            }
            return message;
        };
    
        /**
         * Creates a plain object from a CSVCMsg_Prefetch message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CSVCMsg_Prefetch
         * @static
         * @param {CSVCMsg_Prefetch} message CSVCMsg_Prefetch
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CSVCMsg_Prefetch.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.soundIndex = 0;
                object.resourceType = options.enums === String ? "PFT_SOUND" : 0;
            }
            if (message.soundIndex != null && message.hasOwnProperty("soundIndex"))
                object.soundIndex = message.soundIndex;
            if (message.resourceType != null && message.hasOwnProperty("resourceType"))
                object.resourceType = options.enums === String ? $root.PrefetchType[message.resourceType] === undefined ? message.resourceType : $root.PrefetchType[message.resourceType] : message.resourceType;
            return object;
        };
    
        /**
         * Converts this CSVCMsg_Prefetch to JSON.
         * @function toJSON
         * @memberof CSVCMsg_Prefetch
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CSVCMsg_Prefetch.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * Gets the default type url for CSVCMsg_Prefetch
         * @function getTypeUrl
         * @memberof CSVCMsg_Prefetch
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        CSVCMsg_Prefetch.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/CSVCMsg_Prefetch";
        };
    
        return CSVCMsg_Prefetch;
    })();
    
    $root.CSVCMsg_SetView = (function() {
    
        /**
         * Properties of a CSVCMsg_SetView.
         * @exports ICSVCMsg_SetView
         * @interface ICSVCMsg_SetView
         * @property {number|null} [entityIndex] CSVCMsg_SetView entityIndex
         * @property {number|null} [slot] CSVCMsg_SetView slot
         */
    
        /**
         * Constructs a new CSVCMsg_SetView.
         * @exports CSVCMsg_SetView
         * @classdesc Represents a CSVCMsg_SetView.
         * @implements ICSVCMsg_SetView
         * @constructor
         * @param {ICSVCMsg_SetView=} [properties] Properties to set
         */
        function CSVCMsg_SetView(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CSVCMsg_SetView entityIndex.
         * @member {number} entityIndex
         * @memberof CSVCMsg_SetView
         * @instance
         */
        CSVCMsg_SetView.prototype.entityIndex = -1;
    
        /**
         * CSVCMsg_SetView slot.
         * @member {number} slot
         * @memberof CSVCMsg_SetView
         * @instance
         */
        CSVCMsg_SetView.prototype.slot = -1;
    
        /**
         * Creates a new CSVCMsg_SetView instance using the specified properties.
         * @function create
         * @memberof CSVCMsg_SetView
         * @static
         * @param {ICSVCMsg_SetView=} [properties] Properties to set
         * @returns {CSVCMsg_SetView} CSVCMsg_SetView instance
         */
        CSVCMsg_SetView.create = function create(properties) {
            return new CSVCMsg_SetView(properties);
        };
    
        /**
         * Encodes the specified CSVCMsg_SetView message. Does not implicitly {@link CSVCMsg_SetView.verify|verify} messages.
         * @function encode
         * @memberof CSVCMsg_SetView
         * @static
         * @param {ICSVCMsg_SetView} message CSVCMsg_SetView message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CSVCMsg_SetView.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.entityIndex != null && Object.hasOwnProperty.call(message, "entityIndex"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.entityIndex);
            if (message.slot != null && Object.hasOwnProperty.call(message, "slot"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.slot);
            return writer;
        };
    
        /**
         * Encodes the specified CSVCMsg_SetView message, length delimited. Does not implicitly {@link CSVCMsg_SetView.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CSVCMsg_SetView
         * @static
         * @param {ICSVCMsg_SetView} message CSVCMsg_SetView message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CSVCMsg_SetView.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CSVCMsg_SetView message from the specified reader or buffer.
         * @function decode
         * @memberof CSVCMsg_SetView
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CSVCMsg_SetView} CSVCMsg_SetView
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CSVCMsg_SetView.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CSVCMsg_SetView();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.entityIndex = reader.int32();
                        break;
                    }
                case 2: {
                        message.slot = reader.int32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CSVCMsg_SetView message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CSVCMsg_SetView
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CSVCMsg_SetView} CSVCMsg_SetView
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CSVCMsg_SetView.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CSVCMsg_SetView message.
         * @function verify
         * @memberof CSVCMsg_SetView
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CSVCMsg_SetView.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.entityIndex != null && message.hasOwnProperty("entityIndex"))
                if (!$util.isInteger(message.entityIndex))
                    return "entityIndex: integer expected";
            if (message.slot != null && message.hasOwnProperty("slot"))
                if (!$util.isInteger(message.slot))
                    return "slot: integer expected";
            return null;
        };
    
        /**
         * Creates a CSVCMsg_SetView message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CSVCMsg_SetView
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CSVCMsg_SetView} CSVCMsg_SetView
         */
        CSVCMsg_SetView.fromObject = function fromObject(object) {
            if (object instanceof $root.CSVCMsg_SetView)
                return object;
            var message = new $root.CSVCMsg_SetView();
            if (object.entityIndex != null)
                message.entityIndex = object.entityIndex | 0;
            if (object.slot != null)
                message.slot = object.slot | 0;
            return message;
        };
    
        /**
         * Creates a plain object from a CSVCMsg_SetView message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CSVCMsg_SetView
         * @static
         * @param {CSVCMsg_SetView} message CSVCMsg_SetView
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CSVCMsg_SetView.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.entityIndex = -1;
                object.slot = -1;
            }
            if (message.entityIndex != null && message.hasOwnProperty("entityIndex"))
                object.entityIndex = message.entityIndex;
            if (message.slot != null && message.hasOwnProperty("slot"))
                object.slot = message.slot;
            return object;
        };
    
        /**
         * Converts this CSVCMsg_SetView to JSON.
         * @function toJSON
         * @memberof CSVCMsg_SetView
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CSVCMsg_SetView.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * Gets the default type url for CSVCMsg_SetView
         * @function getTypeUrl
         * @memberof CSVCMsg_SetView
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        CSVCMsg_SetView.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/CSVCMsg_SetView";
        };
    
        return CSVCMsg_SetView;
    })();
    
    $root.CSVCMsg_FixAngle = (function() {
    
        /**
         * Properties of a CSVCMsg_FixAngle.
         * @exports ICSVCMsg_FixAngle
         * @interface ICSVCMsg_FixAngle
         * @property {boolean|null} [relative] CSVCMsg_FixAngle relative
         * @property {ICMsgQAngle|null} [angle] CSVCMsg_FixAngle angle
         */
    
        /**
         * Constructs a new CSVCMsg_FixAngle.
         * @exports CSVCMsg_FixAngle
         * @classdesc Represents a CSVCMsg_FixAngle.
         * @implements ICSVCMsg_FixAngle
         * @constructor
         * @param {ICSVCMsg_FixAngle=} [properties] Properties to set
         */
        function CSVCMsg_FixAngle(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CSVCMsg_FixAngle relative.
         * @member {boolean} relative
         * @memberof CSVCMsg_FixAngle
         * @instance
         */
        CSVCMsg_FixAngle.prototype.relative = false;
    
        /**
         * CSVCMsg_FixAngle angle.
         * @member {ICMsgQAngle|null|undefined} angle
         * @memberof CSVCMsg_FixAngle
         * @instance
         */
        CSVCMsg_FixAngle.prototype.angle = null;
    
        /**
         * Creates a new CSVCMsg_FixAngle instance using the specified properties.
         * @function create
         * @memberof CSVCMsg_FixAngle
         * @static
         * @param {ICSVCMsg_FixAngle=} [properties] Properties to set
         * @returns {CSVCMsg_FixAngle} CSVCMsg_FixAngle instance
         */
        CSVCMsg_FixAngle.create = function create(properties) {
            return new CSVCMsg_FixAngle(properties);
        };
    
        /**
         * Encodes the specified CSVCMsg_FixAngle message. Does not implicitly {@link CSVCMsg_FixAngle.verify|verify} messages.
         * @function encode
         * @memberof CSVCMsg_FixAngle
         * @static
         * @param {ICSVCMsg_FixAngle} message CSVCMsg_FixAngle message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CSVCMsg_FixAngle.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.relative != null && Object.hasOwnProperty.call(message, "relative"))
                writer.uint32(/* id 1, wireType 0 =*/8).bool(message.relative);
            if (message.angle != null && Object.hasOwnProperty.call(message, "angle"))
                $root.CMsgQAngle.encode(message.angle, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };
    
        /**
         * Encodes the specified CSVCMsg_FixAngle message, length delimited. Does not implicitly {@link CSVCMsg_FixAngle.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CSVCMsg_FixAngle
         * @static
         * @param {ICSVCMsg_FixAngle} message CSVCMsg_FixAngle message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CSVCMsg_FixAngle.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CSVCMsg_FixAngle message from the specified reader or buffer.
         * @function decode
         * @memberof CSVCMsg_FixAngle
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CSVCMsg_FixAngle} CSVCMsg_FixAngle
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CSVCMsg_FixAngle.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CSVCMsg_FixAngle();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.relative = reader.bool();
                        break;
                    }
                case 2: {
                        message.angle = $root.CMsgQAngle.decode(reader, reader.uint32());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CSVCMsg_FixAngle message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CSVCMsg_FixAngle
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CSVCMsg_FixAngle} CSVCMsg_FixAngle
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CSVCMsg_FixAngle.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CSVCMsg_FixAngle message.
         * @function verify
         * @memberof CSVCMsg_FixAngle
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CSVCMsg_FixAngle.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.relative != null && message.hasOwnProperty("relative"))
                if (typeof message.relative !== "boolean")
                    return "relative: boolean expected";
            if (message.angle != null && message.hasOwnProperty("angle")) {
                var error = $root.CMsgQAngle.verify(message.angle);
                if (error)
                    return "angle." + error;
            }
            return null;
        };
    
        /**
         * Creates a CSVCMsg_FixAngle message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CSVCMsg_FixAngle
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CSVCMsg_FixAngle} CSVCMsg_FixAngle
         */
        CSVCMsg_FixAngle.fromObject = function fromObject(object) {
            if (object instanceof $root.CSVCMsg_FixAngle)
                return object;
            var message = new $root.CSVCMsg_FixAngle();
            if (object.relative != null)
                message.relative = Boolean(object.relative);
            if (object.angle != null) {
                if (typeof object.angle !== "object")
                    throw TypeError(".CSVCMsg_FixAngle.angle: object expected");
                message.angle = $root.CMsgQAngle.fromObject(object.angle);
            }
            return message;
        };
    
        /**
         * Creates a plain object from a CSVCMsg_FixAngle message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CSVCMsg_FixAngle
         * @static
         * @param {CSVCMsg_FixAngle} message CSVCMsg_FixAngle
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CSVCMsg_FixAngle.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.relative = false;
                object.angle = null;
            }
            if (message.relative != null && message.hasOwnProperty("relative"))
                object.relative = message.relative;
            if (message.angle != null && message.hasOwnProperty("angle"))
                object.angle = $root.CMsgQAngle.toObject(message.angle, options);
            return object;
        };
    
        /**
         * Converts this CSVCMsg_FixAngle to JSON.
         * @function toJSON
         * @memberof CSVCMsg_FixAngle
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CSVCMsg_FixAngle.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * Gets the default type url for CSVCMsg_FixAngle
         * @function getTypeUrl
         * @memberof CSVCMsg_FixAngle
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        CSVCMsg_FixAngle.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/CSVCMsg_FixAngle";
        };
    
        return CSVCMsg_FixAngle;
    })();
    
    $root.CSVCMsg_CrosshairAngle = (function() {
    
        /**
         * Properties of a CSVCMsg_CrosshairAngle.
         * @exports ICSVCMsg_CrosshairAngle
         * @interface ICSVCMsg_CrosshairAngle
         * @property {ICMsgQAngle|null} [angle] CSVCMsg_CrosshairAngle angle
         */
    
        /**
         * Constructs a new CSVCMsg_CrosshairAngle.
         * @exports CSVCMsg_CrosshairAngle
         * @classdesc Represents a CSVCMsg_CrosshairAngle.
         * @implements ICSVCMsg_CrosshairAngle
         * @constructor
         * @param {ICSVCMsg_CrosshairAngle=} [properties] Properties to set
         */
        function CSVCMsg_CrosshairAngle(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CSVCMsg_CrosshairAngle angle.
         * @member {ICMsgQAngle|null|undefined} angle
         * @memberof CSVCMsg_CrosshairAngle
         * @instance
         */
        CSVCMsg_CrosshairAngle.prototype.angle = null;
    
        /**
         * Creates a new CSVCMsg_CrosshairAngle instance using the specified properties.
         * @function create
         * @memberof CSVCMsg_CrosshairAngle
         * @static
         * @param {ICSVCMsg_CrosshairAngle=} [properties] Properties to set
         * @returns {CSVCMsg_CrosshairAngle} CSVCMsg_CrosshairAngle instance
         */
        CSVCMsg_CrosshairAngle.create = function create(properties) {
            return new CSVCMsg_CrosshairAngle(properties);
        };
    
        /**
         * Encodes the specified CSVCMsg_CrosshairAngle message. Does not implicitly {@link CSVCMsg_CrosshairAngle.verify|verify} messages.
         * @function encode
         * @memberof CSVCMsg_CrosshairAngle
         * @static
         * @param {ICSVCMsg_CrosshairAngle} message CSVCMsg_CrosshairAngle message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CSVCMsg_CrosshairAngle.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.angle != null && Object.hasOwnProperty.call(message, "angle"))
                $root.CMsgQAngle.encode(message.angle, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };
    
        /**
         * Encodes the specified CSVCMsg_CrosshairAngle message, length delimited. Does not implicitly {@link CSVCMsg_CrosshairAngle.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CSVCMsg_CrosshairAngle
         * @static
         * @param {ICSVCMsg_CrosshairAngle} message CSVCMsg_CrosshairAngle message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CSVCMsg_CrosshairAngle.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CSVCMsg_CrosshairAngle message from the specified reader or buffer.
         * @function decode
         * @memberof CSVCMsg_CrosshairAngle
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CSVCMsg_CrosshairAngle} CSVCMsg_CrosshairAngle
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CSVCMsg_CrosshairAngle.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CSVCMsg_CrosshairAngle();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.angle = $root.CMsgQAngle.decode(reader, reader.uint32());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CSVCMsg_CrosshairAngle message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CSVCMsg_CrosshairAngle
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CSVCMsg_CrosshairAngle} CSVCMsg_CrosshairAngle
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CSVCMsg_CrosshairAngle.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CSVCMsg_CrosshairAngle message.
         * @function verify
         * @memberof CSVCMsg_CrosshairAngle
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CSVCMsg_CrosshairAngle.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.angle != null && message.hasOwnProperty("angle")) {
                var error = $root.CMsgQAngle.verify(message.angle);
                if (error)
                    return "angle." + error;
            }
            return null;
        };
    
        /**
         * Creates a CSVCMsg_CrosshairAngle message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CSVCMsg_CrosshairAngle
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CSVCMsg_CrosshairAngle} CSVCMsg_CrosshairAngle
         */
        CSVCMsg_CrosshairAngle.fromObject = function fromObject(object) {
            if (object instanceof $root.CSVCMsg_CrosshairAngle)
                return object;
            var message = new $root.CSVCMsg_CrosshairAngle();
            if (object.angle != null) {
                if (typeof object.angle !== "object")
                    throw TypeError(".CSVCMsg_CrosshairAngle.angle: object expected");
                message.angle = $root.CMsgQAngle.fromObject(object.angle);
            }
            return message;
        };
    
        /**
         * Creates a plain object from a CSVCMsg_CrosshairAngle message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CSVCMsg_CrosshairAngle
         * @static
         * @param {CSVCMsg_CrosshairAngle} message CSVCMsg_CrosshairAngle
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CSVCMsg_CrosshairAngle.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.angle = null;
            if (message.angle != null && message.hasOwnProperty("angle"))
                object.angle = $root.CMsgQAngle.toObject(message.angle, options);
            return object;
        };
    
        /**
         * Converts this CSVCMsg_CrosshairAngle to JSON.
         * @function toJSON
         * @memberof CSVCMsg_CrosshairAngle
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CSVCMsg_CrosshairAngle.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * Gets the default type url for CSVCMsg_CrosshairAngle
         * @function getTypeUrl
         * @memberof CSVCMsg_CrosshairAngle
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        CSVCMsg_CrosshairAngle.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/CSVCMsg_CrosshairAngle";
        };
    
        return CSVCMsg_CrosshairAngle;
    })();
    
    $root.CSVCMsg_BSPDecal = (function() {
    
        /**
         * Properties of a CSVCMsg_BSPDecal.
         * @exports ICSVCMsg_BSPDecal
         * @interface ICSVCMsg_BSPDecal
         * @property {ICMsgVector|null} [pos] CSVCMsg_BSPDecal pos
         * @property {number|null} [decalTextureIndex] CSVCMsg_BSPDecal decalTextureIndex
         * @property {number|null} [entityIndex] CSVCMsg_BSPDecal entityIndex
         * @property {number|null} [modelIndex] CSVCMsg_BSPDecal modelIndex
         * @property {boolean|null} [lowPriority] CSVCMsg_BSPDecal lowPriority
         */
    
        /**
         * Constructs a new CSVCMsg_BSPDecal.
         * @exports CSVCMsg_BSPDecal
         * @classdesc Represents a CSVCMsg_BSPDecal.
         * @implements ICSVCMsg_BSPDecal
         * @constructor
         * @param {ICSVCMsg_BSPDecal=} [properties] Properties to set
         */
        function CSVCMsg_BSPDecal(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CSVCMsg_BSPDecal pos.
         * @member {ICMsgVector|null|undefined} pos
         * @memberof CSVCMsg_BSPDecal
         * @instance
         */
        CSVCMsg_BSPDecal.prototype.pos = null;
    
        /**
         * CSVCMsg_BSPDecal decalTextureIndex.
         * @member {number} decalTextureIndex
         * @memberof CSVCMsg_BSPDecal
         * @instance
         */
        CSVCMsg_BSPDecal.prototype.decalTextureIndex = 0;
    
        /**
         * CSVCMsg_BSPDecal entityIndex.
         * @member {number} entityIndex
         * @memberof CSVCMsg_BSPDecal
         * @instance
         */
        CSVCMsg_BSPDecal.prototype.entityIndex = -1;
    
        /**
         * CSVCMsg_BSPDecal modelIndex.
         * @member {number} modelIndex
         * @memberof CSVCMsg_BSPDecal
         * @instance
         */
        CSVCMsg_BSPDecal.prototype.modelIndex = 0;
    
        /**
         * CSVCMsg_BSPDecal lowPriority.
         * @member {boolean} lowPriority
         * @memberof CSVCMsg_BSPDecal
         * @instance
         */
        CSVCMsg_BSPDecal.prototype.lowPriority = false;
    
        /**
         * Creates a new CSVCMsg_BSPDecal instance using the specified properties.
         * @function create
         * @memberof CSVCMsg_BSPDecal
         * @static
         * @param {ICSVCMsg_BSPDecal=} [properties] Properties to set
         * @returns {CSVCMsg_BSPDecal} CSVCMsg_BSPDecal instance
         */
        CSVCMsg_BSPDecal.create = function create(properties) {
            return new CSVCMsg_BSPDecal(properties);
        };
    
        /**
         * Encodes the specified CSVCMsg_BSPDecal message. Does not implicitly {@link CSVCMsg_BSPDecal.verify|verify} messages.
         * @function encode
         * @memberof CSVCMsg_BSPDecal
         * @static
         * @param {ICSVCMsg_BSPDecal} message CSVCMsg_BSPDecal message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CSVCMsg_BSPDecal.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.pos != null && Object.hasOwnProperty.call(message, "pos"))
                $root.CMsgVector.encode(message.pos, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.decalTextureIndex != null && Object.hasOwnProperty.call(message, "decalTextureIndex"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.decalTextureIndex);
            if (message.entityIndex != null && Object.hasOwnProperty.call(message, "entityIndex"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.entityIndex);
            if (message.modelIndex != null && Object.hasOwnProperty.call(message, "modelIndex"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.modelIndex);
            if (message.lowPriority != null && Object.hasOwnProperty.call(message, "lowPriority"))
                writer.uint32(/* id 5, wireType 0 =*/40).bool(message.lowPriority);
            return writer;
        };
    
        /**
         * Encodes the specified CSVCMsg_BSPDecal message, length delimited. Does not implicitly {@link CSVCMsg_BSPDecal.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CSVCMsg_BSPDecal
         * @static
         * @param {ICSVCMsg_BSPDecal} message CSVCMsg_BSPDecal message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CSVCMsg_BSPDecal.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CSVCMsg_BSPDecal message from the specified reader or buffer.
         * @function decode
         * @memberof CSVCMsg_BSPDecal
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CSVCMsg_BSPDecal} CSVCMsg_BSPDecal
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CSVCMsg_BSPDecal.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CSVCMsg_BSPDecal();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.pos = $root.CMsgVector.decode(reader, reader.uint32());
                        break;
                    }
                case 2: {
                        message.decalTextureIndex = reader.int32();
                        break;
                    }
                case 3: {
                        message.entityIndex = reader.int32();
                        break;
                    }
                case 4: {
                        message.modelIndex = reader.int32();
                        break;
                    }
                case 5: {
                        message.lowPriority = reader.bool();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CSVCMsg_BSPDecal message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CSVCMsg_BSPDecal
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CSVCMsg_BSPDecal} CSVCMsg_BSPDecal
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CSVCMsg_BSPDecal.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CSVCMsg_BSPDecal message.
         * @function verify
         * @memberof CSVCMsg_BSPDecal
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CSVCMsg_BSPDecal.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.pos != null && message.hasOwnProperty("pos")) {
                var error = $root.CMsgVector.verify(message.pos);
                if (error)
                    return "pos." + error;
            }
            if (message.decalTextureIndex != null && message.hasOwnProperty("decalTextureIndex"))
                if (!$util.isInteger(message.decalTextureIndex))
                    return "decalTextureIndex: integer expected";
            if (message.entityIndex != null && message.hasOwnProperty("entityIndex"))
                if (!$util.isInteger(message.entityIndex))
                    return "entityIndex: integer expected";
            if (message.modelIndex != null && message.hasOwnProperty("modelIndex"))
                if (!$util.isInteger(message.modelIndex))
                    return "modelIndex: integer expected";
            if (message.lowPriority != null && message.hasOwnProperty("lowPriority"))
                if (typeof message.lowPriority !== "boolean")
                    return "lowPriority: boolean expected";
            return null;
        };
    
        /**
         * Creates a CSVCMsg_BSPDecal message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CSVCMsg_BSPDecal
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CSVCMsg_BSPDecal} CSVCMsg_BSPDecal
         */
        CSVCMsg_BSPDecal.fromObject = function fromObject(object) {
            if (object instanceof $root.CSVCMsg_BSPDecal)
                return object;
            var message = new $root.CSVCMsg_BSPDecal();
            if (object.pos != null) {
                if (typeof object.pos !== "object")
                    throw TypeError(".CSVCMsg_BSPDecal.pos: object expected");
                message.pos = $root.CMsgVector.fromObject(object.pos);
            }
            if (object.decalTextureIndex != null)
                message.decalTextureIndex = object.decalTextureIndex | 0;
            if (object.entityIndex != null)
                message.entityIndex = object.entityIndex | 0;
            if (object.modelIndex != null)
                message.modelIndex = object.modelIndex | 0;
            if (object.lowPriority != null)
                message.lowPriority = Boolean(object.lowPriority);
            return message;
        };
    
        /**
         * Creates a plain object from a CSVCMsg_BSPDecal message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CSVCMsg_BSPDecal
         * @static
         * @param {CSVCMsg_BSPDecal} message CSVCMsg_BSPDecal
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CSVCMsg_BSPDecal.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.pos = null;
                object.decalTextureIndex = 0;
                object.entityIndex = -1;
                object.modelIndex = 0;
                object.lowPriority = false;
            }
            if (message.pos != null && message.hasOwnProperty("pos"))
                object.pos = $root.CMsgVector.toObject(message.pos, options);
            if (message.decalTextureIndex != null && message.hasOwnProperty("decalTextureIndex"))
                object.decalTextureIndex = message.decalTextureIndex;
            if (message.entityIndex != null && message.hasOwnProperty("entityIndex"))
                object.entityIndex = message.entityIndex;
            if (message.modelIndex != null && message.hasOwnProperty("modelIndex"))
                object.modelIndex = message.modelIndex;
            if (message.lowPriority != null && message.hasOwnProperty("lowPriority"))
                object.lowPriority = message.lowPriority;
            return object;
        };
    
        /**
         * Converts this CSVCMsg_BSPDecal to JSON.
         * @function toJSON
         * @memberof CSVCMsg_BSPDecal
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CSVCMsg_BSPDecal.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * Gets the default type url for CSVCMsg_BSPDecal
         * @function getTypeUrl
         * @memberof CSVCMsg_BSPDecal
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        CSVCMsg_BSPDecal.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/CSVCMsg_BSPDecal";
        };
    
        return CSVCMsg_BSPDecal;
    })();
    
    $root.CSVCMsg_SplitScreen = (function() {
    
        /**
         * Properties of a CSVCMsg_SplitScreen.
         * @exports ICSVCMsg_SplitScreen
         * @interface ICSVCMsg_SplitScreen
         * @property {ESplitScreenMessageType|null} [type] CSVCMsg_SplitScreen type
         * @property {number|null} [slot] CSVCMsg_SplitScreen slot
         * @property {number|null} [playerIndex] CSVCMsg_SplitScreen playerIndex
         */
    
        /**
         * Constructs a new CSVCMsg_SplitScreen.
         * @exports CSVCMsg_SplitScreen
         * @classdesc Represents a CSVCMsg_SplitScreen.
         * @implements ICSVCMsg_SplitScreen
         * @constructor
         * @param {ICSVCMsg_SplitScreen=} [properties] Properties to set
         */
        function CSVCMsg_SplitScreen(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CSVCMsg_SplitScreen type.
         * @member {ESplitScreenMessageType} type
         * @memberof CSVCMsg_SplitScreen
         * @instance
         */
        CSVCMsg_SplitScreen.prototype.type = 0;
    
        /**
         * CSVCMsg_SplitScreen slot.
         * @member {number} slot
         * @memberof CSVCMsg_SplitScreen
         * @instance
         */
        CSVCMsg_SplitScreen.prototype.slot = 0;
    
        /**
         * CSVCMsg_SplitScreen playerIndex.
         * @member {number} playerIndex
         * @memberof CSVCMsg_SplitScreen
         * @instance
         */
        CSVCMsg_SplitScreen.prototype.playerIndex = -1;
    
        /**
         * Creates a new CSVCMsg_SplitScreen instance using the specified properties.
         * @function create
         * @memberof CSVCMsg_SplitScreen
         * @static
         * @param {ICSVCMsg_SplitScreen=} [properties] Properties to set
         * @returns {CSVCMsg_SplitScreen} CSVCMsg_SplitScreen instance
         */
        CSVCMsg_SplitScreen.create = function create(properties) {
            return new CSVCMsg_SplitScreen(properties);
        };
    
        /**
         * Encodes the specified CSVCMsg_SplitScreen message. Does not implicitly {@link CSVCMsg_SplitScreen.verify|verify} messages.
         * @function encode
         * @memberof CSVCMsg_SplitScreen
         * @static
         * @param {ICSVCMsg_SplitScreen} message CSVCMsg_SplitScreen message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CSVCMsg_SplitScreen.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
            if (message.slot != null && Object.hasOwnProperty.call(message, "slot"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.slot);
            if (message.playerIndex != null && Object.hasOwnProperty.call(message, "playerIndex"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.playerIndex);
            return writer;
        };
    
        /**
         * Encodes the specified CSVCMsg_SplitScreen message, length delimited. Does not implicitly {@link CSVCMsg_SplitScreen.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CSVCMsg_SplitScreen
         * @static
         * @param {ICSVCMsg_SplitScreen} message CSVCMsg_SplitScreen message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CSVCMsg_SplitScreen.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CSVCMsg_SplitScreen message from the specified reader or buffer.
         * @function decode
         * @memberof CSVCMsg_SplitScreen
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CSVCMsg_SplitScreen} CSVCMsg_SplitScreen
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CSVCMsg_SplitScreen.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CSVCMsg_SplitScreen();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.type = reader.int32();
                        break;
                    }
                case 2: {
                        message.slot = reader.int32();
                        break;
                    }
                case 3: {
                        message.playerIndex = reader.int32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CSVCMsg_SplitScreen message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CSVCMsg_SplitScreen
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CSVCMsg_SplitScreen} CSVCMsg_SplitScreen
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CSVCMsg_SplitScreen.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CSVCMsg_SplitScreen message.
         * @function verify
         * @memberof CSVCMsg_SplitScreen
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CSVCMsg_SplitScreen.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.type != null && message.hasOwnProperty("type"))
                switch (message.type) {
                default:
                    return "type: enum value expected";
                case 0:
                case 1:
                    break;
                }
            if (message.slot != null && message.hasOwnProperty("slot"))
                if (!$util.isInteger(message.slot))
                    return "slot: integer expected";
            if (message.playerIndex != null && message.hasOwnProperty("playerIndex"))
                if (!$util.isInteger(message.playerIndex))
                    return "playerIndex: integer expected";
            return null;
        };
    
        /**
         * Creates a CSVCMsg_SplitScreen message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CSVCMsg_SplitScreen
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CSVCMsg_SplitScreen} CSVCMsg_SplitScreen
         */
        CSVCMsg_SplitScreen.fromObject = function fromObject(object) {
            if (object instanceof $root.CSVCMsg_SplitScreen)
                return object;
            var message = new $root.CSVCMsg_SplitScreen();
            switch (object.type) {
            default:
                if (typeof object.type === "number") {
                    message.type = object.type;
                    break;
                }
                break;
            case "MSG_SPLITSCREEN_ADDUSER":
            case 0:
                message.type = 0;
                break;
            case "MSG_SPLITSCREEN_REMOVEUSER":
            case 1:
                message.type = 1;
                break;
            }
            if (object.slot != null)
                message.slot = object.slot | 0;
            if (object.playerIndex != null)
                message.playerIndex = object.playerIndex | 0;
            return message;
        };
    
        /**
         * Creates a plain object from a CSVCMsg_SplitScreen message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CSVCMsg_SplitScreen
         * @static
         * @param {CSVCMsg_SplitScreen} message CSVCMsg_SplitScreen
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CSVCMsg_SplitScreen.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.type = options.enums === String ? "MSG_SPLITSCREEN_ADDUSER" : 0;
                object.slot = 0;
                object.playerIndex = -1;
            }
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = options.enums === String ? $root.ESplitScreenMessageType[message.type] === undefined ? message.type : $root.ESplitScreenMessageType[message.type] : message.type;
            if (message.slot != null && message.hasOwnProperty("slot"))
                object.slot = message.slot;
            if (message.playerIndex != null && message.hasOwnProperty("playerIndex"))
                object.playerIndex = message.playerIndex;
            return object;
        };
    
        /**
         * Converts this CSVCMsg_SplitScreen to JSON.
         * @function toJSON
         * @memberof CSVCMsg_SplitScreen
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CSVCMsg_SplitScreen.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * Gets the default type url for CSVCMsg_SplitScreen
         * @function getTypeUrl
         * @memberof CSVCMsg_SplitScreen
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        CSVCMsg_SplitScreen.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/CSVCMsg_SplitScreen";
        };
    
        return CSVCMsg_SplitScreen;
    })();
    
    $root.CSVCMsg_GetCvarValue = (function() {
    
        /**
         * Properties of a CSVCMsg_GetCvarValue.
         * @exports ICSVCMsg_GetCvarValue
         * @interface ICSVCMsg_GetCvarValue
         * @property {number|null} [cookie] CSVCMsg_GetCvarValue cookie
         * @property {string|null} [cvarName] CSVCMsg_GetCvarValue cvarName
         */
    
        /**
         * Constructs a new CSVCMsg_GetCvarValue.
         * @exports CSVCMsg_GetCvarValue
         * @classdesc Represents a CSVCMsg_GetCvarValue.
         * @implements ICSVCMsg_GetCvarValue
         * @constructor
         * @param {ICSVCMsg_GetCvarValue=} [properties] Properties to set
         */
        function CSVCMsg_GetCvarValue(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CSVCMsg_GetCvarValue cookie.
         * @member {number} cookie
         * @memberof CSVCMsg_GetCvarValue
         * @instance
         */
        CSVCMsg_GetCvarValue.prototype.cookie = 0;
    
        /**
         * CSVCMsg_GetCvarValue cvarName.
         * @member {string} cvarName
         * @memberof CSVCMsg_GetCvarValue
         * @instance
         */
        CSVCMsg_GetCvarValue.prototype.cvarName = "";
    
        /**
         * Creates a new CSVCMsg_GetCvarValue instance using the specified properties.
         * @function create
         * @memberof CSVCMsg_GetCvarValue
         * @static
         * @param {ICSVCMsg_GetCvarValue=} [properties] Properties to set
         * @returns {CSVCMsg_GetCvarValue} CSVCMsg_GetCvarValue instance
         */
        CSVCMsg_GetCvarValue.create = function create(properties) {
            return new CSVCMsg_GetCvarValue(properties);
        };
    
        /**
         * Encodes the specified CSVCMsg_GetCvarValue message. Does not implicitly {@link CSVCMsg_GetCvarValue.verify|verify} messages.
         * @function encode
         * @memberof CSVCMsg_GetCvarValue
         * @static
         * @param {ICSVCMsg_GetCvarValue} message CSVCMsg_GetCvarValue message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CSVCMsg_GetCvarValue.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.cookie != null && Object.hasOwnProperty.call(message, "cookie"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.cookie);
            if (message.cvarName != null && Object.hasOwnProperty.call(message, "cvarName"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.cvarName);
            return writer;
        };
    
        /**
         * Encodes the specified CSVCMsg_GetCvarValue message, length delimited. Does not implicitly {@link CSVCMsg_GetCvarValue.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CSVCMsg_GetCvarValue
         * @static
         * @param {ICSVCMsg_GetCvarValue} message CSVCMsg_GetCvarValue message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CSVCMsg_GetCvarValue.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CSVCMsg_GetCvarValue message from the specified reader or buffer.
         * @function decode
         * @memberof CSVCMsg_GetCvarValue
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CSVCMsg_GetCvarValue} CSVCMsg_GetCvarValue
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CSVCMsg_GetCvarValue.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CSVCMsg_GetCvarValue();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.cookie = reader.int32();
                        break;
                    }
                case 2: {
                        message.cvarName = reader.string();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CSVCMsg_GetCvarValue message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CSVCMsg_GetCvarValue
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CSVCMsg_GetCvarValue} CSVCMsg_GetCvarValue
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CSVCMsg_GetCvarValue.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CSVCMsg_GetCvarValue message.
         * @function verify
         * @memberof CSVCMsg_GetCvarValue
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CSVCMsg_GetCvarValue.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.cookie != null && message.hasOwnProperty("cookie"))
                if (!$util.isInteger(message.cookie))
                    return "cookie: integer expected";
            if (message.cvarName != null && message.hasOwnProperty("cvarName"))
                if (!$util.isString(message.cvarName))
                    return "cvarName: string expected";
            return null;
        };
    
        /**
         * Creates a CSVCMsg_GetCvarValue message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CSVCMsg_GetCvarValue
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CSVCMsg_GetCvarValue} CSVCMsg_GetCvarValue
         */
        CSVCMsg_GetCvarValue.fromObject = function fromObject(object) {
            if (object instanceof $root.CSVCMsg_GetCvarValue)
                return object;
            var message = new $root.CSVCMsg_GetCvarValue();
            if (object.cookie != null)
                message.cookie = object.cookie | 0;
            if (object.cvarName != null)
                message.cvarName = String(object.cvarName);
            return message;
        };
    
        /**
         * Creates a plain object from a CSVCMsg_GetCvarValue message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CSVCMsg_GetCvarValue
         * @static
         * @param {CSVCMsg_GetCvarValue} message CSVCMsg_GetCvarValue
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CSVCMsg_GetCvarValue.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.cookie = 0;
                object.cvarName = "";
            }
            if (message.cookie != null && message.hasOwnProperty("cookie"))
                object.cookie = message.cookie;
            if (message.cvarName != null && message.hasOwnProperty("cvarName"))
                object.cvarName = message.cvarName;
            return object;
        };
    
        /**
         * Converts this CSVCMsg_GetCvarValue to JSON.
         * @function toJSON
         * @memberof CSVCMsg_GetCvarValue
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CSVCMsg_GetCvarValue.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * Gets the default type url for CSVCMsg_GetCvarValue
         * @function getTypeUrl
         * @memberof CSVCMsg_GetCvarValue
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        CSVCMsg_GetCvarValue.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/CSVCMsg_GetCvarValue";
        };
    
        return CSVCMsg_GetCvarValue;
    })();
    
    $root.CSVCMsg_Menu = (function() {
    
        /**
         * Properties of a CSVCMsg_Menu.
         * @exports ICSVCMsg_Menu
         * @interface ICSVCMsg_Menu
         * @property {number|null} [dialogType] CSVCMsg_Menu dialogType
         * @property {Uint8Array|null} [menuKeyValues] CSVCMsg_Menu menuKeyValues
         */
    
        /**
         * Constructs a new CSVCMsg_Menu.
         * @exports CSVCMsg_Menu
         * @classdesc Represents a CSVCMsg_Menu.
         * @implements ICSVCMsg_Menu
         * @constructor
         * @param {ICSVCMsg_Menu=} [properties] Properties to set
         */
        function CSVCMsg_Menu(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CSVCMsg_Menu dialogType.
         * @member {number} dialogType
         * @memberof CSVCMsg_Menu
         * @instance
         */
        CSVCMsg_Menu.prototype.dialogType = 0;
    
        /**
         * CSVCMsg_Menu menuKeyValues.
         * @member {Uint8Array} menuKeyValues
         * @memberof CSVCMsg_Menu
         * @instance
         */
        CSVCMsg_Menu.prototype.menuKeyValues = $util.newBuffer([]);
    
        /**
         * Creates a new CSVCMsg_Menu instance using the specified properties.
         * @function create
         * @memberof CSVCMsg_Menu
         * @static
         * @param {ICSVCMsg_Menu=} [properties] Properties to set
         * @returns {CSVCMsg_Menu} CSVCMsg_Menu instance
         */
        CSVCMsg_Menu.create = function create(properties) {
            return new CSVCMsg_Menu(properties);
        };
    
        /**
         * Encodes the specified CSVCMsg_Menu message. Does not implicitly {@link CSVCMsg_Menu.verify|verify} messages.
         * @function encode
         * @memberof CSVCMsg_Menu
         * @static
         * @param {ICSVCMsg_Menu} message CSVCMsg_Menu message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CSVCMsg_Menu.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.dialogType != null && Object.hasOwnProperty.call(message, "dialogType"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.dialogType);
            if (message.menuKeyValues != null && Object.hasOwnProperty.call(message, "menuKeyValues"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.menuKeyValues);
            return writer;
        };
    
        /**
         * Encodes the specified CSVCMsg_Menu message, length delimited. Does not implicitly {@link CSVCMsg_Menu.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CSVCMsg_Menu
         * @static
         * @param {ICSVCMsg_Menu} message CSVCMsg_Menu message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CSVCMsg_Menu.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CSVCMsg_Menu message from the specified reader or buffer.
         * @function decode
         * @memberof CSVCMsg_Menu
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CSVCMsg_Menu} CSVCMsg_Menu
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CSVCMsg_Menu.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CSVCMsg_Menu();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.dialogType = reader.int32();
                        break;
                    }
                case 2: {
                        message.menuKeyValues = reader.bytes();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CSVCMsg_Menu message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CSVCMsg_Menu
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CSVCMsg_Menu} CSVCMsg_Menu
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CSVCMsg_Menu.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CSVCMsg_Menu message.
         * @function verify
         * @memberof CSVCMsg_Menu
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CSVCMsg_Menu.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.dialogType != null && message.hasOwnProperty("dialogType"))
                if (!$util.isInteger(message.dialogType))
                    return "dialogType: integer expected";
            if (message.menuKeyValues != null && message.hasOwnProperty("menuKeyValues"))
                if (!(message.menuKeyValues && typeof message.menuKeyValues.length === "number" || $util.isString(message.menuKeyValues)))
                    return "menuKeyValues: buffer expected";
            return null;
        };
    
        /**
         * Creates a CSVCMsg_Menu message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CSVCMsg_Menu
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CSVCMsg_Menu} CSVCMsg_Menu
         */
        CSVCMsg_Menu.fromObject = function fromObject(object) {
            if (object instanceof $root.CSVCMsg_Menu)
                return object;
            var message = new $root.CSVCMsg_Menu();
            if (object.dialogType != null)
                message.dialogType = object.dialogType | 0;
            if (object.menuKeyValues != null)
                if (typeof object.menuKeyValues === "string")
                    $util.base64.decode(object.menuKeyValues, message.menuKeyValues = $util.newBuffer($util.base64.length(object.menuKeyValues)), 0);
                else if (object.menuKeyValues.length >= 0)
                    message.menuKeyValues = object.menuKeyValues;
            return message;
        };
    
        /**
         * Creates a plain object from a CSVCMsg_Menu message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CSVCMsg_Menu
         * @static
         * @param {CSVCMsg_Menu} message CSVCMsg_Menu
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CSVCMsg_Menu.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.dialogType = 0;
                if (options.bytes === String)
                    object.menuKeyValues = "";
                else {
                    object.menuKeyValues = [];
                    if (options.bytes !== Array)
                        object.menuKeyValues = $util.newBuffer(object.menuKeyValues);
                }
            }
            if (message.dialogType != null && message.hasOwnProperty("dialogType"))
                object.dialogType = message.dialogType;
            if (message.menuKeyValues != null && message.hasOwnProperty("menuKeyValues"))
                object.menuKeyValues = options.bytes === String ? $util.base64.encode(message.menuKeyValues, 0, message.menuKeyValues.length) : options.bytes === Array ? Array.prototype.slice.call(message.menuKeyValues) : message.menuKeyValues;
            return object;
        };
    
        /**
         * Converts this CSVCMsg_Menu to JSON.
         * @function toJSON
         * @memberof CSVCMsg_Menu
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CSVCMsg_Menu.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * Gets the default type url for CSVCMsg_Menu
         * @function getTypeUrl
         * @memberof CSVCMsg_Menu
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        CSVCMsg_Menu.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/CSVCMsg_Menu";
        };
    
        return CSVCMsg_Menu;
    })();
    
    $root.CSVCMsg_UserMessage = (function() {
    
        /**
         * Properties of a CSVCMsg_UserMessage.
         * @exports ICSVCMsg_UserMessage
         * @interface ICSVCMsg_UserMessage
         * @property {number|null} [msgType] CSVCMsg_UserMessage msgType
         * @property {Uint8Array|null} [msgData] CSVCMsg_UserMessage msgData
         * @property {number|null} [passthrough] CSVCMsg_UserMessage passthrough
         */
    
        /**
         * Constructs a new CSVCMsg_UserMessage.
         * @exports CSVCMsg_UserMessage
         * @classdesc Represents a CSVCMsg_UserMessage.
         * @implements ICSVCMsg_UserMessage
         * @constructor
         * @param {ICSVCMsg_UserMessage=} [properties] Properties to set
         */
        function CSVCMsg_UserMessage(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CSVCMsg_UserMessage msgType.
         * @member {number} msgType
         * @memberof CSVCMsg_UserMessage
         * @instance
         */
        CSVCMsg_UserMessage.prototype.msgType = 0;
    
        /**
         * CSVCMsg_UserMessage msgData.
         * @member {Uint8Array} msgData
         * @memberof CSVCMsg_UserMessage
         * @instance
         */
        CSVCMsg_UserMessage.prototype.msgData = $util.newBuffer([]);
    
        /**
         * CSVCMsg_UserMessage passthrough.
         * @member {number} passthrough
         * @memberof CSVCMsg_UserMessage
         * @instance
         */
        CSVCMsg_UserMessage.prototype.passthrough = 0;
    
        /**
         * Creates a new CSVCMsg_UserMessage instance using the specified properties.
         * @function create
         * @memberof CSVCMsg_UserMessage
         * @static
         * @param {ICSVCMsg_UserMessage=} [properties] Properties to set
         * @returns {CSVCMsg_UserMessage} CSVCMsg_UserMessage instance
         */
        CSVCMsg_UserMessage.create = function create(properties) {
            return new CSVCMsg_UserMessage(properties);
        };
    
        /**
         * Encodes the specified CSVCMsg_UserMessage message. Does not implicitly {@link CSVCMsg_UserMessage.verify|verify} messages.
         * @function encode
         * @memberof CSVCMsg_UserMessage
         * @static
         * @param {ICSVCMsg_UserMessage} message CSVCMsg_UserMessage message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CSVCMsg_UserMessage.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.msgType != null && Object.hasOwnProperty.call(message, "msgType"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.msgType);
            if (message.msgData != null && Object.hasOwnProperty.call(message, "msgData"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.msgData);
            if (message.passthrough != null && Object.hasOwnProperty.call(message, "passthrough"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.passthrough);
            return writer;
        };
    
        /**
         * Encodes the specified CSVCMsg_UserMessage message, length delimited. Does not implicitly {@link CSVCMsg_UserMessage.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CSVCMsg_UserMessage
         * @static
         * @param {ICSVCMsg_UserMessage} message CSVCMsg_UserMessage message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CSVCMsg_UserMessage.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CSVCMsg_UserMessage message from the specified reader or buffer.
         * @function decode
         * @memberof CSVCMsg_UserMessage
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CSVCMsg_UserMessage} CSVCMsg_UserMessage
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CSVCMsg_UserMessage.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CSVCMsg_UserMessage();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.msgType = reader.int32();
                        break;
                    }
                case 2: {
                        message.msgData = reader.bytes();
                        break;
                    }
                case 3: {
                        message.passthrough = reader.int32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CSVCMsg_UserMessage message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CSVCMsg_UserMessage
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CSVCMsg_UserMessage} CSVCMsg_UserMessage
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CSVCMsg_UserMessage.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CSVCMsg_UserMessage message.
         * @function verify
         * @memberof CSVCMsg_UserMessage
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CSVCMsg_UserMessage.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.msgType != null && message.hasOwnProperty("msgType"))
                if (!$util.isInteger(message.msgType))
                    return "msgType: integer expected";
            if (message.msgData != null && message.hasOwnProperty("msgData"))
                if (!(message.msgData && typeof message.msgData.length === "number" || $util.isString(message.msgData)))
                    return "msgData: buffer expected";
            if (message.passthrough != null && message.hasOwnProperty("passthrough"))
                if (!$util.isInteger(message.passthrough))
                    return "passthrough: integer expected";
            return null;
        };
    
        /**
         * Creates a CSVCMsg_UserMessage message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CSVCMsg_UserMessage
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CSVCMsg_UserMessage} CSVCMsg_UserMessage
         */
        CSVCMsg_UserMessage.fromObject = function fromObject(object) {
            if (object instanceof $root.CSVCMsg_UserMessage)
                return object;
            var message = new $root.CSVCMsg_UserMessage();
            if (object.msgType != null)
                message.msgType = object.msgType | 0;
            if (object.msgData != null)
                if (typeof object.msgData === "string")
                    $util.base64.decode(object.msgData, message.msgData = $util.newBuffer($util.base64.length(object.msgData)), 0);
                else if (object.msgData.length >= 0)
                    message.msgData = object.msgData;
            if (object.passthrough != null)
                message.passthrough = object.passthrough | 0;
            return message;
        };
    
        /**
         * Creates a plain object from a CSVCMsg_UserMessage message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CSVCMsg_UserMessage
         * @static
         * @param {CSVCMsg_UserMessage} message CSVCMsg_UserMessage
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CSVCMsg_UserMessage.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.msgType = 0;
                if (options.bytes === String)
                    object.msgData = "";
                else {
                    object.msgData = [];
                    if (options.bytes !== Array)
                        object.msgData = $util.newBuffer(object.msgData);
                }
                object.passthrough = 0;
            }
            if (message.msgType != null && message.hasOwnProperty("msgType"))
                object.msgType = message.msgType;
            if (message.msgData != null && message.hasOwnProperty("msgData"))
                object.msgData = options.bytes === String ? $util.base64.encode(message.msgData, 0, message.msgData.length) : options.bytes === Array ? Array.prototype.slice.call(message.msgData) : message.msgData;
            if (message.passthrough != null && message.hasOwnProperty("passthrough"))
                object.passthrough = message.passthrough;
            return object;
        };
    
        /**
         * Converts this CSVCMsg_UserMessage to JSON.
         * @function toJSON
         * @memberof CSVCMsg_UserMessage
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CSVCMsg_UserMessage.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * Gets the default type url for CSVCMsg_UserMessage
         * @function getTypeUrl
         * @memberof CSVCMsg_UserMessage
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        CSVCMsg_UserMessage.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/CSVCMsg_UserMessage";
        };
    
        return CSVCMsg_UserMessage;
    })();
    
    $root.CSVCMsg_SendTable = (function() {
    
        /**
         * Properties of a CSVCMsg_SendTable.
         * @exports ICSVCMsg_SendTable
         * @interface ICSVCMsg_SendTable
         * @property {boolean|null} [isEnd] CSVCMsg_SendTable isEnd
         * @property {string|null} [netTableName] CSVCMsg_SendTable netTableName
         * @property {boolean|null} [needsDecoder] CSVCMsg_SendTable needsDecoder
         * @property {Array.<CSVCMsg_SendTable.Isendprop_t>|null} [props] CSVCMsg_SendTable props
         */
    
        /**
         * Constructs a new CSVCMsg_SendTable.
         * @exports CSVCMsg_SendTable
         * @classdesc Represents a CSVCMsg_SendTable.
         * @implements ICSVCMsg_SendTable
         * @constructor
         * @param {ICSVCMsg_SendTable=} [properties] Properties to set
         */
        function CSVCMsg_SendTable(properties) {
            this.props = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CSVCMsg_SendTable isEnd.
         * @member {boolean} isEnd
         * @memberof CSVCMsg_SendTable
         * @instance
         */
        CSVCMsg_SendTable.prototype.isEnd = false;
    
        /**
         * CSVCMsg_SendTable netTableName.
         * @member {string} netTableName
         * @memberof CSVCMsg_SendTable
         * @instance
         */
        CSVCMsg_SendTable.prototype.netTableName = "";
    
        /**
         * CSVCMsg_SendTable needsDecoder.
         * @member {boolean} needsDecoder
         * @memberof CSVCMsg_SendTable
         * @instance
         */
        CSVCMsg_SendTable.prototype.needsDecoder = false;
    
        /**
         * CSVCMsg_SendTable props.
         * @member {Array.<CSVCMsg_SendTable.Isendprop_t>} props
         * @memberof CSVCMsg_SendTable
         * @instance
         */
        CSVCMsg_SendTable.prototype.props = $util.emptyArray;
    
        /**
         * Creates a new CSVCMsg_SendTable instance using the specified properties.
         * @function create
         * @memberof CSVCMsg_SendTable
         * @static
         * @param {ICSVCMsg_SendTable=} [properties] Properties to set
         * @returns {CSVCMsg_SendTable} CSVCMsg_SendTable instance
         */
        CSVCMsg_SendTable.create = function create(properties) {
            return new CSVCMsg_SendTable(properties);
        };
    
        /**
         * Encodes the specified CSVCMsg_SendTable message. Does not implicitly {@link CSVCMsg_SendTable.verify|verify} messages.
         * @function encode
         * @memberof CSVCMsg_SendTable
         * @static
         * @param {ICSVCMsg_SendTable} message CSVCMsg_SendTable message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CSVCMsg_SendTable.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.isEnd != null && Object.hasOwnProperty.call(message, "isEnd"))
                writer.uint32(/* id 1, wireType 0 =*/8).bool(message.isEnd);
            if (message.netTableName != null && Object.hasOwnProperty.call(message, "netTableName"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.netTableName);
            if (message.needsDecoder != null && Object.hasOwnProperty.call(message, "needsDecoder"))
                writer.uint32(/* id 3, wireType 0 =*/24).bool(message.needsDecoder);
            if (message.props != null && message.props.length)
                for (var i = 0; i < message.props.length; ++i)
                    $root.CSVCMsg_SendTable.sendprop_t.encode(message.props[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            return writer;
        };
    
        /**
         * Encodes the specified CSVCMsg_SendTable message, length delimited. Does not implicitly {@link CSVCMsg_SendTable.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CSVCMsg_SendTable
         * @static
         * @param {ICSVCMsg_SendTable} message CSVCMsg_SendTable message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CSVCMsg_SendTable.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CSVCMsg_SendTable message from the specified reader or buffer.
         * @function decode
         * @memberof CSVCMsg_SendTable
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CSVCMsg_SendTable} CSVCMsg_SendTable
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CSVCMsg_SendTable.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CSVCMsg_SendTable();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.isEnd = reader.bool();
                        break;
                    }
                case 2: {
                        message.netTableName = reader.string();
                        break;
                    }
                case 3: {
                        message.needsDecoder = reader.bool();
                        break;
                    }
                case 4: {
                        if (!(message.props && message.props.length))
                            message.props = [];
                        message.props.push($root.CSVCMsg_SendTable.sendprop_t.decode(reader, reader.uint32()));
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CSVCMsg_SendTable message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CSVCMsg_SendTable
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CSVCMsg_SendTable} CSVCMsg_SendTable
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CSVCMsg_SendTable.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CSVCMsg_SendTable message.
         * @function verify
         * @memberof CSVCMsg_SendTable
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CSVCMsg_SendTable.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.isEnd != null && message.hasOwnProperty("isEnd"))
                if (typeof message.isEnd !== "boolean")
                    return "isEnd: boolean expected";
            if (message.netTableName != null && message.hasOwnProperty("netTableName"))
                if (!$util.isString(message.netTableName))
                    return "netTableName: string expected";
            if (message.needsDecoder != null && message.hasOwnProperty("needsDecoder"))
                if (typeof message.needsDecoder !== "boolean")
                    return "needsDecoder: boolean expected";
            if (message.props != null && message.hasOwnProperty("props")) {
                if (!Array.isArray(message.props))
                    return "props: array expected";
                for (var i = 0; i < message.props.length; ++i) {
                    var error = $root.CSVCMsg_SendTable.sendprop_t.verify(message.props[i]);
                    if (error)
                        return "props." + error;
                }
            }
            return null;
        };
    
        /**
         * Creates a CSVCMsg_SendTable message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CSVCMsg_SendTable
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CSVCMsg_SendTable} CSVCMsg_SendTable
         */
        CSVCMsg_SendTable.fromObject = function fromObject(object) {
            if (object instanceof $root.CSVCMsg_SendTable)
                return object;
            var message = new $root.CSVCMsg_SendTable();
            if (object.isEnd != null)
                message.isEnd = Boolean(object.isEnd);
            if (object.netTableName != null)
                message.netTableName = String(object.netTableName);
            if (object.needsDecoder != null)
                message.needsDecoder = Boolean(object.needsDecoder);
            if (object.props) {
                if (!Array.isArray(object.props))
                    throw TypeError(".CSVCMsg_SendTable.props: array expected");
                message.props = [];
                for (var i = 0; i < object.props.length; ++i) {
                    if (typeof object.props[i] !== "object")
                        throw TypeError(".CSVCMsg_SendTable.props: object expected");
                    message.props[i] = $root.CSVCMsg_SendTable.sendprop_t.fromObject(object.props[i]);
                }
            }
            return message;
        };
    
        /**
         * Creates a plain object from a CSVCMsg_SendTable message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CSVCMsg_SendTable
         * @static
         * @param {CSVCMsg_SendTable} message CSVCMsg_SendTable
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CSVCMsg_SendTable.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.props = [];
            if (options.defaults) {
                object.isEnd = false;
                object.netTableName = "";
                object.needsDecoder = false;
            }
            if (message.isEnd != null && message.hasOwnProperty("isEnd"))
                object.isEnd = message.isEnd;
            if (message.netTableName != null && message.hasOwnProperty("netTableName"))
                object.netTableName = message.netTableName;
            if (message.needsDecoder != null && message.hasOwnProperty("needsDecoder"))
                object.needsDecoder = message.needsDecoder;
            if (message.props && message.props.length) {
                object.props = [];
                for (var j = 0; j < message.props.length; ++j)
                    object.props[j] = $root.CSVCMsg_SendTable.sendprop_t.toObject(message.props[j], options);
            }
            return object;
        };
    
        /**
         * Converts this CSVCMsg_SendTable to JSON.
         * @function toJSON
         * @memberof CSVCMsg_SendTable
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CSVCMsg_SendTable.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * Gets the default type url for CSVCMsg_SendTable
         * @function getTypeUrl
         * @memberof CSVCMsg_SendTable
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        CSVCMsg_SendTable.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/CSVCMsg_SendTable";
        };
    
        CSVCMsg_SendTable.sendprop_t = (function() {
    
            /**
             * Properties of a sendprop_t.
             * @memberof CSVCMsg_SendTable
             * @interface Isendprop_t
             * @property {number|null} [type] sendprop_t type
             * @property {string|null} [varName] sendprop_t varName
             * @property {number|null} [flags] sendprop_t flags
             * @property {number|null} [priority] sendprop_t priority
             * @property {string|null} [dtName] sendprop_t dtName
             * @property {number|null} [numElements] sendprop_t numElements
             * @property {number|null} [lowValue] sendprop_t lowValue
             * @property {number|null} [highValue] sendprop_t highValue
             * @property {number|null} [numBits] sendprop_t numBits
             */
    
            /**
             * Constructs a new sendprop_t.
             * @memberof CSVCMsg_SendTable
             * @classdesc Represents a sendprop_t.
             * @implements Isendprop_t
             * @constructor
             * @param {CSVCMsg_SendTable.Isendprop_t=} [properties] Properties to set
             */
            function sendprop_t(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * sendprop_t type.
             * @member {number} type
             * @memberof CSVCMsg_SendTable.sendprop_t
             * @instance
             */
            sendprop_t.prototype.type = 0;
    
            /**
             * sendprop_t varName.
             * @member {string} varName
             * @memberof CSVCMsg_SendTable.sendprop_t
             * @instance
             */
            sendprop_t.prototype.varName = "";
    
            /**
             * sendprop_t flags.
             * @member {number} flags
             * @memberof CSVCMsg_SendTable.sendprop_t
             * @instance
             */
            sendprop_t.prototype.flags = 0;
    
            /**
             * sendprop_t priority.
             * @member {number} priority
             * @memberof CSVCMsg_SendTable.sendprop_t
             * @instance
             */
            sendprop_t.prototype.priority = 0;
    
            /**
             * sendprop_t dtName.
             * @member {string} dtName
             * @memberof CSVCMsg_SendTable.sendprop_t
             * @instance
             */
            sendprop_t.prototype.dtName = "";
    
            /**
             * sendprop_t numElements.
             * @member {number} numElements
             * @memberof CSVCMsg_SendTable.sendprop_t
             * @instance
             */
            sendprop_t.prototype.numElements = 0;
    
            /**
             * sendprop_t lowValue.
             * @member {number} lowValue
             * @memberof CSVCMsg_SendTable.sendprop_t
             * @instance
             */
            sendprop_t.prototype.lowValue = 0;
    
            /**
             * sendprop_t highValue.
             * @member {number} highValue
             * @memberof CSVCMsg_SendTable.sendprop_t
             * @instance
             */
            sendprop_t.prototype.highValue = 0;
    
            /**
             * sendprop_t numBits.
             * @member {number} numBits
             * @memberof CSVCMsg_SendTable.sendprop_t
             * @instance
             */
            sendprop_t.prototype.numBits = 0;
    
            /**
             * Creates a new sendprop_t instance using the specified properties.
             * @function create
             * @memberof CSVCMsg_SendTable.sendprop_t
             * @static
             * @param {CSVCMsg_SendTable.Isendprop_t=} [properties] Properties to set
             * @returns {CSVCMsg_SendTable.sendprop_t} sendprop_t instance
             */
            sendprop_t.create = function create(properties) {
                return new sendprop_t(properties);
            };
    
            /**
             * Encodes the specified sendprop_t message. Does not implicitly {@link CSVCMsg_SendTable.sendprop_t.verify|verify} messages.
             * @function encode
             * @memberof CSVCMsg_SendTable.sendprop_t
             * @static
             * @param {CSVCMsg_SendTable.Isendprop_t} message sendprop_t message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            sendprop_t.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
                if (message.varName != null && Object.hasOwnProperty.call(message, "varName"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.varName);
                if (message.flags != null && Object.hasOwnProperty.call(message, "flags"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int32(message.flags);
                if (message.priority != null && Object.hasOwnProperty.call(message, "priority"))
                    writer.uint32(/* id 4, wireType 0 =*/32).int32(message.priority);
                if (message.dtName != null && Object.hasOwnProperty.call(message, "dtName"))
                    writer.uint32(/* id 5, wireType 2 =*/42).string(message.dtName);
                if (message.numElements != null && Object.hasOwnProperty.call(message, "numElements"))
                    writer.uint32(/* id 6, wireType 0 =*/48).int32(message.numElements);
                if (message.lowValue != null && Object.hasOwnProperty.call(message, "lowValue"))
                    writer.uint32(/* id 7, wireType 5 =*/61).float(message.lowValue);
                if (message.highValue != null && Object.hasOwnProperty.call(message, "highValue"))
                    writer.uint32(/* id 8, wireType 5 =*/69).float(message.highValue);
                if (message.numBits != null && Object.hasOwnProperty.call(message, "numBits"))
                    writer.uint32(/* id 9, wireType 0 =*/72).int32(message.numBits);
                return writer;
            };
    
            /**
             * Encodes the specified sendprop_t message, length delimited. Does not implicitly {@link CSVCMsg_SendTable.sendprop_t.verify|verify} messages.
             * @function encodeDelimited
             * @memberof CSVCMsg_SendTable.sendprop_t
             * @static
             * @param {CSVCMsg_SendTable.Isendprop_t} message sendprop_t message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            sendprop_t.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a sendprop_t message from the specified reader or buffer.
             * @function decode
             * @memberof CSVCMsg_SendTable.sendprop_t
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {CSVCMsg_SendTable.sendprop_t} sendprop_t
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            sendprop_t.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CSVCMsg_SendTable.sendprop_t();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.type = reader.int32();
                            break;
                        }
                    case 2: {
                            message.varName = reader.string();
                            break;
                        }
                    case 3: {
                            message.flags = reader.int32();
                            break;
                        }
                    case 4: {
                            message.priority = reader.int32();
                            break;
                        }
                    case 5: {
                            message.dtName = reader.string();
                            break;
                        }
                    case 6: {
                            message.numElements = reader.int32();
                            break;
                        }
                    case 7: {
                            message.lowValue = reader.float();
                            break;
                        }
                    case 8: {
                            message.highValue = reader.float();
                            break;
                        }
                    case 9: {
                            message.numBits = reader.int32();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a sendprop_t message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof CSVCMsg_SendTable.sendprop_t
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {CSVCMsg_SendTable.sendprop_t} sendprop_t
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            sendprop_t.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a sendprop_t message.
             * @function verify
             * @memberof CSVCMsg_SendTable.sendprop_t
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            sendprop_t.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.type != null && message.hasOwnProperty("type"))
                    if (!$util.isInteger(message.type))
                        return "type: integer expected";
                if (message.varName != null && message.hasOwnProperty("varName"))
                    if (!$util.isString(message.varName))
                        return "varName: string expected";
                if (message.flags != null && message.hasOwnProperty("flags"))
                    if (!$util.isInteger(message.flags))
                        return "flags: integer expected";
                if (message.priority != null && message.hasOwnProperty("priority"))
                    if (!$util.isInteger(message.priority))
                        return "priority: integer expected";
                if (message.dtName != null && message.hasOwnProperty("dtName"))
                    if (!$util.isString(message.dtName))
                        return "dtName: string expected";
                if (message.numElements != null && message.hasOwnProperty("numElements"))
                    if (!$util.isInteger(message.numElements))
                        return "numElements: integer expected";
                if (message.lowValue != null && message.hasOwnProperty("lowValue"))
                    if (typeof message.lowValue !== "number")
                        return "lowValue: number expected";
                if (message.highValue != null && message.hasOwnProperty("highValue"))
                    if (typeof message.highValue !== "number")
                        return "highValue: number expected";
                if (message.numBits != null && message.hasOwnProperty("numBits"))
                    if (!$util.isInteger(message.numBits))
                        return "numBits: integer expected";
                return null;
            };
    
            /**
             * Creates a sendprop_t message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof CSVCMsg_SendTable.sendprop_t
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {CSVCMsg_SendTable.sendprop_t} sendprop_t
             */
            sendprop_t.fromObject = function fromObject(object) {
                if (object instanceof $root.CSVCMsg_SendTable.sendprop_t)
                    return object;
                var message = new $root.CSVCMsg_SendTable.sendprop_t();
                if (object.type != null)
                    message.type = object.type | 0;
                if (object.varName != null)
                    message.varName = String(object.varName);
                if (object.flags != null)
                    message.flags = object.flags | 0;
                if (object.priority != null)
                    message.priority = object.priority | 0;
                if (object.dtName != null)
                    message.dtName = String(object.dtName);
                if (object.numElements != null)
                    message.numElements = object.numElements | 0;
                if (object.lowValue != null)
                    message.lowValue = Number(object.lowValue);
                if (object.highValue != null)
                    message.highValue = Number(object.highValue);
                if (object.numBits != null)
                    message.numBits = object.numBits | 0;
                return message;
            };
    
            /**
             * Creates a plain object from a sendprop_t message. Also converts values to other types if specified.
             * @function toObject
             * @memberof CSVCMsg_SendTable.sendprop_t
             * @static
             * @param {CSVCMsg_SendTable.sendprop_t} message sendprop_t
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            sendprop_t.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.type = 0;
                    object.varName = "";
                    object.flags = 0;
                    object.priority = 0;
                    object.dtName = "";
                    object.numElements = 0;
                    object.lowValue = 0;
                    object.highValue = 0;
                    object.numBits = 0;
                }
                if (message.type != null && message.hasOwnProperty("type"))
                    object.type = message.type;
                if (message.varName != null && message.hasOwnProperty("varName"))
                    object.varName = message.varName;
                if (message.flags != null && message.hasOwnProperty("flags"))
                    object.flags = message.flags;
                if (message.priority != null && message.hasOwnProperty("priority"))
                    object.priority = message.priority;
                if (message.dtName != null && message.hasOwnProperty("dtName"))
                    object.dtName = message.dtName;
                if (message.numElements != null && message.hasOwnProperty("numElements"))
                    object.numElements = message.numElements;
                if (message.lowValue != null && message.hasOwnProperty("lowValue"))
                    object.lowValue = options.json && !isFinite(message.lowValue) ? String(message.lowValue) : message.lowValue;
                if (message.highValue != null && message.hasOwnProperty("highValue"))
                    object.highValue = options.json && !isFinite(message.highValue) ? String(message.highValue) : message.highValue;
                if (message.numBits != null && message.hasOwnProperty("numBits"))
                    object.numBits = message.numBits;
                return object;
            };
    
            /**
             * Converts this sendprop_t to JSON.
             * @function toJSON
             * @memberof CSVCMsg_SendTable.sendprop_t
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            sendprop_t.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            /**
             * Gets the default type url for sendprop_t
             * @function getTypeUrl
             * @memberof CSVCMsg_SendTable.sendprop_t
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            sendprop_t.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/CSVCMsg_SendTable.sendprop_t";
            };
    
            return sendprop_t;
        })();
    
        return CSVCMsg_SendTable;
    })();
    
    $root.CSVCMsg_GameEventList = (function() {
    
        /**
         * Properties of a CSVCMsg_GameEventList.
         * @exports ICSVCMsg_GameEventList
         * @interface ICSVCMsg_GameEventList
         * @property {Array.<CSVCMsg_GameEventList.Idescriptor_t>|null} [descriptors] CSVCMsg_GameEventList descriptors
         */
    
        /**
         * Constructs a new CSVCMsg_GameEventList.
         * @exports CSVCMsg_GameEventList
         * @classdesc Represents a CSVCMsg_GameEventList.
         * @implements ICSVCMsg_GameEventList
         * @constructor
         * @param {ICSVCMsg_GameEventList=} [properties] Properties to set
         */
        function CSVCMsg_GameEventList(properties) {
            this.descriptors = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CSVCMsg_GameEventList descriptors.
         * @member {Array.<CSVCMsg_GameEventList.Idescriptor_t>} descriptors
         * @memberof CSVCMsg_GameEventList
         * @instance
         */
        CSVCMsg_GameEventList.prototype.descriptors = $util.emptyArray;
    
        /**
         * Creates a new CSVCMsg_GameEventList instance using the specified properties.
         * @function create
         * @memberof CSVCMsg_GameEventList
         * @static
         * @param {ICSVCMsg_GameEventList=} [properties] Properties to set
         * @returns {CSVCMsg_GameEventList} CSVCMsg_GameEventList instance
         */
        CSVCMsg_GameEventList.create = function create(properties) {
            return new CSVCMsg_GameEventList(properties);
        };
    
        /**
         * Encodes the specified CSVCMsg_GameEventList message. Does not implicitly {@link CSVCMsg_GameEventList.verify|verify} messages.
         * @function encode
         * @memberof CSVCMsg_GameEventList
         * @static
         * @param {ICSVCMsg_GameEventList} message CSVCMsg_GameEventList message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CSVCMsg_GameEventList.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.descriptors != null && message.descriptors.length)
                for (var i = 0; i < message.descriptors.length; ++i)
                    $root.CSVCMsg_GameEventList.descriptor_t.encode(message.descriptors[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };
    
        /**
         * Encodes the specified CSVCMsg_GameEventList message, length delimited. Does not implicitly {@link CSVCMsg_GameEventList.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CSVCMsg_GameEventList
         * @static
         * @param {ICSVCMsg_GameEventList} message CSVCMsg_GameEventList message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CSVCMsg_GameEventList.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CSVCMsg_GameEventList message from the specified reader or buffer.
         * @function decode
         * @memberof CSVCMsg_GameEventList
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CSVCMsg_GameEventList} CSVCMsg_GameEventList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CSVCMsg_GameEventList.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CSVCMsg_GameEventList();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        if (!(message.descriptors && message.descriptors.length))
                            message.descriptors = [];
                        message.descriptors.push($root.CSVCMsg_GameEventList.descriptor_t.decode(reader, reader.uint32()));
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CSVCMsg_GameEventList message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CSVCMsg_GameEventList
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CSVCMsg_GameEventList} CSVCMsg_GameEventList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CSVCMsg_GameEventList.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CSVCMsg_GameEventList message.
         * @function verify
         * @memberof CSVCMsg_GameEventList
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CSVCMsg_GameEventList.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.descriptors != null && message.hasOwnProperty("descriptors")) {
                if (!Array.isArray(message.descriptors))
                    return "descriptors: array expected";
                for (var i = 0; i < message.descriptors.length; ++i) {
                    var error = $root.CSVCMsg_GameEventList.descriptor_t.verify(message.descriptors[i]);
                    if (error)
                        return "descriptors." + error;
                }
            }
            return null;
        };
    
        /**
         * Creates a CSVCMsg_GameEventList message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CSVCMsg_GameEventList
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CSVCMsg_GameEventList} CSVCMsg_GameEventList
         */
        CSVCMsg_GameEventList.fromObject = function fromObject(object) {
            if (object instanceof $root.CSVCMsg_GameEventList)
                return object;
            var message = new $root.CSVCMsg_GameEventList();
            if (object.descriptors) {
                if (!Array.isArray(object.descriptors))
                    throw TypeError(".CSVCMsg_GameEventList.descriptors: array expected");
                message.descriptors = [];
                for (var i = 0; i < object.descriptors.length; ++i) {
                    if (typeof object.descriptors[i] !== "object")
                        throw TypeError(".CSVCMsg_GameEventList.descriptors: object expected");
                    message.descriptors[i] = $root.CSVCMsg_GameEventList.descriptor_t.fromObject(object.descriptors[i]);
                }
            }
            return message;
        };
    
        /**
         * Creates a plain object from a CSVCMsg_GameEventList message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CSVCMsg_GameEventList
         * @static
         * @param {CSVCMsg_GameEventList} message CSVCMsg_GameEventList
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CSVCMsg_GameEventList.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.descriptors = [];
            if (message.descriptors && message.descriptors.length) {
                object.descriptors = [];
                for (var j = 0; j < message.descriptors.length; ++j)
                    object.descriptors[j] = $root.CSVCMsg_GameEventList.descriptor_t.toObject(message.descriptors[j], options);
            }
            return object;
        };
    
        /**
         * Converts this CSVCMsg_GameEventList to JSON.
         * @function toJSON
         * @memberof CSVCMsg_GameEventList
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CSVCMsg_GameEventList.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * Gets the default type url for CSVCMsg_GameEventList
         * @function getTypeUrl
         * @memberof CSVCMsg_GameEventList
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        CSVCMsg_GameEventList.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/CSVCMsg_GameEventList";
        };
    
        CSVCMsg_GameEventList.key_t = (function() {
    
            /**
             * Properties of a key_t.
             * @memberof CSVCMsg_GameEventList
             * @interface Ikey_t
             * @property {number|null} [type] key_t type
             * @property {string|null} [name] key_t name
             */
    
            /**
             * Constructs a new key_t.
             * @memberof CSVCMsg_GameEventList
             * @classdesc Represents a key_t.
             * @implements Ikey_t
             * @constructor
             * @param {CSVCMsg_GameEventList.Ikey_t=} [properties] Properties to set
             */
            function key_t(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * key_t type.
             * @member {number} type
             * @memberof CSVCMsg_GameEventList.key_t
             * @instance
             */
            key_t.prototype.type = 0;
    
            /**
             * key_t name.
             * @member {string} name
             * @memberof CSVCMsg_GameEventList.key_t
             * @instance
             */
            key_t.prototype.name = "";
    
            /**
             * Creates a new key_t instance using the specified properties.
             * @function create
             * @memberof CSVCMsg_GameEventList.key_t
             * @static
             * @param {CSVCMsg_GameEventList.Ikey_t=} [properties] Properties to set
             * @returns {CSVCMsg_GameEventList.key_t} key_t instance
             */
            key_t.create = function create(properties) {
                return new key_t(properties);
            };
    
            /**
             * Encodes the specified key_t message. Does not implicitly {@link CSVCMsg_GameEventList.key_t.verify|verify} messages.
             * @function encode
             * @memberof CSVCMsg_GameEventList.key_t
             * @static
             * @param {CSVCMsg_GameEventList.Ikey_t} message key_t message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            key_t.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
                if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.name);
                return writer;
            };
    
            /**
             * Encodes the specified key_t message, length delimited. Does not implicitly {@link CSVCMsg_GameEventList.key_t.verify|verify} messages.
             * @function encodeDelimited
             * @memberof CSVCMsg_GameEventList.key_t
             * @static
             * @param {CSVCMsg_GameEventList.Ikey_t} message key_t message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            key_t.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a key_t message from the specified reader or buffer.
             * @function decode
             * @memberof CSVCMsg_GameEventList.key_t
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {CSVCMsg_GameEventList.key_t} key_t
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            key_t.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CSVCMsg_GameEventList.key_t();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.type = reader.int32();
                            break;
                        }
                    case 2: {
                            message.name = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a key_t message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof CSVCMsg_GameEventList.key_t
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {CSVCMsg_GameEventList.key_t} key_t
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            key_t.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a key_t message.
             * @function verify
             * @memberof CSVCMsg_GameEventList.key_t
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            key_t.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.type != null && message.hasOwnProperty("type"))
                    if (!$util.isInteger(message.type))
                        return "type: integer expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                return null;
            };
    
            /**
             * Creates a key_t message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof CSVCMsg_GameEventList.key_t
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {CSVCMsg_GameEventList.key_t} key_t
             */
            key_t.fromObject = function fromObject(object) {
                if (object instanceof $root.CSVCMsg_GameEventList.key_t)
                    return object;
                var message = new $root.CSVCMsg_GameEventList.key_t();
                if (object.type != null)
                    message.type = object.type | 0;
                if (object.name != null)
                    message.name = String(object.name);
                return message;
            };
    
            /**
             * Creates a plain object from a key_t message. Also converts values to other types if specified.
             * @function toObject
             * @memberof CSVCMsg_GameEventList.key_t
             * @static
             * @param {CSVCMsg_GameEventList.key_t} message key_t
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            key_t.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.type = 0;
                    object.name = "";
                }
                if (message.type != null && message.hasOwnProperty("type"))
                    object.type = message.type;
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                return object;
            };
    
            /**
             * Converts this key_t to JSON.
             * @function toJSON
             * @memberof CSVCMsg_GameEventList.key_t
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            key_t.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            /**
             * Gets the default type url for key_t
             * @function getTypeUrl
             * @memberof CSVCMsg_GameEventList.key_t
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            key_t.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/CSVCMsg_GameEventList.key_t";
            };
    
            return key_t;
        })();
    
        CSVCMsg_GameEventList.descriptor_t = (function() {
    
            /**
             * Properties of a descriptor_t.
             * @memberof CSVCMsg_GameEventList
             * @interface Idescriptor_t
             * @property {number|null} [eventid] descriptor_t eventid
             * @property {string|null} [name] descriptor_t name
             * @property {Array.<CSVCMsg_GameEventList.Ikey_t>|null} [keys] descriptor_t keys
             */
    
            /**
             * Constructs a new descriptor_t.
             * @memberof CSVCMsg_GameEventList
             * @classdesc Represents a descriptor_t.
             * @implements Idescriptor_t
             * @constructor
             * @param {CSVCMsg_GameEventList.Idescriptor_t=} [properties] Properties to set
             */
            function descriptor_t(properties) {
                this.keys = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * descriptor_t eventid.
             * @member {number} eventid
             * @memberof CSVCMsg_GameEventList.descriptor_t
             * @instance
             */
            descriptor_t.prototype.eventid = 0;
    
            /**
             * descriptor_t name.
             * @member {string} name
             * @memberof CSVCMsg_GameEventList.descriptor_t
             * @instance
             */
            descriptor_t.prototype.name = "";
    
            /**
             * descriptor_t keys.
             * @member {Array.<CSVCMsg_GameEventList.Ikey_t>} keys
             * @memberof CSVCMsg_GameEventList.descriptor_t
             * @instance
             */
            descriptor_t.prototype.keys = $util.emptyArray;
    
            /**
             * Creates a new descriptor_t instance using the specified properties.
             * @function create
             * @memberof CSVCMsg_GameEventList.descriptor_t
             * @static
             * @param {CSVCMsg_GameEventList.Idescriptor_t=} [properties] Properties to set
             * @returns {CSVCMsg_GameEventList.descriptor_t} descriptor_t instance
             */
            descriptor_t.create = function create(properties) {
                return new descriptor_t(properties);
            };
    
            /**
             * Encodes the specified descriptor_t message. Does not implicitly {@link CSVCMsg_GameEventList.descriptor_t.verify|verify} messages.
             * @function encode
             * @memberof CSVCMsg_GameEventList.descriptor_t
             * @static
             * @param {CSVCMsg_GameEventList.Idescriptor_t} message descriptor_t message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            descriptor_t.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.eventid != null && Object.hasOwnProperty.call(message, "eventid"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.eventid);
                if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.name);
                if (message.keys != null && message.keys.length)
                    for (var i = 0; i < message.keys.length; ++i)
                        $root.CSVCMsg_GameEventList.key_t.encode(message.keys[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                return writer;
            };
    
            /**
             * Encodes the specified descriptor_t message, length delimited. Does not implicitly {@link CSVCMsg_GameEventList.descriptor_t.verify|verify} messages.
             * @function encodeDelimited
             * @memberof CSVCMsg_GameEventList.descriptor_t
             * @static
             * @param {CSVCMsg_GameEventList.Idescriptor_t} message descriptor_t message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            descriptor_t.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a descriptor_t message from the specified reader or buffer.
             * @function decode
             * @memberof CSVCMsg_GameEventList.descriptor_t
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {CSVCMsg_GameEventList.descriptor_t} descriptor_t
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            descriptor_t.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CSVCMsg_GameEventList.descriptor_t();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.eventid = reader.int32();
                            break;
                        }
                    case 2: {
                            message.name = reader.string();
                            break;
                        }
                    case 3: {
                            if (!(message.keys && message.keys.length))
                                message.keys = [];
                            message.keys.push($root.CSVCMsg_GameEventList.key_t.decode(reader, reader.uint32()));
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a descriptor_t message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof CSVCMsg_GameEventList.descriptor_t
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {CSVCMsg_GameEventList.descriptor_t} descriptor_t
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            descriptor_t.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a descriptor_t message.
             * @function verify
             * @memberof CSVCMsg_GameEventList.descriptor_t
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            descriptor_t.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.eventid != null && message.hasOwnProperty("eventid"))
                    if (!$util.isInteger(message.eventid))
                        return "eventid: integer expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                if (message.keys != null && message.hasOwnProperty("keys")) {
                    if (!Array.isArray(message.keys))
                        return "keys: array expected";
                    for (var i = 0; i < message.keys.length; ++i) {
                        var error = $root.CSVCMsg_GameEventList.key_t.verify(message.keys[i]);
                        if (error)
                            return "keys." + error;
                    }
                }
                return null;
            };
    
            /**
             * Creates a descriptor_t message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof CSVCMsg_GameEventList.descriptor_t
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {CSVCMsg_GameEventList.descriptor_t} descriptor_t
             */
            descriptor_t.fromObject = function fromObject(object) {
                if (object instanceof $root.CSVCMsg_GameEventList.descriptor_t)
                    return object;
                var message = new $root.CSVCMsg_GameEventList.descriptor_t();
                if (object.eventid != null)
                    message.eventid = object.eventid | 0;
                if (object.name != null)
                    message.name = String(object.name);
                if (object.keys) {
                    if (!Array.isArray(object.keys))
                        throw TypeError(".CSVCMsg_GameEventList.descriptor_t.keys: array expected");
                    message.keys = [];
                    for (var i = 0; i < object.keys.length; ++i) {
                        if (typeof object.keys[i] !== "object")
                            throw TypeError(".CSVCMsg_GameEventList.descriptor_t.keys: object expected");
                        message.keys[i] = $root.CSVCMsg_GameEventList.key_t.fromObject(object.keys[i]);
                    }
                }
                return message;
            };
    
            /**
             * Creates a plain object from a descriptor_t message. Also converts values to other types if specified.
             * @function toObject
             * @memberof CSVCMsg_GameEventList.descriptor_t
             * @static
             * @param {CSVCMsg_GameEventList.descriptor_t} message descriptor_t
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            descriptor_t.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.keys = [];
                if (options.defaults) {
                    object.eventid = 0;
                    object.name = "";
                }
                if (message.eventid != null && message.hasOwnProperty("eventid"))
                    object.eventid = message.eventid;
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                if (message.keys && message.keys.length) {
                    object.keys = [];
                    for (var j = 0; j < message.keys.length; ++j)
                        object.keys[j] = $root.CSVCMsg_GameEventList.key_t.toObject(message.keys[j], options);
                }
                return object;
            };
    
            /**
             * Converts this descriptor_t to JSON.
             * @function toJSON
             * @memberof CSVCMsg_GameEventList.descriptor_t
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            descriptor_t.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            /**
             * Gets the default type url for descriptor_t
             * @function getTypeUrl
             * @memberof CSVCMsg_GameEventList.descriptor_t
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            descriptor_t.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/CSVCMsg_GameEventList.descriptor_t";
            };
    
            return descriptor_t;
        })();
    
        return CSVCMsg_GameEventList;
    })();
    
    $root.CSVCMsg_PacketEntities = (function() {
    
        /**
         * Properties of a CSVCMsg_PacketEntities.
         * @exports ICSVCMsg_PacketEntities
         * @interface ICSVCMsg_PacketEntities
         * @property {number|null} [maxEntries] CSVCMsg_PacketEntities maxEntries
         * @property {number|null} [updatedEntries] CSVCMsg_PacketEntities updatedEntries
         * @property {boolean|null} [isDelta] CSVCMsg_PacketEntities isDelta
         * @property {boolean|null} [updateBaseline] CSVCMsg_PacketEntities updateBaseline
         * @property {number|null} [baseline] CSVCMsg_PacketEntities baseline
         * @property {number|null} [deltaFrom] CSVCMsg_PacketEntities deltaFrom
         * @property {Uint8Array|null} [entityData] CSVCMsg_PacketEntities entityData
         * @property {boolean|null} [pendingFullFrame] CSVCMsg_PacketEntities pendingFullFrame
         * @property {number|null} [activeSpawngroupHandle] CSVCMsg_PacketEntities activeSpawngroupHandle
         * @property {number|null} [maxSpawngroupCreationsequence] CSVCMsg_PacketEntities maxSpawngroupCreationsequence
         * @property {number|null} [lastCmdNumber] CSVCMsg_PacketEntities lastCmdNumber
         * @property {number|null} [serverTick] CSVCMsg_PacketEntities serverTick
         * @property {Uint8Array|null} [serializedEntities] CSVCMsg_PacketEntities serializedEntities
         * @property {CSVCMsg_PacketEntities.Icommand_queue_info_t|null} [commandQueueInfo] CSVCMsg_PacketEntities commandQueueInfo
         * @property {Array.<CSVCMsg_PacketEntities.Ialternate_baseline_t>|null} [alternateBaselines] CSVCMsg_PacketEntities alternateBaselines
         */
    
        /**
         * Constructs a new CSVCMsg_PacketEntities.
         * @exports CSVCMsg_PacketEntities
         * @classdesc Represents a CSVCMsg_PacketEntities.
         * @implements ICSVCMsg_PacketEntities
         * @constructor
         * @param {ICSVCMsg_PacketEntities=} [properties] Properties to set
         */
        function CSVCMsg_PacketEntities(properties) {
            this.alternateBaselines = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CSVCMsg_PacketEntities maxEntries.
         * @member {number} maxEntries
         * @memberof CSVCMsg_PacketEntities
         * @instance
         */
        CSVCMsg_PacketEntities.prototype.maxEntries = 0;
    
        /**
         * CSVCMsg_PacketEntities updatedEntries.
         * @member {number} updatedEntries
         * @memberof CSVCMsg_PacketEntities
         * @instance
         */
        CSVCMsg_PacketEntities.prototype.updatedEntries = 0;
    
        /**
         * CSVCMsg_PacketEntities isDelta.
         * @member {boolean} isDelta
         * @memberof CSVCMsg_PacketEntities
         * @instance
         */
        CSVCMsg_PacketEntities.prototype.isDelta = false;
    
        /**
         * CSVCMsg_PacketEntities updateBaseline.
         * @member {boolean} updateBaseline
         * @memberof CSVCMsg_PacketEntities
         * @instance
         */
        CSVCMsg_PacketEntities.prototype.updateBaseline = false;
    
        /**
         * CSVCMsg_PacketEntities baseline.
         * @member {number} baseline
         * @memberof CSVCMsg_PacketEntities
         * @instance
         */
        CSVCMsg_PacketEntities.prototype.baseline = 0;
    
        /**
         * CSVCMsg_PacketEntities deltaFrom.
         * @member {number} deltaFrom
         * @memberof CSVCMsg_PacketEntities
         * @instance
         */
        CSVCMsg_PacketEntities.prototype.deltaFrom = 0;
    
        /**
         * CSVCMsg_PacketEntities entityData.
         * @member {Uint8Array} entityData
         * @memberof CSVCMsg_PacketEntities
         * @instance
         */
        CSVCMsg_PacketEntities.prototype.entityData = $util.newBuffer([]);
    
        /**
         * CSVCMsg_PacketEntities pendingFullFrame.
         * @member {boolean} pendingFullFrame
         * @memberof CSVCMsg_PacketEntities
         * @instance
         */
        CSVCMsg_PacketEntities.prototype.pendingFullFrame = false;
    
        /**
         * CSVCMsg_PacketEntities activeSpawngroupHandle.
         * @member {number} activeSpawngroupHandle
         * @memberof CSVCMsg_PacketEntities
         * @instance
         */
        CSVCMsg_PacketEntities.prototype.activeSpawngroupHandle = 0;
    
        /**
         * CSVCMsg_PacketEntities maxSpawngroupCreationsequence.
         * @member {number} maxSpawngroupCreationsequence
         * @memberof CSVCMsg_PacketEntities
         * @instance
         */
        CSVCMsg_PacketEntities.prototype.maxSpawngroupCreationsequence = 0;
    
        /**
         * CSVCMsg_PacketEntities lastCmdNumber.
         * @member {number} lastCmdNumber
         * @memberof CSVCMsg_PacketEntities
         * @instance
         */
        CSVCMsg_PacketEntities.prototype.lastCmdNumber = 0;
    
        /**
         * CSVCMsg_PacketEntities serverTick.
         * @member {number} serverTick
         * @memberof CSVCMsg_PacketEntities
         * @instance
         */
        CSVCMsg_PacketEntities.prototype.serverTick = 0;
    
        /**
         * CSVCMsg_PacketEntities serializedEntities.
         * @member {Uint8Array} serializedEntities
         * @memberof CSVCMsg_PacketEntities
         * @instance
         */
        CSVCMsg_PacketEntities.prototype.serializedEntities = $util.newBuffer([]);
    
        /**
         * CSVCMsg_PacketEntities commandQueueInfo.
         * @member {CSVCMsg_PacketEntities.Icommand_queue_info_t|null|undefined} commandQueueInfo
         * @memberof CSVCMsg_PacketEntities
         * @instance
         */
        CSVCMsg_PacketEntities.prototype.commandQueueInfo = null;
    
        /**
         * CSVCMsg_PacketEntities alternateBaselines.
         * @member {Array.<CSVCMsg_PacketEntities.Ialternate_baseline_t>} alternateBaselines
         * @memberof CSVCMsg_PacketEntities
         * @instance
         */
        CSVCMsg_PacketEntities.prototype.alternateBaselines = $util.emptyArray;
    
        /**
         * Creates a new CSVCMsg_PacketEntities instance using the specified properties.
         * @function create
         * @memberof CSVCMsg_PacketEntities
         * @static
         * @param {ICSVCMsg_PacketEntities=} [properties] Properties to set
         * @returns {CSVCMsg_PacketEntities} CSVCMsg_PacketEntities instance
         */
        CSVCMsg_PacketEntities.create = function create(properties) {
            return new CSVCMsg_PacketEntities(properties);
        };
    
        /**
         * Encodes the specified CSVCMsg_PacketEntities message. Does not implicitly {@link CSVCMsg_PacketEntities.verify|verify} messages.
         * @function encode
         * @memberof CSVCMsg_PacketEntities
         * @static
         * @param {ICSVCMsg_PacketEntities} message CSVCMsg_PacketEntities message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CSVCMsg_PacketEntities.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.maxEntries != null && Object.hasOwnProperty.call(message, "maxEntries"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.maxEntries);
            if (message.updatedEntries != null && Object.hasOwnProperty.call(message, "updatedEntries"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.updatedEntries);
            if (message.isDelta != null && Object.hasOwnProperty.call(message, "isDelta"))
                writer.uint32(/* id 3, wireType 0 =*/24).bool(message.isDelta);
            if (message.updateBaseline != null && Object.hasOwnProperty.call(message, "updateBaseline"))
                writer.uint32(/* id 4, wireType 0 =*/32).bool(message.updateBaseline);
            if (message.baseline != null && Object.hasOwnProperty.call(message, "baseline"))
                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.baseline);
            if (message.deltaFrom != null && Object.hasOwnProperty.call(message, "deltaFrom"))
                writer.uint32(/* id 6, wireType 0 =*/48).int32(message.deltaFrom);
            if (message.entityData != null && Object.hasOwnProperty.call(message, "entityData"))
                writer.uint32(/* id 7, wireType 2 =*/58).bytes(message.entityData);
            if (message.pendingFullFrame != null && Object.hasOwnProperty.call(message, "pendingFullFrame"))
                writer.uint32(/* id 8, wireType 0 =*/64).bool(message.pendingFullFrame);
            if (message.activeSpawngroupHandle != null && Object.hasOwnProperty.call(message, "activeSpawngroupHandle"))
                writer.uint32(/* id 9, wireType 0 =*/72).uint32(message.activeSpawngroupHandle);
            if (message.maxSpawngroupCreationsequence != null && Object.hasOwnProperty.call(message, "maxSpawngroupCreationsequence"))
                writer.uint32(/* id 10, wireType 0 =*/80).uint32(message.maxSpawngroupCreationsequence);
            if (message.lastCmdNumber != null && Object.hasOwnProperty.call(message, "lastCmdNumber"))
                writer.uint32(/* id 11, wireType 0 =*/88).uint32(message.lastCmdNumber);
            if (message.serverTick != null && Object.hasOwnProperty.call(message, "serverTick"))
                writer.uint32(/* id 12, wireType 0 =*/96).uint32(message.serverTick);
            if (message.serializedEntities != null && Object.hasOwnProperty.call(message, "serializedEntities"))
                writer.uint32(/* id 13, wireType 2 =*/106).bytes(message.serializedEntities);
            if (message.commandQueueInfo != null && Object.hasOwnProperty.call(message, "commandQueueInfo"))
                $root.CSVCMsg_PacketEntities.command_queue_info_t.encode(message.commandQueueInfo, writer.uint32(/* id 14, wireType 2 =*/114).fork()).ldelim();
            if (message.alternateBaselines != null && message.alternateBaselines.length)
                for (var i = 0; i < message.alternateBaselines.length; ++i)
                    $root.CSVCMsg_PacketEntities.alternate_baseline_t.encode(message.alternateBaselines[i], writer.uint32(/* id 15, wireType 2 =*/122).fork()).ldelim();
            return writer;
        };
    
        /**
         * Encodes the specified CSVCMsg_PacketEntities message, length delimited. Does not implicitly {@link CSVCMsg_PacketEntities.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CSVCMsg_PacketEntities
         * @static
         * @param {ICSVCMsg_PacketEntities} message CSVCMsg_PacketEntities message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CSVCMsg_PacketEntities.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CSVCMsg_PacketEntities message from the specified reader or buffer.
         * @function decode
         * @memberof CSVCMsg_PacketEntities
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CSVCMsg_PacketEntities} CSVCMsg_PacketEntities
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CSVCMsg_PacketEntities.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CSVCMsg_PacketEntities();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.maxEntries = reader.int32();
                        break;
                    }
                case 2: {
                        message.updatedEntries = reader.int32();
                        break;
                    }
                case 3: {
                        message.isDelta = reader.bool();
                        break;
                    }
                case 4: {
                        message.updateBaseline = reader.bool();
                        break;
                    }
                case 5: {
                        message.baseline = reader.int32();
                        break;
                    }
                case 6: {
                        message.deltaFrom = reader.int32();
                        break;
                    }
                case 7: {
                        message.entityData = reader.bytes();
                        break;
                    }
                case 8: {
                        message.pendingFullFrame = reader.bool();
                        break;
                    }
                case 9: {
                        message.activeSpawngroupHandle = reader.uint32();
                        break;
                    }
                case 10: {
                        message.maxSpawngroupCreationsequence = reader.uint32();
                        break;
                    }
                case 11: {
                        message.lastCmdNumber = reader.uint32();
                        break;
                    }
                case 12: {
                        message.serverTick = reader.uint32();
                        break;
                    }
                case 13: {
                        message.serializedEntities = reader.bytes();
                        break;
                    }
                case 14: {
                        message.commandQueueInfo = $root.CSVCMsg_PacketEntities.command_queue_info_t.decode(reader, reader.uint32());
                        break;
                    }
                case 15: {
                        if (!(message.alternateBaselines && message.alternateBaselines.length))
                            message.alternateBaselines = [];
                        message.alternateBaselines.push($root.CSVCMsg_PacketEntities.alternate_baseline_t.decode(reader, reader.uint32()));
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CSVCMsg_PacketEntities message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CSVCMsg_PacketEntities
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CSVCMsg_PacketEntities} CSVCMsg_PacketEntities
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CSVCMsg_PacketEntities.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CSVCMsg_PacketEntities message.
         * @function verify
         * @memberof CSVCMsg_PacketEntities
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CSVCMsg_PacketEntities.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.maxEntries != null && message.hasOwnProperty("maxEntries"))
                if (!$util.isInteger(message.maxEntries))
                    return "maxEntries: integer expected";
            if (message.updatedEntries != null && message.hasOwnProperty("updatedEntries"))
                if (!$util.isInteger(message.updatedEntries))
                    return "updatedEntries: integer expected";
            if (message.isDelta != null && message.hasOwnProperty("isDelta"))
                if (typeof message.isDelta !== "boolean")
                    return "isDelta: boolean expected";
            if (message.updateBaseline != null && message.hasOwnProperty("updateBaseline"))
                if (typeof message.updateBaseline !== "boolean")
                    return "updateBaseline: boolean expected";
            if (message.baseline != null && message.hasOwnProperty("baseline"))
                if (!$util.isInteger(message.baseline))
                    return "baseline: integer expected";
            if (message.deltaFrom != null && message.hasOwnProperty("deltaFrom"))
                if (!$util.isInteger(message.deltaFrom))
                    return "deltaFrom: integer expected";
            if (message.entityData != null && message.hasOwnProperty("entityData"))
                if (!(message.entityData && typeof message.entityData.length === "number" || $util.isString(message.entityData)))
                    return "entityData: buffer expected";
            if (message.pendingFullFrame != null && message.hasOwnProperty("pendingFullFrame"))
                if (typeof message.pendingFullFrame !== "boolean")
                    return "pendingFullFrame: boolean expected";
            if (message.activeSpawngroupHandle != null && message.hasOwnProperty("activeSpawngroupHandle"))
                if (!$util.isInteger(message.activeSpawngroupHandle))
                    return "activeSpawngroupHandle: integer expected";
            if (message.maxSpawngroupCreationsequence != null && message.hasOwnProperty("maxSpawngroupCreationsequence"))
                if (!$util.isInteger(message.maxSpawngroupCreationsequence))
                    return "maxSpawngroupCreationsequence: integer expected";
            if (message.lastCmdNumber != null && message.hasOwnProperty("lastCmdNumber"))
                if (!$util.isInteger(message.lastCmdNumber))
                    return "lastCmdNumber: integer expected";
            if (message.serverTick != null && message.hasOwnProperty("serverTick"))
                if (!$util.isInteger(message.serverTick))
                    return "serverTick: integer expected";
            if (message.serializedEntities != null && message.hasOwnProperty("serializedEntities"))
                if (!(message.serializedEntities && typeof message.serializedEntities.length === "number" || $util.isString(message.serializedEntities)))
                    return "serializedEntities: buffer expected";
            if (message.commandQueueInfo != null && message.hasOwnProperty("commandQueueInfo")) {
                var error = $root.CSVCMsg_PacketEntities.command_queue_info_t.verify(message.commandQueueInfo);
                if (error)
                    return "commandQueueInfo." + error;
            }
            if (message.alternateBaselines != null && message.hasOwnProperty("alternateBaselines")) {
                if (!Array.isArray(message.alternateBaselines))
                    return "alternateBaselines: array expected";
                for (var i = 0; i < message.alternateBaselines.length; ++i) {
                    var error = $root.CSVCMsg_PacketEntities.alternate_baseline_t.verify(message.alternateBaselines[i]);
                    if (error)
                        return "alternateBaselines." + error;
                }
            }
            return null;
        };
    
        /**
         * Creates a CSVCMsg_PacketEntities message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CSVCMsg_PacketEntities
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CSVCMsg_PacketEntities} CSVCMsg_PacketEntities
         */
        CSVCMsg_PacketEntities.fromObject = function fromObject(object) {
            if (object instanceof $root.CSVCMsg_PacketEntities)
                return object;
            var message = new $root.CSVCMsg_PacketEntities();
            if (object.maxEntries != null)
                message.maxEntries = object.maxEntries | 0;
            if (object.updatedEntries != null)
                message.updatedEntries = object.updatedEntries | 0;
            if (object.isDelta != null)
                message.isDelta = Boolean(object.isDelta);
            if (object.updateBaseline != null)
                message.updateBaseline = Boolean(object.updateBaseline);
            if (object.baseline != null)
                message.baseline = object.baseline | 0;
            if (object.deltaFrom != null)
                message.deltaFrom = object.deltaFrom | 0;
            if (object.entityData != null)
                if (typeof object.entityData === "string")
                    $util.base64.decode(object.entityData, message.entityData = $util.newBuffer($util.base64.length(object.entityData)), 0);
                else if (object.entityData.length >= 0)
                    message.entityData = object.entityData;
            if (object.pendingFullFrame != null)
                message.pendingFullFrame = Boolean(object.pendingFullFrame);
            if (object.activeSpawngroupHandle != null)
                message.activeSpawngroupHandle = object.activeSpawngroupHandle >>> 0;
            if (object.maxSpawngroupCreationsequence != null)
                message.maxSpawngroupCreationsequence = object.maxSpawngroupCreationsequence >>> 0;
            if (object.lastCmdNumber != null)
                message.lastCmdNumber = object.lastCmdNumber >>> 0;
            if (object.serverTick != null)
                message.serverTick = object.serverTick >>> 0;
            if (object.serializedEntities != null)
                if (typeof object.serializedEntities === "string")
                    $util.base64.decode(object.serializedEntities, message.serializedEntities = $util.newBuffer($util.base64.length(object.serializedEntities)), 0);
                else if (object.serializedEntities.length >= 0)
                    message.serializedEntities = object.serializedEntities;
            if (object.commandQueueInfo != null) {
                if (typeof object.commandQueueInfo !== "object")
                    throw TypeError(".CSVCMsg_PacketEntities.commandQueueInfo: object expected");
                message.commandQueueInfo = $root.CSVCMsg_PacketEntities.command_queue_info_t.fromObject(object.commandQueueInfo);
            }
            if (object.alternateBaselines) {
                if (!Array.isArray(object.alternateBaselines))
                    throw TypeError(".CSVCMsg_PacketEntities.alternateBaselines: array expected");
                message.alternateBaselines = [];
                for (var i = 0; i < object.alternateBaselines.length; ++i) {
                    if (typeof object.alternateBaselines[i] !== "object")
                        throw TypeError(".CSVCMsg_PacketEntities.alternateBaselines: object expected");
                    message.alternateBaselines[i] = $root.CSVCMsg_PacketEntities.alternate_baseline_t.fromObject(object.alternateBaselines[i]);
                }
            }
            return message;
        };
    
        /**
         * Creates a plain object from a CSVCMsg_PacketEntities message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CSVCMsg_PacketEntities
         * @static
         * @param {CSVCMsg_PacketEntities} message CSVCMsg_PacketEntities
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CSVCMsg_PacketEntities.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.alternateBaselines = [];
            if (options.defaults) {
                object.maxEntries = 0;
                object.updatedEntries = 0;
                object.isDelta = false;
                object.updateBaseline = false;
                object.baseline = 0;
                object.deltaFrom = 0;
                if (options.bytes === String)
                    object.entityData = "";
                else {
                    object.entityData = [];
                    if (options.bytes !== Array)
                        object.entityData = $util.newBuffer(object.entityData);
                }
                object.pendingFullFrame = false;
                object.activeSpawngroupHandle = 0;
                object.maxSpawngroupCreationsequence = 0;
                object.lastCmdNumber = 0;
                object.serverTick = 0;
                if (options.bytes === String)
                    object.serializedEntities = "";
                else {
                    object.serializedEntities = [];
                    if (options.bytes !== Array)
                        object.serializedEntities = $util.newBuffer(object.serializedEntities);
                }
                object.commandQueueInfo = null;
            }
            if (message.maxEntries != null && message.hasOwnProperty("maxEntries"))
                object.maxEntries = message.maxEntries;
            if (message.updatedEntries != null && message.hasOwnProperty("updatedEntries"))
                object.updatedEntries = message.updatedEntries;
            if (message.isDelta != null && message.hasOwnProperty("isDelta"))
                object.isDelta = message.isDelta;
            if (message.updateBaseline != null && message.hasOwnProperty("updateBaseline"))
                object.updateBaseline = message.updateBaseline;
            if (message.baseline != null && message.hasOwnProperty("baseline"))
                object.baseline = message.baseline;
            if (message.deltaFrom != null && message.hasOwnProperty("deltaFrom"))
                object.deltaFrom = message.deltaFrom;
            if (message.entityData != null && message.hasOwnProperty("entityData"))
                object.entityData = options.bytes === String ? $util.base64.encode(message.entityData, 0, message.entityData.length) : options.bytes === Array ? Array.prototype.slice.call(message.entityData) : message.entityData;
            if (message.pendingFullFrame != null && message.hasOwnProperty("pendingFullFrame"))
                object.pendingFullFrame = message.pendingFullFrame;
            if (message.activeSpawngroupHandle != null && message.hasOwnProperty("activeSpawngroupHandle"))
                object.activeSpawngroupHandle = message.activeSpawngroupHandle;
            if (message.maxSpawngroupCreationsequence != null && message.hasOwnProperty("maxSpawngroupCreationsequence"))
                object.maxSpawngroupCreationsequence = message.maxSpawngroupCreationsequence;
            if (message.lastCmdNumber != null && message.hasOwnProperty("lastCmdNumber"))
                object.lastCmdNumber = message.lastCmdNumber;
            if (message.serverTick != null && message.hasOwnProperty("serverTick"))
                object.serverTick = message.serverTick;
            if (message.serializedEntities != null && message.hasOwnProperty("serializedEntities"))
                object.serializedEntities = options.bytes === String ? $util.base64.encode(message.serializedEntities, 0, message.serializedEntities.length) : options.bytes === Array ? Array.prototype.slice.call(message.serializedEntities) : message.serializedEntities;
            if (message.commandQueueInfo != null && message.hasOwnProperty("commandQueueInfo"))
                object.commandQueueInfo = $root.CSVCMsg_PacketEntities.command_queue_info_t.toObject(message.commandQueueInfo, options);
            if (message.alternateBaselines && message.alternateBaselines.length) {
                object.alternateBaselines = [];
                for (var j = 0; j < message.alternateBaselines.length; ++j)
                    object.alternateBaselines[j] = $root.CSVCMsg_PacketEntities.alternate_baseline_t.toObject(message.alternateBaselines[j], options);
            }
            return object;
        };
    
        /**
         * Converts this CSVCMsg_PacketEntities to JSON.
         * @function toJSON
         * @memberof CSVCMsg_PacketEntities
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CSVCMsg_PacketEntities.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * Gets the default type url for CSVCMsg_PacketEntities
         * @function getTypeUrl
         * @memberof CSVCMsg_PacketEntities
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        CSVCMsg_PacketEntities.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/CSVCMsg_PacketEntities";
        };
    
        CSVCMsg_PacketEntities.command_queue_info_t = (function() {
    
            /**
             * Properties of a command_queue_info_t.
             * @memberof CSVCMsg_PacketEntities
             * @interface Icommand_queue_info_t
             * @property {number|null} [commandsQueued] command_queue_info_t commandsQueued
             * @property {number|null} [commandQueueDesiredSize] command_queue_info_t commandQueueDesiredSize
             * @property {number|null} [starvedCommandTicks] command_queue_info_t starvedCommandTicks
             * @property {number|null} [timeDilationPercent] command_queue_info_t timeDilationPercent
             * @property {number|null} [discardedCommandTicks] command_queue_info_t discardedCommandTicks
             */
    
            /**
             * Constructs a new command_queue_info_t.
             * @memberof CSVCMsg_PacketEntities
             * @classdesc Represents a command_queue_info_t.
             * @implements Icommand_queue_info_t
             * @constructor
             * @param {CSVCMsg_PacketEntities.Icommand_queue_info_t=} [properties] Properties to set
             */
            function command_queue_info_t(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * command_queue_info_t commandsQueued.
             * @member {number} commandsQueued
             * @memberof CSVCMsg_PacketEntities.command_queue_info_t
             * @instance
             */
            command_queue_info_t.prototype.commandsQueued = 0;
    
            /**
             * command_queue_info_t commandQueueDesiredSize.
             * @member {number} commandQueueDesiredSize
             * @memberof CSVCMsg_PacketEntities.command_queue_info_t
             * @instance
             */
            command_queue_info_t.prototype.commandQueueDesiredSize = 0;
    
            /**
             * command_queue_info_t starvedCommandTicks.
             * @member {number} starvedCommandTicks
             * @memberof CSVCMsg_PacketEntities.command_queue_info_t
             * @instance
             */
            command_queue_info_t.prototype.starvedCommandTicks = 0;
    
            /**
             * command_queue_info_t timeDilationPercent.
             * @member {number} timeDilationPercent
             * @memberof CSVCMsg_PacketEntities.command_queue_info_t
             * @instance
             */
            command_queue_info_t.prototype.timeDilationPercent = 0;
    
            /**
             * command_queue_info_t discardedCommandTicks.
             * @member {number} discardedCommandTicks
             * @memberof CSVCMsg_PacketEntities.command_queue_info_t
             * @instance
             */
            command_queue_info_t.prototype.discardedCommandTicks = 0;
    
            /**
             * Creates a new command_queue_info_t instance using the specified properties.
             * @function create
             * @memberof CSVCMsg_PacketEntities.command_queue_info_t
             * @static
             * @param {CSVCMsg_PacketEntities.Icommand_queue_info_t=} [properties] Properties to set
             * @returns {CSVCMsg_PacketEntities.command_queue_info_t} command_queue_info_t instance
             */
            command_queue_info_t.create = function create(properties) {
                return new command_queue_info_t(properties);
            };
    
            /**
             * Encodes the specified command_queue_info_t message. Does not implicitly {@link CSVCMsg_PacketEntities.command_queue_info_t.verify|verify} messages.
             * @function encode
             * @memberof CSVCMsg_PacketEntities.command_queue_info_t
             * @static
             * @param {CSVCMsg_PacketEntities.Icommand_queue_info_t} message command_queue_info_t message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            command_queue_info_t.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.commandsQueued != null && Object.hasOwnProperty.call(message, "commandsQueued"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.commandsQueued);
                if (message.commandQueueDesiredSize != null && Object.hasOwnProperty.call(message, "commandQueueDesiredSize"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.commandQueueDesiredSize);
                if (message.starvedCommandTicks != null && Object.hasOwnProperty.call(message, "starvedCommandTicks"))
                    writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.starvedCommandTicks);
                if (message.timeDilationPercent != null && Object.hasOwnProperty.call(message, "timeDilationPercent"))
                    writer.uint32(/* id 4, wireType 5 =*/37).float(message.timeDilationPercent);
                if (message.discardedCommandTicks != null && Object.hasOwnProperty.call(message, "discardedCommandTicks"))
                    writer.uint32(/* id 5, wireType 0 =*/40).uint32(message.discardedCommandTicks);
                return writer;
            };
    
            /**
             * Encodes the specified command_queue_info_t message, length delimited. Does not implicitly {@link CSVCMsg_PacketEntities.command_queue_info_t.verify|verify} messages.
             * @function encodeDelimited
             * @memberof CSVCMsg_PacketEntities.command_queue_info_t
             * @static
             * @param {CSVCMsg_PacketEntities.Icommand_queue_info_t} message command_queue_info_t message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            command_queue_info_t.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a command_queue_info_t message from the specified reader or buffer.
             * @function decode
             * @memberof CSVCMsg_PacketEntities.command_queue_info_t
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {CSVCMsg_PacketEntities.command_queue_info_t} command_queue_info_t
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            command_queue_info_t.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CSVCMsg_PacketEntities.command_queue_info_t();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.commandsQueued = reader.uint32();
                            break;
                        }
                    case 2: {
                            message.commandQueueDesiredSize = reader.uint32();
                            break;
                        }
                    case 3: {
                            message.starvedCommandTicks = reader.uint32();
                            break;
                        }
                    case 4: {
                            message.timeDilationPercent = reader.float();
                            break;
                        }
                    case 5: {
                            message.discardedCommandTicks = reader.uint32();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a command_queue_info_t message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof CSVCMsg_PacketEntities.command_queue_info_t
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {CSVCMsg_PacketEntities.command_queue_info_t} command_queue_info_t
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            command_queue_info_t.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a command_queue_info_t message.
             * @function verify
             * @memberof CSVCMsg_PacketEntities.command_queue_info_t
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            command_queue_info_t.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.commandsQueued != null && message.hasOwnProperty("commandsQueued"))
                    if (!$util.isInteger(message.commandsQueued))
                        return "commandsQueued: integer expected";
                if (message.commandQueueDesiredSize != null && message.hasOwnProperty("commandQueueDesiredSize"))
                    if (!$util.isInteger(message.commandQueueDesiredSize))
                        return "commandQueueDesiredSize: integer expected";
                if (message.starvedCommandTicks != null && message.hasOwnProperty("starvedCommandTicks"))
                    if (!$util.isInteger(message.starvedCommandTicks))
                        return "starvedCommandTicks: integer expected";
                if (message.timeDilationPercent != null && message.hasOwnProperty("timeDilationPercent"))
                    if (typeof message.timeDilationPercent !== "number")
                        return "timeDilationPercent: number expected";
                if (message.discardedCommandTicks != null && message.hasOwnProperty("discardedCommandTicks"))
                    if (!$util.isInteger(message.discardedCommandTicks))
                        return "discardedCommandTicks: integer expected";
                return null;
            };
    
            /**
             * Creates a command_queue_info_t message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof CSVCMsg_PacketEntities.command_queue_info_t
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {CSVCMsg_PacketEntities.command_queue_info_t} command_queue_info_t
             */
            command_queue_info_t.fromObject = function fromObject(object) {
                if (object instanceof $root.CSVCMsg_PacketEntities.command_queue_info_t)
                    return object;
                var message = new $root.CSVCMsg_PacketEntities.command_queue_info_t();
                if (object.commandsQueued != null)
                    message.commandsQueued = object.commandsQueued >>> 0;
                if (object.commandQueueDesiredSize != null)
                    message.commandQueueDesiredSize = object.commandQueueDesiredSize >>> 0;
                if (object.starvedCommandTicks != null)
                    message.starvedCommandTicks = object.starvedCommandTicks >>> 0;
                if (object.timeDilationPercent != null)
                    message.timeDilationPercent = Number(object.timeDilationPercent);
                if (object.discardedCommandTicks != null)
                    message.discardedCommandTicks = object.discardedCommandTicks >>> 0;
                return message;
            };
    
            /**
             * Creates a plain object from a command_queue_info_t message. Also converts values to other types if specified.
             * @function toObject
             * @memberof CSVCMsg_PacketEntities.command_queue_info_t
             * @static
             * @param {CSVCMsg_PacketEntities.command_queue_info_t} message command_queue_info_t
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            command_queue_info_t.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.commandsQueued = 0;
                    object.commandQueueDesiredSize = 0;
                    object.starvedCommandTicks = 0;
                    object.timeDilationPercent = 0;
                    object.discardedCommandTicks = 0;
                }
                if (message.commandsQueued != null && message.hasOwnProperty("commandsQueued"))
                    object.commandsQueued = message.commandsQueued;
                if (message.commandQueueDesiredSize != null && message.hasOwnProperty("commandQueueDesiredSize"))
                    object.commandQueueDesiredSize = message.commandQueueDesiredSize;
                if (message.starvedCommandTicks != null && message.hasOwnProperty("starvedCommandTicks"))
                    object.starvedCommandTicks = message.starvedCommandTicks;
                if (message.timeDilationPercent != null && message.hasOwnProperty("timeDilationPercent"))
                    object.timeDilationPercent = options.json && !isFinite(message.timeDilationPercent) ? String(message.timeDilationPercent) : message.timeDilationPercent;
                if (message.discardedCommandTicks != null && message.hasOwnProperty("discardedCommandTicks"))
                    object.discardedCommandTicks = message.discardedCommandTicks;
                return object;
            };
    
            /**
             * Converts this command_queue_info_t to JSON.
             * @function toJSON
             * @memberof CSVCMsg_PacketEntities.command_queue_info_t
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            command_queue_info_t.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            /**
             * Gets the default type url for command_queue_info_t
             * @function getTypeUrl
             * @memberof CSVCMsg_PacketEntities.command_queue_info_t
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            command_queue_info_t.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/CSVCMsg_PacketEntities.command_queue_info_t";
            };
    
            return command_queue_info_t;
        })();
    
        CSVCMsg_PacketEntities.alternate_baseline_t = (function() {
    
            /**
             * Properties of an alternate_baseline_t.
             * @memberof CSVCMsg_PacketEntities
             * @interface Ialternate_baseline_t
             * @property {number|null} [entityIndex] alternate_baseline_t entityIndex
             * @property {number|null} [baselineIndex] alternate_baseline_t baselineIndex
             */
    
            /**
             * Constructs a new alternate_baseline_t.
             * @memberof CSVCMsg_PacketEntities
             * @classdesc Represents an alternate_baseline_t.
             * @implements Ialternate_baseline_t
             * @constructor
             * @param {CSVCMsg_PacketEntities.Ialternate_baseline_t=} [properties] Properties to set
             */
            function alternate_baseline_t(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * alternate_baseline_t entityIndex.
             * @member {number} entityIndex
             * @memberof CSVCMsg_PacketEntities.alternate_baseline_t
             * @instance
             */
            alternate_baseline_t.prototype.entityIndex = 0;
    
            /**
             * alternate_baseline_t baselineIndex.
             * @member {number} baselineIndex
             * @memberof CSVCMsg_PacketEntities.alternate_baseline_t
             * @instance
             */
            alternate_baseline_t.prototype.baselineIndex = 0;
    
            /**
             * Creates a new alternate_baseline_t instance using the specified properties.
             * @function create
             * @memberof CSVCMsg_PacketEntities.alternate_baseline_t
             * @static
             * @param {CSVCMsg_PacketEntities.Ialternate_baseline_t=} [properties] Properties to set
             * @returns {CSVCMsg_PacketEntities.alternate_baseline_t} alternate_baseline_t instance
             */
            alternate_baseline_t.create = function create(properties) {
                return new alternate_baseline_t(properties);
            };
    
            /**
             * Encodes the specified alternate_baseline_t message. Does not implicitly {@link CSVCMsg_PacketEntities.alternate_baseline_t.verify|verify} messages.
             * @function encode
             * @memberof CSVCMsg_PacketEntities.alternate_baseline_t
             * @static
             * @param {CSVCMsg_PacketEntities.Ialternate_baseline_t} message alternate_baseline_t message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            alternate_baseline_t.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.entityIndex != null && Object.hasOwnProperty.call(message, "entityIndex"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.entityIndex);
                if (message.baselineIndex != null && Object.hasOwnProperty.call(message, "baselineIndex"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.baselineIndex);
                return writer;
            };
    
            /**
             * Encodes the specified alternate_baseline_t message, length delimited. Does not implicitly {@link CSVCMsg_PacketEntities.alternate_baseline_t.verify|verify} messages.
             * @function encodeDelimited
             * @memberof CSVCMsg_PacketEntities.alternate_baseline_t
             * @static
             * @param {CSVCMsg_PacketEntities.Ialternate_baseline_t} message alternate_baseline_t message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            alternate_baseline_t.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes an alternate_baseline_t message from the specified reader or buffer.
             * @function decode
             * @memberof CSVCMsg_PacketEntities.alternate_baseline_t
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {CSVCMsg_PacketEntities.alternate_baseline_t} alternate_baseline_t
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            alternate_baseline_t.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CSVCMsg_PacketEntities.alternate_baseline_t();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.entityIndex = reader.int32();
                            break;
                        }
                    case 2: {
                            message.baselineIndex = reader.int32();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes an alternate_baseline_t message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof CSVCMsg_PacketEntities.alternate_baseline_t
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {CSVCMsg_PacketEntities.alternate_baseline_t} alternate_baseline_t
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            alternate_baseline_t.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies an alternate_baseline_t message.
             * @function verify
             * @memberof CSVCMsg_PacketEntities.alternate_baseline_t
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            alternate_baseline_t.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.entityIndex != null && message.hasOwnProperty("entityIndex"))
                    if (!$util.isInteger(message.entityIndex))
                        return "entityIndex: integer expected";
                if (message.baselineIndex != null && message.hasOwnProperty("baselineIndex"))
                    if (!$util.isInteger(message.baselineIndex))
                        return "baselineIndex: integer expected";
                return null;
            };
    
            /**
             * Creates an alternate_baseline_t message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof CSVCMsg_PacketEntities.alternate_baseline_t
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {CSVCMsg_PacketEntities.alternate_baseline_t} alternate_baseline_t
             */
            alternate_baseline_t.fromObject = function fromObject(object) {
                if (object instanceof $root.CSVCMsg_PacketEntities.alternate_baseline_t)
                    return object;
                var message = new $root.CSVCMsg_PacketEntities.alternate_baseline_t();
                if (object.entityIndex != null)
                    message.entityIndex = object.entityIndex | 0;
                if (object.baselineIndex != null)
                    message.baselineIndex = object.baselineIndex | 0;
                return message;
            };
    
            /**
             * Creates a plain object from an alternate_baseline_t message. Also converts values to other types if specified.
             * @function toObject
             * @memberof CSVCMsg_PacketEntities.alternate_baseline_t
             * @static
             * @param {CSVCMsg_PacketEntities.alternate_baseline_t} message alternate_baseline_t
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            alternate_baseline_t.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.entityIndex = 0;
                    object.baselineIndex = 0;
                }
                if (message.entityIndex != null && message.hasOwnProperty("entityIndex"))
                    object.entityIndex = message.entityIndex;
                if (message.baselineIndex != null && message.hasOwnProperty("baselineIndex"))
                    object.baselineIndex = message.baselineIndex;
                return object;
            };
    
            /**
             * Converts this alternate_baseline_t to JSON.
             * @function toJSON
             * @memberof CSVCMsg_PacketEntities.alternate_baseline_t
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            alternate_baseline_t.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            /**
             * Gets the default type url for alternate_baseline_t
             * @function getTypeUrl
             * @memberof CSVCMsg_PacketEntities.alternate_baseline_t
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            alternate_baseline_t.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/CSVCMsg_PacketEntities.alternate_baseline_t";
            };
    
            return alternate_baseline_t;
        })();
    
        return CSVCMsg_PacketEntities;
    })();
    
    $root.CSVCMsg_TempEntities = (function() {
    
        /**
         * Properties of a CSVCMsg_TempEntities.
         * @exports ICSVCMsg_TempEntities
         * @interface ICSVCMsg_TempEntities
         * @property {boolean|null} [reliable] CSVCMsg_TempEntities reliable
         * @property {number|null} [numEntries] CSVCMsg_TempEntities numEntries
         * @property {Uint8Array|null} [entityData] CSVCMsg_TempEntities entityData
         */
    
        /**
         * Constructs a new CSVCMsg_TempEntities.
         * @exports CSVCMsg_TempEntities
         * @classdesc Represents a CSVCMsg_TempEntities.
         * @implements ICSVCMsg_TempEntities
         * @constructor
         * @param {ICSVCMsg_TempEntities=} [properties] Properties to set
         */
        function CSVCMsg_TempEntities(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CSVCMsg_TempEntities reliable.
         * @member {boolean} reliable
         * @memberof CSVCMsg_TempEntities
         * @instance
         */
        CSVCMsg_TempEntities.prototype.reliable = false;
    
        /**
         * CSVCMsg_TempEntities numEntries.
         * @member {number} numEntries
         * @memberof CSVCMsg_TempEntities
         * @instance
         */
        CSVCMsg_TempEntities.prototype.numEntries = 0;
    
        /**
         * CSVCMsg_TempEntities entityData.
         * @member {Uint8Array} entityData
         * @memberof CSVCMsg_TempEntities
         * @instance
         */
        CSVCMsg_TempEntities.prototype.entityData = $util.newBuffer([]);
    
        /**
         * Creates a new CSVCMsg_TempEntities instance using the specified properties.
         * @function create
         * @memberof CSVCMsg_TempEntities
         * @static
         * @param {ICSVCMsg_TempEntities=} [properties] Properties to set
         * @returns {CSVCMsg_TempEntities} CSVCMsg_TempEntities instance
         */
        CSVCMsg_TempEntities.create = function create(properties) {
            return new CSVCMsg_TempEntities(properties);
        };
    
        /**
         * Encodes the specified CSVCMsg_TempEntities message. Does not implicitly {@link CSVCMsg_TempEntities.verify|verify} messages.
         * @function encode
         * @memberof CSVCMsg_TempEntities
         * @static
         * @param {ICSVCMsg_TempEntities} message CSVCMsg_TempEntities message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CSVCMsg_TempEntities.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.reliable != null && Object.hasOwnProperty.call(message, "reliable"))
                writer.uint32(/* id 1, wireType 0 =*/8).bool(message.reliable);
            if (message.numEntries != null && Object.hasOwnProperty.call(message, "numEntries"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.numEntries);
            if (message.entityData != null && Object.hasOwnProperty.call(message, "entityData"))
                writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.entityData);
            return writer;
        };
    
        /**
         * Encodes the specified CSVCMsg_TempEntities message, length delimited. Does not implicitly {@link CSVCMsg_TempEntities.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CSVCMsg_TempEntities
         * @static
         * @param {ICSVCMsg_TempEntities} message CSVCMsg_TempEntities message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CSVCMsg_TempEntities.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CSVCMsg_TempEntities message from the specified reader or buffer.
         * @function decode
         * @memberof CSVCMsg_TempEntities
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CSVCMsg_TempEntities} CSVCMsg_TempEntities
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CSVCMsg_TempEntities.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CSVCMsg_TempEntities();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.reliable = reader.bool();
                        break;
                    }
                case 2: {
                        message.numEntries = reader.int32();
                        break;
                    }
                case 3: {
                        message.entityData = reader.bytes();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CSVCMsg_TempEntities message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CSVCMsg_TempEntities
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CSVCMsg_TempEntities} CSVCMsg_TempEntities
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CSVCMsg_TempEntities.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CSVCMsg_TempEntities message.
         * @function verify
         * @memberof CSVCMsg_TempEntities
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CSVCMsg_TempEntities.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.reliable != null && message.hasOwnProperty("reliable"))
                if (typeof message.reliable !== "boolean")
                    return "reliable: boolean expected";
            if (message.numEntries != null && message.hasOwnProperty("numEntries"))
                if (!$util.isInteger(message.numEntries))
                    return "numEntries: integer expected";
            if (message.entityData != null && message.hasOwnProperty("entityData"))
                if (!(message.entityData && typeof message.entityData.length === "number" || $util.isString(message.entityData)))
                    return "entityData: buffer expected";
            return null;
        };
    
        /**
         * Creates a CSVCMsg_TempEntities message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CSVCMsg_TempEntities
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CSVCMsg_TempEntities} CSVCMsg_TempEntities
         */
        CSVCMsg_TempEntities.fromObject = function fromObject(object) {
            if (object instanceof $root.CSVCMsg_TempEntities)
                return object;
            var message = new $root.CSVCMsg_TempEntities();
            if (object.reliable != null)
                message.reliable = Boolean(object.reliable);
            if (object.numEntries != null)
                message.numEntries = object.numEntries | 0;
            if (object.entityData != null)
                if (typeof object.entityData === "string")
                    $util.base64.decode(object.entityData, message.entityData = $util.newBuffer($util.base64.length(object.entityData)), 0);
                else if (object.entityData.length >= 0)
                    message.entityData = object.entityData;
            return message;
        };
    
        /**
         * Creates a plain object from a CSVCMsg_TempEntities message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CSVCMsg_TempEntities
         * @static
         * @param {CSVCMsg_TempEntities} message CSVCMsg_TempEntities
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CSVCMsg_TempEntities.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.reliable = false;
                object.numEntries = 0;
                if (options.bytes === String)
                    object.entityData = "";
                else {
                    object.entityData = [];
                    if (options.bytes !== Array)
                        object.entityData = $util.newBuffer(object.entityData);
                }
            }
            if (message.reliable != null && message.hasOwnProperty("reliable"))
                object.reliable = message.reliable;
            if (message.numEntries != null && message.hasOwnProperty("numEntries"))
                object.numEntries = message.numEntries;
            if (message.entityData != null && message.hasOwnProperty("entityData"))
                object.entityData = options.bytes === String ? $util.base64.encode(message.entityData, 0, message.entityData.length) : options.bytes === Array ? Array.prototype.slice.call(message.entityData) : message.entityData;
            return object;
        };
    
        /**
         * Converts this CSVCMsg_TempEntities to JSON.
         * @function toJSON
         * @memberof CSVCMsg_TempEntities
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CSVCMsg_TempEntities.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * Gets the default type url for CSVCMsg_TempEntities
         * @function getTypeUrl
         * @memberof CSVCMsg_TempEntities
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        CSVCMsg_TempEntities.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/CSVCMsg_TempEntities";
        };
    
        return CSVCMsg_TempEntities;
    })();
    
    $root.CSVCMsg_CreateStringTable = (function() {
    
        /**
         * Properties of a CSVCMsg_CreateStringTable.
         * @exports ICSVCMsg_CreateStringTable
         * @interface ICSVCMsg_CreateStringTable
         * @property {string|null} [name] CSVCMsg_CreateStringTable name
         * @property {number|null} [numEntries] CSVCMsg_CreateStringTable numEntries
         * @property {boolean|null} [userDataFixedSize] CSVCMsg_CreateStringTable userDataFixedSize
         * @property {number|null} [userDataSize] CSVCMsg_CreateStringTable userDataSize
         * @property {number|null} [userDataSizeBits] CSVCMsg_CreateStringTable userDataSizeBits
         * @property {number|null} [flags] CSVCMsg_CreateStringTable flags
         * @property {Uint8Array|null} [stringData] CSVCMsg_CreateStringTable stringData
         * @property {number|null} [uncompressedSize] CSVCMsg_CreateStringTable uncompressedSize
         * @property {boolean|null} [dataCompressed] CSVCMsg_CreateStringTable dataCompressed
         * @property {boolean|null} [usingVarintBitcounts] CSVCMsg_CreateStringTable usingVarintBitcounts
         */
    
        /**
         * Constructs a new CSVCMsg_CreateStringTable.
         * @exports CSVCMsg_CreateStringTable
         * @classdesc Represents a CSVCMsg_CreateStringTable.
         * @implements ICSVCMsg_CreateStringTable
         * @constructor
         * @param {ICSVCMsg_CreateStringTable=} [properties] Properties to set
         */
        function CSVCMsg_CreateStringTable(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CSVCMsg_CreateStringTable name.
         * @member {string} name
         * @memberof CSVCMsg_CreateStringTable
         * @instance
         */
        CSVCMsg_CreateStringTable.prototype.name = "";
    
        /**
         * CSVCMsg_CreateStringTable numEntries.
         * @member {number} numEntries
         * @memberof CSVCMsg_CreateStringTable
         * @instance
         */
        CSVCMsg_CreateStringTable.prototype.numEntries = 0;
    
        /**
         * CSVCMsg_CreateStringTable userDataFixedSize.
         * @member {boolean} userDataFixedSize
         * @memberof CSVCMsg_CreateStringTable
         * @instance
         */
        CSVCMsg_CreateStringTable.prototype.userDataFixedSize = false;
    
        /**
         * CSVCMsg_CreateStringTable userDataSize.
         * @member {number} userDataSize
         * @memberof CSVCMsg_CreateStringTable
         * @instance
         */
        CSVCMsg_CreateStringTable.prototype.userDataSize = 0;
    
        /**
         * CSVCMsg_CreateStringTable userDataSizeBits.
         * @member {number} userDataSizeBits
         * @memberof CSVCMsg_CreateStringTable
         * @instance
         */
        CSVCMsg_CreateStringTable.prototype.userDataSizeBits = 0;
    
        /**
         * CSVCMsg_CreateStringTable flags.
         * @member {number} flags
         * @memberof CSVCMsg_CreateStringTable
         * @instance
         */
        CSVCMsg_CreateStringTable.prototype.flags = 0;
    
        /**
         * CSVCMsg_CreateStringTable stringData.
         * @member {Uint8Array} stringData
         * @memberof CSVCMsg_CreateStringTable
         * @instance
         */
        CSVCMsg_CreateStringTable.prototype.stringData = $util.newBuffer([]);
    
        /**
         * CSVCMsg_CreateStringTable uncompressedSize.
         * @member {number} uncompressedSize
         * @memberof CSVCMsg_CreateStringTable
         * @instance
         */
        CSVCMsg_CreateStringTable.prototype.uncompressedSize = 0;
    
        /**
         * CSVCMsg_CreateStringTable dataCompressed.
         * @member {boolean} dataCompressed
         * @memberof CSVCMsg_CreateStringTable
         * @instance
         */
        CSVCMsg_CreateStringTable.prototype.dataCompressed = false;
    
        /**
         * CSVCMsg_CreateStringTable usingVarintBitcounts.
         * @member {boolean} usingVarintBitcounts
         * @memberof CSVCMsg_CreateStringTable
         * @instance
         */
        CSVCMsg_CreateStringTable.prototype.usingVarintBitcounts = false;
    
        /**
         * Creates a new CSVCMsg_CreateStringTable instance using the specified properties.
         * @function create
         * @memberof CSVCMsg_CreateStringTable
         * @static
         * @param {ICSVCMsg_CreateStringTable=} [properties] Properties to set
         * @returns {CSVCMsg_CreateStringTable} CSVCMsg_CreateStringTable instance
         */
        CSVCMsg_CreateStringTable.create = function create(properties) {
            return new CSVCMsg_CreateStringTable(properties);
        };
    
        /**
         * Encodes the specified CSVCMsg_CreateStringTable message. Does not implicitly {@link CSVCMsg_CreateStringTable.verify|verify} messages.
         * @function encode
         * @memberof CSVCMsg_CreateStringTable
         * @static
         * @param {ICSVCMsg_CreateStringTable} message CSVCMsg_CreateStringTable message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CSVCMsg_CreateStringTable.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
            if (message.numEntries != null && Object.hasOwnProperty.call(message, "numEntries"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.numEntries);
            if (message.userDataFixedSize != null && Object.hasOwnProperty.call(message, "userDataFixedSize"))
                writer.uint32(/* id 3, wireType 0 =*/24).bool(message.userDataFixedSize);
            if (message.userDataSize != null && Object.hasOwnProperty.call(message, "userDataSize"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.userDataSize);
            if (message.userDataSizeBits != null && Object.hasOwnProperty.call(message, "userDataSizeBits"))
                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.userDataSizeBits);
            if (message.flags != null && Object.hasOwnProperty.call(message, "flags"))
                writer.uint32(/* id 6, wireType 0 =*/48).int32(message.flags);
            if (message.stringData != null && Object.hasOwnProperty.call(message, "stringData"))
                writer.uint32(/* id 7, wireType 2 =*/58).bytes(message.stringData);
            if (message.uncompressedSize != null && Object.hasOwnProperty.call(message, "uncompressedSize"))
                writer.uint32(/* id 8, wireType 0 =*/64).int32(message.uncompressedSize);
            if (message.dataCompressed != null && Object.hasOwnProperty.call(message, "dataCompressed"))
                writer.uint32(/* id 9, wireType 0 =*/72).bool(message.dataCompressed);
            if (message.usingVarintBitcounts != null && Object.hasOwnProperty.call(message, "usingVarintBitcounts"))
                writer.uint32(/* id 10, wireType 0 =*/80).bool(message.usingVarintBitcounts);
            return writer;
        };
    
        /**
         * Encodes the specified CSVCMsg_CreateStringTable message, length delimited. Does not implicitly {@link CSVCMsg_CreateStringTable.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CSVCMsg_CreateStringTable
         * @static
         * @param {ICSVCMsg_CreateStringTable} message CSVCMsg_CreateStringTable message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CSVCMsg_CreateStringTable.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CSVCMsg_CreateStringTable message from the specified reader or buffer.
         * @function decode
         * @memberof CSVCMsg_CreateStringTable
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CSVCMsg_CreateStringTable} CSVCMsg_CreateStringTable
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CSVCMsg_CreateStringTable.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CSVCMsg_CreateStringTable();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.name = reader.string();
                        break;
                    }
                case 2: {
                        message.numEntries = reader.int32();
                        break;
                    }
                case 3: {
                        message.userDataFixedSize = reader.bool();
                        break;
                    }
                case 4: {
                        message.userDataSize = reader.int32();
                        break;
                    }
                case 5: {
                        message.userDataSizeBits = reader.int32();
                        break;
                    }
                case 6: {
                        message.flags = reader.int32();
                        break;
                    }
                case 7: {
                        message.stringData = reader.bytes();
                        break;
                    }
                case 8: {
                        message.uncompressedSize = reader.int32();
                        break;
                    }
                case 9: {
                        message.dataCompressed = reader.bool();
                        break;
                    }
                case 10: {
                        message.usingVarintBitcounts = reader.bool();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CSVCMsg_CreateStringTable message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CSVCMsg_CreateStringTable
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CSVCMsg_CreateStringTable} CSVCMsg_CreateStringTable
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CSVCMsg_CreateStringTable.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CSVCMsg_CreateStringTable message.
         * @function verify
         * @memberof CSVCMsg_CreateStringTable
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CSVCMsg_CreateStringTable.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.name != null && message.hasOwnProperty("name"))
                if (!$util.isString(message.name))
                    return "name: string expected";
            if (message.numEntries != null && message.hasOwnProperty("numEntries"))
                if (!$util.isInteger(message.numEntries))
                    return "numEntries: integer expected";
            if (message.userDataFixedSize != null && message.hasOwnProperty("userDataFixedSize"))
                if (typeof message.userDataFixedSize !== "boolean")
                    return "userDataFixedSize: boolean expected";
            if (message.userDataSize != null && message.hasOwnProperty("userDataSize"))
                if (!$util.isInteger(message.userDataSize))
                    return "userDataSize: integer expected";
            if (message.userDataSizeBits != null && message.hasOwnProperty("userDataSizeBits"))
                if (!$util.isInteger(message.userDataSizeBits))
                    return "userDataSizeBits: integer expected";
            if (message.flags != null && message.hasOwnProperty("flags"))
                if (!$util.isInteger(message.flags))
                    return "flags: integer expected";
            if (message.stringData != null && message.hasOwnProperty("stringData"))
                if (!(message.stringData && typeof message.stringData.length === "number" || $util.isString(message.stringData)))
                    return "stringData: buffer expected";
            if (message.uncompressedSize != null && message.hasOwnProperty("uncompressedSize"))
                if (!$util.isInteger(message.uncompressedSize))
                    return "uncompressedSize: integer expected";
            if (message.dataCompressed != null && message.hasOwnProperty("dataCompressed"))
                if (typeof message.dataCompressed !== "boolean")
                    return "dataCompressed: boolean expected";
            if (message.usingVarintBitcounts != null && message.hasOwnProperty("usingVarintBitcounts"))
                if (typeof message.usingVarintBitcounts !== "boolean")
                    return "usingVarintBitcounts: boolean expected";
            return null;
        };
    
        /**
         * Creates a CSVCMsg_CreateStringTable message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CSVCMsg_CreateStringTable
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CSVCMsg_CreateStringTable} CSVCMsg_CreateStringTable
         */
        CSVCMsg_CreateStringTable.fromObject = function fromObject(object) {
            if (object instanceof $root.CSVCMsg_CreateStringTable)
                return object;
            var message = new $root.CSVCMsg_CreateStringTable();
            if (object.name != null)
                message.name = String(object.name);
            if (object.numEntries != null)
                message.numEntries = object.numEntries | 0;
            if (object.userDataFixedSize != null)
                message.userDataFixedSize = Boolean(object.userDataFixedSize);
            if (object.userDataSize != null)
                message.userDataSize = object.userDataSize | 0;
            if (object.userDataSizeBits != null)
                message.userDataSizeBits = object.userDataSizeBits | 0;
            if (object.flags != null)
                message.flags = object.flags | 0;
            if (object.stringData != null)
                if (typeof object.stringData === "string")
                    $util.base64.decode(object.stringData, message.stringData = $util.newBuffer($util.base64.length(object.stringData)), 0);
                else if (object.stringData.length >= 0)
                    message.stringData = object.stringData;
            if (object.uncompressedSize != null)
                message.uncompressedSize = object.uncompressedSize | 0;
            if (object.dataCompressed != null)
                message.dataCompressed = Boolean(object.dataCompressed);
            if (object.usingVarintBitcounts != null)
                message.usingVarintBitcounts = Boolean(object.usingVarintBitcounts);
            return message;
        };
    
        /**
         * Creates a plain object from a CSVCMsg_CreateStringTable message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CSVCMsg_CreateStringTable
         * @static
         * @param {CSVCMsg_CreateStringTable} message CSVCMsg_CreateStringTable
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CSVCMsg_CreateStringTable.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.name = "";
                object.numEntries = 0;
                object.userDataFixedSize = false;
                object.userDataSize = 0;
                object.userDataSizeBits = 0;
                object.flags = 0;
                if (options.bytes === String)
                    object.stringData = "";
                else {
                    object.stringData = [];
                    if (options.bytes !== Array)
                        object.stringData = $util.newBuffer(object.stringData);
                }
                object.uncompressedSize = 0;
                object.dataCompressed = false;
                object.usingVarintBitcounts = false;
            }
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
            if (message.numEntries != null && message.hasOwnProperty("numEntries"))
                object.numEntries = message.numEntries;
            if (message.userDataFixedSize != null && message.hasOwnProperty("userDataFixedSize"))
                object.userDataFixedSize = message.userDataFixedSize;
            if (message.userDataSize != null && message.hasOwnProperty("userDataSize"))
                object.userDataSize = message.userDataSize;
            if (message.userDataSizeBits != null && message.hasOwnProperty("userDataSizeBits"))
                object.userDataSizeBits = message.userDataSizeBits;
            if (message.flags != null && message.hasOwnProperty("flags"))
                object.flags = message.flags;
            if (message.stringData != null && message.hasOwnProperty("stringData"))
                object.stringData = options.bytes === String ? $util.base64.encode(message.stringData, 0, message.stringData.length) : options.bytes === Array ? Array.prototype.slice.call(message.stringData) : message.stringData;
            if (message.uncompressedSize != null && message.hasOwnProperty("uncompressedSize"))
                object.uncompressedSize = message.uncompressedSize;
            if (message.dataCompressed != null && message.hasOwnProperty("dataCompressed"))
                object.dataCompressed = message.dataCompressed;
            if (message.usingVarintBitcounts != null && message.hasOwnProperty("usingVarintBitcounts"))
                object.usingVarintBitcounts = message.usingVarintBitcounts;
            return object;
        };
    
        /**
         * Converts this CSVCMsg_CreateStringTable to JSON.
         * @function toJSON
         * @memberof CSVCMsg_CreateStringTable
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CSVCMsg_CreateStringTable.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * Gets the default type url for CSVCMsg_CreateStringTable
         * @function getTypeUrl
         * @memberof CSVCMsg_CreateStringTable
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        CSVCMsg_CreateStringTable.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/CSVCMsg_CreateStringTable";
        };
    
        return CSVCMsg_CreateStringTable;
    })();
    
    $root.CSVCMsg_UpdateStringTable = (function() {
    
        /**
         * Properties of a CSVCMsg_UpdateStringTable.
         * @exports ICSVCMsg_UpdateStringTable
         * @interface ICSVCMsg_UpdateStringTable
         * @property {number|null} [tableId] CSVCMsg_UpdateStringTable tableId
         * @property {number|null} [numChangedEntries] CSVCMsg_UpdateStringTable numChangedEntries
         * @property {Uint8Array|null} [stringData] CSVCMsg_UpdateStringTable stringData
         */
    
        /**
         * Constructs a new CSVCMsg_UpdateStringTable.
         * @exports CSVCMsg_UpdateStringTable
         * @classdesc Represents a CSVCMsg_UpdateStringTable.
         * @implements ICSVCMsg_UpdateStringTable
         * @constructor
         * @param {ICSVCMsg_UpdateStringTable=} [properties] Properties to set
         */
        function CSVCMsg_UpdateStringTable(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CSVCMsg_UpdateStringTable tableId.
         * @member {number} tableId
         * @memberof CSVCMsg_UpdateStringTable
         * @instance
         */
        CSVCMsg_UpdateStringTable.prototype.tableId = 0;
    
        /**
         * CSVCMsg_UpdateStringTable numChangedEntries.
         * @member {number} numChangedEntries
         * @memberof CSVCMsg_UpdateStringTable
         * @instance
         */
        CSVCMsg_UpdateStringTable.prototype.numChangedEntries = 0;
    
        /**
         * CSVCMsg_UpdateStringTable stringData.
         * @member {Uint8Array} stringData
         * @memberof CSVCMsg_UpdateStringTable
         * @instance
         */
        CSVCMsg_UpdateStringTable.prototype.stringData = $util.newBuffer([]);
    
        /**
         * Creates a new CSVCMsg_UpdateStringTable instance using the specified properties.
         * @function create
         * @memberof CSVCMsg_UpdateStringTable
         * @static
         * @param {ICSVCMsg_UpdateStringTable=} [properties] Properties to set
         * @returns {CSVCMsg_UpdateStringTable} CSVCMsg_UpdateStringTable instance
         */
        CSVCMsg_UpdateStringTable.create = function create(properties) {
            return new CSVCMsg_UpdateStringTable(properties);
        };
    
        /**
         * Encodes the specified CSVCMsg_UpdateStringTable message. Does not implicitly {@link CSVCMsg_UpdateStringTable.verify|verify} messages.
         * @function encode
         * @memberof CSVCMsg_UpdateStringTable
         * @static
         * @param {ICSVCMsg_UpdateStringTable} message CSVCMsg_UpdateStringTable message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CSVCMsg_UpdateStringTable.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.tableId != null && Object.hasOwnProperty.call(message, "tableId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.tableId);
            if (message.numChangedEntries != null && Object.hasOwnProperty.call(message, "numChangedEntries"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.numChangedEntries);
            if (message.stringData != null && Object.hasOwnProperty.call(message, "stringData"))
                writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.stringData);
            return writer;
        };
    
        /**
         * Encodes the specified CSVCMsg_UpdateStringTable message, length delimited. Does not implicitly {@link CSVCMsg_UpdateStringTable.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CSVCMsg_UpdateStringTable
         * @static
         * @param {ICSVCMsg_UpdateStringTable} message CSVCMsg_UpdateStringTable message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CSVCMsg_UpdateStringTable.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CSVCMsg_UpdateStringTable message from the specified reader or buffer.
         * @function decode
         * @memberof CSVCMsg_UpdateStringTable
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CSVCMsg_UpdateStringTable} CSVCMsg_UpdateStringTable
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CSVCMsg_UpdateStringTable.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CSVCMsg_UpdateStringTable();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.tableId = reader.int32();
                        break;
                    }
                case 2: {
                        message.numChangedEntries = reader.int32();
                        break;
                    }
                case 3: {
                        message.stringData = reader.bytes();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CSVCMsg_UpdateStringTable message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CSVCMsg_UpdateStringTable
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CSVCMsg_UpdateStringTable} CSVCMsg_UpdateStringTable
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CSVCMsg_UpdateStringTable.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CSVCMsg_UpdateStringTable message.
         * @function verify
         * @memberof CSVCMsg_UpdateStringTable
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CSVCMsg_UpdateStringTable.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.tableId != null && message.hasOwnProperty("tableId"))
                if (!$util.isInteger(message.tableId))
                    return "tableId: integer expected";
            if (message.numChangedEntries != null && message.hasOwnProperty("numChangedEntries"))
                if (!$util.isInteger(message.numChangedEntries))
                    return "numChangedEntries: integer expected";
            if (message.stringData != null && message.hasOwnProperty("stringData"))
                if (!(message.stringData && typeof message.stringData.length === "number" || $util.isString(message.stringData)))
                    return "stringData: buffer expected";
            return null;
        };
    
        /**
         * Creates a CSVCMsg_UpdateStringTable message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CSVCMsg_UpdateStringTable
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CSVCMsg_UpdateStringTable} CSVCMsg_UpdateStringTable
         */
        CSVCMsg_UpdateStringTable.fromObject = function fromObject(object) {
            if (object instanceof $root.CSVCMsg_UpdateStringTable)
                return object;
            var message = new $root.CSVCMsg_UpdateStringTable();
            if (object.tableId != null)
                message.tableId = object.tableId | 0;
            if (object.numChangedEntries != null)
                message.numChangedEntries = object.numChangedEntries | 0;
            if (object.stringData != null)
                if (typeof object.stringData === "string")
                    $util.base64.decode(object.stringData, message.stringData = $util.newBuffer($util.base64.length(object.stringData)), 0);
                else if (object.stringData.length >= 0)
                    message.stringData = object.stringData;
            return message;
        };
    
        /**
         * Creates a plain object from a CSVCMsg_UpdateStringTable message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CSVCMsg_UpdateStringTable
         * @static
         * @param {CSVCMsg_UpdateStringTable} message CSVCMsg_UpdateStringTable
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CSVCMsg_UpdateStringTable.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.tableId = 0;
                object.numChangedEntries = 0;
                if (options.bytes === String)
                    object.stringData = "";
                else {
                    object.stringData = [];
                    if (options.bytes !== Array)
                        object.stringData = $util.newBuffer(object.stringData);
                }
            }
            if (message.tableId != null && message.hasOwnProperty("tableId"))
                object.tableId = message.tableId;
            if (message.numChangedEntries != null && message.hasOwnProperty("numChangedEntries"))
                object.numChangedEntries = message.numChangedEntries;
            if (message.stringData != null && message.hasOwnProperty("stringData"))
                object.stringData = options.bytes === String ? $util.base64.encode(message.stringData, 0, message.stringData.length) : options.bytes === Array ? Array.prototype.slice.call(message.stringData) : message.stringData;
            return object;
        };
    
        /**
         * Converts this CSVCMsg_UpdateStringTable to JSON.
         * @function toJSON
         * @memberof CSVCMsg_UpdateStringTable
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CSVCMsg_UpdateStringTable.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * Gets the default type url for CSVCMsg_UpdateStringTable
         * @function getTypeUrl
         * @memberof CSVCMsg_UpdateStringTable
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        CSVCMsg_UpdateStringTable.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/CSVCMsg_UpdateStringTable";
        };
    
        return CSVCMsg_UpdateStringTable;
    })();
    
    $root.CSVCMsg_VoiceData = (function() {
    
        /**
         * Properties of a CSVCMsg_VoiceData.
         * @exports ICSVCMsg_VoiceData
         * @interface ICSVCMsg_VoiceData
         * @property {ICMsgVoiceAudio|null} [audio] CSVCMsg_VoiceData audio
         * @property {number|null} [client] CSVCMsg_VoiceData client
         * @property {boolean|null} [proximity] CSVCMsg_VoiceData proximity
         * @property {number|Long|null} [xuid] CSVCMsg_VoiceData xuid
         * @property {number|null} [audibleMask] CSVCMsg_VoiceData audibleMask
         * @property {number|null} [tick] CSVCMsg_VoiceData tick
         * @property {number|null} [passthrough] CSVCMsg_VoiceData passthrough
         */
    
        /**
         * Constructs a new CSVCMsg_VoiceData.
         * @exports CSVCMsg_VoiceData
         * @classdesc Represents a CSVCMsg_VoiceData.
         * @implements ICSVCMsg_VoiceData
         * @constructor
         * @param {ICSVCMsg_VoiceData=} [properties] Properties to set
         */
        function CSVCMsg_VoiceData(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CSVCMsg_VoiceData audio.
         * @member {ICMsgVoiceAudio|null|undefined} audio
         * @memberof CSVCMsg_VoiceData
         * @instance
         */
        CSVCMsg_VoiceData.prototype.audio = null;
    
        /**
         * CSVCMsg_VoiceData client.
         * @member {number} client
         * @memberof CSVCMsg_VoiceData
         * @instance
         */
        CSVCMsg_VoiceData.prototype.client = -1;
    
        /**
         * CSVCMsg_VoiceData proximity.
         * @member {boolean} proximity
         * @memberof CSVCMsg_VoiceData
         * @instance
         */
        CSVCMsg_VoiceData.prototype.proximity = false;
    
        /**
         * CSVCMsg_VoiceData xuid.
         * @member {number|Long} xuid
         * @memberof CSVCMsg_VoiceData
         * @instance
         */
        CSVCMsg_VoiceData.prototype.xuid = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
        /**
         * CSVCMsg_VoiceData audibleMask.
         * @member {number} audibleMask
         * @memberof CSVCMsg_VoiceData
         * @instance
         */
        CSVCMsg_VoiceData.prototype.audibleMask = 0;
    
        /**
         * CSVCMsg_VoiceData tick.
         * @member {number} tick
         * @memberof CSVCMsg_VoiceData
         * @instance
         */
        CSVCMsg_VoiceData.prototype.tick = 0;
    
        /**
         * CSVCMsg_VoiceData passthrough.
         * @member {number} passthrough
         * @memberof CSVCMsg_VoiceData
         * @instance
         */
        CSVCMsg_VoiceData.prototype.passthrough = 0;
    
        /**
         * Creates a new CSVCMsg_VoiceData instance using the specified properties.
         * @function create
         * @memberof CSVCMsg_VoiceData
         * @static
         * @param {ICSVCMsg_VoiceData=} [properties] Properties to set
         * @returns {CSVCMsg_VoiceData} CSVCMsg_VoiceData instance
         */
        CSVCMsg_VoiceData.create = function create(properties) {
            return new CSVCMsg_VoiceData(properties);
        };
    
        /**
         * Encodes the specified CSVCMsg_VoiceData message. Does not implicitly {@link CSVCMsg_VoiceData.verify|verify} messages.
         * @function encode
         * @memberof CSVCMsg_VoiceData
         * @static
         * @param {ICSVCMsg_VoiceData} message CSVCMsg_VoiceData message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CSVCMsg_VoiceData.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.audio != null && Object.hasOwnProperty.call(message, "audio"))
                $root.CMsgVoiceAudio.encode(message.audio, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.client != null && Object.hasOwnProperty.call(message, "client"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.client);
            if (message.proximity != null && Object.hasOwnProperty.call(message, "proximity"))
                writer.uint32(/* id 3, wireType 0 =*/24).bool(message.proximity);
            if (message.xuid != null && Object.hasOwnProperty.call(message, "xuid"))
                writer.uint32(/* id 4, wireType 1 =*/33).fixed64(message.xuid);
            if (message.audibleMask != null && Object.hasOwnProperty.call(message, "audibleMask"))
                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.audibleMask);
            if (message.tick != null && Object.hasOwnProperty.call(message, "tick"))
                writer.uint32(/* id 6, wireType 0 =*/48).uint32(message.tick);
            if (message.passthrough != null && Object.hasOwnProperty.call(message, "passthrough"))
                writer.uint32(/* id 7, wireType 0 =*/56).int32(message.passthrough);
            return writer;
        };
    
        /**
         * Encodes the specified CSVCMsg_VoiceData message, length delimited. Does not implicitly {@link CSVCMsg_VoiceData.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CSVCMsg_VoiceData
         * @static
         * @param {ICSVCMsg_VoiceData} message CSVCMsg_VoiceData message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CSVCMsg_VoiceData.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CSVCMsg_VoiceData message from the specified reader or buffer.
         * @function decode
         * @memberof CSVCMsg_VoiceData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CSVCMsg_VoiceData} CSVCMsg_VoiceData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CSVCMsg_VoiceData.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CSVCMsg_VoiceData();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.audio = $root.CMsgVoiceAudio.decode(reader, reader.uint32());
                        break;
                    }
                case 2: {
                        message.client = reader.int32();
                        break;
                    }
                case 3: {
                        message.proximity = reader.bool();
                        break;
                    }
                case 4: {
                        message.xuid = reader.fixed64();
                        break;
                    }
                case 5: {
                        message.audibleMask = reader.int32();
                        break;
                    }
                case 6: {
                        message.tick = reader.uint32();
                        break;
                    }
                case 7: {
                        message.passthrough = reader.int32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CSVCMsg_VoiceData message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CSVCMsg_VoiceData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CSVCMsg_VoiceData} CSVCMsg_VoiceData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CSVCMsg_VoiceData.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CSVCMsg_VoiceData message.
         * @function verify
         * @memberof CSVCMsg_VoiceData
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CSVCMsg_VoiceData.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.audio != null && message.hasOwnProperty("audio")) {
                var error = $root.CMsgVoiceAudio.verify(message.audio);
                if (error)
                    return "audio." + error;
            }
            if (message.client != null && message.hasOwnProperty("client"))
                if (!$util.isInteger(message.client))
                    return "client: integer expected";
            if (message.proximity != null && message.hasOwnProperty("proximity"))
                if (typeof message.proximity !== "boolean")
                    return "proximity: boolean expected";
            if (message.xuid != null && message.hasOwnProperty("xuid"))
                if (!$util.isInteger(message.xuid) && !(message.xuid && $util.isInteger(message.xuid.low) && $util.isInteger(message.xuid.high)))
                    return "xuid: integer|Long expected";
            if (message.audibleMask != null && message.hasOwnProperty("audibleMask"))
                if (!$util.isInteger(message.audibleMask))
                    return "audibleMask: integer expected";
            if (message.tick != null && message.hasOwnProperty("tick"))
                if (!$util.isInteger(message.tick))
                    return "tick: integer expected";
            if (message.passthrough != null && message.hasOwnProperty("passthrough"))
                if (!$util.isInteger(message.passthrough))
                    return "passthrough: integer expected";
            return null;
        };
    
        /**
         * Creates a CSVCMsg_VoiceData message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CSVCMsg_VoiceData
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CSVCMsg_VoiceData} CSVCMsg_VoiceData
         */
        CSVCMsg_VoiceData.fromObject = function fromObject(object) {
            if (object instanceof $root.CSVCMsg_VoiceData)
                return object;
            var message = new $root.CSVCMsg_VoiceData();
            if (object.audio != null) {
                if (typeof object.audio !== "object")
                    throw TypeError(".CSVCMsg_VoiceData.audio: object expected");
                message.audio = $root.CMsgVoiceAudio.fromObject(object.audio);
            }
            if (object.client != null)
                message.client = object.client | 0;
            if (object.proximity != null)
                message.proximity = Boolean(object.proximity);
            if (object.xuid != null)
                if ($util.Long)
                    (message.xuid = $util.Long.fromValue(object.xuid)).unsigned = false;
                else if (typeof object.xuid === "string")
                    message.xuid = parseInt(object.xuid, 10);
                else if (typeof object.xuid === "number")
                    message.xuid = object.xuid;
                else if (typeof object.xuid === "object")
                    message.xuid = new $util.LongBits(object.xuid.low >>> 0, object.xuid.high >>> 0).toNumber();
            if (object.audibleMask != null)
                message.audibleMask = object.audibleMask | 0;
            if (object.tick != null)
                message.tick = object.tick >>> 0;
            if (object.passthrough != null)
                message.passthrough = object.passthrough | 0;
            return message;
        };
    
        /**
         * Creates a plain object from a CSVCMsg_VoiceData message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CSVCMsg_VoiceData
         * @static
         * @param {CSVCMsg_VoiceData} message CSVCMsg_VoiceData
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CSVCMsg_VoiceData.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.audio = null;
                object.client = -1;
                object.proximity = false;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.xuid = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.xuid = options.longs === String ? "0" : 0;
                object.audibleMask = 0;
                object.tick = 0;
                object.passthrough = 0;
            }
            if (message.audio != null && message.hasOwnProperty("audio"))
                object.audio = $root.CMsgVoiceAudio.toObject(message.audio, options);
            if (message.client != null && message.hasOwnProperty("client"))
                object.client = message.client;
            if (message.proximity != null && message.hasOwnProperty("proximity"))
                object.proximity = message.proximity;
            if (message.xuid != null && message.hasOwnProperty("xuid"))
                if (typeof message.xuid === "number")
                    object.xuid = options.longs === String ? String(message.xuid) : message.xuid;
                else
                    object.xuid = options.longs === String ? $util.Long.prototype.toString.call(message.xuid) : options.longs === Number ? new $util.LongBits(message.xuid.low >>> 0, message.xuid.high >>> 0).toNumber() : message.xuid;
            if (message.audibleMask != null && message.hasOwnProperty("audibleMask"))
                object.audibleMask = message.audibleMask;
            if (message.tick != null && message.hasOwnProperty("tick"))
                object.tick = message.tick;
            if (message.passthrough != null && message.hasOwnProperty("passthrough"))
                object.passthrough = message.passthrough;
            return object;
        };
    
        /**
         * Converts this CSVCMsg_VoiceData to JSON.
         * @function toJSON
         * @memberof CSVCMsg_VoiceData
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CSVCMsg_VoiceData.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * Gets the default type url for CSVCMsg_VoiceData
         * @function getTypeUrl
         * @memberof CSVCMsg_VoiceData
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        CSVCMsg_VoiceData.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/CSVCMsg_VoiceData";
        };
    
        return CSVCMsg_VoiceData;
    })();
    
    $root.CSVCMsg_PacketReliable = (function() {
    
        /**
         * Properties of a CSVCMsg_PacketReliable.
         * @exports ICSVCMsg_PacketReliable
         * @interface ICSVCMsg_PacketReliable
         * @property {number|null} [tick] CSVCMsg_PacketReliable tick
         * @property {number|null} [messagessize] CSVCMsg_PacketReliable messagessize
         * @property {boolean|null} [state] CSVCMsg_PacketReliable state
         */
    
        /**
         * Constructs a new CSVCMsg_PacketReliable.
         * @exports CSVCMsg_PacketReliable
         * @classdesc Represents a CSVCMsg_PacketReliable.
         * @implements ICSVCMsg_PacketReliable
         * @constructor
         * @param {ICSVCMsg_PacketReliable=} [properties] Properties to set
         */
        function CSVCMsg_PacketReliable(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CSVCMsg_PacketReliable tick.
         * @member {number} tick
         * @memberof CSVCMsg_PacketReliable
         * @instance
         */
        CSVCMsg_PacketReliable.prototype.tick = 0;
    
        /**
         * CSVCMsg_PacketReliable messagessize.
         * @member {number} messagessize
         * @memberof CSVCMsg_PacketReliable
         * @instance
         */
        CSVCMsg_PacketReliable.prototype.messagessize = 0;
    
        /**
         * CSVCMsg_PacketReliable state.
         * @member {boolean} state
         * @memberof CSVCMsg_PacketReliable
         * @instance
         */
        CSVCMsg_PacketReliable.prototype.state = false;
    
        /**
         * Creates a new CSVCMsg_PacketReliable instance using the specified properties.
         * @function create
         * @memberof CSVCMsg_PacketReliable
         * @static
         * @param {ICSVCMsg_PacketReliable=} [properties] Properties to set
         * @returns {CSVCMsg_PacketReliable} CSVCMsg_PacketReliable instance
         */
        CSVCMsg_PacketReliable.create = function create(properties) {
            return new CSVCMsg_PacketReliable(properties);
        };
    
        /**
         * Encodes the specified CSVCMsg_PacketReliable message. Does not implicitly {@link CSVCMsg_PacketReliable.verify|verify} messages.
         * @function encode
         * @memberof CSVCMsg_PacketReliable
         * @static
         * @param {ICSVCMsg_PacketReliable} message CSVCMsg_PacketReliable message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CSVCMsg_PacketReliable.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.tick != null && Object.hasOwnProperty.call(message, "tick"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.tick);
            if (message.messagessize != null && Object.hasOwnProperty.call(message, "messagessize"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.messagessize);
            if (message.state != null && Object.hasOwnProperty.call(message, "state"))
                writer.uint32(/* id 3, wireType 0 =*/24).bool(message.state);
            return writer;
        };
    
        /**
         * Encodes the specified CSVCMsg_PacketReliable message, length delimited. Does not implicitly {@link CSVCMsg_PacketReliable.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CSVCMsg_PacketReliable
         * @static
         * @param {ICSVCMsg_PacketReliable} message CSVCMsg_PacketReliable message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CSVCMsg_PacketReliable.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CSVCMsg_PacketReliable message from the specified reader or buffer.
         * @function decode
         * @memberof CSVCMsg_PacketReliable
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CSVCMsg_PacketReliable} CSVCMsg_PacketReliable
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CSVCMsg_PacketReliable.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CSVCMsg_PacketReliable();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.tick = reader.int32();
                        break;
                    }
                case 2: {
                        message.messagessize = reader.int32();
                        break;
                    }
                case 3: {
                        message.state = reader.bool();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CSVCMsg_PacketReliable message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CSVCMsg_PacketReliable
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CSVCMsg_PacketReliable} CSVCMsg_PacketReliable
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CSVCMsg_PacketReliable.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CSVCMsg_PacketReliable message.
         * @function verify
         * @memberof CSVCMsg_PacketReliable
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CSVCMsg_PacketReliable.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.tick != null && message.hasOwnProperty("tick"))
                if (!$util.isInteger(message.tick))
                    return "tick: integer expected";
            if (message.messagessize != null && message.hasOwnProperty("messagessize"))
                if (!$util.isInteger(message.messagessize))
                    return "messagessize: integer expected";
            if (message.state != null && message.hasOwnProperty("state"))
                if (typeof message.state !== "boolean")
                    return "state: boolean expected";
            return null;
        };
    
        /**
         * Creates a CSVCMsg_PacketReliable message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CSVCMsg_PacketReliable
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CSVCMsg_PacketReliable} CSVCMsg_PacketReliable
         */
        CSVCMsg_PacketReliable.fromObject = function fromObject(object) {
            if (object instanceof $root.CSVCMsg_PacketReliable)
                return object;
            var message = new $root.CSVCMsg_PacketReliable();
            if (object.tick != null)
                message.tick = object.tick | 0;
            if (object.messagessize != null)
                message.messagessize = object.messagessize | 0;
            if (object.state != null)
                message.state = Boolean(object.state);
            return message;
        };
    
        /**
         * Creates a plain object from a CSVCMsg_PacketReliable message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CSVCMsg_PacketReliable
         * @static
         * @param {CSVCMsg_PacketReliable} message CSVCMsg_PacketReliable
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CSVCMsg_PacketReliable.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.tick = 0;
                object.messagessize = 0;
                object.state = false;
            }
            if (message.tick != null && message.hasOwnProperty("tick"))
                object.tick = message.tick;
            if (message.messagessize != null && message.hasOwnProperty("messagessize"))
                object.messagessize = message.messagessize;
            if (message.state != null && message.hasOwnProperty("state"))
                object.state = message.state;
            return object;
        };
    
        /**
         * Converts this CSVCMsg_PacketReliable to JSON.
         * @function toJSON
         * @memberof CSVCMsg_PacketReliable
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CSVCMsg_PacketReliable.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * Gets the default type url for CSVCMsg_PacketReliable
         * @function getTypeUrl
         * @memberof CSVCMsg_PacketReliable
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        CSVCMsg_PacketReliable.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/CSVCMsg_PacketReliable";
        };
    
        return CSVCMsg_PacketReliable;
    })();
    
    $root.CSVCMsg_FullFrameSplit = (function() {
    
        /**
         * Properties of a CSVCMsg_FullFrameSplit.
         * @exports ICSVCMsg_FullFrameSplit
         * @interface ICSVCMsg_FullFrameSplit
         * @property {number|null} [tick] CSVCMsg_FullFrameSplit tick
         * @property {number|null} [section] CSVCMsg_FullFrameSplit section
         * @property {number|null} [total] CSVCMsg_FullFrameSplit total
         * @property {Uint8Array|null} [data] CSVCMsg_FullFrameSplit data
         */
    
        /**
         * Constructs a new CSVCMsg_FullFrameSplit.
         * @exports CSVCMsg_FullFrameSplit
         * @classdesc Represents a CSVCMsg_FullFrameSplit.
         * @implements ICSVCMsg_FullFrameSplit
         * @constructor
         * @param {ICSVCMsg_FullFrameSplit=} [properties] Properties to set
         */
        function CSVCMsg_FullFrameSplit(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CSVCMsg_FullFrameSplit tick.
         * @member {number} tick
         * @memberof CSVCMsg_FullFrameSplit
         * @instance
         */
        CSVCMsg_FullFrameSplit.prototype.tick = 0;
    
        /**
         * CSVCMsg_FullFrameSplit section.
         * @member {number} section
         * @memberof CSVCMsg_FullFrameSplit
         * @instance
         */
        CSVCMsg_FullFrameSplit.prototype.section = 0;
    
        /**
         * CSVCMsg_FullFrameSplit total.
         * @member {number} total
         * @memberof CSVCMsg_FullFrameSplit
         * @instance
         */
        CSVCMsg_FullFrameSplit.prototype.total = 0;
    
        /**
         * CSVCMsg_FullFrameSplit data.
         * @member {Uint8Array} data
         * @memberof CSVCMsg_FullFrameSplit
         * @instance
         */
        CSVCMsg_FullFrameSplit.prototype.data = $util.newBuffer([]);
    
        /**
         * Creates a new CSVCMsg_FullFrameSplit instance using the specified properties.
         * @function create
         * @memberof CSVCMsg_FullFrameSplit
         * @static
         * @param {ICSVCMsg_FullFrameSplit=} [properties] Properties to set
         * @returns {CSVCMsg_FullFrameSplit} CSVCMsg_FullFrameSplit instance
         */
        CSVCMsg_FullFrameSplit.create = function create(properties) {
            return new CSVCMsg_FullFrameSplit(properties);
        };
    
        /**
         * Encodes the specified CSVCMsg_FullFrameSplit message. Does not implicitly {@link CSVCMsg_FullFrameSplit.verify|verify} messages.
         * @function encode
         * @memberof CSVCMsg_FullFrameSplit
         * @static
         * @param {ICSVCMsg_FullFrameSplit} message CSVCMsg_FullFrameSplit message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CSVCMsg_FullFrameSplit.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.tick != null && Object.hasOwnProperty.call(message, "tick"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.tick);
            if (message.section != null && Object.hasOwnProperty.call(message, "section"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.section);
            if (message.total != null && Object.hasOwnProperty.call(message, "total"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.total);
            if (message.data != null && Object.hasOwnProperty.call(message, "data"))
                writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.data);
            return writer;
        };
    
        /**
         * Encodes the specified CSVCMsg_FullFrameSplit message, length delimited. Does not implicitly {@link CSVCMsg_FullFrameSplit.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CSVCMsg_FullFrameSplit
         * @static
         * @param {ICSVCMsg_FullFrameSplit} message CSVCMsg_FullFrameSplit message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CSVCMsg_FullFrameSplit.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CSVCMsg_FullFrameSplit message from the specified reader or buffer.
         * @function decode
         * @memberof CSVCMsg_FullFrameSplit
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CSVCMsg_FullFrameSplit} CSVCMsg_FullFrameSplit
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CSVCMsg_FullFrameSplit.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CSVCMsg_FullFrameSplit();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.tick = reader.int32();
                        break;
                    }
                case 2: {
                        message.section = reader.int32();
                        break;
                    }
                case 3: {
                        message.total = reader.int32();
                        break;
                    }
                case 4: {
                        message.data = reader.bytes();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CSVCMsg_FullFrameSplit message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CSVCMsg_FullFrameSplit
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CSVCMsg_FullFrameSplit} CSVCMsg_FullFrameSplit
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CSVCMsg_FullFrameSplit.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CSVCMsg_FullFrameSplit message.
         * @function verify
         * @memberof CSVCMsg_FullFrameSplit
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CSVCMsg_FullFrameSplit.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.tick != null && message.hasOwnProperty("tick"))
                if (!$util.isInteger(message.tick))
                    return "tick: integer expected";
            if (message.section != null && message.hasOwnProperty("section"))
                if (!$util.isInteger(message.section))
                    return "section: integer expected";
            if (message.total != null && message.hasOwnProperty("total"))
                if (!$util.isInteger(message.total))
                    return "total: integer expected";
            if (message.data != null && message.hasOwnProperty("data"))
                if (!(message.data && typeof message.data.length === "number" || $util.isString(message.data)))
                    return "data: buffer expected";
            return null;
        };
    
        /**
         * Creates a CSVCMsg_FullFrameSplit message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CSVCMsg_FullFrameSplit
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CSVCMsg_FullFrameSplit} CSVCMsg_FullFrameSplit
         */
        CSVCMsg_FullFrameSplit.fromObject = function fromObject(object) {
            if (object instanceof $root.CSVCMsg_FullFrameSplit)
                return object;
            var message = new $root.CSVCMsg_FullFrameSplit();
            if (object.tick != null)
                message.tick = object.tick | 0;
            if (object.section != null)
                message.section = object.section | 0;
            if (object.total != null)
                message.total = object.total | 0;
            if (object.data != null)
                if (typeof object.data === "string")
                    $util.base64.decode(object.data, message.data = $util.newBuffer($util.base64.length(object.data)), 0);
                else if (object.data.length >= 0)
                    message.data = object.data;
            return message;
        };
    
        /**
         * Creates a plain object from a CSVCMsg_FullFrameSplit message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CSVCMsg_FullFrameSplit
         * @static
         * @param {CSVCMsg_FullFrameSplit} message CSVCMsg_FullFrameSplit
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CSVCMsg_FullFrameSplit.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.tick = 0;
                object.section = 0;
                object.total = 0;
                if (options.bytes === String)
                    object.data = "";
                else {
                    object.data = [];
                    if (options.bytes !== Array)
                        object.data = $util.newBuffer(object.data);
                }
            }
            if (message.tick != null && message.hasOwnProperty("tick"))
                object.tick = message.tick;
            if (message.section != null && message.hasOwnProperty("section"))
                object.section = message.section;
            if (message.total != null && message.hasOwnProperty("total"))
                object.total = message.total;
            if (message.data != null && message.hasOwnProperty("data"))
                object.data = options.bytes === String ? $util.base64.encode(message.data, 0, message.data.length) : options.bytes === Array ? Array.prototype.slice.call(message.data) : message.data;
            return object;
        };
    
        /**
         * Converts this CSVCMsg_FullFrameSplit to JSON.
         * @function toJSON
         * @memberof CSVCMsg_FullFrameSplit
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CSVCMsg_FullFrameSplit.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * Gets the default type url for CSVCMsg_FullFrameSplit
         * @function getTypeUrl
         * @memberof CSVCMsg_FullFrameSplit
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        CSVCMsg_FullFrameSplit.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/CSVCMsg_FullFrameSplit";
        };
    
        return CSVCMsg_FullFrameSplit;
    })();
    
    $root.CSVCMsg_HLTVStatus = (function() {
    
        /**
         * Properties of a CSVCMsg_HLTVStatus.
         * @exports ICSVCMsg_HLTVStatus
         * @interface ICSVCMsg_HLTVStatus
         * @property {string|null} [master] CSVCMsg_HLTVStatus master
         * @property {number|null} [clients] CSVCMsg_HLTVStatus clients
         * @property {number|null} [slots] CSVCMsg_HLTVStatus slots
         * @property {number|null} [proxies] CSVCMsg_HLTVStatus proxies
         */
    
        /**
         * Constructs a new CSVCMsg_HLTVStatus.
         * @exports CSVCMsg_HLTVStatus
         * @classdesc Represents a CSVCMsg_HLTVStatus.
         * @implements ICSVCMsg_HLTVStatus
         * @constructor
         * @param {ICSVCMsg_HLTVStatus=} [properties] Properties to set
         */
        function CSVCMsg_HLTVStatus(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CSVCMsg_HLTVStatus master.
         * @member {string} master
         * @memberof CSVCMsg_HLTVStatus
         * @instance
         */
        CSVCMsg_HLTVStatus.prototype.master = "";
    
        /**
         * CSVCMsg_HLTVStatus clients.
         * @member {number} clients
         * @memberof CSVCMsg_HLTVStatus
         * @instance
         */
        CSVCMsg_HLTVStatus.prototype.clients = 0;
    
        /**
         * CSVCMsg_HLTVStatus slots.
         * @member {number} slots
         * @memberof CSVCMsg_HLTVStatus
         * @instance
         */
        CSVCMsg_HLTVStatus.prototype.slots = 0;
    
        /**
         * CSVCMsg_HLTVStatus proxies.
         * @member {number} proxies
         * @memberof CSVCMsg_HLTVStatus
         * @instance
         */
        CSVCMsg_HLTVStatus.prototype.proxies = 0;
    
        /**
         * Creates a new CSVCMsg_HLTVStatus instance using the specified properties.
         * @function create
         * @memberof CSVCMsg_HLTVStatus
         * @static
         * @param {ICSVCMsg_HLTVStatus=} [properties] Properties to set
         * @returns {CSVCMsg_HLTVStatus} CSVCMsg_HLTVStatus instance
         */
        CSVCMsg_HLTVStatus.create = function create(properties) {
            return new CSVCMsg_HLTVStatus(properties);
        };
    
        /**
         * Encodes the specified CSVCMsg_HLTVStatus message. Does not implicitly {@link CSVCMsg_HLTVStatus.verify|verify} messages.
         * @function encode
         * @memberof CSVCMsg_HLTVStatus
         * @static
         * @param {ICSVCMsg_HLTVStatus} message CSVCMsg_HLTVStatus message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CSVCMsg_HLTVStatus.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.master != null && Object.hasOwnProperty.call(message, "master"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.master);
            if (message.clients != null && Object.hasOwnProperty.call(message, "clients"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.clients);
            if (message.slots != null && Object.hasOwnProperty.call(message, "slots"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.slots);
            if (message.proxies != null && Object.hasOwnProperty.call(message, "proxies"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.proxies);
            return writer;
        };
    
        /**
         * Encodes the specified CSVCMsg_HLTVStatus message, length delimited. Does not implicitly {@link CSVCMsg_HLTVStatus.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CSVCMsg_HLTVStatus
         * @static
         * @param {ICSVCMsg_HLTVStatus} message CSVCMsg_HLTVStatus message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CSVCMsg_HLTVStatus.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CSVCMsg_HLTVStatus message from the specified reader or buffer.
         * @function decode
         * @memberof CSVCMsg_HLTVStatus
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CSVCMsg_HLTVStatus} CSVCMsg_HLTVStatus
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CSVCMsg_HLTVStatus.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CSVCMsg_HLTVStatus();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.master = reader.string();
                        break;
                    }
                case 2: {
                        message.clients = reader.int32();
                        break;
                    }
                case 3: {
                        message.slots = reader.int32();
                        break;
                    }
                case 4: {
                        message.proxies = reader.int32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CSVCMsg_HLTVStatus message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CSVCMsg_HLTVStatus
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CSVCMsg_HLTVStatus} CSVCMsg_HLTVStatus
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CSVCMsg_HLTVStatus.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CSVCMsg_HLTVStatus message.
         * @function verify
         * @memberof CSVCMsg_HLTVStatus
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CSVCMsg_HLTVStatus.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.master != null && message.hasOwnProperty("master"))
                if (!$util.isString(message.master))
                    return "master: string expected";
            if (message.clients != null && message.hasOwnProperty("clients"))
                if (!$util.isInteger(message.clients))
                    return "clients: integer expected";
            if (message.slots != null && message.hasOwnProperty("slots"))
                if (!$util.isInteger(message.slots))
                    return "slots: integer expected";
            if (message.proxies != null && message.hasOwnProperty("proxies"))
                if (!$util.isInteger(message.proxies))
                    return "proxies: integer expected";
            return null;
        };
    
        /**
         * Creates a CSVCMsg_HLTVStatus message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CSVCMsg_HLTVStatus
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CSVCMsg_HLTVStatus} CSVCMsg_HLTVStatus
         */
        CSVCMsg_HLTVStatus.fromObject = function fromObject(object) {
            if (object instanceof $root.CSVCMsg_HLTVStatus)
                return object;
            var message = new $root.CSVCMsg_HLTVStatus();
            if (object.master != null)
                message.master = String(object.master);
            if (object.clients != null)
                message.clients = object.clients | 0;
            if (object.slots != null)
                message.slots = object.slots | 0;
            if (object.proxies != null)
                message.proxies = object.proxies | 0;
            return message;
        };
    
        /**
         * Creates a plain object from a CSVCMsg_HLTVStatus message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CSVCMsg_HLTVStatus
         * @static
         * @param {CSVCMsg_HLTVStatus} message CSVCMsg_HLTVStatus
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CSVCMsg_HLTVStatus.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.master = "";
                object.clients = 0;
                object.slots = 0;
                object.proxies = 0;
            }
            if (message.master != null && message.hasOwnProperty("master"))
                object.master = message.master;
            if (message.clients != null && message.hasOwnProperty("clients"))
                object.clients = message.clients;
            if (message.slots != null && message.hasOwnProperty("slots"))
                object.slots = message.slots;
            if (message.proxies != null && message.hasOwnProperty("proxies"))
                object.proxies = message.proxies;
            return object;
        };
    
        /**
         * Converts this CSVCMsg_HLTVStatus to JSON.
         * @function toJSON
         * @memberof CSVCMsg_HLTVStatus
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CSVCMsg_HLTVStatus.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * Gets the default type url for CSVCMsg_HLTVStatus
         * @function getTypeUrl
         * @memberof CSVCMsg_HLTVStatus
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        CSVCMsg_HLTVStatus.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/CSVCMsg_HLTVStatus";
        };
    
        return CSVCMsg_HLTVStatus;
    })();
    
    $root.CSVCMsg_ServerSteamID = (function() {
    
        /**
         * Properties of a CSVCMsg_ServerSteamID.
         * @exports ICSVCMsg_ServerSteamID
         * @interface ICSVCMsg_ServerSteamID
         * @property {number|Long|null} [steamId] CSVCMsg_ServerSteamID steamId
         */
    
        /**
         * Constructs a new CSVCMsg_ServerSteamID.
         * @exports CSVCMsg_ServerSteamID
         * @classdesc Represents a CSVCMsg_ServerSteamID.
         * @implements ICSVCMsg_ServerSteamID
         * @constructor
         * @param {ICSVCMsg_ServerSteamID=} [properties] Properties to set
         */
        function CSVCMsg_ServerSteamID(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CSVCMsg_ServerSteamID steamId.
         * @member {number|Long} steamId
         * @memberof CSVCMsg_ServerSteamID
         * @instance
         */
        CSVCMsg_ServerSteamID.prototype.steamId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
        /**
         * Creates a new CSVCMsg_ServerSteamID instance using the specified properties.
         * @function create
         * @memberof CSVCMsg_ServerSteamID
         * @static
         * @param {ICSVCMsg_ServerSteamID=} [properties] Properties to set
         * @returns {CSVCMsg_ServerSteamID} CSVCMsg_ServerSteamID instance
         */
        CSVCMsg_ServerSteamID.create = function create(properties) {
            return new CSVCMsg_ServerSteamID(properties);
        };
    
        /**
         * Encodes the specified CSVCMsg_ServerSteamID message. Does not implicitly {@link CSVCMsg_ServerSteamID.verify|verify} messages.
         * @function encode
         * @memberof CSVCMsg_ServerSteamID
         * @static
         * @param {ICSVCMsg_ServerSteamID} message CSVCMsg_ServerSteamID message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CSVCMsg_ServerSteamID.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.steamId != null && Object.hasOwnProperty.call(message, "steamId"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.steamId);
            return writer;
        };
    
        /**
         * Encodes the specified CSVCMsg_ServerSteamID message, length delimited. Does not implicitly {@link CSVCMsg_ServerSteamID.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CSVCMsg_ServerSteamID
         * @static
         * @param {ICSVCMsg_ServerSteamID} message CSVCMsg_ServerSteamID message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CSVCMsg_ServerSteamID.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CSVCMsg_ServerSteamID message from the specified reader or buffer.
         * @function decode
         * @memberof CSVCMsg_ServerSteamID
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CSVCMsg_ServerSteamID} CSVCMsg_ServerSteamID
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CSVCMsg_ServerSteamID.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CSVCMsg_ServerSteamID();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.steamId = reader.uint64();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CSVCMsg_ServerSteamID message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CSVCMsg_ServerSteamID
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CSVCMsg_ServerSteamID} CSVCMsg_ServerSteamID
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CSVCMsg_ServerSteamID.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CSVCMsg_ServerSteamID message.
         * @function verify
         * @memberof CSVCMsg_ServerSteamID
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CSVCMsg_ServerSteamID.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.steamId != null && message.hasOwnProperty("steamId"))
                if (!$util.isInteger(message.steamId) && !(message.steamId && $util.isInteger(message.steamId.low) && $util.isInteger(message.steamId.high)))
                    return "steamId: integer|Long expected";
            return null;
        };
    
        /**
         * Creates a CSVCMsg_ServerSteamID message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CSVCMsg_ServerSteamID
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CSVCMsg_ServerSteamID} CSVCMsg_ServerSteamID
         */
        CSVCMsg_ServerSteamID.fromObject = function fromObject(object) {
            if (object instanceof $root.CSVCMsg_ServerSteamID)
                return object;
            var message = new $root.CSVCMsg_ServerSteamID();
            if (object.steamId != null)
                if ($util.Long)
                    (message.steamId = $util.Long.fromValue(object.steamId)).unsigned = true;
                else if (typeof object.steamId === "string")
                    message.steamId = parseInt(object.steamId, 10);
                else if (typeof object.steamId === "number")
                    message.steamId = object.steamId;
                else if (typeof object.steamId === "object")
                    message.steamId = new $util.LongBits(object.steamId.low >>> 0, object.steamId.high >>> 0).toNumber(true);
            return message;
        };
    
        /**
         * Creates a plain object from a CSVCMsg_ServerSteamID message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CSVCMsg_ServerSteamID
         * @static
         * @param {CSVCMsg_ServerSteamID} message CSVCMsg_ServerSteamID
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CSVCMsg_ServerSteamID.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.steamId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.steamId = options.longs === String ? "0" : 0;
            if (message.steamId != null && message.hasOwnProperty("steamId"))
                if (typeof message.steamId === "number")
                    object.steamId = options.longs === String ? String(message.steamId) : message.steamId;
                else
                    object.steamId = options.longs === String ? $util.Long.prototype.toString.call(message.steamId) : options.longs === Number ? new $util.LongBits(message.steamId.low >>> 0, message.steamId.high >>> 0).toNumber(true) : message.steamId;
            return object;
        };
    
        /**
         * Converts this CSVCMsg_ServerSteamID to JSON.
         * @function toJSON
         * @memberof CSVCMsg_ServerSteamID
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CSVCMsg_ServerSteamID.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * Gets the default type url for CSVCMsg_ServerSteamID
         * @function getTypeUrl
         * @memberof CSVCMsg_ServerSteamID
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        CSVCMsg_ServerSteamID.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/CSVCMsg_ServerSteamID";
        };
    
        return CSVCMsg_ServerSteamID;
    })();
    
    $root.CSVCMsg_CmdKeyValues = (function() {
    
        /**
         * Properties of a CSVCMsg_CmdKeyValues.
         * @exports ICSVCMsg_CmdKeyValues
         * @interface ICSVCMsg_CmdKeyValues
         * @property {Uint8Array|null} [data] CSVCMsg_CmdKeyValues data
         */
    
        /**
         * Constructs a new CSVCMsg_CmdKeyValues.
         * @exports CSVCMsg_CmdKeyValues
         * @classdesc Represents a CSVCMsg_CmdKeyValues.
         * @implements ICSVCMsg_CmdKeyValues
         * @constructor
         * @param {ICSVCMsg_CmdKeyValues=} [properties] Properties to set
         */
        function CSVCMsg_CmdKeyValues(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CSVCMsg_CmdKeyValues data.
         * @member {Uint8Array} data
         * @memberof CSVCMsg_CmdKeyValues
         * @instance
         */
        CSVCMsg_CmdKeyValues.prototype.data = $util.newBuffer([]);
    
        /**
         * Creates a new CSVCMsg_CmdKeyValues instance using the specified properties.
         * @function create
         * @memberof CSVCMsg_CmdKeyValues
         * @static
         * @param {ICSVCMsg_CmdKeyValues=} [properties] Properties to set
         * @returns {CSVCMsg_CmdKeyValues} CSVCMsg_CmdKeyValues instance
         */
        CSVCMsg_CmdKeyValues.create = function create(properties) {
            return new CSVCMsg_CmdKeyValues(properties);
        };
    
        /**
         * Encodes the specified CSVCMsg_CmdKeyValues message. Does not implicitly {@link CSVCMsg_CmdKeyValues.verify|verify} messages.
         * @function encode
         * @memberof CSVCMsg_CmdKeyValues
         * @static
         * @param {ICSVCMsg_CmdKeyValues} message CSVCMsg_CmdKeyValues message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CSVCMsg_CmdKeyValues.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.data != null && Object.hasOwnProperty.call(message, "data"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.data);
            return writer;
        };
    
        /**
         * Encodes the specified CSVCMsg_CmdKeyValues message, length delimited. Does not implicitly {@link CSVCMsg_CmdKeyValues.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CSVCMsg_CmdKeyValues
         * @static
         * @param {ICSVCMsg_CmdKeyValues} message CSVCMsg_CmdKeyValues message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CSVCMsg_CmdKeyValues.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CSVCMsg_CmdKeyValues message from the specified reader or buffer.
         * @function decode
         * @memberof CSVCMsg_CmdKeyValues
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CSVCMsg_CmdKeyValues} CSVCMsg_CmdKeyValues
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CSVCMsg_CmdKeyValues.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CSVCMsg_CmdKeyValues();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.data = reader.bytes();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CSVCMsg_CmdKeyValues message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CSVCMsg_CmdKeyValues
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CSVCMsg_CmdKeyValues} CSVCMsg_CmdKeyValues
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CSVCMsg_CmdKeyValues.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CSVCMsg_CmdKeyValues message.
         * @function verify
         * @memberof CSVCMsg_CmdKeyValues
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CSVCMsg_CmdKeyValues.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.data != null && message.hasOwnProperty("data"))
                if (!(message.data && typeof message.data.length === "number" || $util.isString(message.data)))
                    return "data: buffer expected";
            return null;
        };
    
        /**
         * Creates a CSVCMsg_CmdKeyValues message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CSVCMsg_CmdKeyValues
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CSVCMsg_CmdKeyValues} CSVCMsg_CmdKeyValues
         */
        CSVCMsg_CmdKeyValues.fromObject = function fromObject(object) {
            if (object instanceof $root.CSVCMsg_CmdKeyValues)
                return object;
            var message = new $root.CSVCMsg_CmdKeyValues();
            if (object.data != null)
                if (typeof object.data === "string")
                    $util.base64.decode(object.data, message.data = $util.newBuffer($util.base64.length(object.data)), 0);
                else if (object.data.length >= 0)
                    message.data = object.data;
            return message;
        };
    
        /**
         * Creates a plain object from a CSVCMsg_CmdKeyValues message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CSVCMsg_CmdKeyValues
         * @static
         * @param {CSVCMsg_CmdKeyValues} message CSVCMsg_CmdKeyValues
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CSVCMsg_CmdKeyValues.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                if (options.bytes === String)
                    object.data = "";
                else {
                    object.data = [];
                    if (options.bytes !== Array)
                        object.data = $util.newBuffer(object.data);
                }
            if (message.data != null && message.hasOwnProperty("data"))
                object.data = options.bytes === String ? $util.base64.encode(message.data, 0, message.data.length) : options.bytes === Array ? Array.prototype.slice.call(message.data) : message.data;
            return object;
        };
    
        /**
         * Converts this CSVCMsg_CmdKeyValues to JSON.
         * @function toJSON
         * @memberof CSVCMsg_CmdKeyValues
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CSVCMsg_CmdKeyValues.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * Gets the default type url for CSVCMsg_CmdKeyValues
         * @function getTypeUrl
         * @memberof CSVCMsg_CmdKeyValues
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        CSVCMsg_CmdKeyValues.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/CSVCMsg_CmdKeyValues";
        };
    
        return CSVCMsg_CmdKeyValues;
    })();
    
    $root.CSVCMsg_RconServerDetails = (function() {
    
        /**
         * Properties of a CSVCMsg_RconServerDetails.
         * @exports ICSVCMsg_RconServerDetails
         * @interface ICSVCMsg_RconServerDetails
         * @property {Uint8Array|null} [token] CSVCMsg_RconServerDetails token
         * @property {string|null} [details] CSVCMsg_RconServerDetails details
         */
    
        /**
         * Constructs a new CSVCMsg_RconServerDetails.
         * @exports CSVCMsg_RconServerDetails
         * @classdesc Represents a CSVCMsg_RconServerDetails.
         * @implements ICSVCMsg_RconServerDetails
         * @constructor
         * @param {ICSVCMsg_RconServerDetails=} [properties] Properties to set
         */
        function CSVCMsg_RconServerDetails(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CSVCMsg_RconServerDetails token.
         * @member {Uint8Array} token
         * @memberof CSVCMsg_RconServerDetails
         * @instance
         */
        CSVCMsg_RconServerDetails.prototype.token = $util.newBuffer([]);
    
        /**
         * CSVCMsg_RconServerDetails details.
         * @member {string} details
         * @memberof CSVCMsg_RconServerDetails
         * @instance
         */
        CSVCMsg_RconServerDetails.prototype.details = "";
    
        /**
         * Creates a new CSVCMsg_RconServerDetails instance using the specified properties.
         * @function create
         * @memberof CSVCMsg_RconServerDetails
         * @static
         * @param {ICSVCMsg_RconServerDetails=} [properties] Properties to set
         * @returns {CSVCMsg_RconServerDetails} CSVCMsg_RconServerDetails instance
         */
        CSVCMsg_RconServerDetails.create = function create(properties) {
            return new CSVCMsg_RconServerDetails(properties);
        };
    
        /**
         * Encodes the specified CSVCMsg_RconServerDetails message. Does not implicitly {@link CSVCMsg_RconServerDetails.verify|verify} messages.
         * @function encode
         * @memberof CSVCMsg_RconServerDetails
         * @static
         * @param {ICSVCMsg_RconServerDetails} message CSVCMsg_RconServerDetails message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CSVCMsg_RconServerDetails.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.token != null && Object.hasOwnProperty.call(message, "token"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.token);
            if (message.details != null && Object.hasOwnProperty.call(message, "details"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.details);
            return writer;
        };
    
        /**
         * Encodes the specified CSVCMsg_RconServerDetails message, length delimited. Does not implicitly {@link CSVCMsg_RconServerDetails.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CSVCMsg_RconServerDetails
         * @static
         * @param {ICSVCMsg_RconServerDetails} message CSVCMsg_RconServerDetails message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CSVCMsg_RconServerDetails.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CSVCMsg_RconServerDetails message from the specified reader or buffer.
         * @function decode
         * @memberof CSVCMsg_RconServerDetails
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CSVCMsg_RconServerDetails} CSVCMsg_RconServerDetails
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CSVCMsg_RconServerDetails.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CSVCMsg_RconServerDetails();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.token = reader.bytes();
                        break;
                    }
                case 2: {
                        message.details = reader.string();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CSVCMsg_RconServerDetails message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CSVCMsg_RconServerDetails
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CSVCMsg_RconServerDetails} CSVCMsg_RconServerDetails
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CSVCMsg_RconServerDetails.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CSVCMsg_RconServerDetails message.
         * @function verify
         * @memberof CSVCMsg_RconServerDetails
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CSVCMsg_RconServerDetails.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.token != null && message.hasOwnProperty("token"))
                if (!(message.token && typeof message.token.length === "number" || $util.isString(message.token)))
                    return "token: buffer expected";
            if (message.details != null && message.hasOwnProperty("details"))
                if (!$util.isString(message.details))
                    return "details: string expected";
            return null;
        };
    
        /**
         * Creates a CSVCMsg_RconServerDetails message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CSVCMsg_RconServerDetails
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CSVCMsg_RconServerDetails} CSVCMsg_RconServerDetails
         */
        CSVCMsg_RconServerDetails.fromObject = function fromObject(object) {
            if (object instanceof $root.CSVCMsg_RconServerDetails)
                return object;
            var message = new $root.CSVCMsg_RconServerDetails();
            if (object.token != null)
                if (typeof object.token === "string")
                    $util.base64.decode(object.token, message.token = $util.newBuffer($util.base64.length(object.token)), 0);
                else if (object.token.length >= 0)
                    message.token = object.token;
            if (object.details != null)
                message.details = String(object.details);
            return message;
        };
    
        /**
         * Creates a plain object from a CSVCMsg_RconServerDetails message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CSVCMsg_RconServerDetails
         * @static
         * @param {CSVCMsg_RconServerDetails} message CSVCMsg_RconServerDetails
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CSVCMsg_RconServerDetails.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if (options.bytes === String)
                    object.token = "";
                else {
                    object.token = [];
                    if (options.bytes !== Array)
                        object.token = $util.newBuffer(object.token);
                }
                object.details = "";
            }
            if (message.token != null && message.hasOwnProperty("token"))
                object.token = options.bytes === String ? $util.base64.encode(message.token, 0, message.token.length) : options.bytes === Array ? Array.prototype.slice.call(message.token) : message.token;
            if (message.details != null && message.hasOwnProperty("details"))
                object.details = message.details;
            return object;
        };
    
        /**
         * Converts this CSVCMsg_RconServerDetails to JSON.
         * @function toJSON
         * @memberof CSVCMsg_RconServerDetails
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CSVCMsg_RconServerDetails.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * Gets the default type url for CSVCMsg_RconServerDetails
         * @function getTypeUrl
         * @memberof CSVCMsg_RconServerDetails
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        CSVCMsg_RconServerDetails.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/CSVCMsg_RconServerDetails";
        };
    
        return CSVCMsg_RconServerDetails;
    })();
    
    $root.CMsgIPCAddress = (function() {
    
        /**
         * Properties of a CMsgIPCAddress.
         * @exports ICMsgIPCAddress
         * @interface ICMsgIPCAddress
         * @property {number|Long|null} [computerGuid] CMsgIPCAddress computerGuid
         * @property {number|null} [processId] CMsgIPCAddress processId
         */
    
        /**
         * Constructs a new CMsgIPCAddress.
         * @exports CMsgIPCAddress
         * @classdesc Represents a CMsgIPCAddress.
         * @implements ICMsgIPCAddress
         * @constructor
         * @param {ICMsgIPCAddress=} [properties] Properties to set
         */
        function CMsgIPCAddress(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CMsgIPCAddress computerGuid.
         * @member {number|Long} computerGuid
         * @memberof CMsgIPCAddress
         * @instance
         */
        CMsgIPCAddress.prototype.computerGuid = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
        /**
         * CMsgIPCAddress processId.
         * @member {number} processId
         * @memberof CMsgIPCAddress
         * @instance
         */
        CMsgIPCAddress.prototype.processId = 0;
    
        /**
         * Creates a new CMsgIPCAddress instance using the specified properties.
         * @function create
         * @memberof CMsgIPCAddress
         * @static
         * @param {ICMsgIPCAddress=} [properties] Properties to set
         * @returns {CMsgIPCAddress} CMsgIPCAddress instance
         */
        CMsgIPCAddress.create = function create(properties) {
            return new CMsgIPCAddress(properties);
        };
    
        /**
         * Encodes the specified CMsgIPCAddress message. Does not implicitly {@link CMsgIPCAddress.verify|verify} messages.
         * @function encode
         * @memberof CMsgIPCAddress
         * @static
         * @param {ICMsgIPCAddress} message CMsgIPCAddress message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CMsgIPCAddress.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.computerGuid != null && Object.hasOwnProperty.call(message, "computerGuid"))
                writer.uint32(/* id 1, wireType 1 =*/9).fixed64(message.computerGuid);
            if (message.processId != null && Object.hasOwnProperty.call(message, "processId"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.processId);
            return writer;
        };
    
        /**
         * Encodes the specified CMsgIPCAddress message, length delimited. Does not implicitly {@link CMsgIPCAddress.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CMsgIPCAddress
         * @static
         * @param {ICMsgIPCAddress} message CMsgIPCAddress message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CMsgIPCAddress.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CMsgIPCAddress message from the specified reader or buffer.
         * @function decode
         * @memberof CMsgIPCAddress
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CMsgIPCAddress} CMsgIPCAddress
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CMsgIPCAddress.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgIPCAddress();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.computerGuid = reader.fixed64();
                        break;
                    }
                case 2: {
                        message.processId = reader.uint32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CMsgIPCAddress message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CMsgIPCAddress
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CMsgIPCAddress} CMsgIPCAddress
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CMsgIPCAddress.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CMsgIPCAddress message.
         * @function verify
         * @memberof CMsgIPCAddress
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CMsgIPCAddress.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.computerGuid != null && message.hasOwnProperty("computerGuid"))
                if (!$util.isInteger(message.computerGuid) && !(message.computerGuid && $util.isInteger(message.computerGuid.low) && $util.isInteger(message.computerGuid.high)))
                    return "computerGuid: integer|Long expected";
            if (message.processId != null && message.hasOwnProperty("processId"))
                if (!$util.isInteger(message.processId))
                    return "processId: integer expected";
            return null;
        };
    
        /**
         * Creates a CMsgIPCAddress message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CMsgIPCAddress
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CMsgIPCAddress} CMsgIPCAddress
         */
        CMsgIPCAddress.fromObject = function fromObject(object) {
            if (object instanceof $root.CMsgIPCAddress)
                return object;
            var message = new $root.CMsgIPCAddress();
            if (object.computerGuid != null)
                if ($util.Long)
                    (message.computerGuid = $util.Long.fromValue(object.computerGuid)).unsigned = false;
                else if (typeof object.computerGuid === "string")
                    message.computerGuid = parseInt(object.computerGuid, 10);
                else if (typeof object.computerGuid === "number")
                    message.computerGuid = object.computerGuid;
                else if (typeof object.computerGuid === "object")
                    message.computerGuid = new $util.LongBits(object.computerGuid.low >>> 0, object.computerGuid.high >>> 0).toNumber();
            if (object.processId != null)
                message.processId = object.processId >>> 0;
            return message;
        };
    
        /**
         * Creates a plain object from a CMsgIPCAddress message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CMsgIPCAddress
         * @static
         * @param {CMsgIPCAddress} message CMsgIPCAddress
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CMsgIPCAddress.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.computerGuid = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.computerGuid = options.longs === String ? "0" : 0;
                object.processId = 0;
            }
            if (message.computerGuid != null && message.hasOwnProperty("computerGuid"))
                if (typeof message.computerGuid === "number")
                    object.computerGuid = options.longs === String ? String(message.computerGuid) : message.computerGuid;
                else
                    object.computerGuid = options.longs === String ? $util.Long.prototype.toString.call(message.computerGuid) : options.longs === Number ? new $util.LongBits(message.computerGuid.low >>> 0, message.computerGuid.high >>> 0).toNumber() : message.computerGuid;
            if (message.processId != null && message.hasOwnProperty("processId"))
                object.processId = message.processId;
            return object;
        };
    
        /**
         * Converts this CMsgIPCAddress to JSON.
         * @function toJSON
         * @memberof CMsgIPCAddress
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CMsgIPCAddress.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * Gets the default type url for CMsgIPCAddress
         * @function getTypeUrl
         * @memberof CMsgIPCAddress
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        CMsgIPCAddress.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/CMsgIPCAddress";
        };
    
        return CMsgIPCAddress;
    })();
    
    $root.CMsgServerPeer = (function() {
    
        /**
         * Properties of a CMsgServerPeer.
         * @exports ICMsgServerPeer
         * @interface ICMsgServerPeer
         * @property {number|null} [playerSlot] CMsgServerPeer playerSlot
         * @property {number|Long|null} [steamid] CMsgServerPeer steamid
         * @property {ICMsgIPCAddress|null} [ipc] CMsgServerPeer ipc
         * @property {boolean|null} [theyHearYou] CMsgServerPeer theyHearYou
         * @property {boolean|null} [youHearThem] CMsgServerPeer youHearThem
         * @property {boolean|null} [isListenserverHost] CMsgServerPeer isListenserverHost
         */
    
        /**
         * Constructs a new CMsgServerPeer.
         * @exports CMsgServerPeer
         * @classdesc Represents a CMsgServerPeer.
         * @implements ICMsgServerPeer
         * @constructor
         * @param {ICMsgServerPeer=} [properties] Properties to set
         */
        function CMsgServerPeer(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CMsgServerPeer playerSlot.
         * @member {number} playerSlot
         * @memberof CMsgServerPeer
         * @instance
         */
        CMsgServerPeer.prototype.playerSlot = -1;
    
        /**
         * CMsgServerPeer steamid.
         * @member {number|Long} steamid
         * @memberof CMsgServerPeer
         * @instance
         */
        CMsgServerPeer.prototype.steamid = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
        /**
         * CMsgServerPeer ipc.
         * @member {ICMsgIPCAddress|null|undefined} ipc
         * @memberof CMsgServerPeer
         * @instance
         */
        CMsgServerPeer.prototype.ipc = null;
    
        /**
         * CMsgServerPeer theyHearYou.
         * @member {boolean} theyHearYou
         * @memberof CMsgServerPeer
         * @instance
         */
        CMsgServerPeer.prototype.theyHearYou = false;
    
        /**
         * CMsgServerPeer youHearThem.
         * @member {boolean} youHearThem
         * @memberof CMsgServerPeer
         * @instance
         */
        CMsgServerPeer.prototype.youHearThem = false;
    
        /**
         * CMsgServerPeer isListenserverHost.
         * @member {boolean} isListenserverHost
         * @memberof CMsgServerPeer
         * @instance
         */
        CMsgServerPeer.prototype.isListenserverHost = false;
    
        /**
         * Creates a new CMsgServerPeer instance using the specified properties.
         * @function create
         * @memberof CMsgServerPeer
         * @static
         * @param {ICMsgServerPeer=} [properties] Properties to set
         * @returns {CMsgServerPeer} CMsgServerPeer instance
         */
        CMsgServerPeer.create = function create(properties) {
            return new CMsgServerPeer(properties);
        };
    
        /**
         * Encodes the specified CMsgServerPeer message. Does not implicitly {@link CMsgServerPeer.verify|verify} messages.
         * @function encode
         * @memberof CMsgServerPeer
         * @static
         * @param {ICMsgServerPeer} message CMsgServerPeer message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CMsgServerPeer.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.playerSlot != null && Object.hasOwnProperty.call(message, "playerSlot"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.playerSlot);
            if (message.steamid != null && Object.hasOwnProperty.call(message, "steamid"))
                writer.uint32(/* id 2, wireType 1 =*/17).fixed64(message.steamid);
            if (message.ipc != null && Object.hasOwnProperty.call(message, "ipc"))
                $root.CMsgIPCAddress.encode(message.ipc, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.theyHearYou != null && Object.hasOwnProperty.call(message, "theyHearYou"))
                writer.uint32(/* id 4, wireType 0 =*/32).bool(message.theyHearYou);
            if (message.youHearThem != null && Object.hasOwnProperty.call(message, "youHearThem"))
                writer.uint32(/* id 5, wireType 0 =*/40).bool(message.youHearThem);
            if (message.isListenserverHost != null && Object.hasOwnProperty.call(message, "isListenserverHost"))
                writer.uint32(/* id 6, wireType 0 =*/48).bool(message.isListenserverHost);
            return writer;
        };
    
        /**
         * Encodes the specified CMsgServerPeer message, length delimited. Does not implicitly {@link CMsgServerPeer.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CMsgServerPeer
         * @static
         * @param {ICMsgServerPeer} message CMsgServerPeer message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CMsgServerPeer.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CMsgServerPeer message from the specified reader or buffer.
         * @function decode
         * @memberof CMsgServerPeer
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CMsgServerPeer} CMsgServerPeer
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CMsgServerPeer.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgServerPeer();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.playerSlot = reader.int32();
                        break;
                    }
                case 2: {
                        message.steamid = reader.fixed64();
                        break;
                    }
                case 3: {
                        message.ipc = $root.CMsgIPCAddress.decode(reader, reader.uint32());
                        break;
                    }
                case 4: {
                        message.theyHearYou = reader.bool();
                        break;
                    }
                case 5: {
                        message.youHearThem = reader.bool();
                        break;
                    }
                case 6: {
                        message.isListenserverHost = reader.bool();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CMsgServerPeer message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CMsgServerPeer
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CMsgServerPeer} CMsgServerPeer
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CMsgServerPeer.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CMsgServerPeer message.
         * @function verify
         * @memberof CMsgServerPeer
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CMsgServerPeer.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.playerSlot != null && message.hasOwnProperty("playerSlot"))
                if (!$util.isInteger(message.playerSlot))
                    return "playerSlot: integer expected";
            if (message.steamid != null && message.hasOwnProperty("steamid"))
                if (!$util.isInteger(message.steamid) && !(message.steamid && $util.isInteger(message.steamid.low) && $util.isInteger(message.steamid.high)))
                    return "steamid: integer|Long expected";
            if (message.ipc != null && message.hasOwnProperty("ipc")) {
                var error = $root.CMsgIPCAddress.verify(message.ipc);
                if (error)
                    return "ipc." + error;
            }
            if (message.theyHearYou != null && message.hasOwnProperty("theyHearYou"))
                if (typeof message.theyHearYou !== "boolean")
                    return "theyHearYou: boolean expected";
            if (message.youHearThem != null && message.hasOwnProperty("youHearThem"))
                if (typeof message.youHearThem !== "boolean")
                    return "youHearThem: boolean expected";
            if (message.isListenserverHost != null && message.hasOwnProperty("isListenserverHost"))
                if (typeof message.isListenserverHost !== "boolean")
                    return "isListenserverHost: boolean expected";
            return null;
        };
    
        /**
         * Creates a CMsgServerPeer message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CMsgServerPeer
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CMsgServerPeer} CMsgServerPeer
         */
        CMsgServerPeer.fromObject = function fromObject(object) {
            if (object instanceof $root.CMsgServerPeer)
                return object;
            var message = new $root.CMsgServerPeer();
            if (object.playerSlot != null)
                message.playerSlot = object.playerSlot | 0;
            if (object.steamid != null)
                if ($util.Long)
                    (message.steamid = $util.Long.fromValue(object.steamid)).unsigned = false;
                else if (typeof object.steamid === "string")
                    message.steamid = parseInt(object.steamid, 10);
                else if (typeof object.steamid === "number")
                    message.steamid = object.steamid;
                else if (typeof object.steamid === "object")
                    message.steamid = new $util.LongBits(object.steamid.low >>> 0, object.steamid.high >>> 0).toNumber();
            if (object.ipc != null) {
                if (typeof object.ipc !== "object")
                    throw TypeError(".CMsgServerPeer.ipc: object expected");
                message.ipc = $root.CMsgIPCAddress.fromObject(object.ipc);
            }
            if (object.theyHearYou != null)
                message.theyHearYou = Boolean(object.theyHearYou);
            if (object.youHearThem != null)
                message.youHearThem = Boolean(object.youHearThem);
            if (object.isListenserverHost != null)
                message.isListenserverHost = Boolean(object.isListenserverHost);
            return message;
        };
    
        /**
         * Creates a plain object from a CMsgServerPeer message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CMsgServerPeer
         * @static
         * @param {CMsgServerPeer} message CMsgServerPeer
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CMsgServerPeer.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.playerSlot = -1;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.steamid = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.steamid = options.longs === String ? "0" : 0;
                object.ipc = null;
                object.theyHearYou = false;
                object.youHearThem = false;
                object.isListenserverHost = false;
            }
            if (message.playerSlot != null && message.hasOwnProperty("playerSlot"))
                object.playerSlot = message.playerSlot;
            if (message.steamid != null && message.hasOwnProperty("steamid"))
                if (typeof message.steamid === "number")
                    object.steamid = options.longs === String ? String(message.steamid) : message.steamid;
                else
                    object.steamid = options.longs === String ? $util.Long.prototype.toString.call(message.steamid) : options.longs === Number ? new $util.LongBits(message.steamid.low >>> 0, message.steamid.high >>> 0).toNumber() : message.steamid;
            if (message.ipc != null && message.hasOwnProperty("ipc"))
                object.ipc = $root.CMsgIPCAddress.toObject(message.ipc, options);
            if (message.theyHearYou != null && message.hasOwnProperty("theyHearYou"))
                object.theyHearYou = message.theyHearYou;
            if (message.youHearThem != null && message.hasOwnProperty("youHearThem"))
                object.youHearThem = message.youHearThem;
            if (message.isListenserverHost != null && message.hasOwnProperty("isListenserverHost"))
                object.isListenserverHost = message.isListenserverHost;
            return object;
        };
    
        /**
         * Converts this CMsgServerPeer to JSON.
         * @function toJSON
         * @memberof CMsgServerPeer
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CMsgServerPeer.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * Gets the default type url for CMsgServerPeer
         * @function getTypeUrl
         * @memberof CMsgServerPeer
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        CMsgServerPeer.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/CMsgServerPeer";
        };
    
        return CMsgServerPeer;
    })();
    
    $root.CSVCMsg_PeerList = (function() {
    
        /**
         * Properties of a CSVCMsg_PeerList.
         * @exports ICSVCMsg_PeerList
         * @interface ICSVCMsg_PeerList
         * @property {Array.<ICMsgServerPeer>|null} [peer] CSVCMsg_PeerList peer
         */
    
        /**
         * Constructs a new CSVCMsg_PeerList.
         * @exports CSVCMsg_PeerList
         * @classdesc Represents a CSVCMsg_PeerList.
         * @implements ICSVCMsg_PeerList
         * @constructor
         * @param {ICSVCMsg_PeerList=} [properties] Properties to set
         */
        function CSVCMsg_PeerList(properties) {
            this.peer = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CSVCMsg_PeerList peer.
         * @member {Array.<ICMsgServerPeer>} peer
         * @memberof CSVCMsg_PeerList
         * @instance
         */
        CSVCMsg_PeerList.prototype.peer = $util.emptyArray;
    
        /**
         * Creates a new CSVCMsg_PeerList instance using the specified properties.
         * @function create
         * @memberof CSVCMsg_PeerList
         * @static
         * @param {ICSVCMsg_PeerList=} [properties] Properties to set
         * @returns {CSVCMsg_PeerList} CSVCMsg_PeerList instance
         */
        CSVCMsg_PeerList.create = function create(properties) {
            return new CSVCMsg_PeerList(properties);
        };
    
        /**
         * Encodes the specified CSVCMsg_PeerList message. Does not implicitly {@link CSVCMsg_PeerList.verify|verify} messages.
         * @function encode
         * @memberof CSVCMsg_PeerList
         * @static
         * @param {ICSVCMsg_PeerList} message CSVCMsg_PeerList message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CSVCMsg_PeerList.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.peer != null && message.peer.length)
                for (var i = 0; i < message.peer.length; ++i)
                    $root.CMsgServerPeer.encode(message.peer[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };
    
        /**
         * Encodes the specified CSVCMsg_PeerList message, length delimited. Does not implicitly {@link CSVCMsg_PeerList.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CSVCMsg_PeerList
         * @static
         * @param {ICSVCMsg_PeerList} message CSVCMsg_PeerList message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CSVCMsg_PeerList.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CSVCMsg_PeerList message from the specified reader or buffer.
         * @function decode
         * @memberof CSVCMsg_PeerList
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CSVCMsg_PeerList} CSVCMsg_PeerList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CSVCMsg_PeerList.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CSVCMsg_PeerList();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        if (!(message.peer && message.peer.length))
                            message.peer = [];
                        message.peer.push($root.CMsgServerPeer.decode(reader, reader.uint32()));
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CSVCMsg_PeerList message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CSVCMsg_PeerList
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CSVCMsg_PeerList} CSVCMsg_PeerList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CSVCMsg_PeerList.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CSVCMsg_PeerList message.
         * @function verify
         * @memberof CSVCMsg_PeerList
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CSVCMsg_PeerList.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.peer != null && message.hasOwnProperty("peer")) {
                if (!Array.isArray(message.peer))
                    return "peer: array expected";
                for (var i = 0; i < message.peer.length; ++i) {
                    var error = $root.CMsgServerPeer.verify(message.peer[i]);
                    if (error)
                        return "peer." + error;
                }
            }
            return null;
        };
    
        /**
         * Creates a CSVCMsg_PeerList message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CSVCMsg_PeerList
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CSVCMsg_PeerList} CSVCMsg_PeerList
         */
        CSVCMsg_PeerList.fromObject = function fromObject(object) {
            if (object instanceof $root.CSVCMsg_PeerList)
                return object;
            var message = new $root.CSVCMsg_PeerList();
            if (object.peer) {
                if (!Array.isArray(object.peer))
                    throw TypeError(".CSVCMsg_PeerList.peer: array expected");
                message.peer = [];
                for (var i = 0; i < object.peer.length; ++i) {
                    if (typeof object.peer[i] !== "object")
                        throw TypeError(".CSVCMsg_PeerList.peer: object expected");
                    message.peer[i] = $root.CMsgServerPeer.fromObject(object.peer[i]);
                }
            }
            return message;
        };
    
        /**
         * Creates a plain object from a CSVCMsg_PeerList message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CSVCMsg_PeerList
         * @static
         * @param {CSVCMsg_PeerList} message CSVCMsg_PeerList
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CSVCMsg_PeerList.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.peer = [];
            if (message.peer && message.peer.length) {
                object.peer = [];
                for (var j = 0; j < message.peer.length; ++j)
                    object.peer[j] = $root.CMsgServerPeer.toObject(message.peer[j], options);
            }
            return object;
        };
    
        /**
         * Converts this CSVCMsg_PeerList to JSON.
         * @function toJSON
         * @memberof CSVCMsg_PeerList
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CSVCMsg_PeerList.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * Gets the default type url for CSVCMsg_PeerList
         * @function getTypeUrl
         * @memberof CSVCMsg_PeerList
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        CSVCMsg_PeerList.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/CSVCMsg_PeerList";
        };
    
        return CSVCMsg_PeerList;
    })();
    
    $root.CSVCMsg_ClearAllStringTables = (function() {
    
        /**
         * Properties of a CSVCMsg_ClearAllStringTables.
         * @exports ICSVCMsg_ClearAllStringTables
         * @interface ICSVCMsg_ClearAllStringTables
         * @property {string|null} [mapname] CSVCMsg_ClearAllStringTables mapname
         * @property {boolean|null} [createTablesSkipped] CSVCMsg_ClearAllStringTables createTablesSkipped
         */
    
        /**
         * Constructs a new CSVCMsg_ClearAllStringTables.
         * @exports CSVCMsg_ClearAllStringTables
         * @classdesc Represents a CSVCMsg_ClearAllStringTables.
         * @implements ICSVCMsg_ClearAllStringTables
         * @constructor
         * @param {ICSVCMsg_ClearAllStringTables=} [properties] Properties to set
         */
        function CSVCMsg_ClearAllStringTables(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CSVCMsg_ClearAllStringTables mapname.
         * @member {string} mapname
         * @memberof CSVCMsg_ClearAllStringTables
         * @instance
         */
        CSVCMsg_ClearAllStringTables.prototype.mapname = "";
    
        /**
         * CSVCMsg_ClearAllStringTables createTablesSkipped.
         * @member {boolean} createTablesSkipped
         * @memberof CSVCMsg_ClearAllStringTables
         * @instance
         */
        CSVCMsg_ClearAllStringTables.prototype.createTablesSkipped = false;
    
        /**
         * Creates a new CSVCMsg_ClearAllStringTables instance using the specified properties.
         * @function create
         * @memberof CSVCMsg_ClearAllStringTables
         * @static
         * @param {ICSVCMsg_ClearAllStringTables=} [properties] Properties to set
         * @returns {CSVCMsg_ClearAllStringTables} CSVCMsg_ClearAllStringTables instance
         */
        CSVCMsg_ClearAllStringTables.create = function create(properties) {
            return new CSVCMsg_ClearAllStringTables(properties);
        };
    
        /**
         * Encodes the specified CSVCMsg_ClearAllStringTables message. Does not implicitly {@link CSVCMsg_ClearAllStringTables.verify|verify} messages.
         * @function encode
         * @memberof CSVCMsg_ClearAllStringTables
         * @static
         * @param {ICSVCMsg_ClearAllStringTables} message CSVCMsg_ClearAllStringTables message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CSVCMsg_ClearAllStringTables.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.mapname != null && Object.hasOwnProperty.call(message, "mapname"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.mapname);
            if (message.createTablesSkipped != null && Object.hasOwnProperty.call(message, "createTablesSkipped"))
                writer.uint32(/* id 3, wireType 0 =*/24).bool(message.createTablesSkipped);
            return writer;
        };
    
        /**
         * Encodes the specified CSVCMsg_ClearAllStringTables message, length delimited. Does not implicitly {@link CSVCMsg_ClearAllStringTables.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CSVCMsg_ClearAllStringTables
         * @static
         * @param {ICSVCMsg_ClearAllStringTables} message CSVCMsg_ClearAllStringTables message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CSVCMsg_ClearAllStringTables.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CSVCMsg_ClearAllStringTables message from the specified reader or buffer.
         * @function decode
         * @memberof CSVCMsg_ClearAllStringTables
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CSVCMsg_ClearAllStringTables} CSVCMsg_ClearAllStringTables
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CSVCMsg_ClearAllStringTables.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CSVCMsg_ClearAllStringTables();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.mapname = reader.string();
                        break;
                    }
                case 3: {
                        message.createTablesSkipped = reader.bool();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CSVCMsg_ClearAllStringTables message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CSVCMsg_ClearAllStringTables
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CSVCMsg_ClearAllStringTables} CSVCMsg_ClearAllStringTables
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CSVCMsg_ClearAllStringTables.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CSVCMsg_ClearAllStringTables message.
         * @function verify
         * @memberof CSVCMsg_ClearAllStringTables
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CSVCMsg_ClearAllStringTables.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.mapname != null && message.hasOwnProperty("mapname"))
                if (!$util.isString(message.mapname))
                    return "mapname: string expected";
            if (message.createTablesSkipped != null && message.hasOwnProperty("createTablesSkipped"))
                if (typeof message.createTablesSkipped !== "boolean")
                    return "createTablesSkipped: boolean expected";
            return null;
        };
    
        /**
         * Creates a CSVCMsg_ClearAllStringTables message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CSVCMsg_ClearAllStringTables
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CSVCMsg_ClearAllStringTables} CSVCMsg_ClearAllStringTables
         */
        CSVCMsg_ClearAllStringTables.fromObject = function fromObject(object) {
            if (object instanceof $root.CSVCMsg_ClearAllStringTables)
                return object;
            var message = new $root.CSVCMsg_ClearAllStringTables();
            if (object.mapname != null)
                message.mapname = String(object.mapname);
            if (object.createTablesSkipped != null)
                message.createTablesSkipped = Boolean(object.createTablesSkipped);
            return message;
        };
    
        /**
         * Creates a plain object from a CSVCMsg_ClearAllStringTables message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CSVCMsg_ClearAllStringTables
         * @static
         * @param {CSVCMsg_ClearAllStringTables} message CSVCMsg_ClearAllStringTables
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CSVCMsg_ClearAllStringTables.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.mapname = "";
                object.createTablesSkipped = false;
            }
            if (message.mapname != null && message.hasOwnProperty("mapname"))
                object.mapname = message.mapname;
            if (message.createTablesSkipped != null && message.hasOwnProperty("createTablesSkipped"))
                object.createTablesSkipped = message.createTablesSkipped;
            return object;
        };
    
        /**
         * Converts this CSVCMsg_ClearAllStringTables to JSON.
         * @function toJSON
         * @memberof CSVCMsg_ClearAllStringTables
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CSVCMsg_ClearAllStringTables.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * Gets the default type url for CSVCMsg_ClearAllStringTables
         * @function getTypeUrl
         * @memberof CSVCMsg_ClearAllStringTables
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        CSVCMsg_ClearAllStringTables.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/CSVCMsg_ClearAllStringTables";
        };
    
        return CSVCMsg_ClearAllStringTables;
    })();
    
    $root.ProtoFlattenedSerializerField_t = (function() {
    
        /**
         * Properties of a ProtoFlattenedSerializerField_t.
         * @exports IProtoFlattenedSerializerField_t
         * @interface IProtoFlattenedSerializerField_t
         * @property {number|null} [varTypeSym] ProtoFlattenedSerializerField_t varTypeSym
         * @property {number|null} [varNameSym] ProtoFlattenedSerializerField_t varNameSym
         * @property {number|null} [bitCount] ProtoFlattenedSerializerField_t bitCount
         * @property {number|null} [lowValue] ProtoFlattenedSerializerField_t lowValue
         * @property {number|null} [highValue] ProtoFlattenedSerializerField_t highValue
         * @property {number|null} [encodeFlags] ProtoFlattenedSerializerField_t encodeFlags
         * @property {number|null} [fieldSerializerNameSym] ProtoFlattenedSerializerField_t fieldSerializerNameSym
         * @property {number|null} [fieldSerializerVersion] ProtoFlattenedSerializerField_t fieldSerializerVersion
         * @property {number|null} [sendNodeSym] ProtoFlattenedSerializerField_t sendNodeSym
         * @property {number|null} [varEncoderSym] ProtoFlattenedSerializerField_t varEncoderSym
         * @property {Array.<ProtoFlattenedSerializerField_t.Ipolymorphic_field_t>|null} [polymorphicTypes] ProtoFlattenedSerializerField_t polymorphicTypes
         */
    
        /**
         * Constructs a new ProtoFlattenedSerializerField_t.
         * @exports ProtoFlattenedSerializerField_t
         * @classdesc Represents a ProtoFlattenedSerializerField_t.
         * @implements IProtoFlattenedSerializerField_t
         * @constructor
         * @param {IProtoFlattenedSerializerField_t=} [properties] Properties to set
         */
        function ProtoFlattenedSerializerField_t(properties) {
            this.polymorphicTypes = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * ProtoFlattenedSerializerField_t varTypeSym.
         * @member {number} varTypeSym
         * @memberof ProtoFlattenedSerializerField_t
         * @instance
         */
        ProtoFlattenedSerializerField_t.prototype.varTypeSym = 0;
    
        /**
         * ProtoFlattenedSerializerField_t varNameSym.
         * @member {number} varNameSym
         * @memberof ProtoFlattenedSerializerField_t
         * @instance
         */
        ProtoFlattenedSerializerField_t.prototype.varNameSym = 0;
    
        /**
         * ProtoFlattenedSerializerField_t bitCount.
         * @member {number} bitCount
         * @memberof ProtoFlattenedSerializerField_t
         * @instance
         */
        ProtoFlattenedSerializerField_t.prototype.bitCount = 0;
    
        /**
         * ProtoFlattenedSerializerField_t lowValue.
         * @member {number} lowValue
         * @memberof ProtoFlattenedSerializerField_t
         * @instance
         */
        ProtoFlattenedSerializerField_t.prototype.lowValue = 0;
    
        /**
         * ProtoFlattenedSerializerField_t highValue.
         * @member {number} highValue
         * @memberof ProtoFlattenedSerializerField_t
         * @instance
         */
        ProtoFlattenedSerializerField_t.prototype.highValue = 0;
    
        /**
         * ProtoFlattenedSerializerField_t encodeFlags.
         * @member {number} encodeFlags
         * @memberof ProtoFlattenedSerializerField_t
         * @instance
         */
        ProtoFlattenedSerializerField_t.prototype.encodeFlags = 0;
    
        /**
         * ProtoFlattenedSerializerField_t fieldSerializerNameSym.
         * @member {number} fieldSerializerNameSym
         * @memberof ProtoFlattenedSerializerField_t
         * @instance
         */
        ProtoFlattenedSerializerField_t.prototype.fieldSerializerNameSym = 0;
    
        /**
         * ProtoFlattenedSerializerField_t fieldSerializerVersion.
         * @member {number} fieldSerializerVersion
         * @memberof ProtoFlattenedSerializerField_t
         * @instance
         */
        ProtoFlattenedSerializerField_t.prototype.fieldSerializerVersion = 0;
    
        /**
         * ProtoFlattenedSerializerField_t sendNodeSym.
         * @member {number} sendNodeSym
         * @memberof ProtoFlattenedSerializerField_t
         * @instance
         */
        ProtoFlattenedSerializerField_t.prototype.sendNodeSym = 0;
    
        /**
         * ProtoFlattenedSerializerField_t varEncoderSym.
         * @member {number} varEncoderSym
         * @memberof ProtoFlattenedSerializerField_t
         * @instance
         */
        ProtoFlattenedSerializerField_t.prototype.varEncoderSym = 0;
    
        /**
         * ProtoFlattenedSerializerField_t polymorphicTypes.
         * @member {Array.<ProtoFlattenedSerializerField_t.Ipolymorphic_field_t>} polymorphicTypes
         * @memberof ProtoFlattenedSerializerField_t
         * @instance
         */
        ProtoFlattenedSerializerField_t.prototype.polymorphicTypes = $util.emptyArray;
    
        /**
         * Creates a new ProtoFlattenedSerializerField_t instance using the specified properties.
         * @function create
         * @memberof ProtoFlattenedSerializerField_t
         * @static
         * @param {IProtoFlattenedSerializerField_t=} [properties] Properties to set
         * @returns {ProtoFlattenedSerializerField_t} ProtoFlattenedSerializerField_t instance
         */
        ProtoFlattenedSerializerField_t.create = function create(properties) {
            return new ProtoFlattenedSerializerField_t(properties);
        };
    
        /**
         * Encodes the specified ProtoFlattenedSerializerField_t message. Does not implicitly {@link ProtoFlattenedSerializerField_t.verify|verify} messages.
         * @function encode
         * @memberof ProtoFlattenedSerializerField_t
         * @static
         * @param {IProtoFlattenedSerializerField_t} message ProtoFlattenedSerializerField_t message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ProtoFlattenedSerializerField_t.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.varTypeSym != null && Object.hasOwnProperty.call(message, "varTypeSym"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.varTypeSym);
            if (message.varNameSym != null && Object.hasOwnProperty.call(message, "varNameSym"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.varNameSym);
            if (message.bitCount != null && Object.hasOwnProperty.call(message, "bitCount"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.bitCount);
            if (message.lowValue != null && Object.hasOwnProperty.call(message, "lowValue"))
                writer.uint32(/* id 4, wireType 5 =*/37).float(message.lowValue);
            if (message.highValue != null && Object.hasOwnProperty.call(message, "highValue"))
                writer.uint32(/* id 5, wireType 5 =*/45).float(message.highValue);
            if (message.encodeFlags != null && Object.hasOwnProperty.call(message, "encodeFlags"))
                writer.uint32(/* id 6, wireType 0 =*/48).int32(message.encodeFlags);
            if (message.fieldSerializerNameSym != null && Object.hasOwnProperty.call(message, "fieldSerializerNameSym"))
                writer.uint32(/* id 7, wireType 0 =*/56).int32(message.fieldSerializerNameSym);
            if (message.fieldSerializerVersion != null && Object.hasOwnProperty.call(message, "fieldSerializerVersion"))
                writer.uint32(/* id 8, wireType 0 =*/64).int32(message.fieldSerializerVersion);
            if (message.sendNodeSym != null && Object.hasOwnProperty.call(message, "sendNodeSym"))
                writer.uint32(/* id 9, wireType 0 =*/72).int32(message.sendNodeSym);
            if (message.varEncoderSym != null && Object.hasOwnProperty.call(message, "varEncoderSym"))
                writer.uint32(/* id 10, wireType 0 =*/80).int32(message.varEncoderSym);
            if (message.polymorphicTypes != null && message.polymorphicTypes.length)
                for (var i = 0; i < message.polymorphicTypes.length; ++i)
                    $root.ProtoFlattenedSerializerField_t.polymorphic_field_t.encode(message.polymorphicTypes[i], writer.uint32(/* id 11, wireType 2 =*/90).fork()).ldelim();
            return writer;
        };
    
        /**
         * Encodes the specified ProtoFlattenedSerializerField_t message, length delimited. Does not implicitly {@link ProtoFlattenedSerializerField_t.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ProtoFlattenedSerializerField_t
         * @static
         * @param {IProtoFlattenedSerializerField_t} message ProtoFlattenedSerializerField_t message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ProtoFlattenedSerializerField_t.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a ProtoFlattenedSerializerField_t message from the specified reader or buffer.
         * @function decode
         * @memberof ProtoFlattenedSerializerField_t
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ProtoFlattenedSerializerField_t} ProtoFlattenedSerializerField_t
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ProtoFlattenedSerializerField_t.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ProtoFlattenedSerializerField_t();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.varTypeSym = reader.int32();
                        break;
                    }
                case 2: {
                        message.varNameSym = reader.int32();
                        break;
                    }
                case 3: {
                        message.bitCount = reader.int32();
                        break;
                    }
                case 4: {
                        message.lowValue = reader.float();
                        break;
                    }
                case 5: {
                        message.highValue = reader.float();
                        break;
                    }
                case 6: {
                        message.encodeFlags = reader.int32();
                        break;
                    }
                case 7: {
                        message.fieldSerializerNameSym = reader.int32();
                        break;
                    }
                case 8: {
                        message.fieldSerializerVersion = reader.int32();
                        break;
                    }
                case 9: {
                        message.sendNodeSym = reader.int32();
                        break;
                    }
                case 10: {
                        message.varEncoderSym = reader.int32();
                        break;
                    }
                case 11: {
                        if (!(message.polymorphicTypes && message.polymorphicTypes.length))
                            message.polymorphicTypes = [];
                        message.polymorphicTypes.push($root.ProtoFlattenedSerializerField_t.polymorphic_field_t.decode(reader, reader.uint32()));
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a ProtoFlattenedSerializerField_t message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ProtoFlattenedSerializerField_t
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ProtoFlattenedSerializerField_t} ProtoFlattenedSerializerField_t
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ProtoFlattenedSerializerField_t.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a ProtoFlattenedSerializerField_t message.
         * @function verify
         * @memberof ProtoFlattenedSerializerField_t
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ProtoFlattenedSerializerField_t.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.varTypeSym != null && message.hasOwnProperty("varTypeSym"))
                if (!$util.isInteger(message.varTypeSym))
                    return "varTypeSym: integer expected";
            if (message.varNameSym != null && message.hasOwnProperty("varNameSym"))
                if (!$util.isInteger(message.varNameSym))
                    return "varNameSym: integer expected";
            if (message.bitCount != null && message.hasOwnProperty("bitCount"))
                if (!$util.isInteger(message.bitCount))
                    return "bitCount: integer expected";
            if (message.lowValue != null && message.hasOwnProperty("lowValue"))
                if (typeof message.lowValue !== "number")
                    return "lowValue: number expected";
            if (message.highValue != null && message.hasOwnProperty("highValue"))
                if (typeof message.highValue !== "number")
                    return "highValue: number expected";
            if (message.encodeFlags != null && message.hasOwnProperty("encodeFlags"))
                if (!$util.isInteger(message.encodeFlags))
                    return "encodeFlags: integer expected";
            if (message.fieldSerializerNameSym != null && message.hasOwnProperty("fieldSerializerNameSym"))
                if (!$util.isInteger(message.fieldSerializerNameSym))
                    return "fieldSerializerNameSym: integer expected";
            if (message.fieldSerializerVersion != null && message.hasOwnProperty("fieldSerializerVersion"))
                if (!$util.isInteger(message.fieldSerializerVersion))
                    return "fieldSerializerVersion: integer expected";
            if (message.sendNodeSym != null && message.hasOwnProperty("sendNodeSym"))
                if (!$util.isInteger(message.sendNodeSym))
                    return "sendNodeSym: integer expected";
            if (message.varEncoderSym != null && message.hasOwnProperty("varEncoderSym"))
                if (!$util.isInteger(message.varEncoderSym))
                    return "varEncoderSym: integer expected";
            if (message.polymorphicTypes != null && message.hasOwnProperty("polymorphicTypes")) {
                if (!Array.isArray(message.polymorphicTypes))
                    return "polymorphicTypes: array expected";
                for (var i = 0; i < message.polymorphicTypes.length; ++i) {
                    var error = $root.ProtoFlattenedSerializerField_t.polymorphic_field_t.verify(message.polymorphicTypes[i]);
                    if (error)
                        return "polymorphicTypes." + error;
                }
            }
            return null;
        };
    
        /**
         * Creates a ProtoFlattenedSerializerField_t message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ProtoFlattenedSerializerField_t
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ProtoFlattenedSerializerField_t} ProtoFlattenedSerializerField_t
         */
        ProtoFlattenedSerializerField_t.fromObject = function fromObject(object) {
            if (object instanceof $root.ProtoFlattenedSerializerField_t)
                return object;
            var message = new $root.ProtoFlattenedSerializerField_t();
            if (object.varTypeSym != null)
                message.varTypeSym = object.varTypeSym | 0;
            if (object.varNameSym != null)
                message.varNameSym = object.varNameSym | 0;
            if (object.bitCount != null)
                message.bitCount = object.bitCount | 0;
            if (object.lowValue != null)
                message.lowValue = Number(object.lowValue);
            if (object.highValue != null)
                message.highValue = Number(object.highValue);
            if (object.encodeFlags != null)
                message.encodeFlags = object.encodeFlags | 0;
            if (object.fieldSerializerNameSym != null)
                message.fieldSerializerNameSym = object.fieldSerializerNameSym | 0;
            if (object.fieldSerializerVersion != null)
                message.fieldSerializerVersion = object.fieldSerializerVersion | 0;
            if (object.sendNodeSym != null)
                message.sendNodeSym = object.sendNodeSym | 0;
            if (object.varEncoderSym != null)
                message.varEncoderSym = object.varEncoderSym | 0;
            if (object.polymorphicTypes) {
                if (!Array.isArray(object.polymorphicTypes))
                    throw TypeError(".ProtoFlattenedSerializerField_t.polymorphicTypes: array expected");
                message.polymorphicTypes = [];
                for (var i = 0; i < object.polymorphicTypes.length; ++i) {
                    if (typeof object.polymorphicTypes[i] !== "object")
                        throw TypeError(".ProtoFlattenedSerializerField_t.polymorphicTypes: object expected");
                    message.polymorphicTypes[i] = $root.ProtoFlattenedSerializerField_t.polymorphic_field_t.fromObject(object.polymorphicTypes[i]);
                }
            }
            return message;
        };
    
        /**
         * Creates a plain object from a ProtoFlattenedSerializerField_t message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ProtoFlattenedSerializerField_t
         * @static
         * @param {ProtoFlattenedSerializerField_t} message ProtoFlattenedSerializerField_t
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ProtoFlattenedSerializerField_t.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.polymorphicTypes = [];
            if (options.defaults) {
                object.varTypeSym = 0;
                object.varNameSym = 0;
                object.bitCount = 0;
                object.lowValue = 0;
                object.highValue = 0;
                object.encodeFlags = 0;
                object.fieldSerializerNameSym = 0;
                object.fieldSerializerVersion = 0;
                object.sendNodeSym = 0;
                object.varEncoderSym = 0;
            }
            if (message.varTypeSym != null && message.hasOwnProperty("varTypeSym"))
                object.varTypeSym = message.varTypeSym;
            if (message.varNameSym != null && message.hasOwnProperty("varNameSym"))
                object.varNameSym = message.varNameSym;
            if (message.bitCount != null && message.hasOwnProperty("bitCount"))
                object.bitCount = message.bitCount;
            if (message.lowValue != null && message.hasOwnProperty("lowValue"))
                object.lowValue = options.json && !isFinite(message.lowValue) ? String(message.lowValue) : message.lowValue;
            if (message.highValue != null && message.hasOwnProperty("highValue"))
                object.highValue = options.json && !isFinite(message.highValue) ? String(message.highValue) : message.highValue;
            if (message.encodeFlags != null && message.hasOwnProperty("encodeFlags"))
                object.encodeFlags = message.encodeFlags;
            if (message.fieldSerializerNameSym != null && message.hasOwnProperty("fieldSerializerNameSym"))
                object.fieldSerializerNameSym = message.fieldSerializerNameSym;
            if (message.fieldSerializerVersion != null && message.hasOwnProperty("fieldSerializerVersion"))
                object.fieldSerializerVersion = message.fieldSerializerVersion;
            if (message.sendNodeSym != null && message.hasOwnProperty("sendNodeSym"))
                object.sendNodeSym = message.sendNodeSym;
            if (message.varEncoderSym != null && message.hasOwnProperty("varEncoderSym"))
                object.varEncoderSym = message.varEncoderSym;
            if (message.polymorphicTypes && message.polymorphicTypes.length) {
                object.polymorphicTypes = [];
                for (var j = 0; j < message.polymorphicTypes.length; ++j)
                    object.polymorphicTypes[j] = $root.ProtoFlattenedSerializerField_t.polymorphic_field_t.toObject(message.polymorphicTypes[j], options);
            }
            return object;
        };
    
        /**
         * Converts this ProtoFlattenedSerializerField_t to JSON.
         * @function toJSON
         * @memberof ProtoFlattenedSerializerField_t
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ProtoFlattenedSerializerField_t.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * Gets the default type url for ProtoFlattenedSerializerField_t
         * @function getTypeUrl
         * @memberof ProtoFlattenedSerializerField_t
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        ProtoFlattenedSerializerField_t.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/ProtoFlattenedSerializerField_t";
        };
    
        ProtoFlattenedSerializerField_t.polymorphic_field_t = (function() {
    
            /**
             * Properties of a polymorphic_field_t.
             * @memberof ProtoFlattenedSerializerField_t
             * @interface Ipolymorphic_field_t
             * @property {number|null} [polymorphicFieldSerializerNameSym] polymorphic_field_t polymorphicFieldSerializerNameSym
             * @property {number|null} [polymorphicFieldSerializerVersion] polymorphic_field_t polymorphicFieldSerializerVersion
             */
    
            /**
             * Constructs a new polymorphic_field_t.
             * @memberof ProtoFlattenedSerializerField_t
             * @classdesc Represents a polymorphic_field_t.
             * @implements Ipolymorphic_field_t
             * @constructor
             * @param {ProtoFlattenedSerializerField_t.Ipolymorphic_field_t=} [properties] Properties to set
             */
            function polymorphic_field_t(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * polymorphic_field_t polymorphicFieldSerializerNameSym.
             * @member {number} polymorphicFieldSerializerNameSym
             * @memberof ProtoFlattenedSerializerField_t.polymorphic_field_t
             * @instance
             */
            polymorphic_field_t.prototype.polymorphicFieldSerializerNameSym = 0;
    
            /**
             * polymorphic_field_t polymorphicFieldSerializerVersion.
             * @member {number} polymorphicFieldSerializerVersion
             * @memberof ProtoFlattenedSerializerField_t.polymorphic_field_t
             * @instance
             */
            polymorphic_field_t.prototype.polymorphicFieldSerializerVersion = 0;
    
            /**
             * Creates a new polymorphic_field_t instance using the specified properties.
             * @function create
             * @memberof ProtoFlattenedSerializerField_t.polymorphic_field_t
             * @static
             * @param {ProtoFlattenedSerializerField_t.Ipolymorphic_field_t=} [properties] Properties to set
             * @returns {ProtoFlattenedSerializerField_t.polymorphic_field_t} polymorphic_field_t instance
             */
            polymorphic_field_t.create = function create(properties) {
                return new polymorphic_field_t(properties);
            };
    
            /**
             * Encodes the specified polymorphic_field_t message. Does not implicitly {@link ProtoFlattenedSerializerField_t.polymorphic_field_t.verify|verify} messages.
             * @function encode
             * @memberof ProtoFlattenedSerializerField_t.polymorphic_field_t
             * @static
             * @param {ProtoFlattenedSerializerField_t.Ipolymorphic_field_t} message polymorphic_field_t message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            polymorphic_field_t.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.polymorphicFieldSerializerNameSym != null && Object.hasOwnProperty.call(message, "polymorphicFieldSerializerNameSym"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.polymorphicFieldSerializerNameSym);
                if (message.polymorphicFieldSerializerVersion != null && Object.hasOwnProperty.call(message, "polymorphicFieldSerializerVersion"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.polymorphicFieldSerializerVersion);
                return writer;
            };
    
            /**
             * Encodes the specified polymorphic_field_t message, length delimited. Does not implicitly {@link ProtoFlattenedSerializerField_t.polymorphic_field_t.verify|verify} messages.
             * @function encodeDelimited
             * @memberof ProtoFlattenedSerializerField_t.polymorphic_field_t
             * @static
             * @param {ProtoFlattenedSerializerField_t.Ipolymorphic_field_t} message polymorphic_field_t message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            polymorphic_field_t.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a polymorphic_field_t message from the specified reader or buffer.
             * @function decode
             * @memberof ProtoFlattenedSerializerField_t.polymorphic_field_t
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {ProtoFlattenedSerializerField_t.polymorphic_field_t} polymorphic_field_t
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            polymorphic_field_t.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ProtoFlattenedSerializerField_t.polymorphic_field_t();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.polymorphicFieldSerializerNameSym = reader.int32();
                            break;
                        }
                    case 2: {
                            message.polymorphicFieldSerializerVersion = reader.int32();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a polymorphic_field_t message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof ProtoFlattenedSerializerField_t.polymorphic_field_t
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {ProtoFlattenedSerializerField_t.polymorphic_field_t} polymorphic_field_t
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            polymorphic_field_t.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a polymorphic_field_t message.
             * @function verify
             * @memberof ProtoFlattenedSerializerField_t.polymorphic_field_t
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            polymorphic_field_t.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.polymorphicFieldSerializerNameSym != null && message.hasOwnProperty("polymorphicFieldSerializerNameSym"))
                    if (!$util.isInteger(message.polymorphicFieldSerializerNameSym))
                        return "polymorphicFieldSerializerNameSym: integer expected";
                if (message.polymorphicFieldSerializerVersion != null && message.hasOwnProperty("polymorphicFieldSerializerVersion"))
                    if (!$util.isInteger(message.polymorphicFieldSerializerVersion))
                        return "polymorphicFieldSerializerVersion: integer expected";
                return null;
            };
    
            /**
             * Creates a polymorphic_field_t message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof ProtoFlattenedSerializerField_t.polymorphic_field_t
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {ProtoFlattenedSerializerField_t.polymorphic_field_t} polymorphic_field_t
             */
            polymorphic_field_t.fromObject = function fromObject(object) {
                if (object instanceof $root.ProtoFlattenedSerializerField_t.polymorphic_field_t)
                    return object;
                var message = new $root.ProtoFlattenedSerializerField_t.polymorphic_field_t();
                if (object.polymorphicFieldSerializerNameSym != null)
                    message.polymorphicFieldSerializerNameSym = object.polymorphicFieldSerializerNameSym | 0;
                if (object.polymorphicFieldSerializerVersion != null)
                    message.polymorphicFieldSerializerVersion = object.polymorphicFieldSerializerVersion | 0;
                return message;
            };
    
            /**
             * Creates a plain object from a polymorphic_field_t message. Also converts values to other types if specified.
             * @function toObject
             * @memberof ProtoFlattenedSerializerField_t.polymorphic_field_t
             * @static
             * @param {ProtoFlattenedSerializerField_t.polymorphic_field_t} message polymorphic_field_t
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            polymorphic_field_t.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.polymorphicFieldSerializerNameSym = 0;
                    object.polymorphicFieldSerializerVersion = 0;
                }
                if (message.polymorphicFieldSerializerNameSym != null && message.hasOwnProperty("polymorphicFieldSerializerNameSym"))
                    object.polymorphicFieldSerializerNameSym = message.polymorphicFieldSerializerNameSym;
                if (message.polymorphicFieldSerializerVersion != null && message.hasOwnProperty("polymorphicFieldSerializerVersion"))
                    object.polymorphicFieldSerializerVersion = message.polymorphicFieldSerializerVersion;
                return object;
            };
    
            /**
             * Converts this polymorphic_field_t to JSON.
             * @function toJSON
             * @memberof ProtoFlattenedSerializerField_t.polymorphic_field_t
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            polymorphic_field_t.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            /**
             * Gets the default type url for polymorphic_field_t
             * @function getTypeUrl
             * @memberof ProtoFlattenedSerializerField_t.polymorphic_field_t
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            polymorphic_field_t.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/ProtoFlattenedSerializerField_t.polymorphic_field_t";
            };
    
            return polymorphic_field_t;
        })();
    
        return ProtoFlattenedSerializerField_t;
    })();
    
    $root.ProtoFlattenedSerializer_t = (function() {
    
        /**
         * Properties of a ProtoFlattenedSerializer_t.
         * @exports IProtoFlattenedSerializer_t
         * @interface IProtoFlattenedSerializer_t
         * @property {number|null} [serializerNameSym] ProtoFlattenedSerializer_t serializerNameSym
         * @property {number|null} [serializerVersion] ProtoFlattenedSerializer_t serializerVersion
         * @property {Array.<number>|null} [fieldsIndex] ProtoFlattenedSerializer_t fieldsIndex
         */
    
        /**
         * Constructs a new ProtoFlattenedSerializer_t.
         * @exports ProtoFlattenedSerializer_t
         * @classdesc Represents a ProtoFlattenedSerializer_t.
         * @implements IProtoFlattenedSerializer_t
         * @constructor
         * @param {IProtoFlattenedSerializer_t=} [properties] Properties to set
         */
        function ProtoFlattenedSerializer_t(properties) {
            this.fieldsIndex = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * ProtoFlattenedSerializer_t serializerNameSym.
         * @member {number} serializerNameSym
         * @memberof ProtoFlattenedSerializer_t
         * @instance
         */
        ProtoFlattenedSerializer_t.prototype.serializerNameSym = 0;
    
        /**
         * ProtoFlattenedSerializer_t serializerVersion.
         * @member {number} serializerVersion
         * @memberof ProtoFlattenedSerializer_t
         * @instance
         */
        ProtoFlattenedSerializer_t.prototype.serializerVersion = 0;
    
        /**
         * ProtoFlattenedSerializer_t fieldsIndex.
         * @member {Array.<number>} fieldsIndex
         * @memberof ProtoFlattenedSerializer_t
         * @instance
         */
        ProtoFlattenedSerializer_t.prototype.fieldsIndex = $util.emptyArray;
    
        /**
         * Creates a new ProtoFlattenedSerializer_t instance using the specified properties.
         * @function create
         * @memberof ProtoFlattenedSerializer_t
         * @static
         * @param {IProtoFlattenedSerializer_t=} [properties] Properties to set
         * @returns {ProtoFlattenedSerializer_t} ProtoFlattenedSerializer_t instance
         */
        ProtoFlattenedSerializer_t.create = function create(properties) {
            return new ProtoFlattenedSerializer_t(properties);
        };
    
        /**
         * Encodes the specified ProtoFlattenedSerializer_t message. Does not implicitly {@link ProtoFlattenedSerializer_t.verify|verify} messages.
         * @function encode
         * @memberof ProtoFlattenedSerializer_t
         * @static
         * @param {IProtoFlattenedSerializer_t} message ProtoFlattenedSerializer_t message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ProtoFlattenedSerializer_t.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.serializerNameSym != null && Object.hasOwnProperty.call(message, "serializerNameSym"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.serializerNameSym);
            if (message.serializerVersion != null && Object.hasOwnProperty.call(message, "serializerVersion"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.serializerVersion);
            if (message.fieldsIndex != null && message.fieldsIndex.length)
                for (var i = 0; i < message.fieldsIndex.length; ++i)
                    writer.uint32(/* id 3, wireType 0 =*/24).int32(message.fieldsIndex[i]);
            return writer;
        };
    
        /**
         * Encodes the specified ProtoFlattenedSerializer_t message, length delimited. Does not implicitly {@link ProtoFlattenedSerializer_t.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ProtoFlattenedSerializer_t
         * @static
         * @param {IProtoFlattenedSerializer_t} message ProtoFlattenedSerializer_t message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ProtoFlattenedSerializer_t.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a ProtoFlattenedSerializer_t message from the specified reader or buffer.
         * @function decode
         * @memberof ProtoFlattenedSerializer_t
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ProtoFlattenedSerializer_t} ProtoFlattenedSerializer_t
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ProtoFlattenedSerializer_t.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ProtoFlattenedSerializer_t();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.serializerNameSym = reader.int32();
                        break;
                    }
                case 2: {
                        message.serializerVersion = reader.int32();
                        break;
                    }
                case 3: {
                        if (!(message.fieldsIndex && message.fieldsIndex.length))
                            message.fieldsIndex = [];
                        if ((tag & 7) === 2) {
                            var end2 = reader.uint32() + reader.pos;
                            while (reader.pos < end2)
                                message.fieldsIndex.push(reader.int32());
                        } else
                            message.fieldsIndex.push(reader.int32());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a ProtoFlattenedSerializer_t message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ProtoFlattenedSerializer_t
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ProtoFlattenedSerializer_t} ProtoFlattenedSerializer_t
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ProtoFlattenedSerializer_t.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a ProtoFlattenedSerializer_t message.
         * @function verify
         * @memberof ProtoFlattenedSerializer_t
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ProtoFlattenedSerializer_t.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.serializerNameSym != null && message.hasOwnProperty("serializerNameSym"))
                if (!$util.isInteger(message.serializerNameSym))
                    return "serializerNameSym: integer expected";
            if (message.serializerVersion != null && message.hasOwnProperty("serializerVersion"))
                if (!$util.isInteger(message.serializerVersion))
                    return "serializerVersion: integer expected";
            if (message.fieldsIndex != null && message.hasOwnProperty("fieldsIndex")) {
                if (!Array.isArray(message.fieldsIndex))
                    return "fieldsIndex: array expected";
                for (var i = 0; i < message.fieldsIndex.length; ++i)
                    if (!$util.isInteger(message.fieldsIndex[i]))
                        return "fieldsIndex: integer[] expected";
            }
            return null;
        };
    
        /**
         * Creates a ProtoFlattenedSerializer_t message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ProtoFlattenedSerializer_t
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ProtoFlattenedSerializer_t} ProtoFlattenedSerializer_t
         */
        ProtoFlattenedSerializer_t.fromObject = function fromObject(object) {
            if (object instanceof $root.ProtoFlattenedSerializer_t)
                return object;
            var message = new $root.ProtoFlattenedSerializer_t();
            if (object.serializerNameSym != null)
                message.serializerNameSym = object.serializerNameSym | 0;
            if (object.serializerVersion != null)
                message.serializerVersion = object.serializerVersion | 0;
            if (object.fieldsIndex) {
                if (!Array.isArray(object.fieldsIndex))
                    throw TypeError(".ProtoFlattenedSerializer_t.fieldsIndex: array expected");
                message.fieldsIndex = [];
                for (var i = 0; i < object.fieldsIndex.length; ++i)
                    message.fieldsIndex[i] = object.fieldsIndex[i] | 0;
            }
            return message;
        };
    
        /**
         * Creates a plain object from a ProtoFlattenedSerializer_t message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ProtoFlattenedSerializer_t
         * @static
         * @param {ProtoFlattenedSerializer_t} message ProtoFlattenedSerializer_t
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ProtoFlattenedSerializer_t.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.fieldsIndex = [];
            if (options.defaults) {
                object.serializerNameSym = 0;
                object.serializerVersion = 0;
            }
            if (message.serializerNameSym != null && message.hasOwnProperty("serializerNameSym"))
                object.serializerNameSym = message.serializerNameSym;
            if (message.serializerVersion != null && message.hasOwnProperty("serializerVersion"))
                object.serializerVersion = message.serializerVersion;
            if (message.fieldsIndex && message.fieldsIndex.length) {
                object.fieldsIndex = [];
                for (var j = 0; j < message.fieldsIndex.length; ++j)
                    object.fieldsIndex[j] = message.fieldsIndex[j];
            }
            return object;
        };
    
        /**
         * Converts this ProtoFlattenedSerializer_t to JSON.
         * @function toJSON
         * @memberof ProtoFlattenedSerializer_t
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ProtoFlattenedSerializer_t.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * Gets the default type url for ProtoFlattenedSerializer_t
         * @function getTypeUrl
         * @memberof ProtoFlattenedSerializer_t
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        ProtoFlattenedSerializer_t.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/ProtoFlattenedSerializer_t";
        };
    
        return ProtoFlattenedSerializer_t;
    })();
    
    $root.CSVCMsg_FlattenedSerializer = (function() {
    
        /**
         * Properties of a CSVCMsg_FlattenedSerializer.
         * @exports ICSVCMsg_FlattenedSerializer
         * @interface ICSVCMsg_FlattenedSerializer
         * @property {Array.<IProtoFlattenedSerializer_t>|null} [serializers] CSVCMsg_FlattenedSerializer serializers
         * @property {Array.<string>|null} [symbols] CSVCMsg_FlattenedSerializer symbols
         * @property {Array.<IProtoFlattenedSerializerField_t>|null} [fields] CSVCMsg_FlattenedSerializer fields
         */
    
        /**
         * Constructs a new CSVCMsg_FlattenedSerializer.
         * @exports CSVCMsg_FlattenedSerializer
         * @classdesc Represents a CSVCMsg_FlattenedSerializer.
         * @implements ICSVCMsg_FlattenedSerializer
         * @constructor
         * @param {ICSVCMsg_FlattenedSerializer=} [properties] Properties to set
         */
        function CSVCMsg_FlattenedSerializer(properties) {
            this.serializers = [];
            this.symbols = [];
            this.fields = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CSVCMsg_FlattenedSerializer serializers.
         * @member {Array.<IProtoFlattenedSerializer_t>} serializers
         * @memberof CSVCMsg_FlattenedSerializer
         * @instance
         */
        CSVCMsg_FlattenedSerializer.prototype.serializers = $util.emptyArray;
    
        /**
         * CSVCMsg_FlattenedSerializer symbols.
         * @member {Array.<string>} symbols
         * @memberof CSVCMsg_FlattenedSerializer
         * @instance
         */
        CSVCMsg_FlattenedSerializer.prototype.symbols = $util.emptyArray;
    
        /**
         * CSVCMsg_FlattenedSerializer fields.
         * @member {Array.<IProtoFlattenedSerializerField_t>} fields
         * @memberof CSVCMsg_FlattenedSerializer
         * @instance
         */
        CSVCMsg_FlattenedSerializer.prototype.fields = $util.emptyArray;
    
        /**
         * Creates a new CSVCMsg_FlattenedSerializer instance using the specified properties.
         * @function create
         * @memberof CSVCMsg_FlattenedSerializer
         * @static
         * @param {ICSVCMsg_FlattenedSerializer=} [properties] Properties to set
         * @returns {CSVCMsg_FlattenedSerializer} CSVCMsg_FlattenedSerializer instance
         */
        CSVCMsg_FlattenedSerializer.create = function create(properties) {
            return new CSVCMsg_FlattenedSerializer(properties);
        };
    
        /**
         * Encodes the specified CSVCMsg_FlattenedSerializer message. Does not implicitly {@link CSVCMsg_FlattenedSerializer.verify|verify} messages.
         * @function encode
         * @memberof CSVCMsg_FlattenedSerializer
         * @static
         * @param {ICSVCMsg_FlattenedSerializer} message CSVCMsg_FlattenedSerializer message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CSVCMsg_FlattenedSerializer.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.serializers != null && message.serializers.length)
                for (var i = 0; i < message.serializers.length; ++i)
                    $root.ProtoFlattenedSerializer_t.encode(message.serializers[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.symbols != null && message.symbols.length)
                for (var i = 0; i < message.symbols.length; ++i)
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.symbols[i]);
            if (message.fields != null && message.fields.length)
                for (var i = 0; i < message.fields.length; ++i)
                    $root.ProtoFlattenedSerializerField_t.encode(message.fields[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            return writer;
        };
    
        /**
         * Encodes the specified CSVCMsg_FlattenedSerializer message, length delimited. Does not implicitly {@link CSVCMsg_FlattenedSerializer.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CSVCMsg_FlattenedSerializer
         * @static
         * @param {ICSVCMsg_FlattenedSerializer} message CSVCMsg_FlattenedSerializer message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CSVCMsg_FlattenedSerializer.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CSVCMsg_FlattenedSerializer message from the specified reader or buffer.
         * @function decode
         * @memberof CSVCMsg_FlattenedSerializer
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CSVCMsg_FlattenedSerializer} CSVCMsg_FlattenedSerializer
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CSVCMsg_FlattenedSerializer.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CSVCMsg_FlattenedSerializer();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        if (!(message.serializers && message.serializers.length))
                            message.serializers = [];
                        message.serializers.push($root.ProtoFlattenedSerializer_t.decode(reader, reader.uint32()));
                        break;
                    }
                case 2: {
                        if (!(message.symbols && message.symbols.length))
                            message.symbols = [];
                        message.symbols.push(reader.string());
                        break;
                    }
                case 3: {
                        if (!(message.fields && message.fields.length))
                            message.fields = [];
                        message.fields.push($root.ProtoFlattenedSerializerField_t.decode(reader, reader.uint32()));
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CSVCMsg_FlattenedSerializer message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CSVCMsg_FlattenedSerializer
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CSVCMsg_FlattenedSerializer} CSVCMsg_FlattenedSerializer
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CSVCMsg_FlattenedSerializer.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CSVCMsg_FlattenedSerializer message.
         * @function verify
         * @memberof CSVCMsg_FlattenedSerializer
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CSVCMsg_FlattenedSerializer.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.serializers != null && message.hasOwnProperty("serializers")) {
                if (!Array.isArray(message.serializers))
                    return "serializers: array expected";
                for (var i = 0; i < message.serializers.length; ++i) {
                    var error = $root.ProtoFlattenedSerializer_t.verify(message.serializers[i]);
                    if (error)
                        return "serializers." + error;
                }
            }
            if (message.symbols != null && message.hasOwnProperty("symbols")) {
                if (!Array.isArray(message.symbols))
                    return "symbols: array expected";
                for (var i = 0; i < message.symbols.length; ++i)
                    if (!$util.isString(message.symbols[i]))
                        return "symbols: string[] expected";
            }
            if (message.fields != null && message.hasOwnProperty("fields")) {
                if (!Array.isArray(message.fields))
                    return "fields: array expected";
                for (var i = 0; i < message.fields.length; ++i) {
                    var error = $root.ProtoFlattenedSerializerField_t.verify(message.fields[i]);
                    if (error)
                        return "fields." + error;
                }
            }
            return null;
        };
    
        /**
         * Creates a CSVCMsg_FlattenedSerializer message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CSVCMsg_FlattenedSerializer
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CSVCMsg_FlattenedSerializer} CSVCMsg_FlattenedSerializer
         */
        CSVCMsg_FlattenedSerializer.fromObject = function fromObject(object) {
            if (object instanceof $root.CSVCMsg_FlattenedSerializer)
                return object;
            var message = new $root.CSVCMsg_FlattenedSerializer();
            if (object.serializers) {
                if (!Array.isArray(object.serializers))
                    throw TypeError(".CSVCMsg_FlattenedSerializer.serializers: array expected");
                message.serializers = [];
                for (var i = 0; i < object.serializers.length; ++i) {
                    if (typeof object.serializers[i] !== "object")
                        throw TypeError(".CSVCMsg_FlattenedSerializer.serializers: object expected");
                    message.serializers[i] = $root.ProtoFlattenedSerializer_t.fromObject(object.serializers[i]);
                }
            }
            if (object.symbols) {
                if (!Array.isArray(object.symbols))
                    throw TypeError(".CSVCMsg_FlattenedSerializer.symbols: array expected");
                message.symbols = [];
                for (var i = 0; i < object.symbols.length; ++i)
                    message.symbols[i] = String(object.symbols[i]);
            }
            if (object.fields) {
                if (!Array.isArray(object.fields))
                    throw TypeError(".CSVCMsg_FlattenedSerializer.fields: array expected");
                message.fields = [];
                for (var i = 0; i < object.fields.length; ++i) {
                    if (typeof object.fields[i] !== "object")
                        throw TypeError(".CSVCMsg_FlattenedSerializer.fields: object expected");
                    message.fields[i] = $root.ProtoFlattenedSerializerField_t.fromObject(object.fields[i]);
                }
            }
            return message;
        };
    
        /**
         * Creates a plain object from a CSVCMsg_FlattenedSerializer message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CSVCMsg_FlattenedSerializer
         * @static
         * @param {CSVCMsg_FlattenedSerializer} message CSVCMsg_FlattenedSerializer
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CSVCMsg_FlattenedSerializer.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults) {
                object.serializers = [];
                object.symbols = [];
                object.fields = [];
            }
            if (message.serializers && message.serializers.length) {
                object.serializers = [];
                for (var j = 0; j < message.serializers.length; ++j)
                    object.serializers[j] = $root.ProtoFlattenedSerializer_t.toObject(message.serializers[j], options);
            }
            if (message.symbols && message.symbols.length) {
                object.symbols = [];
                for (var j = 0; j < message.symbols.length; ++j)
                    object.symbols[j] = message.symbols[j];
            }
            if (message.fields && message.fields.length) {
                object.fields = [];
                for (var j = 0; j < message.fields.length; ++j)
                    object.fields[j] = $root.ProtoFlattenedSerializerField_t.toObject(message.fields[j], options);
            }
            return object;
        };
    
        /**
         * Converts this CSVCMsg_FlattenedSerializer to JSON.
         * @function toJSON
         * @memberof CSVCMsg_FlattenedSerializer
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CSVCMsg_FlattenedSerializer.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * Gets the default type url for CSVCMsg_FlattenedSerializer
         * @function getTypeUrl
         * @memberof CSVCMsg_FlattenedSerializer
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        CSVCMsg_FlattenedSerializer.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/CSVCMsg_FlattenedSerializer";
        };
    
        return CSVCMsg_FlattenedSerializer;
    })();
    
    $root.CSVCMsg_StopSound = (function() {
    
        /**
         * Properties of a CSVCMsg_StopSound.
         * @exports ICSVCMsg_StopSound
         * @interface ICSVCMsg_StopSound
         * @property {number|null} [guid] CSVCMsg_StopSound guid
         */
    
        /**
         * Constructs a new CSVCMsg_StopSound.
         * @exports CSVCMsg_StopSound
         * @classdesc Represents a CSVCMsg_StopSound.
         * @implements ICSVCMsg_StopSound
         * @constructor
         * @param {ICSVCMsg_StopSound=} [properties] Properties to set
         */
        function CSVCMsg_StopSound(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CSVCMsg_StopSound guid.
         * @member {number} guid
         * @memberof CSVCMsg_StopSound
         * @instance
         */
        CSVCMsg_StopSound.prototype.guid = 0;
    
        /**
         * Creates a new CSVCMsg_StopSound instance using the specified properties.
         * @function create
         * @memberof CSVCMsg_StopSound
         * @static
         * @param {ICSVCMsg_StopSound=} [properties] Properties to set
         * @returns {CSVCMsg_StopSound} CSVCMsg_StopSound instance
         */
        CSVCMsg_StopSound.create = function create(properties) {
            return new CSVCMsg_StopSound(properties);
        };
    
        /**
         * Encodes the specified CSVCMsg_StopSound message. Does not implicitly {@link CSVCMsg_StopSound.verify|verify} messages.
         * @function encode
         * @memberof CSVCMsg_StopSound
         * @static
         * @param {ICSVCMsg_StopSound} message CSVCMsg_StopSound message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CSVCMsg_StopSound.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.guid != null && Object.hasOwnProperty.call(message, "guid"))
                writer.uint32(/* id 1, wireType 5 =*/13).fixed32(message.guid);
            return writer;
        };
    
        /**
         * Encodes the specified CSVCMsg_StopSound message, length delimited. Does not implicitly {@link CSVCMsg_StopSound.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CSVCMsg_StopSound
         * @static
         * @param {ICSVCMsg_StopSound} message CSVCMsg_StopSound message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CSVCMsg_StopSound.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CSVCMsg_StopSound message from the specified reader or buffer.
         * @function decode
         * @memberof CSVCMsg_StopSound
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CSVCMsg_StopSound} CSVCMsg_StopSound
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CSVCMsg_StopSound.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CSVCMsg_StopSound();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.guid = reader.fixed32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CSVCMsg_StopSound message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CSVCMsg_StopSound
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CSVCMsg_StopSound} CSVCMsg_StopSound
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CSVCMsg_StopSound.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CSVCMsg_StopSound message.
         * @function verify
         * @memberof CSVCMsg_StopSound
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CSVCMsg_StopSound.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.guid != null && message.hasOwnProperty("guid"))
                if (!$util.isInteger(message.guid))
                    return "guid: integer expected";
            return null;
        };
    
        /**
         * Creates a CSVCMsg_StopSound message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CSVCMsg_StopSound
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CSVCMsg_StopSound} CSVCMsg_StopSound
         */
        CSVCMsg_StopSound.fromObject = function fromObject(object) {
            if (object instanceof $root.CSVCMsg_StopSound)
                return object;
            var message = new $root.CSVCMsg_StopSound();
            if (object.guid != null)
                message.guid = object.guid >>> 0;
            return message;
        };
    
        /**
         * Creates a plain object from a CSVCMsg_StopSound message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CSVCMsg_StopSound
         * @static
         * @param {CSVCMsg_StopSound} message CSVCMsg_StopSound
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CSVCMsg_StopSound.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.guid = 0;
            if (message.guid != null && message.hasOwnProperty("guid"))
                object.guid = message.guid;
            return object;
        };
    
        /**
         * Converts this CSVCMsg_StopSound to JSON.
         * @function toJSON
         * @memberof CSVCMsg_StopSound
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CSVCMsg_StopSound.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * Gets the default type url for CSVCMsg_StopSound
         * @function getTypeUrl
         * @memberof CSVCMsg_StopSound
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        CSVCMsg_StopSound.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/CSVCMsg_StopSound";
        };
    
        return CSVCMsg_StopSound;
    })();
    
    $root.CBidirMsg_RebroadcastGameEvent = (function() {
    
        /**
         * Properties of a CBidirMsg_RebroadcastGameEvent.
         * @exports ICBidirMsg_RebroadcastGameEvent
         * @interface ICBidirMsg_RebroadcastGameEvent
         * @property {boolean|null} [posttoserver] CBidirMsg_RebroadcastGameEvent posttoserver
         * @property {number|null} [buftype] CBidirMsg_RebroadcastGameEvent buftype
         * @property {number|null} [clientbitcount] CBidirMsg_RebroadcastGameEvent clientbitcount
         * @property {number|Long|null} [receivingclients] CBidirMsg_RebroadcastGameEvent receivingclients
         */
    
        /**
         * Constructs a new CBidirMsg_RebroadcastGameEvent.
         * @exports CBidirMsg_RebroadcastGameEvent
         * @classdesc Represents a CBidirMsg_RebroadcastGameEvent.
         * @implements ICBidirMsg_RebroadcastGameEvent
         * @constructor
         * @param {ICBidirMsg_RebroadcastGameEvent=} [properties] Properties to set
         */
        function CBidirMsg_RebroadcastGameEvent(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CBidirMsg_RebroadcastGameEvent posttoserver.
         * @member {boolean} posttoserver
         * @memberof CBidirMsg_RebroadcastGameEvent
         * @instance
         */
        CBidirMsg_RebroadcastGameEvent.prototype.posttoserver = false;
    
        /**
         * CBidirMsg_RebroadcastGameEvent buftype.
         * @member {number} buftype
         * @memberof CBidirMsg_RebroadcastGameEvent
         * @instance
         */
        CBidirMsg_RebroadcastGameEvent.prototype.buftype = 0;
    
        /**
         * CBidirMsg_RebroadcastGameEvent clientbitcount.
         * @member {number} clientbitcount
         * @memberof CBidirMsg_RebroadcastGameEvent
         * @instance
         */
        CBidirMsg_RebroadcastGameEvent.prototype.clientbitcount = 0;
    
        /**
         * CBidirMsg_RebroadcastGameEvent receivingclients.
         * @member {number|Long} receivingclients
         * @memberof CBidirMsg_RebroadcastGameEvent
         * @instance
         */
        CBidirMsg_RebroadcastGameEvent.prototype.receivingclients = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
        /**
         * Creates a new CBidirMsg_RebroadcastGameEvent instance using the specified properties.
         * @function create
         * @memberof CBidirMsg_RebroadcastGameEvent
         * @static
         * @param {ICBidirMsg_RebroadcastGameEvent=} [properties] Properties to set
         * @returns {CBidirMsg_RebroadcastGameEvent} CBidirMsg_RebroadcastGameEvent instance
         */
        CBidirMsg_RebroadcastGameEvent.create = function create(properties) {
            return new CBidirMsg_RebroadcastGameEvent(properties);
        };
    
        /**
         * Encodes the specified CBidirMsg_RebroadcastGameEvent message. Does not implicitly {@link CBidirMsg_RebroadcastGameEvent.verify|verify} messages.
         * @function encode
         * @memberof CBidirMsg_RebroadcastGameEvent
         * @static
         * @param {ICBidirMsg_RebroadcastGameEvent} message CBidirMsg_RebroadcastGameEvent message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CBidirMsg_RebroadcastGameEvent.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.posttoserver != null && Object.hasOwnProperty.call(message, "posttoserver"))
                writer.uint32(/* id 1, wireType 0 =*/8).bool(message.posttoserver);
            if (message.buftype != null && Object.hasOwnProperty.call(message, "buftype"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.buftype);
            if (message.clientbitcount != null && Object.hasOwnProperty.call(message, "clientbitcount"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.clientbitcount);
            if (message.receivingclients != null && Object.hasOwnProperty.call(message, "receivingclients"))
                writer.uint32(/* id 4, wireType 0 =*/32).uint64(message.receivingclients);
            return writer;
        };
    
        /**
         * Encodes the specified CBidirMsg_RebroadcastGameEvent message, length delimited. Does not implicitly {@link CBidirMsg_RebroadcastGameEvent.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CBidirMsg_RebroadcastGameEvent
         * @static
         * @param {ICBidirMsg_RebroadcastGameEvent} message CBidirMsg_RebroadcastGameEvent message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CBidirMsg_RebroadcastGameEvent.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CBidirMsg_RebroadcastGameEvent message from the specified reader or buffer.
         * @function decode
         * @memberof CBidirMsg_RebroadcastGameEvent
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CBidirMsg_RebroadcastGameEvent} CBidirMsg_RebroadcastGameEvent
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CBidirMsg_RebroadcastGameEvent.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CBidirMsg_RebroadcastGameEvent();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.posttoserver = reader.bool();
                        break;
                    }
                case 2: {
                        message.buftype = reader.int32();
                        break;
                    }
                case 3: {
                        message.clientbitcount = reader.uint32();
                        break;
                    }
                case 4: {
                        message.receivingclients = reader.uint64();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CBidirMsg_RebroadcastGameEvent message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CBidirMsg_RebroadcastGameEvent
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CBidirMsg_RebroadcastGameEvent} CBidirMsg_RebroadcastGameEvent
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CBidirMsg_RebroadcastGameEvent.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CBidirMsg_RebroadcastGameEvent message.
         * @function verify
         * @memberof CBidirMsg_RebroadcastGameEvent
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CBidirMsg_RebroadcastGameEvent.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.posttoserver != null && message.hasOwnProperty("posttoserver"))
                if (typeof message.posttoserver !== "boolean")
                    return "posttoserver: boolean expected";
            if (message.buftype != null && message.hasOwnProperty("buftype"))
                if (!$util.isInteger(message.buftype))
                    return "buftype: integer expected";
            if (message.clientbitcount != null && message.hasOwnProperty("clientbitcount"))
                if (!$util.isInteger(message.clientbitcount))
                    return "clientbitcount: integer expected";
            if (message.receivingclients != null && message.hasOwnProperty("receivingclients"))
                if (!$util.isInteger(message.receivingclients) && !(message.receivingclients && $util.isInteger(message.receivingclients.low) && $util.isInteger(message.receivingclients.high)))
                    return "receivingclients: integer|Long expected";
            return null;
        };
    
        /**
         * Creates a CBidirMsg_RebroadcastGameEvent message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CBidirMsg_RebroadcastGameEvent
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CBidirMsg_RebroadcastGameEvent} CBidirMsg_RebroadcastGameEvent
         */
        CBidirMsg_RebroadcastGameEvent.fromObject = function fromObject(object) {
            if (object instanceof $root.CBidirMsg_RebroadcastGameEvent)
                return object;
            var message = new $root.CBidirMsg_RebroadcastGameEvent();
            if (object.posttoserver != null)
                message.posttoserver = Boolean(object.posttoserver);
            if (object.buftype != null)
                message.buftype = object.buftype | 0;
            if (object.clientbitcount != null)
                message.clientbitcount = object.clientbitcount >>> 0;
            if (object.receivingclients != null)
                if ($util.Long)
                    (message.receivingclients = $util.Long.fromValue(object.receivingclients)).unsigned = true;
                else if (typeof object.receivingclients === "string")
                    message.receivingclients = parseInt(object.receivingclients, 10);
                else if (typeof object.receivingclients === "number")
                    message.receivingclients = object.receivingclients;
                else if (typeof object.receivingclients === "object")
                    message.receivingclients = new $util.LongBits(object.receivingclients.low >>> 0, object.receivingclients.high >>> 0).toNumber(true);
            return message;
        };
    
        /**
         * Creates a plain object from a CBidirMsg_RebroadcastGameEvent message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CBidirMsg_RebroadcastGameEvent
         * @static
         * @param {CBidirMsg_RebroadcastGameEvent} message CBidirMsg_RebroadcastGameEvent
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CBidirMsg_RebroadcastGameEvent.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.posttoserver = false;
                object.buftype = 0;
                object.clientbitcount = 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.receivingclients = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.receivingclients = options.longs === String ? "0" : 0;
            }
            if (message.posttoserver != null && message.hasOwnProperty("posttoserver"))
                object.posttoserver = message.posttoserver;
            if (message.buftype != null && message.hasOwnProperty("buftype"))
                object.buftype = message.buftype;
            if (message.clientbitcount != null && message.hasOwnProperty("clientbitcount"))
                object.clientbitcount = message.clientbitcount;
            if (message.receivingclients != null && message.hasOwnProperty("receivingclients"))
                if (typeof message.receivingclients === "number")
                    object.receivingclients = options.longs === String ? String(message.receivingclients) : message.receivingclients;
                else
                    object.receivingclients = options.longs === String ? $util.Long.prototype.toString.call(message.receivingclients) : options.longs === Number ? new $util.LongBits(message.receivingclients.low >>> 0, message.receivingclients.high >>> 0).toNumber(true) : message.receivingclients;
            return object;
        };
    
        /**
         * Converts this CBidirMsg_RebroadcastGameEvent to JSON.
         * @function toJSON
         * @memberof CBidirMsg_RebroadcastGameEvent
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CBidirMsg_RebroadcastGameEvent.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * Gets the default type url for CBidirMsg_RebroadcastGameEvent
         * @function getTypeUrl
         * @memberof CBidirMsg_RebroadcastGameEvent
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        CBidirMsg_RebroadcastGameEvent.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/CBidirMsg_RebroadcastGameEvent";
        };
    
        return CBidirMsg_RebroadcastGameEvent;
    })();
    
    $root.CBidirMsg_RebroadcastSource = (function() {
    
        /**
         * Properties of a CBidirMsg_RebroadcastSource.
         * @exports ICBidirMsg_RebroadcastSource
         * @interface ICBidirMsg_RebroadcastSource
         * @property {number|null} [eventsource] CBidirMsg_RebroadcastSource eventsource
         */
    
        /**
         * Constructs a new CBidirMsg_RebroadcastSource.
         * @exports CBidirMsg_RebroadcastSource
         * @classdesc Represents a CBidirMsg_RebroadcastSource.
         * @implements ICBidirMsg_RebroadcastSource
         * @constructor
         * @param {ICBidirMsg_RebroadcastSource=} [properties] Properties to set
         */
        function CBidirMsg_RebroadcastSource(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CBidirMsg_RebroadcastSource eventsource.
         * @member {number} eventsource
         * @memberof CBidirMsg_RebroadcastSource
         * @instance
         */
        CBidirMsg_RebroadcastSource.prototype.eventsource = 0;
    
        /**
         * Creates a new CBidirMsg_RebroadcastSource instance using the specified properties.
         * @function create
         * @memberof CBidirMsg_RebroadcastSource
         * @static
         * @param {ICBidirMsg_RebroadcastSource=} [properties] Properties to set
         * @returns {CBidirMsg_RebroadcastSource} CBidirMsg_RebroadcastSource instance
         */
        CBidirMsg_RebroadcastSource.create = function create(properties) {
            return new CBidirMsg_RebroadcastSource(properties);
        };
    
        /**
         * Encodes the specified CBidirMsg_RebroadcastSource message. Does not implicitly {@link CBidirMsg_RebroadcastSource.verify|verify} messages.
         * @function encode
         * @memberof CBidirMsg_RebroadcastSource
         * @static
         * @param {ICBidirMsg_RebroadcastSource} message CBidirMsg_RebroadcastSource message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CBidirMsg_RebroadcastSource.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.eventsource != null && Object.hasOwnProperty.call(message, "eventsource"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.eventsource);
            return writer;
        };
    
        /**
         * Encodes the specified CBidirMsg_RebroadcastSource message, length delimited. Does not implicitly {@link CBidirMsg_RebroadcastSource.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CBidirMsg_RebroadcastSource
         * @static
         * @param {ICBidirMsg_RebroadcastSource} message CBidirMsg_RebroadcastSource message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CBidirMsg_RebroadcastSource.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CBidirMsg_RebroadcastSource message from the specified reader or buffer.
         * @function decode
         * @memberof CBidirMsg_RebroadcastSource
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CBidirMsg_RebroadcastSource} CBidirMsg_RebroadcastSource
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CBidirMsg_RebroadcastSource.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CBidirMsg_RebroadcastSource();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.eventsource = reader.int32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CBidirMsg_RebroadcastSource message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CBidirMsg_RebroadcastSource
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CBidirMsg_RebroadcastSource} CBidirMsg_RebroadcastSource
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CBidirMsg_RebroadcastSource.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CBidirMsg_RebroadcastSource message.
         * @function verify
         * @memberof CBidirMsg_RebroadcastSource
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CBidirMsg_RebroadcastSource.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.eventsource != null && message.hasOwnProperty("eventsource"))
                if (!$util.isInteger(message.eventsource))
                    return "eventsource: integer expected";
            return null;
        };
    
        /**
         * Creates a CBidirMsg_RebroadcastSource message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CBidirMsg_RebroadcastSource
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CBidirMsg_RebroadcastSource} CBidirMsg_RebroadcastSource
         */
        CBidirMsg_RebroadcastSource.fromObject = function fromObject(object) {
            if (object instanceof $root.CBidirMsg_RebroadcastSource)
                return object;
            var message = new $root.CBidirMsg_RebroadcastSource();
            if (object.eventsource != null)
                message.eventsource = object.eventsource | 0;
            return message;
        };
    
        /**
         * Creates a plain object from a CBidirMsg_RebroadcastSource message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CBidirMsg_RebroadcastSource
         * @static
         * @param {CBidirMsg_RebroadcastSource} message CBidirMsg_RebroadcastSource
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CBidirMsg_RebroadcastSource.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.eventsource = 0;
            if (message.eventsource != null && message.hasOwnProperty("eventsource"))
                object.eventsource = message.eventsource;
            return object;
        };
    
        /**
         * Converts this CBidirMsg_RebroadcastSource to JSON.
         * @function toJSON
         * @memberof CBidirMsg_RebroadcastSource
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CBidirMsg_RebroadcastSource.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * Gets the default type url for CBidirMsg_RebroadcastSource
         * @function getTypeUrl
         * @memberof CBidirMsg_RebroadcastSource
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        CBidirMsg_RebroadcastSource.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/CBidirMsg_RebroadcastSource";
        };
    
        return CBidirMsg_RebroadcastSource;
    })();
    
    $root.CMsgServerNetworkStats = (function() {
    
        /**
         * Properties of a CMsgServerNetworkStats.
         * @exports ICMsgServerNetworkStats
         * @interface ICMsgServerNetworkStats
         * @property {boolean|null} [dedicated] CMsgServerNetworkStats dedicated
         * @property {number|null} [cpuUsage] CMsgServerNetworkStats cpuUsage
         * @property {number|null} [memoryUsedMb] CMsgServerNetworkStats memoryUsedMb
         * @property {number|null} [memoryFreeMb] CMsgServerNetworkStats memoryFreeMb
         * @property {number|null} [uptime] CMsgServerNetworkStats uptime
         * @property {number|null} [spawnCount] CMsgServerNetworkStats spawnCount
         * @property {number|null} [numClients] CMsgServerNetworkStats numClients
         * @property {number|null} [numBots] CMsgServerNetworkStats numBots
         * @property {number|null} [numSpectators] CMsgServerNetworkStats numSpectators
         * @property {number|null} [numTvRelays] CMsgServerNetworkStats numTvRelays
         * @property {number|null} [fps] CMsgServerNetworkStats fps
         * @property {Array.<CMsgServerNetworkStats.IPort>|null} [ports] CMsgServerNetworkStats ports
         * @property {number|null} [avgPingMs] CMsgServerNetworkStats avgPingMs
         * @property {number|null} [avgEngineLatencyOut] CMsgServerNetworkStats avgEngineLatencyOut
         * @property {number|null} [avgPacketsOut] CMsgServerNetworkStats avgPacketsOut
         * @property {number|null} [avgPacketsIn] CMsgServerNetworkStats avgPacketsIn
         * @property {number|null} [avgLossOut] CMsgServerNetworkStats avgLossOut
         * @property {number|null} [avgLossIn] CMsgServerNetworkStats avgLossIn
         * @property {number|null} [avgDataOut] CMsgServerNetworkStats avgDataOut
         * @property {number|null} [avgDataIn] CMsgServerNetworkStats avgDataIn
         * @property {number|Long|null} [totalDataIn] CMsgServerNetworkStats totalDataIn
         * @property {number|Long|null} [totalPacketsIn] CMsgServerNetworkStats totalPacketsIn
         * @property {number|Long|null} [totalDataOut] CMsgServerNetworkStats totalDataOut
         * @property {number|Long|null} [totalPacketsOut] CMsgServerNetworkStats totalPacketsOut
         * @property {Array.<CMsgServerNetworkStats.IPlayer>|null} [players] CMsgServerNetworkStats players
         */
    
        /**
         * Constructs a new CMsgServerNetworkStats.
         * @exports CMsgServerNetworkStats
         * @classdesc Represents a CMsgServerNetworkStats.
         * @implements ICMsgServerNetworkStats
         * @constructor
         * @param {ICMsgServerNetworkStats=} [properties] Properties to set
         */
        function CMsgServerNetworkStats(properties) {
            this.ports = [];
            this.players = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CMsgServerNetworkStats dedicated.
         * @member {boolean} dedicated
         * @memberof CMsgServerNetworkStats
         * @instance
         */
        CMsgServerNetworkStats.prototype.dedicated = false;
    
        /**
         * CMsgServerNetworkStats cpuUsage.
         * @member {number} cpuUsage
         * @memberof CMsgServerNetworkStats
         * @instance
         */
        CMsgServerNetworkStats.prototype.cpuUsage = 0;
    
        /**
         * CMsgServerNetworkStats memoryUsedMb.
         * @member {number} memoryUsedMb
         * @memberof CMsgServerNetworkStats
         * @instance
         */
        CMsgServerNetworkStats.prototype.memoryUsedMb = 0;
    
        /**
         * CMsgServerNetworkStats memoryFreeMb.
         * @member {number} memoryFreeMb
         * @memberof CMsgServerNetworkStats
         * @instance
         */
        CMsgServerNetworkStats.prototype.memoryFreeMb = 0;
    
        /**
         * CMsgServerNetworkStats uptime.
         * @member {number} uptime
         * @memberof CMsgServerNetworkStats
         * @instance
         */
        CMsgServerNetworkStats.prototype.uptime = 0;
    
        /**
         * CMsgServerNetworkStats spawnCount.
         * @member {number} spawnCount
         * @memberof CMsgServerNetworkStats
         * @instance
         */
        CMsgServerNetworkStats.prototype.spawnCount = 0;
    
        /**
         * CMsgServerNetworkStats numClients.
         * @member {number} numClients
         * @memberof CMsgServerNetworkStats
         * @instance
         */
        CMsgServerNetworkStats.prototype.numClients = 0;
    
        /**
         * CMsgServerNetworkStats numBots.
         * @member {number} numBots
         * @memberof CMsgServerNetworkStats
         * @instance
         */
        CMsgServerNetworkStats.prototype.numBots = 0;
    
        /**
         * CMsgServerNetworkStats numSpectators.
         * @member {number} numSpectators
         * @memberof CMsgServerNetworkStats
         * @instance
         */
        CMsgServerNetworkStats.prototype.numSpectators = 0;
    
        /**
         * CMsgServerNetworkStats numTvRelays.
         * @member {number} numTvRelays
         * @memberof CMsgServerNetworkStats
         * @instance
         */
        CMsgServerNetworkStats.prototype.numTvRelays = 0;
    
        /**
         * CMsgServerNetworkStats fps.
         * @member {number} fps
         * @memberof CMsgServerNetworkStats
         * @instance
         */
        CMsgServerNetworkStats.prototype.fps = 0;
    
        /**
         * CMsgServerNetworkStats ports.
         * @member {Array.<CMsgServerNetworkStats.IPort>} ports
         * @memberof CMsgServerNetworkStats
         * @instance
         */
        CMsgServerNetworkStats.prototype.ports = $util.emptyArray;
    
        /**
         * CMsgServerNetworkStats avgPingMs.
         * @member {number} avgPingMs
         * @memberof CMsgServerNetworkStats
         * @instance
         */
        CMsgServerNetworkStats.prototype.avgPingMs = 0;
    
        /**
         * CMsgServerNetworkStats avgEngineLatencyOut.
         * @member {number} avgEngineLatencyOut
         * @memberof CMsgServerNetworkStats
         * @instance
         */
        CMsgServerNetworkStats.prototype.avgEngineLatencyOut = 0;
    
        /**
         * CMsgServerNetworkStats avgPacketsOut.
         * @member {number} avgPacketsOut
         * @memberof CMsgServerNetworkStats
         * @instance
         */
        CMsgServerNetworkStats.prototype.avgPacketsOut = 0;
    
        /**
         * CMsgServerNetworkStats avgPacketsIn.
         * @member {number} avgPacketsIn
         * @memberof CMsgServerNetworkStats
         * @instance
         */
        CMsgServerNetworkStats.prototype.avgPacketsIn = 0;
    
        /**
         * CMsgServerNetworkStats avgLossOut.
         * @member {number} avgLossOut
         * @memberof CMsgServerNetworkStats
         * @instance
         */
        CMsgServerNetworkStats.prototype.avgLossOut = 0;
    
        /**
         * CMsgServerNetworkStats avgLossIn.
         * @member {number} avgLossIn
         * @memberof CMsgServerNetworkStats
         * @instance
         */
        CMsgServerNetworkStats.prototype.avgLossIn = 0;
    
        /**
         * CMsgServerNetworkStats avgDataOut.
         * @member {number} avgDataOut
         * @memberof CMsgServerNetworkStats
         * @instance
         */
        CMsgServerNetworkStats.prototype.avgDataOut = 0;
    
        /**
         * CMsgServerNetworkStats avgDataIn.
         * @member {number} avgDataIn
         * @memberof CMsgServerNetworkStats
         * @instance
         */
        CMsgServerNetworkStats.prototype.avgDataIn = 0;
    
        /**
         * CMsgServerNetworkStats totalDataIn.
         * @member {number|Long} totalDataIn
         * @memberof CMsgServerNetworkStats
         * @instance
         */
        CMsgServerNetworkStats.prototype.totalDataIn = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
        /**
         * CMsgServerNetworkStats totalPacketsIn.
         * @member {number|Long} totalPacketsIn
         * @memberof CMsgServerNetworkStats
         * @instance
         */
        CMsgServerNetworkStats.prototype.totalPacketsIn = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
        /**
         * CMsgServerNetworkStats totalDataOut.
         * @member {number|Long} totalDataOut
         * @memberof CMsgServerNetworkStats
         * @instance
         */
        CMsgServerNetworkStats.prototype.totalDataOut = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
        /**
         * CMsgServerNetworkStats totalPacketsOut.
         * @member {number|Long} totalPacketsOut
         * @memberof CMsgServerNetworkStats
         * @instance
         */
        CMsgServerNetworkStats.prototype.totalPacketsOut = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
        /**
         * CMsgServerNetworkStats players.
         * @member {Array.<CMsgServerNetworkStats.IPlayer>} players
         * @memberof CMsgServerNetworkStats
         * @instance
         */
        CMsgServerNetworkStats.prototype.players = $util.emptyArray;
    
        /**
         * Creates a new CMsgServerNetworkStats instance using the specified properties.
         * @function create
         * @memberof CMsgServerNetworkStats
         * @static
         * @param {ICMsgServerNetworkStats=} [properties] Properties to set
         * @returns {CMsgServerNetworkStats} CMsgServerNetworkStats instance
         */
        CMsgServerNetworkStats.create = function create(properties) {
            return new CMsgServerNetworkStats(properties);
        };
    
        /**
         * Encodes the specified CMsgServerNetworkStats message. Does not implicitly {@link CMsgServerNetworkStats.verify|verify} messages.
         * @function encode
         * @memberof CMsgServerNetworkStats
         * @static
         * @param {ICMsgServerNetworkStats} message CMsgServerNetworkStats message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CMsgServerNetworkStats.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.dedicated != null && Object.hasOwnProperty.call(message, "dedicated"))
                writer.uint32(/* id 1, wireType 0 =*/8).bool(message.dedicated);
            if (message.cpuUsage != null && Object.hasOwnProperty.call(message, "cpuUsage"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.cpuUsage);
            if (message.memoryUsedMb != null && Object.hasOwnProperty.call(message, "memoryUsedMb"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.memoryUsedMb);
            if (message.memoryFreeMb != null && Object.hasOwnProperty.call(message, "memoryFreeMb"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.memoryFreeMb);
            if (message.uptime != null && Object.hasOwnProperty.call(message, "uptime"))
                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.uptime);
            if (message.spawnCount != null && Object.hasOwnProperty.call(message, "spawnCount"))
                writer.uint32(/* id 6, wireType 0 =*/48).int32(message.spawnCount);
            if (message.numClients != null && Object.hasOwnProperty.call(message, "numClients"))
                writer.uint32(/* id 8, wireType 0 =*/64).int32(message.numClients);
            if (message.numBots != null && Object.hasOwnProperty.call(message, "numBots"))
                writer.uint32(/* id 9, wireType 0 =*/72).int32(message.numBots);
            if (message.numSpectators != null && Object.hasOwnProperty.call(message, "numSpectators"))
                writer.uint32(/* id 10, wireType 0 =*/80).int32(message.numSpectators);
            if (message.numTvRelays != null && Object.hasOwnProperty.call(message, "numTvRelays"))
                writer.uint32(/* id 11, wireType 0 =*/88).int32(message.numTvRelays);
            if (message.fps != null && Object.hasOwnProperty.call(message, "fps"))
                writer.uint32(/* id 12, wireType 5 =*/101).float(message.fps);
            if (message.ports != null && message.ports.length)
                for (var i = 0; i < message.ports.length; ++i)
                    $root.CMsgServerNetworkStats.Port.encode(message.ports[i], writer.uint32(/* id 17, wireType 2 =*/138).fork()).ldelim();
            if (message.avgPingMs != null && Object.hasOwnProperty.call(message, "avgPingMs"))
                writer.uint32(/* id 18, wireType 5 =*/149).float(message.avgPingMs);
            if (message.avgEngineLatencyOut != null && Object.hasOwnProperty.call(message, "avgEngineLatencyOut"))
                writer.uint32(/* id 19, wireType 5 =*/157).float(message.avgEngineLatencyOut);
            if (message.avgPacketsOut != null && Object.hasOwnProperty.call(message, "avgPacketsOut"))
                writer.uint32(/* id 20, wireType 5 =*/165).float(message.avgPacketsOut);
            if (message.avgPacketsIn != null && Object.hasOwnProperty.call(message, "avgPacketsIn"))
                writer.uint32(/* id 21, wireType 5 =*/173).float(message.avgPacketsIn);
            if (message.avgLossOut != null && Object.hasOwnProperty.call(message, "avgLossOut"))
                writer.uint32(/* id 22, wireType 5 =*/181).float(message.avgLossOut);
            if (message.avgLossIn != null && Object.hasOwnProperty.call(message, "avgLossIn"))
                writer.uint32(/* id 23, wireType 5 =*/189).float(message.avgLossIn);
            if (message.avgDataOut != null && Object.hasOwnProperty.call(message, "avgDataOut"))
                writer.uint32(/* id 24, wireType 5 =*/197).float(message.avgDataOut);
            if (message.avgDataIn != null && Object.hasOwnProperty.call(message, "avgDataIn"))
                writer.uint32(/* id 25, wireType 5 =*/205).float(message.avgDataIn);
            if (message.totalDataIn != null && Object.hasOwnProperty.call(message, "totalDataIn"))
                writer.uint32(/* id 26, wireType 0 =*/208).uint64(message.totalDataIn);
            if (message.totalPacketsIn != null && Object.hasOwnProperty.call(message, "totalPacketsIn"))
                writer.uint32(/* id 27, wireType 0 =*/216).uint64(message.totalPacketsIn);
            if (message.totalDataOut != null && Object.hasOwnProperty.call(message, "totalDataOut"))
                writer.uint32(/* id 28, wireType 0 =*/224).uint64(message.totalDataOut);
            if (message.totalPacketsOut != null && Object.hasOwnProperty.call(message, "totalPacketsOut"))
                writer.uint32(/* id 29, wireType 0 =*/232).uint64(message.totalPacketsOut);
            if (message.players != null && message.players.length)
                for (var i = 0; i < message.players.length; ++i)
                    $root.CMsgServerNetworkStats.Player.encode(message.players[i], writer.uint32(/* id 30, wireType 2 =*/242).fork()).ldelim();
            return writer;
        };
    
        /**
         * Encodes the specified CMsgServerNetworkStats message, length delimited. Does not implicitly {@link CMsgServerNetworkStats.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CMsgServerNetworkStats
         * @static
         * @param {ICMsgServerNetworkStats} message CMsgServerNetworkStats message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CMsgServerNetworkStats.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CMsgServerNetworkStats message from the specified reader or buffer.
         * @function decode
         * @memberof CMsgServerNetworkStats
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CMsgServerNetworkStats} CMsgServerNetworkStats
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CMsgServerNetworkStats.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgServerNetworkStats();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.dedicated = reader.bool();
                        break;
                    }
                case 2: {
                        message.cpuUsage = reader.int32();
                        break;
                    }
                case 3: {
                        message.memoryUsedMb = reader.int32();
                        break;
                    }
                case 4: {
                        message.memoryFreeMb = reader.int32();
                        break;
                    }
                case 5: {
                        message.uptime = reader.int32();
                        break;
                    }
                case 6: {
                        message.spawnCount = reader.int32();
                        break;
                    }
                case 8: {
                        message.numClients = reader.int32();
                        break;
                    }
                case 9: {
                        message.numBots = reader.int32();
                        break;
                    }
                case 10: {
                        message.numSpectators = reader.int32();
                        break;
                    }
                case 11: {
                        message.numTvRelays = reader.int32();
                        break;
                    }
                case 12: {
                        message.fps = reader.float();
                        break;
                    }
                case 17: {
                        if (!(message.ports && message.ports.length))
                            message.ports = [];
                        message.ports.push($root.CMsgServerNetworkStats.Port.decode(reader, reader.uint32()));
                        break;
                    }
                case 18: {
                        message.avgPingMs = reader.float();
                        break;
                    }
                case 19: {
                        message.avgEngineLatencyOut = reader.float();
                        break;
                    }
                case 20: {
                        message.avgPacketsOut = reader.float();
                        break;
                    }
                case 21: {
                        message.avgPacketsIn = reader.float();
                        break;
                    }
                case 22: {
                        message.avgLossOut = reader.float();
                        break;
                    }
                case 23: {
                        message.avgLossIn = reader.float();
                        break;
                    }
                case 24: {
                        message.avgDataOut = reader.float();
                        break;
                    }
                case 25: {
                        message.avgDataIn = reader.float();
                        break;
                    }
                case 26: {
                        message.totalDataIn = reader.uint64();
                        break;
                    }
                case 27: {
                        message.totalPacketsIn = reader.uint64();
                        break;
                    }
                case 28: {
                        message.totalDataOut = reader.uint64();
                        break;
                    }
                case 29: {
                        message.totalPacketsOut = reader.uint64();
                        break;
                    }
                case 30: {
                        if (!(message.players && message.players.length))
                            message.players = [];
                        message.players.push($root.CMsgServerNetworkStats.Player.decode(reader, reader.uint32()));
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CMsgServerNetworkStats message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CMsgServerNetworkStats
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CMsgServerNetworkStats} CMsgServerNetworkStats
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CMsgServerNetworkStats.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CMsgServerNetworkStats message.
         * @function verify
         * @memberof CMsgServerNetworkStats
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CMsgServerNetworkStats.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.dedicated != null && message.hasOwnProperty("dedicated"))
                if (typeof message.dedicated !== "boolean")
                    return "dedicated: boolean expected";
            if (message.cpuUsage != null && message.hasOwnProperty("cpuUsage"))
                if (!$util.isInteger(message.cpuUsage))
                    return "cpuUsage: integer expected";
            if (message.memoryUsedMb != null && message.hasOwnProperty("memoryUsedMb"))
                if (!$util.isInteger(message.memoryUsedMb))
                    return "memoryUsedMb: integer expected";
            if (message.memoryFreeMb != null && message.hasOwnProperty("memoryFreeMb"))
                if (!$util.isInteger(message.memoryFreeMb))
                    return "memoryFreeMb: integer expected";
            if (message.uptime != null && message.hasOwnProperty("uptime"))
                if (!$util.isInteger(message.uptime))
                    return "uptime: integer expected";
            if (message.spawnCount != null && message.hasOwnProperty("spawnCount"))
                if (!$util.isInteger(message.spawnCount))
                    return "spawnCount: integer expected";
            if (message.numClients != null && message.hasOwnProperty("numClients"))
                if (!$util.isInteger(message.numClients))
                    return "numClients: integer expected";
            if (message.numBots != null && message.hasOwnProperty("numBots"))
                if (!$util.isInteger(message.numBots))
                    return "numBots: integer expected";
            if (message.numSpectators != null && message.hasOwnProperty("numSpectators"))
                if (!$util.isInteger(message.numSpectators))
                    return "numSpectators: integer expected";
            if (message.numTvRelays != null && message.hasOwnProperty("numTvRelays"))
                if (!$util.isInteger(message.numTvRelays))
                    return "numTvRelays: integer expected";
            if (message.fps != null && message.hasOwnProperty("fps"))
                if (typeof message.fps !== "number")
                    return "fps: number expected";
            if (message.ports != null && message.hasOwnProperty("ports")) {
                if (!Array.isArray(message.ports))
                    return "ports: array expected";
                for (var i = 0; i < message.ports.length; ++i) {
                    var error = $root.CMsgServerNetworkStats.Port.verify(message.ports[i]);
                    if (error)
                        return "ports." + error;
                }
            }
            if (message.avgPingMs != null && message.hasOwnProperty("avgPingMs"))
                if (typeof message.avgPingMs !== "number")
                    return "avgPingMs: number expected";
            if (message.avgEngineLatencyOut != null && message.hasOwnProperty("avgEngineLatencyOut"))
                if (typeof message.avgEngineLatencyOut !== "number")
                    return "avgEngineLatencyOut: number expected";
            if (message.avgPacketsOut != null && message.hasOwnProperty("avgPacketsOut"))
                if (typeof message.avgPacketsOut !== "number")
                    return "avgPacketsOut: number expected";
            if (message.avgPacketsIn != null && message.hasOwnProperty("avgPacketsIn"))
                if (typeof message.avgPacketsIn !== "number")
                    return "avgPacketsIn: number expected";
            if (message.avgLossOut != null && message.hasOwnProperty("avgLossOut"))
                if (typeof message.avgLossOut !== "number")
                    return "avgLossOut: number expected";
            if (message.avgLossIn != null && message.hasOwnProperty("avgLossIn"))
                if (typeof message.avgLossIn !== "number")
                    return "avgLossIn: number expected";
            if (message.avgDataOut != null && message.hasOwnProperty("avgDataOut"))
                if (typeof message.avgDataOut !== "number")
                    return "avgDataOut: number expected";
            if (message.avgDataIn != null && message.hasOwnProperty("avgDataIn"))
                if (typeof message.avgDataIn !== "number")
                    return "avgDataIn: number expected";
            if (message.totalDataIn != null && message.hasOwnProperty("totalDataIn"))
                if (!$util.isInteger(message.totalDataIn) && !(message.totalDataIn && $util.isInteger(message.totalDataIn.low) && $util.isInteger(message.totalDataIn.high)))
                    return "totalDataIn: integer|Long expected";
            if (message.totalPacketsIn != null && message.hasOwnProperty("totalPacketsIn"))
                if (!$util.isInteger(message.totalPacketsIn) && !(message.totalPacketsIn && $util.isInteger(message.totalPacketsIn.low) && $util.isInteger(message.totalPacketsIn.high)))
                    return "totalPacketsIn: integer|Long expected";
            if (message.totalDataOut != null && message.hasOwnProperty("totalDataOut"))
                if (!$util.isInteger(message.totalDataOut) && !(message.totalDataOut && $util.isInteger(message.totalDataOut.low) && $util.isInteger(message.totalDataOut.high)))
                    return "totalDataOut: integer|Long expected";
            if (message.totalPacketsOut != null && message.hasOwnProperty("totalPacketsOut"))
                if (!$util.isInteger(message.totalPacketsOut) && !(message.totalPacketsOut && $util.isInteger(message.totalPacketsOut.low) && $util.isInteger(message.totalPacketsOut.high)))
                    return "totalPacketsOut: integer|Long expected";
            if (message.players != null && message.hasOwnProperty("players")) {
                if (!Array.isArray(message.players))
                    return "players: array expected";
                for (var i = 0; i < message.players.length; ++i) {
                    var error = $root.CMsgServerNetworkStats.Player.verify(message.players[i]);
                    if (error)
                        return "players." + error;
                }
            }
            return null;
        };
    
        /**
         * Creates a CMsgServerNetworkStats message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CMsgServerNetworkStats
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CMsgServerNetworkStats} CMsgServerNetworkStats
         */
        CMsgServerNetworkStats.fromObject = function fromObject(object) {
            if (object instanceof $root.CMsgServerNetworkStats)
                return object;
            var message = new $root.CMsgServerNetworkStats();
            if (object.dedicated != null)
                message.dedicated = Boolean(object.dedicated);
            if (object.cpuUsage != null)
                message.cpuUsage = object.cpuUsage | 0;
            if (object.memoryUsedMb != null)
                message.memoryUsedMb = object.memoryUsedMb | 0;
            if (object.memoryFreeMb != null)
                message.memoryFreeMb = object.memoryFreeMb | 0;
            if (object.uptime != null)
                message.uptime = object.uptime | 0;
            if (object.spawnCount != null)
                message.spawnCount = object.spawnCount | 0;
            if (object.numClients != null)
                message.numClients = object.numClients | 0;
            if (object.numBots != null)
                message.numBots = object.numBots | 0;
            if (object.numSpectators != null)
                message.numSpectators = object.numSpectators | 0;
            if (object.numTvRelays != null)
                message.numTvRelays = object.numTvRelays | 0;
            if (object.fps != null)
                message.fps = Number(object.fps);
            if (object.ports) {
                if (!Array.isArray(object.ports))
                    throw TypeError(".CMsgServerNetworkStats.ports: array expected");
                message.ports = [];
                for (var i = 0; i < object.ports.length; ++i) {
                    if (typeof object.ports[i] !== "object")
                        throw TypeError(".CMsgServerNetworkStats.ports: object expected");
                    message.ports[i] = $root.CMsgServerNetworkStats.Port.fromObject(object.ports[i]);
                }
            }
            if (object.avgPingMs != null)
                message.avgPingMs = Number(object.avgPingMs);
            if (object.avgEngineLatencyOut != null)
                message.avgEngineLatencyOut = Number(object.avgEngineLatencyOut);
            if (object.avgPacketsOut != null)
                message.avgPacketsOut = Number(object.avgPacketsOut);
            if (object.avgPacketsIn != null)
                message.avgPacketsIn = Number(object.avgPacketsIn);
            if (object.avgLossOut != null)
                message.avgLossOut = Number(object.avgLossOut);
            if (object.avgLossIn != null)
                message.avgLossIn = Number(object.avgLossIn);
            if (object.avgDataOut != null)
                message.avgDataOut = Number(object.avgDataOut);
            if (object.avgDataIn != null)
                message.avgDataIn = Number(object.avgDataIn);
            if (object.totalDataIn != null)
                if ($util.Long)
                    (message.totalDataIn = $util.Long.fromValue(object.totalDataIn)).unsigned = true;
                else if (typeof object.totalDataIn === "string")
                    message.totalDataIn = parseInt(object.totalDataIn, 10);
                else if (typeof object.totalDataIn === "number")
                    message.totalDataIn = object.totalDataIn;
                else if (typeof object.totalDataIn === "object")
                    message.totalDataIn = new $util.LongBits(object.totalDataIn.low >>> 0, object.totalDataIn.high >>> 0).toNumber(true);
            if (object.totalPacketsIn != null)
                if ($util.Long)
                    (message.totalPacketsIn = $util.Long.fromValue(object.totalPacketsIn)).unsigned = true;
                else if (typeof object.totalPacketsIn === "string")
                    message.totalPacketsIn = parseInt(object.totalPacketsIn, 10);
                else if (typeof object.totalPacketsIn === "number")
                    message.totalPacketsIn = object.totalPacketsIn;
                else if (typeof object.totalPacketsIn === "object")
                    message.totalPacketsIn = new $util.LongBits(object.totalPacketsIn.low >>> 0, object.totalPacketsIn.high >>> 0).toNumber(true);
            if (object.totalDataOut != null)
                if ($util.Long)
                    (message.totalDataOut = $util.Long.fromValue(object.totalDataOut)).unsigned = true;
                else if (typeof object.totalDataOut === "string")
                    message.totalDataOut = parseInt(object.totalDataOut, 10);
                else if (typeof object.totalDataOut === "number")
                    message.totalDataOut = object.totalDataOut;
                else if (typeof object.totalDataOut === "object")
                    message.totalDataOut = new $util.LongBits(object.totalDataOut.low >>> 0, object.totalDataOut.high >>> 0).toNumber(true);
            if (object.totalPacketsOut != null)
                if ($util.Long)
                    (message.totalPacketsOut = $util.Long.fromValue(object.totalPacketsOut)).unsigned = true;
                else if (typeof object.totalPacketsOut === "string")
                    message.totalPacketsOut = parseInt(object.totalPacketsOut, 10);
                else if (typeof object.totalPacketsOut === "number")
                    message.totalPacketsOut = object.totalPacketsOut;
                else if (typeof object.totalPacketsOut === "object")
                    message.totalPacketsOut = new $util.LongBits(object.totalPacketsOut.low >>> 0, object.totalPacketsOut.high >>> 0).toNumber(true);
            if (object.players) {
                if (!Array.isArray(object.players))
                    throw TypeError(".CMsgServerNetworkStats.players: array expected");
                message.players = [];
                for (var i = 0; i < object.players.length; ++i) {
                    if (typeof object.players[i] !== "object")
                        throw TypeError(".CMsgServerNetworkStats.players: object expected");
                    message.players[i] = $root.CMsgServerNetworkStats.Player.fromObject(object.players[i]);
                }
            }
            return message;
        };
    
        /**
         * Creates a plain object from a CMsgServerNetworkStats message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CMsgServerNetworkStats
         * @static
         * @param {CMsgServerNetworkStats} message CMsgServerNetworkStats
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CMsgServerNetworkStats.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults) {
                object.ports = [];
                object.players = [];
            }
            if (options.defaults) {
                object.dedicated = false;
                object.cpuUsage = 0;
                object.memoryUsedMb = 0;
                object.memoryFreeMb = 0;
                object.uptime = 0;
                object.spawnCount = 0;
                object.numClients = 0;
                object.numBots = 0;
                object.numSpectators = 0;
                object.numTvRelays = 0;
                object.fps = 0;
                object.avgPingMs = 0;
                object.avgEngineLatencyOut = 0;
                object.avgPacketsOut = 0;
                object.avgPacketsIn = 0;
                object.avgLossOut = 0;
                object.avgLossIn = 0;
                object.avgDataOut = 0;
                object.avgDataIn = 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.totalDataIn = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.totalDataIn = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.totalPacketsIn = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.totalPacketsIn = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.totalDataOut = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.totalDataOut = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.totalPacketsOut = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.totalPacketsOut = options.longs === String ? "0" : 0;
            }
            if (message.dedicated != null && message.hasOwnProperty("dedicated"))
                object.dedicated = message.dedicated;
            if (message.cpuUsage != null && message.hasOwnProperty("cpuUsage"))
                object.cpuUsage = message.cpuUsage;
            if (message.memoryUsedMb != null && message.hasOwnProperty("memoryUsedMb"))
                object.memoryUsedMb = message.memoryUsedMb;
            if (message.memoryFreeMb != null && message.hasOwnProperty("memoryFreeMb"))
                object.memoryFreeMb = message.memoryFreeMb;
            if (message.uptime != null && message.hasOwnProperty("uptime"))
                object.uptime = message.uptime;
            if (message.spawnCount != null && message.hasOwnProperty("spawnCount"))
                object.spawnCount = message.spawnCount;
            if (message.numClients != null && message.hasOwnProperty("numClients"))
                object.numClients = message.numClients;
            if (message.numBots != null && message.hasOwnProperty("numBots"))
                object.numBots = message.numBots;
            if (message.numSpectators != null && message.hasOwnProperty("numSpectators"))
                object.numSpectators = message.numSpectators;
            if (message.numTvRelays != null && message.hasOwnProperty("numTvRelays"))
                object.numTvRelays = message.numTvRelays;
            if (message.fps != null && message.hasOwnProperty("fps"))
                object.fps = options.json && !isFinite(message.fps) ? String(message.fps) : message.fps;
            if (message.ports && message.ports.length) {
                object.ports = [];
                for (var j = 0; j < message.ports.length; ++j)
                    object.ports[j] = $root.CMsgServerNetworkStats.Port.toObject(message.ports[j], options);
            }
            if (message.avgPingMs != null && message.hasOwnProperty("avgPingMs"))
                object.avgPingMs = options.json && !isFinite(message.avgPingMs) ? String(message.avgPingMs) : message.avgPingMs;
            if (message.avgEngineLatencyOut != null && message.hasOwnProperty("avgEngineLatencyOut"))
                object.avgEngineLatencyOut = options.json && !isFinite(message.avgEngineLatencyOut) ? String(message.avgEngineLatencyOut) : message.avgEngineLatencyOut;
            if (message.avgPacketsOut != null && message.hasOwnProperty("avgPacketsOut"))
                object.avgPacketsOut = options.json && !isFinite(message.avgPacketsOut) ? String(message.avgPacketsOut) : message.avgPacketsOut;
            if (message.avgPacketsIn != null && message.hasOwnProperty("avgPacketsIn"))
                object.avgPacketsIn = options.json && !isFinite(message.avgPacketsIn) ? String(message.avgPacketsIn) : message.avgPacketsIn;
            if (message.avgLossOut != null && message.hasOwnProperty("avgLossOut"))
                object.avgLossOut = options.json && !isFinite(message.avgLossOut) ? String(message.avgLossOut) : message.avgLossOut;
            if (message.avgLossIn != null && message.hasOwnProperty("avgLossIn"))
                object.avgLossIn = options.json && !isFinite(message.avgLossIn) ? String(message.avgLossIn) : message.avgLossIn;
            if (message.avgDataOut != null && message.hasOwnProperty("avgDataOut"))
                object.avgDataOut = options.json && !isFinite(message.avgDataOut) ? String(message.avgDataOut) : message.avgDataOut;
            if (message.avgDataIn != null && message.hasOwnProperty("avgDataIn"))
                object.avgDataIn = options.json && !isFinite(message.avgDataIn) ? String(message.avgDataIn) : message.avgDataIn;
            if (message.totalDataIn != null && message.hasOwnProperty("totalDataIn"))
                if (typeof message.totalDataIn === "number")
                    object.totalDataIn = options.longs === String ? String(message.totalDataIn) : message.totalDataIn;
                else
                    object.totalDataIn = options.longs === String ? $util.Long.prototype.toString.call(message.totalDataIn) : options.longs === Number ? new $util.LongBits(message.totalDataIn.low >>> 0, message.totalDataIn.high >>> 0).toNumber(true) : message.totalDataIn;
            if (message.totalPacketsIn != null && message.hasOwnProperty("totalPacketsIn"))
                if (typeof message.totalPacketsIn === "number")
                    object.totalPacketsIn = options.longs === String ? String(message.totalPacketsIn) : message.totalPacketsIn;
                else
                    object.totalPacketsIn = options.longs === String ? $util.Long.prototype.toString.call(message.totalPacketsIn) : options.longs === Number ? new $util.LongBits(message.totalPacketsIn.low >>> 0, message.totalPacketsIn.high >>> 0).toNumber(true) : message.totalPacketsIn;
            if (message.totalDataOut != null && message.hasOwnProperty("totalDataOut"))
                if (typeof message.totalDataOut === "number")
                    object.totalDataOut = options.longs === String ? String(message.totalDataOut) : message.totalDataOut;
                else
                    object.totalDataOut = options.longs === String ? $util.Long.prototype.toString.call(message.totalDataOut) : options.longs === Number ? new $util.LongBits(message.totalDataOut.low >>> 0, message.totalDataOut.high >>> 0).toNumber(true) : message.totalDataOut;
            if (message.totalPacketsOut != null && message.hasOwnProperty("totalPacketsOut"))
                if (typeof message.totalPacketsOut === "number")
                    object.totalPacketsOut = options.longs === String ? String(message.totalPacketsOut) : message.totalPacketsOut;
                else
                    object.totalPacketsOut = options.longs === String ? $util.Long.prototype.toString.call(message.totalPacketsOut) : options.longs === Number ? new $util.LongBits(message.totalPacketsOut.low >>> 0, message.totalPacketsOut.high >>> 0).toNumber(true) : message.totalPacketsOut;
            if (message.players && message.players.length) {
                object.players = [];
                for (var j = 0; j < message.players.length; ++j)
                    object.players[j] = $root.CMsgServerNetworkStats.Player.toObject(message.players[j], options);
            }
            return object;
        };
    
        /**
         * Converts this CMsgServerNetworkStats to JSON.
         * @function toJSON
         * @memberof CMsgServerNetworkStats
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CMsgServerNetworkStats.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * Gets the default type url for CMsgServerNetworkStats
         * @function getTypeUrl
         * @memberof CMsgServerNetworkStats
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        CMsgServerNetworkStats.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/CMsgServerNetworkStats";
        };
    
        CMsgServerNetworkStats.Port = (function() {
    
            /**
             * Properties of a Port.
             * @memberof CMsgServerNetworkStats
             * @interface IPort
             * @property {number|null} [port] Port port
             * @property {string|null} [name] Port name
             */
    
            /**
             * Constructs a new Port.
             * @memberof CMsgServerNetworkStats
             * @classdesc Represents a Port.
             * @implements IPort
             * @constructor
             * @param {CMsgServerNetworkStats.IPort=} [properties] Properties to set
             */
            function Port(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * Port port.
             * @member {number} port
             * @memberof CMsgServerNetworkStats.Port
             * @instance
             */
            Port.prototype.port = 0;
    
            /**
             * Port name.
             * @member {string} name
             * @memberof CMsgServerNetworkStats.Port
             * @instance
             */
            Port.prototype.name = "";
    
            /**
             * Creates a new Port instance using the specified properties.
             * @function create
             * @memberof CMsgServerNetworkStats.Port
             * @static
             * @param {CMsgServerNetworkStats.IPort=} [properties] Properties to set
             * @returns {CMsgServerNetworkStats.Port} Port instance
             */
            Port.create = function create(properties) {
                return new Port(properties);
            };
    
            /**
             * Encodes the specified Port message. Does not implicitly {@link CMsgServerNetworkStats.Port.verify|verify} messages.
             * @function encode
             * @memberof CMsgServerNetworkStats.Port
             * @static
             * @param {CMsgServerNetworkStats.IPort} message Port message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Port.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.port != null && Object.hasOwnProperty.call(message, "port"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.port);
                if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.name);
                return writer;
            };
    
            /**
             * Encodes the specified Port message, length delimited. Does not implicitly {@link CMsgServerNetworkStats.Port.verify|verify} messages.
             * @function encodeDelimited
             * @memberof CMsgServerNetworkStats.Port
             * @static
             * @param {CMsgServerNetworkStats.IPort} message Port message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Port.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a Port message from the specified reader or buffer.
             * @function decode
             * @memberof CMsgServerNetworkStats.Port
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {CMsgServerNetworkStats.Port} Port
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Port.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgServerNetworkStats.Port();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.port = reader.int32();
                            break;
                        }
                    case 2: {
                            message.name = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a Port message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof CMsgServerNetworkStats.Port
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {CMsgServerNetworkStats.Port} Port
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Port.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a Port message.
             * @function verify
             * @memberof CMsgServerNetworkStats.Port
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Port.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.port != null && message.hasOwnProperty("port"))
                    if (!$util.isInteger(message.port))
                        return "port: integer expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                return null;
            };
    
            /**
             * Creates a Port message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof CMsgServerNetworkStats.Port
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {CMsgServerNetworkStats.Port} Port
             */
            Port.fromObject = function fromObject(object) {
                if (object instanceof $root.CMsgServerNetworkStats.Port)
                    return object;
                var message = new $root.CMsgServerNetworkStats.Port();
                if (object.port != null)
                    message.port = object.port | 0;
                if (object.name != null)
                    message.name = String(object.name);
                return message;
            };
    
            /**
             * Creates a plain object from a Port message. Also converts values to other types if specified.
             * @function toObject
             * @memberof CMsgServerNetworkStats.Port
             * @static
             * @param {CMsgServerNetworkStats.Port} message Port
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Port.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.port = 0;
                    object.name = "";
                }
                if (message.port != null && message.hasOwnProperty("port"))
                    object.port = message.port;
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                return object;
            };
    
            /**
             * Converts this Port to JSON.
             * @function toJSON
             * @memberof CMsgServerNetworkStats.Port
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Port.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            /**
             * Gets the default type url for Port
             * @function getTypeUrl
             * @memberof CMsgServerNetworkStats.Port
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            Port.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/CMsgServerNetworkStats.Port";
            };
    
            return Port;
        })();
    
        CMsgServerNetworkStats.Player = (function() {
    
            /**
             * Properties of a Player.
             * @memberof CMsgServerNetworkStats
             * @interface IPlayer
             * @property {number|Long|null} [steamid] Player steamid
             * @property {string|null} [remoteAddr] Player remoteAddr
             * @property {number|null} [pingAvgMs] Player pingAvgMs
             * @property {number|null} [packetLossPct] Player packetLossPct
             * @property {boolean|null} [isBot] Player isBot
             * @property {number|null} [lossIn] Player lossIn
             * @property {number|null} [lossOut] Player lossOut
             * @property {number|null} [engineLatencyMs] Player engineLatencyMs
             */
    
            /**
             * Constructs a new Player.
             * @memberof CMsgServerNetworkStats
             * @classdesc Represents a Player.
             * @implements IPlayer
             * @constructor
             * @param {CMsgServerNetworkStats.IPlayer=} [properties] Properties to set
             */
            function Player(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * Player steamid.
             * @member {number|Long} steamid
             * @memberof CMsgServerNetworkStats.Player
             * @instance
             */
            Player.prototype.steamid = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
            /**
             * Player remoteAddr.
             * @member {string} remoteAddr
             * @memberof CMsgServerNetworkStats.Player
             * @instance
             */
            Player.prototype.remoteAddr = "";
    
            /**
             * Player pingAvgMs.
             * @member {number} pingAvgMs
             * @memberof CMsgServerNetworkStats.Player
             * @instance
             */
            Player.prototype.pingAvgMs = 0;
    
            /**
             * Player packetLossPct.
             * @member {number} packetLossPct
             * @memberof CMsgServerNetworkStats.Player
             * @instance
             */
            Player.prototype.packetLossPct = 0;
    
            /**
             * Player isBot.
             * @member {boolean} isBot
             * @memberof CMsgServerNetworkStats.Player
             * @instance
             */
            Player.prototype.isBot = false;
    
            /**
             * Player lossIn.
             * @member {number} lossIn
             * @memberof CMsgServerNetworkStats.Player
             * @instance
             */
            Player.prototype.lossIn = 0;
    
            /**
             * Player lossOut.
             * @member {number} lossOut
             * @memberof CMsgServerNetworkStats.Player
             * @instance
             */
            Player.prototype.lossOut = 0;
    
            /**
             * Player engineLatencyMs.
             * @member {number} engineLatencyMs
             * @memberof CMsgServerNetworkStats.Player
             * @instance
             */
            Player.prototype.engineLatencyMs = 0;
    
            /**
             * Creates a new Player instance using the specified properties.
             * @function create
             * @memberof CMsgServerNetworkStats.Player
             * @static
             * @param {CMsgServerNetworkStats.IPlayer=} [properties] Properties to set
             * @returns {CMsgServerNetworkStats.Player} Player instance
             */
            Player.create = function create(properties) {
                return new Player(properties);
            };
    
            /**
             * Encodes the specified Player message. Does not implicitly {@link CMsgServerNetworkStats.Player.verify|verify} messages.
             * @function encode
             * @memberof CMsgServerNetworkStats.Player
             * @static
             * @param {CMsgServerNetworkStats.IPlayer} message Player message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Player.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.steamid != null && Object.hasOwnProperty.call(message, "steamid"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.steamid);
                if (message.remoteAddr != null && Object.hasOwnProperty.call(message, "remoteAddr"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.remoteAddr);
                if (message.pingAvgMs != null && Object.hasOwnProperty.call(message, "pingAvgMs"))
                    writer.uint32(/* id 4, wireType 0 =*/32).int32(message.pingAvgMs);
                if (message.packetLossPct != null && Object.hasOwnProperty.call(message, "packetLossPct"))
                    writer.uint32(/* id 5, wireType 5 =*/45).float(message.packetLossPct);
                if (message.isBot != null && Object.hasOwnProperty.call(message, "isBot"))
                    writer.uint32(/* id 6, wireType 0 =*/48).bool(message.isBot);
                if (message.lossIn != null && Object.hasOwnProperty.call(message, "lossIn"))
                    writer.uint32(/* id 7, wireType 5 =*/61).float(message.lossIn);
                if (message.lossOut != null && Object.hasOwnProperty.call(message, "lossOut"))
                    writer.uint32(/* id 8, wireType 5 =*/69).float(message.lossOut);
                if (message.engineLatencyMs != null && Object.hasOwnProperty.call(message, "engineLatencyMs"))
                    writer.uint32(/* id 9, wireType 0 =*/72).int32(message.engineLatencyMs);
                return writer;
            };
    
            /**
             * Encodes the specified Player message, length delimited. Does not implicitly {@link CMsgServerNetworkStats.Player.verify|verify} messages.
             * @function encodeDelimited
             * @memberof CMsgServerNetworkStats.Player
             * @static
             * @param {CMsgServerNetworkStats.IPlayer} message Player message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Player.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a Player message from the specified reader or buffer.
             * @function decode
             * @memberof CMsgServerNetworkStats.Player
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {CMsgServerNetworkStats.Player} Player
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Player.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgServerNetworkStats.Player();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.steamid = reader.uint64();
                            break;
                        }
                    case 2: {
                            message.remoteAddr = reader.string();
                            break;
                        }
                    case 4: {
                            message.pingAvgMs = reader.int32();
                            break;
                        }
                    case 5: {
                            message.packetLossPct = reader.float();
                            break;
                        }
                    case 6: {
                            message.isBot = reader.bool();
                            break;
                        }
                    case 7: {
                            message.lossIn = reader.float();
                            break;
                        }
                    case 8: {
                            message.lossOut = reader.float();
                            break;
                        }
                    case 9: {
                            message.engineLatencyMs = reader.int32();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a Player message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof CMsgServerNetworkStats.Player
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {CMsgServerNetworkStats.Player} Player
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Player.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a Player message.
             * @function verify
             * @memberof CMsgServerNetworkStats.Player
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Player.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.steamid != null && message.hasOwnProperty("steamid"))
                    if (!$util.isInteger(message.steamid) && !(message.steamid && $util.isInteger(message.steamid.low) && $util.isInteger(message.steamid.high)))
                        return "steamid: integer|Long expected";
                if (message.remoteAddr != null && message.hasOwnProperty("remoteAddr"))
                    if (!$util.isString(message.remoteAddr))
                        return "remoteAddr: string expected";
                if (message.pingAvgMs != null && message.hasOwnProperty("pingAvgMs"))
                    if (!$util.isInteger(message.pingAvgMs))
                        return "pingAvgMs: integer expected";
                if (message.packetLossPct != null && message.hasOwnProperty("packetLossPct"))
                    if (typeof message.packetLossPct !== "number")
                        return "packetLossPct: number expected";
                if (message.isBot != null && message.hasOwnProperty("isBot"))
                    if (typeof message.isBot !== "boolean")
                        return "isBot: boolean expected";
                if (message.lossIn != null && message.hasOwnProperty("lossIn"))
                    if (typeof message.lossIn !== "number")
                        return "lossIn: number expected";
                if (message.lossOut != null && message.hasOwnProperty("lossOut"))
                    if (typeof message.lossOut !== "number")
                        return "lossOut: number expected";
                if (message.engineLatencyMs != null && message.hasOwnProperty("engineLatencyMs"))
                    if (!$util.isInteger(message.engineLatencyMs))
                        return "engineLatencyMs: integer expected";
                return null;
            };
    
            /**
             * Creates a Player message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof CMsgServerNetworkStats.Player
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {CMsgServerNetworkStats.Player} Player
             */
            Player.fromObject = function fromObject(object) {
                if (object instanceof $root.CMsgServerNetworkStats.Player)
                    return object;
                var message = new $root.CMsgServerNetworkStats.Player();
                if (object.steamid != null)
                    if ($util.Long)
                        (message.steamid = $util.Long.fromValue(object.steamid)).unsigned = true;
                    else if (typeof object.steamid === "string")
                        message.steamid = parseInt(object.steamid, 10);
                    else if (typeof object.steamid === "number")
                        message.steamid = object.steamid;
                    else if (typeof object.steamid === "object")
                        message.steamid = new $util.LongBits(object.steamid.low >>> 0, object.steamid.high >>> 0).toNumber(true);
                if (object.remoteAddr != null)
                    message.remoteAddr = String(object.remoteAddr);
                if (object.pingAvgMs != null)
                    message.pingAvgMs = object.pingAvgMs | 0;
                if (object.packetLossPct != null)
                    message.packetLossPct = Number(object.packetLossPct);
                if (object.isBot != null)
                    message.isBot = Boolean(object.isBot);
                if (object.lossIn != null)
                    message.lossIn = Number(object.lossIn);
                if (object.lossOut != null)
                    message.lossOut = Number(object.lossOut);
                if (object.engineLatencyMs != null)
                    message.engineLatencyMs = object.engineLatencyMs | 0;
                return message;
            };
    
            /**
             * Creates a plain object from a Player message. Also converts values to other types if specified.
             * @function toObject
             * @memberof CMsgServerNetworkStats.Player
             * @static
             * @param {CMsgServerNetworkStats.Player} message Player
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Player.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, true);
                        object.steamid = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.steamid = options.longs === String ? "0" : 0;
                    object.remoteAddr = "";
                    object.pingAvgMs = 0;
                    object.packetLossPct = 0;
                    object.isBot = false;
                    object.lossIn = 0;
                    object.lossOut = 0;
                    object.engineLatencyMs = 0;
                }
                if (message.steamid != null && message.hasOwnProperty("steamid"))
                    if (typeof message.steamid === "number")
                        object.steamid = options.longs === String ? String(message.steamid) : message.steamid;
                    else
                        object.steamid = options.longs === String ? $util.Long.prototype.toString.call(message.steamid) : options.longs === Number ? new $util.LongBits(message.steamid.low >>> 0, message.steamid.high >>> 0).toNumber(true) : message.steamid;
                if (message.remoteAddr != null && message.hasOwnProperty("remoteAddr"))
                    object.remoteAddr = message.remoteAddr;
                if (message.pingAvgMs != null && message.hasOwnProperty("pingAvgMs"))
                    object.pingAvgMs = message.pingAvgMs;
                if (message.packetLossPct != null && message.hasOwnProperty("packetLossPct"))
                    object.packetLossPct = options.json && !isFinite(message.packetLossPct) ? String(message.packetLossPct) : message.packetLossPct;
                if (message.isBot != null && message.hasOwnProperty("isBot"))
                    object.isBot = message.isBot;
                if (message.lossIn != null && message.hasOwnProperty("lossIn"))
                    object.lossIn = options.json && !isFinite(message.lossIn) ? String(message.lossIn) : message.lossIn;
                if (message.lossOut != null && message.hasOwnProperty("lossOut"))
                    object.lossOut = options.json && !isFinite(message.lossOut) ? String(message.lossOut) : message.lossOut;
                if (message.engineLatencyMs != null && message.hasOwnProperty("engineLatencyMs"))
                    object.engineLatencyMs = message.engineLatencyMs;
                return object;
            };
    
            /**
             * Converts this Player to JSON.
             * @function toJSON
             * @memberof CMsgServerNetworkStats.Player
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Player.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            /**
             * Gets the default type url for Player
             * @function getTypeUrl
             * @memberof CMsgServerNetworkStats.Player
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            Player.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/CMsgServerNetworkStats.Player";
            };
    
            return Player;
        })();
    
        return CMsgServerNetworkStats;
    })();
    
    $root.CSVCMsg_HltvReplay = (function() {
    
        /**
         * Properties of a CSVCMsg_HltvReplay.
         * @exports ICSVCMsg_HltvReplay
         * @interface ICSVCMsg_HltvReplay
         * @property {number|null} [delay] CSVCMsg_HltvReplay delay
         * @property {number|null} [primaryTarget] CSVCMsg_HltvReplay primaryTarget
         * @property {number|null} [replayStopAt] CSVCMsg_HltvReplay replayStopAt
         * @property {number|null} [replayStartAt] CSVCMsg_HltvReplay replayStartAt
         * @property {number|null} [replaySlowdownBegin] CSVCMsg_HltvReplay replaySlowdownBegin
         * @property {number|null} [replaySlowdownEnd] CSVCMsg_HltvReplay replaySlowdownEnd
         * @property {number|null} [replaySlowdownRate] CSVCMsg_HltvReplay replaySlowdownRate
         * @property {number|null} [reason] CSVCMsg_HltvReplay reason
         */
    
        /**
         * Constructs a new CSVCMsg_HltvReplay.
         * @exports CSVCMsg_HltvReplay
         * @classdesc Represents a CSVCMsg_HltvReplay.
         * @implements ICSVCMsg_HltvReplay
         * @constructor
         * @param {ICSVCMsg_HltvReplay=} [properties] Properties to set
         */
        function CSVCMsg_HltvReplay(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CSVCMsg_HltvReplay delay.
         * @member {number} delay
         * @memberof CSVCMsg_HltvReplay
         * @instance
         */
        CSVCMsg_HltvReplay.prototype.delay = 0;
    
        /**
         * CSVCMsg_HltvReplay primaryTarget.
         * @member {number} primaryTarget
         * @memberof CSVCMsg_HltvReplay
         * @instance
         */
        CSVCMsg_HltvReplay.prototype.primaryTarget = -1;
    
        /**
         * CSVCMsg_HltvReplay replayStopAt.
         * @member {number} replayStopAt
         * @memberof CSVCMsg_HltvReplay
         * @instance
         */
        CSVCMsg_HltvReplay.prototype.replayStopAt = 0;
    
        /**
         * CSVCMsg_HltvReplay replayStartAt.
         * @member {number} replayStartAt
         * @memberof CSVCMsg_HltvReplay
         * @instance
         */
        CSVCMsg_HltvReplay.prototype.replayStartAt = 0;
    
        /**
         * CSVCMsg_HltvReplay replaySlowdownBegin.
         * @member {number} replaySlowdownBegin
         * @memberof CSVCMsg_HltvReplay
         * @instance
         */
        CSVCMsg_HltvReplay.prototype.replaySlowdownBegin = 0;
    
        /**
         * CSVCMsg_HltvReplay replaySlowdownEnd.
         * @member {number} replaySlowdownEnd
         * @memberof CSVCMsg_HltvReplay
         * @instance
         */
        CSVCMsg_HltvReplay.prototype.replaySlowdownEnd = 0;
    
        /**
         * CSVCMsg_HltvReplay replaySlowdownRate.
         * @member {number} replaySlowdownRate
         * @memberof CSVCMsg_HltvReplay
         * @instance
         */
        CSVCMsg_HltvReplay.prototype.replaySlowdownRate = 0;
    
        /**
         * CSVCMsg_HltvReplay reason.
         * @member {number} reason
         * @memberof CSVCMsg_HltvReplay
         * @instance
         */
        CSVCMsg_HltvReplay.prototype.reason = 0;
    
        /**
         * Creates a new CSVCMsg_HltvReplay instance using the specified properties.
         * @function create
         * @memberof CSVCMsg_HltvReplay
         * @static
         * @param {ICSVCMsg_HltvReplay=} [properties] Properties to set
         * @returns {CSVCMsg_HltvReplay} CSVCMsg_HltvReplay instance
         */
        CSVCMsg_HltvReplay.create = function create(properties) {
            return new CSVCMsg_HltvReplay(properties);
        };
    
        /**
         * Encodes the specified CSVCMsg_HltvReplay message. Does not implicitly {@link CSVCMsg_HltvReplay.verify|verify} messages.
         * @function encode
         * @memberof CSVCMsg_HltvReplay
         * @static
         * @param {ICSVCMsg_HltvReplay} message CSVCMsg_HltvReplay message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CSVCMsg_HltvReplay.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.delay != null && Object.hasOwnProperty.call(message, "delay"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.delay);
            if (message.primaryTarget != null && Object.hasOwnProperty.call(message, "primaryTarget"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.primaryTarget);
            if (message.replayStopAt != null && Object.hasOwnProperty.call(message, "replayStopAt"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.replayStopAt);
            if (message.replayStartAt != null && Object.hasOwnProperty.call(message, "replayStartAt"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.replayStartAt);
            if (message.replaySlowdownBegin != null && Object.hasOwnProperty.call(message, "replaySlowdownBegin"))
                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.replaySlowdownBegin);
            if (message.replaySlowdownEnd != null && Object.hasOwnProperty.call(message, "replaySlowdownEnd"))
                writer.uint32(/* id 6, wireType 0 =*/48).int32(message.replaySlowdownEnd);
            if (message.replaySlowdownRate != null && Object.hasOwnProperty.call(message, "replaySlowdownRate"))
                writer.uint32(/* id 7, wireType 5 =*/61).float(message.replaySlowdownRate);
            if (message.reason != null && Object.hasOwnProperty.call(message, "reason"))
                writer.uint32(/* id 8, wireType 0 =*/64).int32(message.reason);
            return writer;
        };
    
        /**
         * Encodes the specified CSVCMsg_HltvReplay message, length delimited. Does not implicitly {@link CSVCMsg_HltvReplay.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CSVCMsg_HltvReplay
         * @static
         * @param {ICSVCMsg_HltvReplay} message CSVCMsg_HltvReplay message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CSVCMsg_HltvReplay.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CSVCMsg_HltvReplay message from the specified reader or buffer.
         * @function decode
         * @memberof CSVCMsg_HltvReplay
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CSVCMsg_HltvReplay} CSVCMsg_HltvReplay
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CSVCMsg_HltvReplay.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CSVCMsg_HltvReplay();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.delay = reader.int32();
                        break;
                    }
                case 2: {
                        message.primaryTarget = reader.int32();
                        break;
                    }
                case 3: {
                        message.replayStopAt = reader.int32();
                        break;
                    }
                case 4: {
                        message.replayStartAt = reader.int32();
                        break;
                    }
                case 5: {
                        message.replaySlowdownBegin = reader.int32();
                        break;
                    }
                case 6: {
                        message.replaySlowdownEnd = reader.int32();
                        break;
                    }
                case 7: {
                        message.replaySlowdownRate = reader.float();
                        break;
                    }
                case 8: {
                        message.reason = reader.int32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CSVCMsg_HltvReplay message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CSVCMsg_HltvReplay
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CSVCMsg_HltvReplay} CSVCMsg_HltvReplay
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CSVCMsg_HltvReplay.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CSVCMsg_HltvReplay message.
         * @function verify
         * @memberof CSVCMsg_HltvReplay
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CSVCMsg_HltvReplay.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.delay != null && message.hasOwnProperty("delay"))
                if (!$util.isInteger(message.delay))
                    return "delay: integer expected";
            if (message.primaryTarget != null && message.hasOwnProperty("primaryTarget"))
                if (!$util.isInteger(message.primaryTarget))
                    return "primaryTarget: integer expected";
            if (message.replayStopAt != null && message.hasOwnProperty("replayStopAt"))
                if (!$util.isInteger(message.replayStopAt))
                    return "replayStopAt: integer expected";
            if (message.replayStartAt != null && message.hasOwnProperty("replayStartAt"))
                if (!$util.isInteger(message.replayStartAt))
                    return "replayStartAt: integer expected";
            if (message.replaySlowdownBegin != null && message.hasOwnProperty("replaySlowdownBegin"))
                if (!$util.isInteger(message.replaySlowdownBegin))
                    return "replaySlowdownBegin: integer expected";
            if (message.replaySlowdownEnd != null && message.hasOwnProperty("replaySlowdownEnd"))
                if (!$util.isInteger(message.replaySlowdownEnd))
                    return "replaySlowdownEnd: integer expected";
            if (message.replaySlowdownRate != null && message.hasOwnProperty("replaySlowdownRate"))
                if (typeof message.replaySlowdownRate !== "number")
                    return "replaySlowdownRate: number expected";
            if (message.reason != null && message.hasOwnProperty("reason"))
                if (!$util.isInteger(message.reason))
                    return "reason: integer expected";
            return null;
        };
    
        /**
         * Creates a CSVCMsg_HltvReplay message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CSVCMsg_HltvReplay
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CSVCMsg_HltvReplay} CSVCMsg_HltvReplay
         */
        CSVCMsg_HltvReplay.fromObject = function fromObject(object) {
            if (object instanceof $root.CSVCMsg_HltvReplay)
                return object;
            var message = new $root.CSVCMsg_HltvReplay();
            if (object.delay != null)
                message.delay = object.delay | 0;
            if (object.primaryTarget != null)
                message.primaryTarget = object.primaryTarget | 0;
            if (object.replayStopAt != null)
                message.replayStopAt = object.replayStopAt | 0;
            if (object.replayStartAt != null)
                message.replayStartAt = object.replayStartAt | 0;
            if (object.replaySlowdownBegin != null)
                message.replaySlowdownBegin = object.replaySlowdownBegin | 0;
            if (object.replaySlowdownEnd != null)
                message.replaySlowdownEnd = object.replaySlowdownEnd | 0;
            if (object.replaySlowdownRate != null)
                message.replaySlowdownRate = Number(object.replaySlowdownRate);
            if (object.reason != null)
                message.reason = object.reason | 0;
            return message;
        };
    
        /**
         * Creates a plain object from a CSVCMsg_HltvReplay message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CSVCMsg_HltvReplay
         * @static
         * @param {CSVCMsg_HltvReplay} message CSVCMsg_HltvReplay
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CSVCMsg_HltvReplay.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.delay = 0;
                object.primaryTarget = -1;
                object.replayStopAt = 0;
                object.replayStartAt = 0;
                object.replaySlowdownBegin = 0;
                object.replaySlowdownEnd = 0;
                object.replaySlowdownRate = 0;
                object.reason = 0;
            }
            if (message.delay != null && message.hasOwnProperty("delay"))
                object.delay = message.delay;
            if (message.primaryTarget != null && message.hasOwnProperty("primaryTarget"))
                object.primaryTarget = message.primaryTarget;
            if (message.replayStopAt != null && message.hasOwnProperty("replayStopAt"))
                object.replayStopAt = message.replayStopAt;
            if (message.replayStartAt != null && message.hasOwnProperty("replayStartAt"))
                object.replayStartAt = message.replayStartAt;
            if (message.replaySlowdownBegin != null && message.hasOwnProperty("replaySlowdownBegin"))
                object.replaySlowdownBegin = message.replaySlowdownBegin;
            if (message.replaySlowdownEnd != null && message.hasOwnProperty("replaySlowdownEnd"))
                object.replaySlowdownEnd = message.replaySlowdownEnd;
            if (message.replaySlowdownRate != null && message.hasOwnProperty("replaySlowdownRate"))
                object.replaySlowdownRate = options.json && !isFinite(message.replaySlowdownRate) ? String(message.replaySlowdownRate) : message.replaySlowdownRate;
            if (message.reason != null && message.hasOwnProperty("reason"))
                object.reason = message.reason;
            return object;
        };
    
        /**
         * Converts this CSVCMsg_HltvReplay to JSON.
         * @function toJSON
         * @memberof CSVCMsg_HltvReplay
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CSVCMsg_HltvReplay.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * Gets the default type url for CSVCMsg_HltvReplay
         * @function getTypeUrl
         * @memberof CSVCMsg_HltvReplay
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        CSVCMsg_HltvReplay.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/CSVCMsg_HltvReplay";
        };
    
        return CSVCMsg_HltvReplay;
    })();
    
    $root.CCLCMsg_HltvReplay = (function() {
    
        /**
         * Properties of a CCLCMsg_HltvReplay.
         * @exports ICCLCMsg_HltvReplay
         * @interface ICCLCMsg_HltvReplay
         * @property {number|null} [request] CCLCMsg_HltvReplay request
         * @property {number|null} [slowdownLength] CCLCMsg_HltvReplay slowdownLength
         * @property {number|null} [slowdownRate] CCLCMsg_HltvReplay slowdownRate
         * @property {number|null} [primaryTarget] CCLCMsg_HltvReplay primaryTarget
         * @property {number|null} [eventTime] CCLCMsg_HltvReplay eventTime
         */
    
        /**
         * Constructs a new CCLCMsg_HltvReplay.
         * @exports CCLCMsg_HltvReplay
         * @classdesc Represents a CCLCMsg_HltvReplay.
         * @implements ICCLCMsg_HltvReplay
         * @constructor
         * @param {ICCLCMsg_HltvReplay=} [properties] Properties to set
         */
        function CCLCMsg_HltvReplay(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CCLCMsg_HltvReplay request.
         * @member {number} request
         * @memberof CCLCMsg_HltvReplay
         * @instance
         */
        CCLCMsg_HltvReplay.prototype.request = 0;
    
        /**
         * CCLCMsg_HltvReplay slowdownLength.
         * @member {number} slowdownLength
         * @memberof CCLCMsg_HltvReplay
         * @instance
         */
        CCLCMsg_HltvReplay.prototype.slowdownLength = 0;
    
        /**
         * CCLCMsg_HltvReplay slowdownRate.
         * @member {number} slowdownRate
         * @memberof CCLCMsg_HltvReplay
         * @instance
         */
        CCLCMsg_HltvReplay.prototype.slowdownRate = 0;
    
        /**
         * CCLCMsg_HltvReplay primaryTarget.
         * @member {number} primaryTarget
         * @memberof CCLCMsg_HltvReplay
         * @instance
         */
        CCLCMsg_HltvReplay.prototype.primaryTarget = -1;
    
        /**
         * CCLCMsg_HltvReplay eventTime.
         * @member {number} eventTime
         * @memberof CCLCMsg_HltvReplay
         * @instance
         */
        CCLCMsg_HltvReplay.prototype.eventTime = 0;
    
        /**
         * Creates a new CCLCMsg_HltvReplay instance using the specified properties.
         * @function create
         * @memberof CCLCMsg_HltvReplay
         * @static
         * @param {ICCLCMsg_HltvReplay=} [properties] Properties to set
         * @returns {CCLCMsg_HltvReplay} CCLCMsg_HltvReplay instance
         */
        CCLCMsg_HltvReplay.create = function create(properties) {
            return new CCLCMsg_HltvReplay(properties);
        };
    
        /**
         * Encodes the specified CCLCMsg_HltvReplay message. Does not implicitly {@link CCLCMsg_HltvReplay.verify|verify} messages.
         * @function encode
         * @memberof CCLCMsg_HltvReplay
         * @static
         * @param {ICCLCMsg_HltvReplay} message CCLCMsg_HltvReplay message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CCLCMsg_HltvReplay.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.request != null && Object.hasOwnProperty.call(message, "request"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.request);
            if (message.slowdownLength != null && Object.hasOwnProperty.call(message, "slowdownLength"))
                writer.uint32(/* id 2, wireType 5 =*/21).float(message.slowdownLength);
            if (message.slowdownRate != null && Object.hasOwnProperty.call(message, "slowdownRate"))
                writer.uint32(/* id 3, wireType 5 =*/29).float(message.slowdownRate);
            if (message.primaryTarget != null && Object.hasOwnProperty.call(message, "primaryTarget"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.primaryTarget);
            if (message.eventTime != null && Object.hasOwnProperty.call(message, "eventTime"))
                writer.uint32(/* id 5, wireType 5 =*/45).float(message.eventTime);
            return writer;
        };
    
        /**
         * Encodes the specified CCLCMsg_HltvReplay message, length delimited. Does not implicitly {@link CCLCMsg_HltvReplay.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CCLCMsg_HltvReplay
         * @static
         * @param {ICCLCMsg_HltvReplay} message CCLCMsg_HltvReplay message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CCLCMsg_HltvReplay.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CCLCMsg_HltvReplay message from the specified reader or buffer.
         * @function decode
         * @memberof CCLCMsg_HltvReplay
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CCLCMsg_HltvReplay} CCLCMsg_HltvReplay
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CCLCMsg_HltvReplay.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CCLCMsg_HltvReplay();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.request = reader.int32();
                        break;
                    }
                case 2: {
                        message.slowdownLength = reader.float();
                        break;
                    }
                case 3: {
                        message.slowdownRate = reader.float();
                        break;
                    }
                case 4: {
                        message.primaryTarget = reader.int32();
                        break;
                    }
                case 5: {
                        message.eventTime = reader.float();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CCLCMsg_HltvReplay message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CCLCMsg_HltvReplay
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CCLCMsg_HltvReplay} CCLCMsg_HltvReplay
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CCLCMsg_HltvReplay.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CCLCMsg_HltvReplay message.
         * @function verify
         * @memberof CCLCMsg_HltvReplay
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CCLCMsg_HltvReplay.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.request != null && message.hasOwnProperty("request"))
                if (!$util.isInteger(message.request))
                    return "request: integer expected";
            if (message.slowdownLength != null && message.hasOwnProperty("slowdownLength"))
                if (typeof message.slowdownLength !== "number")
                    return "slowdownLength: number expected";
            if (message.slowdownRate != null && message.hasOwnProperty("slowdownRate"))
                if (typeof message.slowdownRate !== "number")
                    return "slowdownRate: number expected";
            if (message.primaryTarget != null && message.hasOwnProperty("primaryTarget"))
                if (!$util.isInteger(message.primaryTarget))
                    return "primaryTarget: integer expected";
            if (message.eventTime != null && message.hasOwnProperty("eventTime"))
                if (typeof message.eventTime !== "number")
                    return "eventTime: number expected";
            return null;
        };
    
        /**
         * Creates a CCLCMsg_HltvReplay message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CCLCMsg_HltvReplay
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CCLCMsg_HltvReplay} CCLCMsg_HltvReplay
         */
        CCLCMsg_HltvReplay.fromObject = function fromObject(object) {
            if (object instanceof $root.CCLCMsg_HltvReplay)
                return object;
            var message = new $root.CCLCMsg_HltvReplay();
            if (object.request != null)
                message.request = object.request | 0;
            if (object.slowdownLength != null)
                message.slowdownLength = Number(object.slowdownLength);
            if (object.slowdownRate != null)
                message.slowdownRate = Number(object.slowdownRate);
            if (object.primaryTarget != null)
                message.primaryTarget = object.primaryTarget | 0;
            if (object.eventTime != null)
                message.eventTime = Number(object.eventTime);
            return message;
        };
    
        /**
         * Creates a plain object from a CCLCMsg_HltvReplay message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CCLCMsg_HltvReplay
         * @static
         * @param {CCLCMsg_HltvReplay} message CCLCMsg_HltvReplay
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CCLCMsg_HltvReplay.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.request = 0;
                object.slowdownLength = 0;
                object.slowdownRate = 0;
                object.primaryTarget = -1;
                object.eventTime = 0;
            }
            if (message.request != null && message.hasOwnProperty("request"))
                object.request = message.request;
            if (message.slowdownLength != null && message.hasOwnProperty("slowdownLength"))
                object.slowdownLength = options.json && !isFinite(message.slowdownLength) ? String(message.slowdownLength) : message.slowdownLength;
            if (message.slowdownRate != null && message.hasOwnProperty("slowdownRate"))
                object.slowdownRate = options.json && !isFinite(message.slowdownRate) ? String(message.slowdownRate) : message.slowdownRate;
            if (message.primaryTarget != null && message.hasOwnProperty("primaryTarget"))
                object.primaryTarget = message.primaryTarget;
            if (message.eventTime != null && message.hasOwnProperty("eventTime"))
                object.eventTime = options.json && !isFinite(message.eventTime) ? String(message.eventTime) : message.eventTime;
            return object;
        };
    
        /**
         * Converts this CCLCMsg_HltvReplay to JSON.
         * @function toJSON
         * @memberof CCLCMsg_HltvReplay
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CCLCMsg_HltvReplay.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * Gets the default type url for CCLCMsg_HltvReplay
         * @function getTypeUrl
         * @memberof CCLCMsg_HltvReplay
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        CCLCMsg_HltvReplay.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/CCLCMsg_HltvReplay";
        };
    
        return CCLCMsg_HltvReplay;
    })();
    
    $root.CSVCMsg_Broadcast_Command = (function() {
    
        /**
         * Properties of a CSVCMsg_Broadcast_Command.
         * @exports ICSVCMsg_Broadcast_Command
         * @interface ICSVCMsg_Broadcast_Command
         * @property {string|null} [cmd] CSVCMsg_Broadcast_Command cmd
         */
    
        /**
         * Constructs a new CSVCMsg_Broadcast_Command.
         * @exports CSVCMsg_Broadcast_Command
         * @classdesc Represents a CSVCMsg_Broadcast_Command.
         * @implements ICSVCMsg_Broadcast_Command
         * @constructor
         * @param {ICSVCMsg_Broadcast_Command=} [properties] Properties to set
         */
        function CSVCMsg_Broadcast_Command(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CSVCMsg_Broadcast_Command cmd.
         * @member {string} cmd
         * @memberof CSVCMsg_Broadcast_Command
         * @instance
         */
        CSVCMsg_Broadcast_Command.prototype.cmd = "";
    
        /**
         * Creates a new CSVCMsg_Broadcast_Command instance using the specified properties.
         * @function create
         * @memberof CSVCMsg_Broadcast_Command
         * @static
         * @param {ICSVCMsg_Broadcast_Command=} [properties] Properties to set
         * @returns {CSVCMsg_Broadcast_Command} CSVCMsg_Broadcast_Command instance
         */
        CSVCMsg_Broadcast_Command.create = function create(properties) {
            return new CSVCMsg_Broadcast_Command(properties);
        };
    
        /**
         * Encodes the specified CSVCMsg_Broadcast_Command message. Does not implicitly {@link CSVCMsg_Broadcast_Command.verify|verify} messages.
         * @function encode
         * @memberof CSVCMsg_Broadcast_Command
         * @static
         * @param {ICSVCMsg_Broadcast_Command} message CSVCMsg_Broadcast_Command message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CSVCMsg_Broadcast_Command.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.cmd != null && Object.hasOwnProperty.call(message, "cmd"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.cmd);
            return writer;
        };
    
        /**
         * Encodes the specified CSVCMsg_Broadcast_Command message, length delimited. Does not implicitly {@link CSVCMsg_Broadcast_Command.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CSVCMsg_Broadcast_Command
         * @static
         * @param {ICSVCMsg_Broadcast_Command} message CSVCMsg_Broadcast_Command message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CSVCMsg_Broadcast_Command.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CSVCMsg_Broadcast_Command message from the specified reader or buffer.
         * @function decode
         * @memberof CSVCMsg_Broadcast_Command
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CSVCMsg_Broadcast_Command} CSVCMsg_Broadcast_Command
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CSVCMsg_Broadcast_Command.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CSVCMsg_Broadcast_Command();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.cmd = reader.string();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CSVCMsg_Broadcast_Command message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CSVCMsg_Broadcast_Command
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CSVCMsg_Broadcast_Command} CSVCMsg_Broadcast_Command
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CSVCMsg_Broadcast_Command.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CSVCMsg_Broadcast_Command message.
         * @function verify
         * @memberof CSVCMsg_Broadcast_Command
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CSVCMsg_Broadcast_Command.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.cmd != null && message.hasOwnProperty("cmd"))
                if (!$util.isString(message.cmd))
                    return "cmd: string expected";
            return null;
        };
    
        /**
         * Creates a CSVCMsg_Broadcast_Command message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CSVCMsg_Broadcast_Command
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CSVCMsg_Broadcast_Command} CSVCMsg_Broadcast_Command
         */
        CSVCMsg_Broadcast_Command.fromObject = function fromObject(object) {
            if (object instanceof $root.CSVCMsg_Broadcast_Command)
                return object;
            var message = new $root.CSVCMsg_Broadcast_Command();
            if (object.cmd != null)
                message.cmd = String(object.cmd);
            return message;
        };
    
        /**
         * Creates a plain object from a CSVCMsg_Broadcast_Command message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CSVCMsg_Broadcast_Command
         * @static
         * @param {CSVCMsg_Broadcast_Command} message CSVCMsg_Broadcast_Command
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CSVCMsg_Broadcast_Command.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.cmd = "";
            if (message.cmd != null && message.hasOwnProperty("cmd"))
                object.cmd = message.cmd;
            return object;
        };
    
        /**
         * Converts this CSVCMsg_Broadcast_Command to JSON.
         * @function toJSON
         * @memberof CSVCMsg_Broadcast_Command
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CSVCMsg_Broadcast_Command.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * Gets the default type url for CSVCMsg_Broadcast_Command
         * @function getTypeUrl
         * @memberof CSVCMsg_Broadcast_Command
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        CSVCMsg_Broadcast_Command.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/CSVCMsg_Broadcast_Command";
        };
    
        return CSVCMsg_Broadcast_Command;
    })();
    
    $root.CCLCMsg_HltvFixupOperatorTick = (function() {
    
        /**
         * Properties of a CCLCMsg_HltvFixupOperatorTick.
         * @exports ICCLCMsg_HltvFixupOperatorTick
         * @interface ICCLCMsg_HltvFixupOperatorTick
         * @property {number|null} [tick] CCLCMsg_HltvFixupOperatorTick tick
         * @property {Uint8Array|null} [propsData] CCLCMsg_HltvFixupOperatorTick propsData
         * @property {ICMsgVector|null} [origin] CCLCMsg_HltvFixupOperatorTick origin
         * @property {ICMsgQAngle|null} [eyeAngles] CCLCMsg_HltvFixupOperatorTick eyeAngles
         * @property {number|null} [observerMode] CCLCMsg_HltvFixupOperatorTick observerMode
         * @property {boolean|null} [cameramanScoreboard] CCLCMsg_HltvFixupOperatorTick cameramanScoreboard
         * @property {number|null} [observerTarget] CCLCMsg_HltvFixupOperatorTick observerTarget
         * @property {ICMsgVector|null} [viewOffset] CCLCMsg_HltvFixupOperatorTick viewOffset
         */
    
        /**
         * Constructs a new CCLCMsg_HltvFixupOperatorTick.
         * @exports CCLCMsg_HltvFixupOperatorTick
         * @classdesc Represents a CCLCMsg_HltvFixupOperatorTick.
         * @implements ICCLCMsg_HltvFixupOperatorTick
         * @constructor
         * @param {ICCLCMsg_HltvFixupOperatorTick=} [properties] Properties to set
         */
        function CCLCMsg_HltvFixupOperatorTick(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CCLCMsg_HltvFixupOperatorTick tick.
         * @member {number} tick
         * @memberof CCLCMsg_HltvFixupOperatorTick
         * @instance
         */
        CCLCMsg_HltvFixupOperatorTick.prototype.tick = 0;
    
        /**
         * CCLCMsg_HltvFixupOperatorTick propsData.
         * @member {Uint8Array} propsData
         * @memberof CCLCMsg_HltvFixupOperatorTick
         * @instance
         */
        CCLCMsg_HltvFixupOperatorTick.prototype.propsData = $util.newBuffer([]);
    
        /**
         * CCLCMsg_HltvFixupOperatorTick origin.
         * @member {ICMsgVector|null|undefined} origin
         * @memberof CCLCMsg_HltvFixupOperatorTick
         * @instance
         */
        CCLCMsg_HltvFixupOperatorTick.prototype.origin = null;
    
        /**
         * CCLCMsg_HltvFixupOperatorTick eyeAngles.
         * @member {ICMsgQAngle|null|undefined} eyeAngles
         * @memberof CCLCMsg_HltvFixupOperatorTick
         * @instance
         */
        CCLCMsg_HltvFixupOperatorTick.prototype.eyeAngles = null;
    
        /**
         * CCLCMsg_HltvFixupOperatorTick observerMode.
         * @member {number} observerMode
         * @memberof CCLCMsg_HltvFixupOperatorTick
         * @instance
         */
        CCLCMsg_HltvFixupOperatorTick.prototype.observerMode = 0;
    
        /**
         * CCLCMsg_HltvFixupOperatorTick cameramanScoreboard.
         * @member {boolean} cameramanScoreboard
         * @memberof CCLCMsg_HltvFixupOperatorTick
         * @instance
         */
        CCLCMsg_HltvFixupOperatorTick.prototype.cameramanScoreboard = false;
    
        /**
         * CCLCMsg_HltvFixupOperatorTick observerTarget.
         * @member {number} observerTarget
         * @memberof CCLCMsg_HltvFixupOperatorTick
         * @instance
         */
        CCLCMsg_HltvFixupOperatorTick.prototype.observerTarget = 0;
    
        /**
         * CCLCMsg_HltvFixupOperatorTick viewOffset.
         * @member {ICMsgVector|null|undefined} viewOffset
         * @memberof CCLCMsg_HltvFixupOperatorTick
         * @instance
         */
        CCLCMsg_HltvFixupOperatorTick.prototype.viewOffset = null;
    
        /**
         * Creates a new CCLCMsg_HltvFixupOperatorTick instance using the specified properties.
         * @function create
         * @memberof CCLCMsg_HltvFixupOperatorTick
         * @static
         * @param {ICCLCMsg_HltvFixupOperatorTick=} [properties] Properties to set
         * @returns {CCLCMsg_HltvFixupOperatorTick} CCLCMsg_HltvFixupOperatorTick instance
         */
        CCLCMsg_HltvFixupOperatorTick.create = function create(properties) {
            return new CCLCMsg_HltvFixupOperatorTick(properties);
        };
    
        /**
         * Encodes the specified CCLCMsg_HltvFixupOperatorTick message. Does not implicitly {@link CCLCMsg_HltvFixupOperatorTick.verify|verify} messages.
         * @function encode
         * @memberof CCLCMsg_HltvFixupOperatorTick
         * @static
         * @param {ICCLCMsg_HltvFixupOperatorTick} message CCLCMsg_HltvFixupOperatorTick message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CCLCMsg_HltvFixupOperatorTick.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.tick != null && Object.hasOwnProperty.call(message, "tick"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.tick);
            if (message.propsData != null && Object.hasOwnProperty.call(message, "propsData"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.propsData);
            if (message.origin != null && Object.hasOwnProperty.call(message, "origin"))
                $root.CMsgVector.encode(message.origin, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.eyeAngles != null && Object.hasOwnProperty.call(message, "eyeAngles"))
                $root.CMsgQAngle.encode(message.eyeAngles, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            if (message.observerMode != null && Object.hasOwnProperty.call(message, "observerMode"))
                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.observerMode);
            if (message.cameramanScoreboard != null && Object.hasOwnProperty.call(message, "cameramanScoreboard"))
                writer.uint32(/* id 6, wireType 0 =*/48).bool(message.cameramanScoreboard);
            if (message.observerTarget != null && Object.hasOwnProperty.call(message, "observerTarget"))
                writer.uint32(/* id 7, wireType 0 =*/56).int32(message.observerTarget);
            if (message.viewOffset != null && Object.hasOwnProperty.call(message, "viewOffset"))
                $root.CMsgVector.encode(message.viewOffset, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
            return writer;
        };
    
        /**
         * Encodes the specified CCLCMsg_HltvFixupOperatorTick message, length delimited. Does not implicitly {@link CCLCMsg_HltvFixupOperatorTick.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CCLCMsg_HltvFixupOperatorTick
         * @static
         * @param {ICCLCMsg_HltvFixupOperatorTick} message CCLCMsg_HltvFixupOperatorTick message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CCLCMsg_HltvFixupOperatorTick.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CCLCMsg_HltvFixupOperatorTick message from the specified reader or buffer.
         * @function decode
         * @memberof CCLCMsg_HltvFixupOperatorTick
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CCLCMsg_HltvFixupOperatorTick} CCLCMsg_HltvFixupOperatorTick
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CCLCMsg_HltvFixupOperatorTick.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CCLCMsg_HltvFixupOperatorTick();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.tick = reader.int32();
                        break;
                    }
                case 2: {
                        message.propsData = reader.bytes();
                        break;
                    }
                case 3: {
                        message.origin = $root.CMsgVector.decode(reader, reader.uint32());
                        break;
                    }
                case 4: {
                        message.eyeAngles = $root.CMsgQAngle.decode(reader, reader.uint32());
                        break;
                    }
                case 5: {
                        message.observerMode = reader.int32();
                        break;
                    }
                case 6: {
                        message.cameramanScoreboard = reader.bool();
                        break;
                    }
                case 7: {
                        message.observerTarget = reader.int32();
                        break;
                    }
                case 8: {
                        message.viewOffset = $root.CMsgVector.decode(reader, reader.uint32());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CCLCMsg_HltvFixupOperatorTick message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CCLCMsg_HltvFixupOperatorTick
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CCLCMsg_HltvFixupOperatorTick} CCLCMsg_HltvFixupOperatorTick
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CCLCMsg_HltvFixupOperatorTick.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CCLCMsg_HltvFixupOperatorTick message.
         * @function verify
         * @memberof CCLCMsg_HltvFixupOperatorTick
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CCLCMsg_HltvFixupOperatorTick.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.tick != null && message.hasOwnProperty("tick"))
                if (!$util.isInteger(message.tick))
                    return "tick: integer expected";
            if (message.propsData != null && message.hasOwnProperty("propsData"))
                if (!(message.propsData && typeof message.propsData.length === "number" || $util.isString(message.propsData)))
                    return "propsData: buffer expected";
            if (message.origin != null && message.hasOwnProperty("origin")) {
                var error = $root.CMsgVector.verify(message.origin);
                if (error)
                    return "origin." + error;
            }
            if (message.eyeAngles != null && message.hasOwnProperty("eyeAngles")) {
                var error = $root.CMsgQAngle.verify(message.eyeAngles);
                if (error)
                    return "eyeAngles." + error;
            }
            if (message.observerMode != null && message.hasOwnProperty("observerMode"))
                if (!$util.isInteger(message.observerMode))
                    return "observerMode: integer expected";
            if (message.cameramanScoreboard != null && message.hasOwnProperty("cameramanScoreboard"))
                if (typeof message.cameramanScoreboard !== "boolean")
                    return "cameramanScoreboard: boolean expected";
            if (message.observerTarget != null && message.hasOwnProperty("observerTarget"))
                if (!$util.isInteger(message.observerTarget))
                    return "observerTarget: integer expected";
            if (message.viewOffset != null && message.hasOwnProperty("viewOffset")) {
                var error = $root.CMsgVector.verify(message.viewOffset);
                if (error)
                    return "viewOffset." + error;
            }
            return null;
        };
    
        /**
         * Creates a CCLCMsg_HltvFixupOperatorTick message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CCLCMsg_HltvFixupOperatorTick
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CCLCMsg_HltvFixupOperatorTick} CCLCMsg_HltvFixupOperatorTick
         */
        CCLCMsg_HltvFixupOperatorTick.fromObject = function fromObject(object) {
            if (object instanceof $root.CCLCMsg_HltvFixupOperatorTick)
                return object;
            var message = new $root.CCLCMsg_HltvFixupOperatorTick();
            if (object.tick != null)
                message.tick = object.tick | 0;
            if (object.propsData != null)
                if (typeof object.propsData === "string")
                    $util.base64.decode(object.propsData, message.propsData = $util.newBuffer($util.base64.length(object.propsData)), 0);
                else if (object.propsData.length >= 0)
                    message.propsData = object.propsData;
            if (object.origin != null) {
                if (typeof object.origin !== "object")
                    throw TypeError(".CCLCMsg_HltvFixupOperatorTick.origin: object expected");
                message.origin = $root.CMsgVector.fromObject(object.origin);
            }
            if (object.eyeAngles != null) {
                if (typeof object.eyeAngles !== "object")
                    throw TypeError(".CCLCMsg_HltvFixupOperatorTick.eyeAngles: object expected");
                message.eyeAngles = $root.CMsgQAngle.fromObject(object.eyeAngles);
            }
            if (object.observerMode != null)
                message.observerMode = object.observerMode | 0;
            if (object.cameramanScoreboard != null)
                message.cameramanScoreboard = Boolean(object.cameramanScoreboard);
            if (object.observerTarget != null)
                message.observerTarget = object.observerTarget | 0;
            if (object.viewOffset != null) {
                if (typeof object.viewOffset !== "object")
                    throw TypeError(".CCLCMsg_HltvFixupOperatorTick.viewOffset: object expected");
                message.viewOffset = $root.CMsgVector.fromObject(object.viewOffset);
            }
            return message;
        };
    
        /**
         * Creates a plain object from a CCLCMsg_HltvFixupOperatorTick message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CCLCMsg_HltvFixupOperatorTick
         * @static
         * @param {CCLCMsg_HltvFixupOperatorTick} message CCLCMsg_HltvFixupOperatorTick
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CCLCMsg_HltvFixupOperatorTick.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.tick = 0;
                if (options.bytes === String)
                    object.propsData = "";
                else {
                    object.propsData = [];
                    if (options.bytes !== Array)
                        object.propsData = $util.newBuffer(object.propsData);
                }
                object.origin = null;
                object.eyeAngles = null;
                object.observerMode = 0;
                object.cameramanScoreboard = false;
                object.observerTarget = 0;
                object.viewOffset = null;
            }
            if (message.tick != null && message.hasOwnProperty("tick"))
                object.tick = message.tick;
            if (message.propsData != null && message.hasOwnProperty("propsData"))
                object.propsData = options.bytes === String ? $util.base64.encode(message.propsData, 0, message.propsData.length) : options.bytes === Array ? Array.prototype.slice.call(message.propsData) : message.propsData;
            if (message.origin != null && message.hasOwnProperty("origin"))
                object.origin = $root.CMsgVector.toObject(message.origin, options);
            if (message.eyeAngles != null && message.hasOwnProperty("eyeAngles"))
                object.eyeAngles = $root.CMsgQAngle.toObject(message.eyeAngles, options);
            if (message.observerMode != null && message.hasOwnProperty("observerMode"))
                object.observerMode = message.observerMode;
            if (message.cameramanScoreboard != null && message.hasOwnProperty("cameramanScoreboard"))
                object.cameramanScoreboard = message.cameramanScoreboard;
            if (message.observerTarget != null && message.hasOwnProperty("observerTarget"))
                object.observerTarget = message.observerTarget;
            if (message.viewOffset != null && message.hasOwnProperty("viewOffset"))
                object.viewOffset = $root.CMsgVector.toObject(message.viewOffset, options);
            return object;
        };
    
        /**
         * Converts this CCLCMsg_HltvFixupOperatorTick to JSON.
         * @function toJSON
         * @memberof CCLCMsg_HltvFixupOperatorTick
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CCLCMsg_HltvFixupOperatorTick.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * Gets the default type url for CCLCMsg_HltvFixupOperatorTick
         * @function getTypeUrl
         * @memberof CCLCMsg_HltvFixupOperatorTick
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        CCLCMsg_HltvFixupOperatorTick.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/CCLCMsg_HltvFixupOperatorTick";
        };
    
        return CCLCMsg_HltvFixupOperatorTick;
    })();
    
    $root.CSVCMsg_HltvFixupOperatorStatus = (function() {
    
        /**
         * Properties of a CSVCMsg_HltvFixupOperatorStatus.
         * @exports ICSVCMsg_HltvFixupOperatorStatus
         * @interface ICSVCMsg_HltvFixupOperatorStatus
         * @property {number|null} [mode] CSVCMsg_HltvFixupOperatorStatus mode
         * @property {string|null} [overrideOperatorName] CSVCMsg_HltvFixupOperatorStatus overrideOperatorName
         */
    
        /**
         * Constructs a new CSVCMsg_HltvFixupOperatorStatus.
         * @exports CSVCMsg_HltvFixupOperatorStatus
         * @classdesc Represents a CSVCMsg_HltvFixupOperatorStatus.
         * @implements ICSVCMsg_HltvFixupOperatorStatus
         * @constructor
         * @param {ICSVCMsg_HltvFixupOperatorStatus=} [properties] Properties to set
         */
        function CSVCMsg_HltvFixupOperatorStatus(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CSVCMsg_HltvFixupOperatorStatus mode.
         * @member {number} mode
         * @memberof CSVCMsg_HltvFixupOperatorStatus
         * @instance
         */
        CSVCMsg_HltvFixupOperatorStatus.prototype.mode = 0;
    
        /**
         * CSVCMsg_HltvFixupOperatorStatus overrideOperatorName.
         * @member {string} overrideOperatorName
         * @memberof CSVCMsg_HltvFixupOperatorStatus
         * @instance
         */
        CSVCMsg_HltvFixupOperatorStatus.prototype.overrideOperatorName = "";
    
        /**
         * Creates a new CSVCMsg_HltvFixupOperatorStatus instance using the specified properties.
         * @function create
         * @memberof CSVCMsg_HltvFixupOperatorStatus
         * @static
         * @param {ICSVCMsg_HltvFixupOperatorStatus=} [properties] Properties to set
         * @returns {CSVCMsg_HltvFixupOperatorStatus} CSVCMsg_HltvFixupOperatorStatus instance
         */
        CSVCMsg_HltvFixupOperatorStatus.create = function create(properties) {
            return new CSVCMsg_HltvFixupOperatorStatus(properties);
        };
    
        /**
         * Encodes the specified CSVCMsg_HltvFixupOperatorStatus message. Does not implicitly {@link CSVCMsg_HltvFixupOperatorStatus.verify|verify} messages.
         * @function encode
         * @memberof CSVCMsg_HltvFixupOperatorStatus
         * @static
         * @param {ICSVCMsg_HltvFixupOperatorStatus} message CSVCMsg_HltvFixupOperatorStatus message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CSVCMsg_HltvFixupOperatorStatus.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.mode != null && Object.hasOwnProperty.call(message, "mode"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.mode);
            if (message.overrideOperatorName != null && Object.hasOwnProperty.call(message, "overrideOperatorName"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.overrideOperatorName);
            return writer;
        };
    
        /**
         * Encodes the specified CSVCMsg_HltvFixupOperatorStatus message, length delimited. Does not implicitly {@link CSVCMsg_HltvFixupOperatorStatus.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CSVCMsg_HltvFixupOperatorStatus
         * @static
         * @param {ICSVCMsg_HltvFixupOperatorStatus} message CSVCMsg_HltvFixupOperatorStatus message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CSVCMsg_HltvFixupOperatorStatus.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CSVCMsg_HltvFixupOperatorStatus message from the specified reader or buffer.
         * @function decode
         * @memberof CSVCMsg_HltvFixupOperatorStatus
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CSVCMsg_HltvFixupOperatorStatus} CSVCMsg_HltvFixupOperatorStatus
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CSVCMsg_HltvFixupOperatorStatus.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CSVCMsg_HltvFixupOperatorStatus();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.mode = reader.uint32();
                        break;
                    }
                case 2: {
                        message.overrideOperatorName = reader.string();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CSVCMsg_HltvFixupOperatorStatus message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CSVCMsg_HltvFixupOperatorStatus
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CSVCMsg_HltvFixupOperatorStatus} CSVCMsg_HltvFixupOperatorStatus
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CSVCMsg_HltvFixupOperatorStatus.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CSVCMsg_HltvFixupOperatorStatus message.
         * @function verify
         * @memberof CSVCMsg_HltvFixupOperatorStatus
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CSVCMsg_HltvFixupOperatorStatus.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.mode != null && message.hasOwnProperty("mode"))
                if (!$util.isInteger(message.mode))
                    return "mode: integer expected";
            if (message.overrideOperatorName != null && message.hasOwnProperty("overrideOperatorName"))
                if (!$util.isString(message.overrideOperatorName))
                    return "overrideOperatorName: string expected";
            return null;
        };
    
        /**
         * Creates a CSVCMsg_HltvFixupOperatorStatus message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CSVCMsg_HltvFixupOperatorStatus
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CSVCMsg_HltvFixupOperatorStatus} CSVCMsg_HltvFixupOperatorStatus
         */
        CSVCMsg_HltvFixupOperatorStatus.fromObject = function fromObject(object) {
            if (object instanceof $root.CSVCMsg_HltvFixupOperatorStatus)
                return object;
            var message = new $root.CSVCMsg_HltvFixupOperatorStatus();
            if (object.mode != null)
                message.mode = object.mode >>> 0;
            if (object.overrideOperatorName != null)
                message.overrideOperatorName = String(object.overrideOperatorName);
            return message;
        };
    
        /**
         * Creates a plain object from a CSVCMsg_HltvFixupOperatorStatus message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CSVCMsg_HltvFixupOperatorStatus
         * @static
         * @param {CSVCMsg_HltvFixupOperatorStatus} message CSVCMsg_HltvFixupOperatorStatus
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CSVCMsg_HltvFixupOperatorStatus.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.mode = 0;
                object.overrideOperatorName = "";
            }
            if (message.mode != null && message.hasOwnProperty("mode"))
                object.mode = message.mode;
            if (message.overrideOperatorName != null && message.hasOwnProperty("overrideOperatorName"))
                object.overrideOperatorName = message.overrideOperatorName;
            return object;
        };
    
        /**
         * Converts this CSVCMsg_HltvFixupOperatorStatus to JSON.
         * @function toJSON
         * @memberof CSVCMsg_HltvFixupOperatorStatus
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CSVCMsg_HltvFixupOperatorStatus.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * Gets the default type url for CSVCMsg_HltvFixupOperatorStatus
         * @function getTypeUrl
         * @memberof CSVCMsg_HltvFixupOperatorStatus
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        CSVCMsg_HltvFixupOperatorStatus.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/CSVCMsg_HltvFixupOperatorStatus";
        };
    
        return CSVCMsg_HltvFixupOperatorStatus;
    })();
    
    /**
     * SignonState_t enum.
     * @exports SignonState_t
     * @enum {number}
     * @property {number} SIGNONSTATE_NONE=0 SIGNONSTATE_NONE value
     * @property {number} SIGNONSTATE_CHALLENGE=1 SIGNONSTATE_CHALLENGE value
     * @property {number} SIGNONSTATE_CONNECTED=2 SIGNONSTATE_CONNECTED value
     * @property {number} SIGNONSTATE_NEW=3 SIGNONSTATE_NEW value
     * @property {number} SIGNONSTATE_PRESPAWN=4 SIGNONSTATE_PRESPAWN value
     * @property {number} SIGNONSTATE_SPAWN=5 SIGNONSTATE_SPAWN value
     * @property {number} SIGNONSTATE_FULL=6 SIGNONSTATE_FULL value
     * @property {number} SIGNONSTATE_CHANGELEVEL=7 SIGNONSTATE_CHANGELEVEL value
     */
    $root.SignonState_t = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "SIGNONSTATE_NONE"] = 0;
        values[valuesById[1] = "SIGNONSTATE_CHALLENGE"] = 1;
        values[valuesById[2] = "SIGNONSTATE_CONNECTED"] = 2;
        values[valuesById[3] = "SIGNONSTATE_NEW"] = 3;
        values[valuesById[4] = "SIGNONSTATE_PRESPAWN"] = 4;
        values[valuesById[5] = "SIGNONSTATE_SPAWN"] = 5;
        values[valuesById[6] = "SIGNONSTATE_FULL"] = 6;
        values[valuesById[7] = "SIGNONSTATE_CHANGELEVEL"] = 7;
        return values;
    })();
    
    /**
     * NET_Messages enum.
     * @exports NET_Messages
     * @enum {number}
     * @property {number} net_NOP=0 net_NOP value
     * @property {number} net_Disconnect=1 net_Disconnect value
     * @property {number} net_SplitScreenUser=3 net_SplitScreenUser value
     * @property {number} net_Tick=4 net_Tick value
     * @property {number} net_StringCmd=5 net_StringCmd value
     * @property {number} net_SetConVar=6 net_SetConVar value
     * @property {number} net_SignonState=7 net_SignonState value
     * @property {number} net_SpawnGroup_Load=8 net_SpawnGroup_Load value
     * @property {number} net_SpawnGroup_ManifestUpdate=9 net_SpawnGroup_ManifestUpdate value
     * @property {number} net_SpawnGroup_SetCreationTick=11 net_SpawnGroup_SetCreationTick value
     * @property {number} net_SpawnGroup_Unload=12 net_SpawnGroup_Unload value
     * @property {number} net_SpawnGroup_LoadCompleted=13 net_SpawnGroup_LoadCompleted value
     * @property {number} net_DebugOverlay=15 net_DebugOverlay value
     */
    $root.NET_Messages = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "net_NOP"] = 0;
        values[valuesById[1] = "net_Disconnect"] = 1;
        values[valuesById[3] = "net_SplitScreenUser"] = 3;
        values[valuesById[4] = "net_Tick"] = 4;
        values[valuesById[5] = "net_StringCmd"] = 5;
        values[valuesById[6] = "net_SetConVar"] = 6;
        values[valuesById[7] = "net_SignonState"] = 7;
        values[valuesById[8] = "net_SpawnGroup_Load"] = 8;
        values[valuesById[9] = "net_SpawnGroup_ManifestUpdate"] = 9;
        values[valuesById[11] = "net_SpawnGroup_SetCreationTick"] = 11;
        values[valuesById[12] = "net_SpawnGroup_Unload"] = 12;
        values[valuesById[13] = "net_SpawnGroup_LoadCompleted"] = 13;
        values[valuesById[15] = "net_DebugOverlay"] = 15;
        return values;
    })();
    
    /**
     * SpawnGroupFlags_t enum.
     * @exports SpawnGroupFlags_t
     * @enum {number}
     * @property {number} SPAWN_GROUP_LOAD_ENTITIES_FROM_SAVE=1 SPAWN_GROUP_LOAD_ENTITIES_FROM_SAVE value
     * @property {number} SPAWN_GROUP_DONT_SPAWN_ENTITIES=2 SPAWN_GROUP_DONT_SPAWN_ENTITIES value
     * @property {number} SPAWN_GROUP_SYNCHRONOUS_SPAWN=4 SPAWN_GROUP_SYNCHRONOUS_SPAWN value
     * @property {number} SPAWN_GROUP_IS_INITIAL_SPAWN_GROUP=8 SPAWN_GROUP_IS_INITIAL_SPAWN_GROUP value
     * @property {number} SPAWN_GROUP_CREATE_CLIENT_ONLY_ENTITIES=16 SPAWN_GROUP_CREATE_CLIENT_ONLY_ENTITIES value
     * @property {number} SPAWN_GROUP_BLOCK_UNTIL_LOADED=64 SPAWN_GROUP_BLOCK_UNTIL_LOADED value
     * @property {number} SPAWN_GROUP_LOAD_STREAMING_DATA=128 SPAWN_GROUP_LOAD_STREAMING_DATA value
     * @property {number} SPAWN_GROUP_CREATE_NEW_SCENE_WORLD=256 SPAWN_GROUP_CREATE_NEW_SCENE_WORLD value
     */
    $root.SpawnGroupFlags_t = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[1] = "SPAWN_GROUP_LOAD_ENTITIES_FROM_SAVE"] = 1;
        values[valuesById[2] = "SPAWN_GROUP_DONT_SPAWN_ENTITIES"] = 2;
        values[valuesById[4] = "SPAWN_GROUP_SYNCHRONOUS_SPAWN"] = 4;
        values[valuesById[8] = "SPAWN_GROUP_IS_INITIAL_SPAWN_GROUP"] = 8;
        values[valuesById[16] = "SPAWN_GROUP_CREATE_CLIENT_ONLY_ENTITIES"] = 16;
        values[valuesById[64] = "SPAWN_GROUP_BLOCK_UNTIL_LOADED"] = 64;
        values[valuesById[128] = "SPAWN_GROUP_LOAD_STREAMING_DATA"] = 128;
        values[valuesById[256] = "SPAWN_GROUP_CREATE_NEW_SCENE_WORLD"] = 256;
        return values;
    })();
    
    $root.CMsgVector = (function() {
    
        /**
         * Properties of a CMsgVector.
         * @exports ICMsgVector
         * @interface ICMsgVector
         * @property {number|null} [x] CMsgVector x
         * @property {number|null} [y] CMsgVector y
         * @property {number|null} [z] CMsgVector z
         * @property {number|null} [w] CMsgVector w
         */
    
        /**
         * Constructs a new CMsgVector.
         * @exports CMsgVector
         * @classdesc Represents a CMsgVector.
         * @implements ICMsgVector
         * @constructor
         * @param {ICMsgVector=} [properties] Properties to set
         */
        function CMsgVector(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CMsgVector x.
         * @member {number} x
         * @memberof CMsgVector
         * @instance
         */
        CMsgVector.prototype.x = 0;
    
        /**
         * CMsgVector y.
         * @member {number} y
         * @memberof CMsgVector
         * @instance
         */
        CMsgVector.prototype.y = 0;
    
        /**
         * CMsgVector z.
         * @member {number} z
         * @memberof CMsgVector
         * @instance
         */
        CMsgVector.prototype.z = 0;
    
        /**
         * CMsgVector w.
         * @member {number} w
         * @memberof CMsgVector
         * @instance
         */
        CMsgVector.prototype.w = 0;
    
        /**
         * Creates a new CMsgVector instance using the specified properties.
         * @function create
         * @memberof CMsgVector
         * @static
         * @param {ICMsgVector=} [properties] Properties to set
         * @returns {CMsgVector} CMsgVector instance
         */
        CMsgVector.create = function create(properties) {
            return new CMsgVector(properties);
        };
    
        /**
         * Encodes the specified CMsgVector message. Does not implicitly {@link CMsgVector.verify|verify} messages.
         * @function encode
         * @memberof CMsgVector
         * @static
         * @param {ICMsgVector} message CMsgVector message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CMsgVector.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.x != null && Object.hasOwnProperty.call(message, "x"))
                writer.uint32(/* id 1, wireType 5 =*/13).float(message.x);
            if (message.y != null && Object.hasOwnProperty.call(message, "y"))
                writer.uint32(/* id 2, wireType 5 =*/21).float(message.y);
            if (message.z != null && Object.hasOwnProperty.call(message, "z"))
                writer.uint32(/* id 3, wireType 5 =*/29).float(message.z);
            if (message.w != null && Object.hasOwnProperty.call(message, "w"))
                writer.uint32(/* id 4, wireType 5 =*/37).float(message.w);
            return writer;
        };
    
        /**
         * Encodes the specified CMsgVector message, length delimited. Does not implicitly {@link CMsgVector.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CMsgVector
         * @static
         * @param {ICMsgVector} message CMsgVector message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CMsgVector.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CMsgVector message from the specified reader or buffer.
         * @function decode
         * @memberof CMsgVector
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CMsgVector} CMsgVector
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CMsgVector.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgVector();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.x = reader.float();
                        break;
                    }
                case 2: {
                        message.y = reader.float();
                        break;
                    }
                case 3: {
                        message.z = reader.float();
                        break;
                    }
                case 4: {
                        message.w = reader.float();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CMsgVector message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CMsgVector
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CMsgVector} CMsgVector
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CMsgVector.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CMsgVector message.
         * @function verify
         * @memberof CMsgVector
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CMsgVector.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.x != null && message.hasOwnProperty("x"))
                if (typeof message.x !== "number")
                    return "x: number expected";
            if (message.y != null && message.hasOwnProperty("y"))
                if (typeof message.y !== "number")
                    return "y: number expected";
            if (message.z != null && message.hasOwnProperty("z"))
                if (typeof message.z !== "number")
                    return "z: number expected";
            if (message.w != null && message.hasOwnProperty("w"))
                if (typeof message.w !== "number")
                    return "w: number expected";
            return null;
        };
    
        /**
         * Creates a CMsgVector message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CMsgVector
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CMsgVector} CMsgVector
         */
        CMsgVector.fromObject = function fromObject(object) {
            if (object instanceof $root.CMsgVector)
                return object;
            var message = new $root.CMsgVector();
            if (object.x != null)
                message.x = Number(object.x);
            if (object.y != null)
                message.y = Number(object.y);
            if (object.z != null)
                message.z = Number(object.z);
            if (object.w != null)
                message.w = Number(object.w);
            return message;
        };
    
        /**
         * Creates a plain object from a CMsgVector message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CMsgVector
         * @static
         * @param {CMsgVector} message CMsgVector
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CMsgVector.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.x = 0;
                object.y = 0;
                object.z = 0;
                object.w = 0;
            }
            if (message.x != null && message.hasOwnProperty("x"))
                object.x = options.json && !isFinite(message.x) ? String(message.x) : message.x;
            if (message.y != null && message.hasOwnProperty("y"))
                object.y = options.json && !isFinite(message.y) ? String(message.y) : message.y;
            if (message.z != null && message.hasOwnProperty("z"))
                object.z = options.json && !isFinite(message.z) ? String(message.z) : message.z;
            if (message.w != null && message.hasOwnProperty("w"))
                object.w = options.json && !isFinite(message.w) ? String(message.w) : message.w;
            return object;
        };
    
        /**
         * Converts this CMsgVector to JSON.
         * @function toJSON
         * @memberof CMsgVector
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CMsgVector.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * Gets the default type url for CMsgVector
         * @function getTypeUrl
         * @memberof CMsgVector
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        CMsgVector.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/CMsgVector";
        };
    
        return CMsgVector;
    })();
    
    $root.CMsgVector2D = (function() {
    
        /**
         * Properties of a CMsgVector2D.
         * @exports ICMsgVector2D
         * @interface ICMsgVector2D
         * @property {number|null} [x] CMsgVector2D x
         * @property {number|null} [y] CMsgVector2D y
         */
    
        /**
         * Constructs a new CMsgVector2D.
         * @exports CMsgVector2D
         * @classdesc Represents a CMsgVector2D.
         * @implements ICMsgVector2D
         * @constructor
         * @param {ICMsgVector2D=} [properties] Properties to set
         */
        function CMsgVector2D(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CMsgVector2D x.
         * @member {number} x
         * @memberof CMsgVector2D
         * @instance
         */
        CMsgVector2D.prototype.x = 0;
    
        /**
         * CMsgVector2D y.
         * @member {number} y
         * @memberof CMsgVector2D
         * @instance
         */
        CMsgVector2D.prototype.y = 0;
    
        /**
         * Creates a new CMsgVector2D instance using the specified properties.
         * @function create
         * @memberof CMsgVector2D
         * @static
         * @param {ICMsgVector2D=} [properties] Properties to set
         * @returns {CMsgVector2D} CMsgVector2D instance
         */
        CMsgVector2D.create = function create(properties) {
            return new CMsgVector2D(properties);
        };
    
        /**
         * Encodes the specified CMsgVector2D message. Does not implicitly {@link CMsgVector2D.verify|verify} messages.
         * @function encode
         * @memberof CMsgVector2D
         * @static
         * @param {ICMsgVector2D} message CMsgVector2D message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CMsgVector2D.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.x != null && Object.hasOwnProperty.call(message, "x"))
                writer.uint32(/* id 1, wireType 5 =*/13).float(message.x);
            if (message.y != null && Object.hasOwnProperty.call(message, "y"))
                writer.uint32(/* id 2, wireType 5 =*/21).float(message.y);
            return writer;
        };
    
        /**
         * Encodes the specified CMsgVector2D message, length delimited. Does not implicitly {@link CMsgVector2D.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CMsgVector2D
         * @static
         * @param {ICMsgVector2D} message CMsgVector2D message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CMsgVector2D.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CMsgVector2D message from the specified reader or buffer.
         * @function decode
         * @memberof CMsgVector2D
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CMsgVector2D} CMsgVector2D
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CMsgVector2D.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgVector2D();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.x = reader.float();
                        break;
                    }
                case 2: {
                        message.y = reader.float();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CMsgVector2D message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CMsgVector2D
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CMsgVector2D} CMsgVector2D
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CMsgVector2D.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CMsgVector2D message.
         * @function verify
         * @memberof CMsgVector2D
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CMsgVector2D.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.x != null && message.hasOwnProperty("x"))
                if (typeof message.x !== "number")
                    return "x: number expected";
            if (message.y != null && message.hasOwnProperty("y"))
                if (typeof message.y !== "number")
                    return "y: number expected";
            return null;
        };
    
        /**
         * Creates a CMsgVector2D message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CMsgVector2D
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CMsgVector2D} CMsgVector2D
         */
        CMsgVector2D.fromObject = function fromObject(object) {
            if (object instanceof $root.CMsgVector2D)
                return object;
            var message = new $root.CMsgVector2D();
            if (object.x != null)
                message.x = Number(object.x);
            if (object.y != null)
                message.y = Number(object.y);
            return message;
        };
    
        /**
         * Creates a plain object from a CMsgVector2D message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CMsgVector2D
         * @static
         * @param {CMsgVector2D} message CMsgVector2D
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CMsgVector2D.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.x = 0;
                object.y = 0;
            }
            if (message.x != null && message.hasOwnProperty("x"))
                object.x = options.json && !isFinite(message.x) ? String(message.x) : message.x;
            if (message.y != null && message.hasOwnProperty("y"))
                object.y = options.json && !isFinite(message.y) ? String(message.y) : message.y;
            return object;
        };
    
        /**
         * Converts this CMsgVector2D to JSON.
         * @function toJSON
         * @memberof CMsgVector2D
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CMsgVector2D.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * Gets the default type url for CMsgVector2D
         * @function getTypeUrl
         * @memberof CMsgVector2D
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        CMsgVector2D.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/CMsgVector2D";
        };
    
        return CMsgVector2D;
    })();
    
    $root.CMsgQAngle = (function() {
    
        /**
         * Properties of a CMsgQAngle.
         * @exports ICMsgQAngle
         * @interface ICMsgQAngle
         * @property {number|null} [x] CMsgQAngle x
         * @property {number|null} [y] CMsgQAngle y
         * @property {number|null} [z] CMsgQAngle z
         */
    
        /**
         * Constructs a new CMsgQAngle.
         * @exports CMsgQAngle
         * @classdesc Represents a CMsgQAngle.
         * @implements ICMsgQAngle
         * @constructor
         * @param {ICMsgQAngle=} [properties] Properties to set
         */
        function CMsgQAngle(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CMsgQAngle x.
         * @member {number} x
         * @memberof CMsgQAngle
         * @instance
         */
        CMsgQAngle.prototype.x = 0;
    
        /**
         * CMsgQAngle y.
         * @member {number} y
         * @memberof CMsgQAngle
         * @instance
         */
        CMsgQAngle.prototype.y = 0;
    
        /**
         * CMsgQAngle z.
         * @member {number} z
         * @memberof CMsgQAngle
         * @instance
         */
        CMsgQAngle.prototype.z = 0;
    
        /**
         * Creates a new CMsgQAngle instance using the specified properties.
         * @function create
         * @memberof CMsgQAngle
         * @static
         * @param {ICMsgQAngle=} [properties] Properties to set
         * @returns {CMsgQAngle} CMsgQAngle instance
         */
        CMsgQAngle.create = function create(properties) {
            return new CMsgQAngle(properties);
        };
    
        /**
         * Encodes the specified CMsgQAngle message. Does not implicitly {@link CMsgQAngle.verify|verify} messages.
         * @function encode
         * @memberof CMsgQAngle
         * @static
         * @param {ICMsgQAngle} message CMsgQAngle message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CMsgQAngle.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.x != null && Object.hasOwnProperty.call(message, "x"))
                writer.uint32(/* id 1, wireType 5 =*/13).float(message.x);
            if (message.y != null && Object.hasOwnProperty.call(message, "y"))
                writer.uint32(/* id 2, wireType 5 =*/21).float(message.y);
            if (message.z != null && Object.hasOwnProperty.call(message, "z"))
                writer.uint32(/* id 3, wireType 5 =*/29).float(message.z);
            return writer;
        };
    
        /**
         * Encodes the specified CMsgQAngle message, length delimited. Does not implicitly {@link CMsgQAngle.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CMsgQAngle
         * @static
         * @param {ICMsgQAngle} message CMsgQAngle message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CMsgQAngle.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CMsgQAngle message from the specified reader or buffer.
         * @function decode
         * @memberof CMsgQAngle
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CMsgQAngle} CMsgQAngle
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CMsgQAngle.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgQAngle();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.x = reader.float();
                        break;
                    }
                case 2: {
                        message.y = reader.float();
                        break;
                    }
                case 3: {
                        message.z = reader.float();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CMsgQAngle message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CMsgQAngle
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CMsgQAngle} CMsgQAngle
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CMsgQAngle.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CMsgQAngle message.
         * @function verify
         * @memberof CMsgQAngle
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CMsgQAngle.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.x != null && message.hasOwnProperty("x"))
                if (typeof message.x !== "number")
                    return "x: number expected";
            if (message.y != null && message.hasOwnProperty("y"))
                if (typeof message.y !== "number")
                    return "y: number expected";
            if (message.z != null && message.hasOwnProperty("z"))
                if (typeof message.z !== "number")
                    return "z: number expected";
            return null;
        };
    
        /**
         * Creates a CMsgQAngle message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CMsgQAngle
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CMsgQAngle} CMsgQAngle
         */
        CMsgQAngle.fromObject = function fromObject(object) {
            if (object instanceof $root.CMsgQAngle)
                return object;
            var message = new $root.CMsgQAngle();
            if (object.x != null)
                message.x = Number(object.x);
            if (object.y != null)
                message.y = Number(object.y);
            if (object.z != null)
                message.z = Number(object.z);
            return message;
        };
    
        /**
         * Creates a plain object from a CMsgQAngle message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CMsgQAngle
         * @static
         * @param {CMsgQAngle} message CMsgQAngle
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CMsgQAngle.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.x = 0;
                object.y = 0;
                object.z = 0;
            }
            if (message.x != null && message.hasOwnProperty("x"))
                object.x = options.json && !isFinite(message.x) ? String(message.x) : message.x;
            if (message.y != null && message.hasOwnProperty("y"))
                object.y = options.json && !isFinite(message.y) ? String(message.y) : message.y;
            if (message.z != null && message.hasOwnProperty("z"))
                object.z = options.json && !isFinite(message.z) ? String(message.z) : message.z;
            return object;
        };
    
        /**
         * Converts this CMsgQAngle to JSON.
         * @function toJSON
         * @memberof CMsgQAngle
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CMsgQAngle.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * Gets the default type url for CMsgQAngle
         * @function getTypeUrl
         * @memberof CMsgQAngle
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        CMsgQAngle.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/CMsgQAngle";
        };
    
        return CMsgQAngle;
    })();
    
    $root.CMsgQuaternion = (function() {
    
        /**
         * Properties of a CMsgQuaternion.
         * @exports ICMsgQuaternion
         * @interface ICMsgQuaternion
         * @property {number|null} [x] CMsgQuaternion x
         * @property {number|null} [y] CMsgQuaternion y
         * @property {number|null} [z] CMsgQuaternion z
         * @property {number|null} [w] CMsgQuaternion w
         */
    
        /**
         * Constructs a new CMsgQuaternion.
         * @exports CMsgQuaternion
         * @classdesc Represents a CMsgQuaternion.
         * @implements ICMsgQuaternion
         * @constructor
         * @param {ICMsgQuaternion=} [properties] Properties to set
         */
        function CMsgQuaternion(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CMsgQuaternion x.
         * @member {number} x
         * @memberof CMsgQuaternion
         * @instance
         */
        CMsgQuaternion.prototype.x = 0;
    
        /**
         * CMsgQuaternion y.
         * @member {number} y
         * @memberof CMsgQuaternion
         * @instance
         */
        CMsgQuaternion.prototype.y = 0;
    
        /**
         * CMsgQuaternion z.
         * @member {number} z
         * @memberof CMsgQuaternion
         * @instance
         */
        CMsgQuaternion.prototype.z = 0;
    
        /**
         * CMsgQuaternion w.
         * @member {number} w
         * @memberof CMsgQuaternion
         * @instance
         */
        CMsgQuaternion.prototype.w = 0;
    
        /**
         * Creates a new CMsgQuaternion instance using the specified properties.
         * @function create
         * @memberof CMsgQuaternion
         * @static
         * @param {ICMsgQuaternion=} [properties] Properties to set
         * @returns {CMsgQuaternion} CMsgQuaternion instance
         */
        CMsgQuaternion.create = function create(properties) {
            return new CMsgQuaternion(properties);
        };
    
        /**
         * Encodes the specified CMsgQuaternion message. Does not implicitly {@link CMsgQuaternion.verify|verify} messages.
         * @function encode
         * @memberof CMsgQuaternion
         * @static
         * @param {ICMsgQuaternion} message CMsgQuaternion message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CMsgQuaternion.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.x != null && Object.hasOwnProperty.call(message, "x"))
                writer.uint32(/* id 1, wireType 5 =*/13).float(message.x);
            if (message.y != null && Object.hasOwnProperty.call(message, "y"))
                writer.uint32(/* id 2, wireType 5 =*/21).float(message.y);
            if (message.z != null && Object.hasOwnProperty.call(message, "z"))
                writer.uint32(/* id 3, wireType 5 =*/29).float(message.z);
            if (message.w != null && Object.hasOwnProperty.call(message, "w"))
                writer.uint32(/* id 4, wireType 5 =*/37).float(message.w);
            return writer;
        };
    
        /**
         * Encodes the specified CMsgQuaternion message, length delimited. Does not implicitly {@link CMsgQuaternion.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CMsgQuaternion
         * @static
         * @param {ICMsgQuaternion} message CMsgQuaternion message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CMsgQuaternion.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CMsgQuaternion message from the specified reader or buffer.
         * @function decode
         * @memberof CMsgQuaternion
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CMsgQuaternion} CMsgQuaternion
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CMsgQuaternion.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgQuaternion();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.x = reader.float();
                        break;
                    }
                case 2: {
                        message.y = reader.float();
                        break;
                    }
                case 3: {
                        message.z = reader.float();
                        break;
                    }
                case 4: {
                        message.w = reader.float();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CMsgQuaternion message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CMsgQuaternion
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CMsgQuaternion} CMsgQuaternion
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CMsgQuaternion.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CMsgQuaternion message.
         * @function verify
         * @memberof CMsgQuaternion
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CMsgQuaternion.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.x != null && message.hasOwnProperty("x"))
                if (typeof message.x !== "number")
                    return "x: number expected";
            if (message.y != null && message.hasOwnProperty("y"))
                if (typeof message.y !== "number")
                    return "y: number expected";
            if (message.z != null && message.hasOwnProperty("z"))
                if (typeof message.z !== "number")
                    return "z: number expected";
            if (message.w != null && message.hasOwnProperty("w"))
                if (typeof message.w !== "number")
                    return "w: number expected";
            return null;
        };
    
        /**
         * Creates a CMsgQuaternion message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CMsgQuaternion
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CMsgQuaternion} CMsgQuaternion
         */
        CMsgQuaternion.fromObject = function fromObject(object) {
            if (object instanceof $root.CMsgQuaternion)
                return object;
            var message = new $root.CMsgQuaternion();
            if (object.x != null)
                message.x = Number(object.x);
            if (object.y != null)
                message.y = Number(object.y);
            if (object.z != null)
                message.z = Number(object.z);
            if (object.w != null)
                message.w = Number(object.w);
            return message;
        };
    
        /**
         * Creates a plain object from a CMsgQuaternion message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CMsgQuaternion
         * @static
         * @param {CMsgQuaternion} message CMsgQuaternion
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CMsgQuaternion.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.x = 0;
                object.y = 0;
                object.z = 0;
                object.w = 0;
            }
            if (message.x != null && message.hasOwnProperty("x"))
                object.x = options.json && !isFinite(message.x) ? String(message.x) : message.x;
            if (message.y != null && message.hasOwnProperty("y"))
                object.y = options.json && !isFinite(message.y) ? String(message.y) : message.y;
            if (message.z != null && message.hasOwnProperty("z"))
                object.z = options.json && !isFinite(message.z) ? String(message.z) : message.z;
            if (message.w != null && message.hasOwnProperty("w"))
                object.w = options.json && !isFinite(message.w) ? String(message.w) : message.w;
            return object;
        };
    
        /**
         * Converts this CMsgQuaternion to JSON.
         * @function toJSON
         * @memberof CMsgQuaternion
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CMsgQuaternion.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * Gets the default type url for CMsgQuaternion
         * @function getTypeUrl
         * @memberof CMsgQuaternion
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        CMsgQuaternion.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/CMsgQuaternion";
        };
    
        return CMsgQuaternion;
    })();
    
    $root.CMsgTransform = (function() {
    
        /**
         * Properties of a CMsgTransform.
         * @exports ICMsgTransform
         * @interface ICMsgTransform
         * @property {ICMsgVector|null} [position] CMsgTransform position
         * @property {number|null} [scale] CMsgTransform scale
         * @property {ICMsgQuaternion|null} [orientation] CMsgTransform orientation
         */
    
        /**
         * Constructs a new CMsgTransform.
         * @exports CMsgTransform
         * @classdesc Represents a CMsgTransform.
         * @implements ICMsgTransform
         * @constructor
         * @param {ICMsgTransform=} [properties] Properties to set
         */
        function CMsgTransform(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CMsgTransform position.
         * @member {ICMsgVector|null|undefined} position
         * @memberof CMsgTransform
         * @instance
         */
        CMsgTransform.prototype.position = null;
    
        /**
         * CMsgTransform scale.
         * @member {number} scale
         * @memberof CMsgTransform
         * @instance
         */
        CMsgTransform.prototype.scale = 0;
    
        /**
         * CMsgTransform orientation.
         * @member {ICMsgQuaternion|null|undefined} orientation
         * @memberof CMsgTransform
         * @instance
         */
        CMsgTransform.prototype.orientation = null;
    
        /**
         * Creates a new CMsgTransform instance using the specified properties.
         * @function create
         * @memberof CMsgTransform
         * @static
         * @param {ICMsgTransform=} [properties] Properties to set
         * @returns {CMsgTransform} CMsgTransform instance
         */
        CMsgTransform.create = function create(properties) {
            return new CMsgTransform(properties);
        };
    
        /**
         * Encodes the specified CMsgTransform message. Does not implicitly {@link CMsgTransform.verify|verify} messages.
         * @function encode
         * @memberof CMsgTransform
         * @static
         * @param {ICMsgTransform} message CMsgTransform message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CMsgTransform.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.position != null && Object.hasOwnProperty.call(message, "position"))
                $root.CMsgVector.encode(message.position, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.scale != null && Object.hasOwnProperty.call(message, "scale"))
                writer.uint32(/* id 2, wireType 5 =*/21).float(message.scale);
            if (message.orientation != null && Object.hasOwnProperty.call(message, "orientation"))
                $root.CMsgQuaternion.encode(message.orientation, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            return writer;
        };
    
        /**
         * Encodes the specified CMsgTransform message, length delimited. Does not implicitly {@link CMsgTransform.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CMsgTransform
         * @static
         * @param {ICMsgTransform} message CMsgTransform message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CMsgTransform.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CMsgTransform message from the specified reader or buffer.
         * @function decode
         * @memberof CMsgTransform
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CMsgTransform} CMsgTransform
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CMsgTransform.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgTransform();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.position = $root.CMsgVector.decode(reader, reader.uint32());
                        break;
                    }
                case 2: {
                        message.scale = reader.float();
                        break;
                    }
                case 3: {
                        message.orientation = $root.CMsgQuaternion.decode(reader, reader.uint32());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CMsgTransform message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CMsgTransform
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CMsgTransform} CMsgTransform
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CMsgTransform.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CMsgTransform message.
         * @function verify
         * @memberof CMsgTransform
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CMsgTransform.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.position != null && message.hasOwnProperty("position")) {
                var error = $root.CMsgVector.verify(message.position);
                if (error)
                    return "position." + error;
            }
            if (message.scale != null && message.hasOwnProperty("scale"))
                if (typeof message.scale !== "number")
                    return "scale: number expected";
            if (message.orientation != null && message.hasOwnProperty("orientation")) {
                var error = $root.CMsgQuaternion.verify(message.orientation);
                if (error)
                    return "orientation." + error;
            }
            return null;
        };
    
        /**
         * Creates a CMsgTransform message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CMsgTransform
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CMsgTransform} CMsgTransform
         */
        CMsgTransform.fromObject = function fromObject(object) {
            if (object instanceof $root.CMsgTransform)
                return object;
            var message = new $root.CMsgTransform();
            if (object.position != null) {
                if (typeof object.position !== "object")
                    throw TypeError(".CMsgTransform.position: object expected");
                message.position = $root.CMsgVector.fromObject(object.position);
            }
            if (object.scale != null)
                message.scale = Number(object.scale);
            if (object.orientation != null) {
                if (typeof object.orientation !== "object")
                    throw TypeError(".CMsgTransform.orientation: object expected");
                message.orientation = $root.CMsgQuaternion.fromObject(object.orientation);
            }
            return message;
        };
    
        /**
         * Creates a plain object from a CMsgTransform message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CMsgTransform
         * @static
         * @param {CMsgTransform} message CMsgTransform
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CMsgTransform.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.position = null;
                object.scale = 0;
                object.orientation = null;
            }
            if (message.position != null && message.hasOwnProperty("position"))
                object.position = $root.CMsgVector.toObject(message.position, options);
            if (message.scale != null && message.hasOwnProperty("scale"))
                object.scale = options.json && !isFinite(message.scale) ? String(message.scale) : message.scale;
            if (message.orientation != null && message.hasOwnProperty("orientation"))
                object.orientation = $root.CMsgQuaternion.toObject(message.orientation, options);
            return object;
        };
    
        /**
         * Converts this CMsgTransform to JSON.
         * @function toJSON
         * @memberof CMsgTransform
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CMsgTransform.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * Gets the default type url for CMsgTransform
         * @function getTypeUrl
         * @memberof CMsgTransform
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        CMsgTransform.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/CMsgTransform";
        };
    
        return CMsgTransform;
    })();
    
    $root.CMsgRGBA = (function() {
    
        /**
         * Properties of a CMsgRGBA.
         * @exports ICMsgRGBA
         * @interface ICMsgRGBA
         * @property {number|null} [r] CMsgRGBA r
         * @property {number|null} [g] CMsgRGBA g
         * @property {number|null} [b] CMsgRGBA b
         * @property {number|null} [a] CMsgRGBA a
         */
    
        /**
         * Constructs a new CMsgRGBA.
         * @exports CMsgRGBA
         * @classdesc Represents a CMsgRGBA.
         * @implements ICMsgRGBA
         * @constructor
         * @param {ICMsgRGBA=} [properties] Properties to set
         */
        function CMsgRGBA(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CMsgRGBA r.
         * @member {number} r
         * @memberof CMsgRGBA
         * @instance
         */
        CMsgRGBA.prototype.r = 0;
    
        /**
         * CMsgRGBA g.
         * @member {number} g
         * @memberof CMsgRGBA
         * @instance
         */
        CMsgRGBA.prototype.g = 0;
    
        /**
         * CMsgRGBA b.
         * @member {number} b
         * @memberof CMsgRGBA
         * @instance
         */
        CMsgRGBA.prototype.b = 0;
    
        /**
         * CMsgRGBA a.
         * @member {number} a
         * @memberof CMsgRGBA
         * @instance
         */
        CMsgRGBA.prototype.a = 0;
    
        /**
         * Creates a new CMsgRGBA instance using the specified properties.
         * @function create
         * @memberof CMsgRGBA
         * @static
         * @param {ICMsgRGBA=} [properties] Properties to set
         * @returns {CMsgRGBA} CMsgRGBA instance
         */
        CMsgRGBA.create = function create(properties) {
            return new CMsgRGBA(properties);
        };
    
        /**
         * Encodes the specified CMsgRGBA message. Does not implicitly {@link CMsgRGBA.verify|verify} messages.
         * @function encode
         * @memberof CMsgRGBA
         * @static
         * @param {ICMsgRGBA} message CMsgRGBA message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CMsgRGBA.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.r != null && Object.hasOwnProperty.call(message, "r"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.r);
            if (message.g != null && Object.hasOwnProperty.call(message, "g"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.g);
            if (message.b != null && Object.hasOwnProperty.call(message, "b"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.b);
            if (message.a != null && Object.hasOwnProperty.call(message, "a"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.a);
            return writer;
        };
    
        /**
         * Encodes the specified CMsgRGBA message, length delimited. Does not implicitly {@link CMsgRGBA.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CMsgRGBA
         * @static
         * @param {ICMsgRGBA} message CMsgRGBA message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CMsgRGBA.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CMsgRGBA message from the specified reader or buffer.
         * @function decode
         * @memberof CMsgRGBA
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CMsgRGBA} CMsgRGBA
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CMsgRGBA.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgRGBA();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.r = reader.int32();
                        break;
                    }
                case 2: {
                        message.g = reader.int32();
                        break;
                    }
                case 3: {
                        message.b = reader.int32();
                        break;
                    }
                case 4: {
                        message.a = reader.int32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CMsgRGBA message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CMsgRGBA
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CMsgRGBA} CMsgRGBA
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CMsgRGBA.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CMsgRGBA message.
         * @function verify
         * @memberof CMsgRGBA
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CMsgRGBA.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.r != null && message.hasOwnProperty("r"))
                if (!$util.isInteger(message.r))
                    return "r: integer expected";
            if (message.g != null && message.hasOwnProperty("g"))
                if (!$util.isInteger(message.g))
                    return "g: integer expected";
            if (message.b != null && message.hasOwnProperty("b"))
                if (!$util.isInteger(message.b))
                    return "b: integer expected";
            if (message.a != null && message.hasOwnProperty("a"))
                if (!$util.isInteger(message.a))
                    return "a: integer expected";
            return null;
        };
    
        /**
         * Creates a CMsgRGBA message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CMsgRGBA
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CMsgRGBA} CMsgRGBA
         */
        CMsgRGBA.fromObject = function fromObject(object) {
            if (object instanceof $root.CMsgRGBA)
                return object;
            var message = new $root.CMsgRGBA();
            if (object.r != null)
                message.r = object.r | 0;
            if (object.g != null)
                message.g = object.g | 0;
            if (object.b != null)
                message.b = object.b | 0;
            if (object.a != null)
                message.a = object.a | 0;
            return message;
        };
    
        /**
         * Creates a plain object from a CMsgRGBA message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CMsgRGBA
         * @static
         * @param {CMsgRGBA} message CMsgRGBA
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CMsgRGBA.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.r = 0;
                object.g = 0;
                object.b = 0;
                object.a = 0;
            }
            if (message.r != null && message.hasOwnProperty("r"))
                object.r = message.r;
            if (message.g != null && message.hasOwnProperty("g"))
                object.g = message.g;
            if (message.b != null && message.hasOwnProperty("b"))
                object.b = message.b;
            if (message.a != null && message.hasOwnProperty("a"))
                object.a = message.a;
            return object;
        };
    
        /**
         * Converts this CMsgRGBA to JSON.
         * @function toJSON
         * @memberof CMsgRGBA
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CMsgRGBA.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * Gets the default type url for CMsgRGBA
         * @function getTypeUrl
         * @memberof CMsgRGBA
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        CMsgRGBA.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/CMsgRGBA";
        };
    
        return CMsgRGBA;
    })();
    
    $root.CMsgPlayerInfo = (function() {
    
        /**
         * Properties of a CMsgPlayerInfo.
         * @exports ICMsgPlayerInfo
         * @interface ICMsgPlayerInfo
         * @property {string|null} [name] CMsgPlayerInfo name
         * @property {number|Long|null} [xuid] CMsgPlayerInfo xuid
         * @property {number|null} [userid] CMsgPlayerInfo userid
         * @property {number|Long|null} [steamid] CMsgPlayerInfo steamid
         * @property {boolean|null} [fakeplayer] CMsgPlayerInfo fakeplayer
         * @property {boolean|null} [ishltv] CMsgPlayerInfo ishltv
         */
    
        /**
         * Constructs a new CMsgPlayerInfo.
         * @exports CMsgPlayerInfo
         * @classdesc Represents a CMsgPlayerInfo.
         * @implements ICMsgPlayerInfo
         * @constructor
         * @param {ICMsgPlayerInfo=} [properties] Properties to set
         */
        function CMsgPlayerInfo(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CMsgPlayerInfo name.
         * @member {string} name
         * @memberof CMsgPlayerInfo
         * @instance
         */
        CMsgPlayerInfo.prototype.name = "";
    
        /**
         * CMsgPlayerInfo xuid.
         * @member {number|Long} xuid
         * @memberof CMsgPlayerInfo
         * @instance
         */
        CMsgPlayerInfo.prototype.xuid = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
        /**
         * CMsgPlayerInfo userid.
         * @member {number} userid
         * @memberof CMsgPlayerInfo
         * @instance
         */
        CMsgPlayerInfo.prototype.userid = 0;
    
        /**
         * CMsgPlayerInfo steamid.
         * @member {number|Long} steamid
         * @memberof CMsgPlayerInfo
         * @instance
         */
        CMsgPlayerInfo.prototype.steamid = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
        /**
         * CMsgPlayerInfo fakeplayer.
         * @member {boolean} fakeplayer
         * @memberof CMsgPlayerInfo
         * @instance
         */
        CMsgPlayerInfo.prototype.fakeplayer = false;
    
        /**
         * CMsgPlayerInfo ishltv.
         * @member {boolean} ishltv
         * @memberof CMsgPlayerInfo
         * @instance
         */
        CMsgPlayerInfo.prototype.ishltv = false;
    
        /**
         * Creates a new CMsgPlayerInfo instance using the specified properties.
         * @function create
         * @memberof CMsgPlayerInfo
         * @static
         * @param {ICMsgPlayerInfo=} [properties] Properties to set
         * @returns {CMsgPlayerInfo} CMsgPlayerInfo instance
         */
        CMsgPlayerInfo.create = function create(properties) {
            return new CMsgPlayerInfo(properties);
        };
    
        /**
         * Encodes the specified CMsgPlayerInfo message. Does not implicitly {@link CMsgPlayerInfo.verify|verify} messages.
         * @function encode
         * @memberof CMsgPlayerInfo
         * @static
         * @param {ICMsgPlayerInfo} message CMsgPlayerInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CMsgPlayerInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
            if (message.xuid != null && Object.hasOwnProperty.call(message, "xuid"))
                writer.uint32(/* id 2, wireType 1 =*/17).fixed64(message.xuid);
            if (message.userid != null && Object.hasOwnProperty.call(message, "userid"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.userid);
            if (message.steamid != null && Object.hasOwnProperty.call(message, "steamid"))
                writer.uint32(/* id 4, wireType 1 =*/33).fixed64(message.steamid);
            if (message.fakeplayer != null && Object.hasOwnProperty.call(message, "fakeplayer"))
                writer.uint32(/* id 5, wireType 0 =*/40).bool(message.fakeplayer);
            if (message.ishltv != null && Object.hasOwnProperty.call(message, "ishltv"))
                writer.uint32(/* id 6, wireType 0 =*/48).bool(message.ishltv);
            return writer;
        };
    
        /**
         * Encodes the specified CMsgPlayerInfo message, length delimited. Does not implicitly {@link CMsgPlayerInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CMsgPlayerInfo
         * @static
         * @param {ICMsgPlayerInfo} message CMsgPlayerInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CMsgPlayerInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CMsgPlayerInfo message from the specified reader or buffer.
         * @function decode
         * @memberof CMsgPlayerInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CMsgPlayerInfo} CMsgPlayerInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CMsgPlayerInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgPlayerInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.name = reader.string();
                        break;
                    }
                case 2: {
                        message.xuid = reader.fixed64();
                        break;
                    }
                case 3: {
                        message.userid = reader.int32();
                        break;
                    }
                case 4: {
                        message.steamid = reader.fixed64();
                        break;
                    }
                case 5: {
                        message.fakeplayer = reader.bool();
                        break;
                    }
                case 6: {
                        message.ishltv = reader.bool();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CMsgPlayerInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CMsgPlayerInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CMsgPlayerInfo} CMsgPlayerInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CMsgPlayerInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CMsgPlayerInfo message.
         * @function verify
         * @memberof CMsgPlayerInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CMsgPlayerInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.name != null && message.hasOwnProperty("name"))
                if (!$util.isString(message.name))
                    return "name: string expected";
            if (message.xuid != null && message.hasOwnProperty("xuid"))
                if (!$util.isInteger(message.xuid) && !(message.xuid && $util.isInteger(message.xuid.low) && $util.isInteger(message.xuid.high)))
                    return "xuid: integer|Long expected";
            if (message.userid != null && message.hasOwnProperty("userid"))
                if (!$util.isInteger(message.userid))
                    return "userid: integer expected";
            if (message.steamid != null && message.hasOwnProperty("steamid"))
                if (!$util.isInteger(message.steamid) && !(message.steamid && $util.isInteger(message.steamid.low) && $util.isInteger(message.steamid.high)))
                    return "steamid: integer|Long expected";
            if (message.fakeplayer != null && message.hasOwnProperty("fakeplayer"))
                if (typeof message.fakeplayer !== "boolean")
                    return "fakeplayer: boolean expected";
            if (message.ishltv != null && message.hasOwnProperty("ishltv"))
                if (typeof message.ishltv !== "boolean")
                    return "ishltv: boolean expected";
            return null;
        };
    
        /**
         * Creates a CMsgPlayerInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CMsgPlayerInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CMsgPlayerInfo} CMsgPlayerInfo
         */
        CMsgPlayerInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.CMsgPlayerInfo)
                return object;
            var message = new $root.CMsgPlayerInfo();
            if (object.name != null)
                message.name = String(object.name);
            if (object.xuid != null)
                if ($util.Long)
                    (message.xuid = $util.Long.fromValue(object.xuid)).unsigned = false;
                else if (typeof object.xuid === "string")
                    message.xuid = parseInt(object.xuid, 10);
                else if (typeof object.xuid === "number")
                    message.xuid = object.xuid;
                else if (typeof object.xuid === "object")
                    message.xuid = new $util.LongBits(object.xuid.low >>> 0, object.xuid.high >>> 0).toNumber();
            if (object.userid != null)
                message.userid = object.userid | 0;
            if (object.steamid != null)
                if ($util.Long)
                    (message.steamid = $util.Long.fromValue(object.steamid)).unsigned = false;
                else if (typeof object.steamid === "string")
                    message.steamid = parseInt(object.steamid, 10);
                else if (typeof object.steamid === "number")
                    message.steamid = object.steamid;
                else if (typeof object.steamid === "object")
                    message.steamid = new $util.LongBits(object.steamid.low >>> 0, object.steamid.high >>> 0).toNumber();
            if (object.fakeplayer != null)
                message.fakeplayer = Boolean(object.fakeplayer);
            if (object.ishltv != null)
                message.ishltv = Boolean(object.ishltv);
            return message;
        };
    
        /**
         * Creates a plain object from a CMsgPlayerInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CMsgPlayerInfo
         * @static
         * @param {CMsgPlayerInfo} message CMsgPlayerInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CMsgPlayerInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.name = "";
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.xuid = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.xuid = options.longs === String ? "0" : 0;
                object.userid = 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.steamid = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.steamid = options.longs === String ? "0" : 0;
                object.fakeplayer = false;
                object.ishltv = false;
            }
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
            if (message.xuid != null && message.hasOwnProperty("xuid"))
                if (typeof message.xuid === "number")
                    object.xuid = options.longs === String ? String(message.xuid) : message.xuid;
                else
                    object.xuid = options.longs === String ? $util.Long.prototype.toString.call(message.xuid) : options.longs === Number ? new $util.LongBits(message.xuid.low >>> 0, message.xuid.high >>> 0).toNumber() : message.xuid;
            if (message.userid != null && message.hasOwnProperty("userid"))
                object.userid = message.userid;
            if (message.steamid != null && message.hasOwnProperty("steamid"))
                if (typeof message.steamid === "number")
                    object.steamid = options.longs === String ? String(message.steamid) : message.steamid;
                else
                    object.steamid = options.longs === String ? $util.Long.prototype.toString.call(message.steamid) : options.longs === Number ? new $util.LongBits(message.steamid.low >>> 0, message.steamid.high >>> 0).toNumber() : message.steamid;
            if (message.fakeplayer != null && message.hasOwnProperty("fakeplayer"))
                object.fakeplayer = message.fakeplayer;
            if (message.ishltv != null && message.hasOwnProperty("ishltv"))
                object.ishltv = message.ishltv;
            return object;
        };
    
        /**
         * Converts this CMsgPlayerInfo to JSON.
         * @function toJSON
         * @memberof CMsgPlayerInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CMsgPlayerInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * Gets the default type url for CMsgPlayerInfo
         * @function getTypeUrl
         * @memberof CMsgPlayerInfo
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        CMsgPlayerInfo.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/CMsgPlayerInfo";
        };
    
        return CMsgPlayerInfo;
    })();
    
    $root.CEntityMsg = (function() {
    
        /**
         * Properties of a CEntityMsg.
         * @exports ICEntityMsg
         * @interface ICEntityMsg
         * @property {number|null} [targetEntity] CEntityMsg targetEntity
         */
    
        /**
         * Constructs a new CEntityMsg.
         * @exports CEntityMsg
         * @classdesc Represents a CEntityMsg.
         * @implements ICEntityMsg
         * @constructor
         * @param {ICEntityMsg=} [properties] Properties to set
         */
        function CEntityMsg(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CEntityMsg targetEntity.
         * @member {number} targetEntity
         * @memberof CEntityMsg
         * @instance
         */
        CEntityMsg.prototype.targetEntity = 16777215;
    
        /**
         * Creates a new CEntityMsg instance using the specified properties.
         * @function create
         * @memberof CEntityMsg
         * @static
         * @param {ICEntityMsg=} [properties] Properties to set
         * @returns {CEntityMsg} CEntityMsg instance
         */
        CEntityMsg.create = function create(properties) {
            return new CEntityMsg(properties);
        };
    
        /**
         * Encodes the specified CEntityMsg message. Does not implicitly {@link CEntityMsg.verify|verify} messages.
         * @function encode
         * @memberof CEntityMsg
         * @static
         * @param {ICEntityMsg} message CEntityMsg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CEntityMsg.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.targetEntity != null && Object.hasOwnProperty.call(message, "targetEntity"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.targetEntity);
            return writer;
        };
    
        /**
         * Encodes the specified CEntityMsg message, length delimited. Does not implicitly {@link CEntityMsg.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CEntityMsg
         * @static
         * @param {ICEntityMsg} message CEntityMsg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CEntityMsg.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CEntityMsg message from the specified reader or buffer.
         * @function decode
         * @memberof CEntityMsg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CEntityMsg} CEntityMsg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CEntityMsg.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CEntityMsg();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.targetEntity = reader.uint32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CEntityMsg message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CEntityMsg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CEntityMsg} CEntityMsg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CEntityMsg.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CEntityMsg message.
         * @function verify
         * @memberof CEntityMsg
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CEntityMsg.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.targetEntity != null && message.hasOwnProperty("targetEntity"))
                if (!$util.isInteger(message.targetEntity))
                    return "targetEntity: integer expected";
            return null;
        };
    
        /**
         * Creates a CEntityMsg message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CEntityMsg
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CEntityMsg} CEntityMsg
         */
        CEntityMsg.fromObject = function fromObject(object) {
            if (object instanceof $root.CEntityMsg)
                return object;
            var message = new $root.CEntityMsg();
            if (object.targetEntity != null)
                message.targetEntity = object.targetEntity >>> 0;
            return message;
        };
    
        /**
         * Creates a plain object from a CEntityMsg message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CEntityMsg
         * @static
         * @param {CEntityMsg} message CEntityMsg
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CEntityMsg.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.targetEntity = 16777215;
            if (message.targetEntity != null && message.hasOwnProperty("targetEntity"))
                object.targetEntity = message.targetEntity;
            return object;
        };
    
        /**
         * Converts this CEntityMsg to JSON.
         * @function toJSON
         * @memberof CEntityMsg
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CEntityMsg.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * Gets the default type url for CEntityMsg
         * @function getTypeUrl
         * @memberof CEntityMsg
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        CEntityMsg.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/CEntityMsg";
        };
    
        return CEntityMsg;
    })();
    
    $root.CMsg_CVars = (function() {
    
        /**
         * Properties of a CMsg_CVars.
         * @exports ICMsg_CVars
         * @interface ICMsg_CVars
         * @property {Array.<CMsg_CVars.ICVar>|null} [cvars] CMsg_CVars cvars
         */
    
        /**
         * Constructs a new CMsg_CVars.
         * @exports CMsg_CVars
         * @classdesc Represents a CMsg_CVars.
         * @implements ICMsg_CVars
         * @constructor
         * @param {ICMsg_CVars=} [properties] Properties to set
         */
        function CMsg_CVars(properties) {
            this.cvars = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CMsg_CVars cvars.
         * @member {Array.<CMsg_CVars.ICVar>} cvars
         * @memberof CMsg_CVars
         * @instance
         */
        CMsg_CVars.prototype.cvars = $util.emptyArray;
    
        /**
         * Creates a new CMsg_CVars instance using the specified properties.
         * @function create
         * @memberof CMsg_CVars
         * @static
         * @param {ICMsg_CVars=} [properties] Properties to set
         * @returns {CMsg_CVars} CMsg_CVars instance
         */
        CMsg_CVars.create = function create(properties) {
            return new CMsg_CVars(properties);
        };
    
        /**
         * Encodes the specified CMsg_CVars message. Does not implicitly {@link CMsg_CVars.verify|verify} messages.
         * @function encode
         * @memberof CMsg_CVars
         * @static
         * @param {ICMsg_CVars} message CMsg_CVars message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CMsg_CVars.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.cvars != null && message.cvars.length)
                for (var i = 0; i < message.cvars.length; ++i)
                    $root.CMsg_CVars.CVar.encode(message.cvars[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };
    
        /**
         * Encodes the specified CMsg_CVars message, length delimited. Does not implicitly {@link CMsg_CVars.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CMsg_CVars
         * @static
         * @param {ICMsg_CVars} message CMsg_CVars message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CMsg_CVars.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CMsg_CVars message from the specified reader or buffer.
         * @function decode
         * @memberof CMsg_CVars
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CMsg_CVars} CMsg_CVars
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CMsg_CVars.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsg_CVars();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        if (!(message.cvars && message.cvars.length))
                            message.cvars = [];
                        message.cvars.push($root.CMsg_CVars.CVar.decode(reader, reader.uint32()));
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CMsg_CVars message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CMsg_CVars
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CMsg_CVars} CMsg_CVars
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CMsg_CVars.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CMsg_CVars message.
         * @function verify
         * @memberof CMsg_CVars
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CMsg_CVars.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.cvars != null && message.hasOwnProperty("cvars")) {
                if (!Array.isArray(message.cvars))
                    return "cvars: array expected";
                for (var i = 0; i < message.cvars.length; ++i) {
                    var error = $root.CMsg_CVars.CVar.verify(message.cvars[i]);
                    if (error)
                        return "cvars." + error;
                }
            }
            return null;
        };
    
        /**
         * Creates a CMsg_CVars message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CMsg_CVars
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CMsg_CVars} CMsg_CVars
         */
        CMsg_CVars.fromObject = function fromObject(object) {
            if (object instanceof $root.CMsg_CVars)
                return object;
            var message = new $root.CMsg_CVars();
            if (object.cvars) {
                if (!Array.isArray(object.cvars))
                    throw TypeError(".CMsg_CVars.cvars: array expected");
                message.cvars = [];
                for (var i = 0; i < object.cvars.length; ++i) {
                    if (typeof object.cvars[i] !== "object")
                        throw TypeError(".CMsg_CVars.cvars: object expected");
                    message.cvars[i] = $root.CMsg_CVars.CVar.fromObject(object.cvars[i]);
                }
            }
            return message;
        };
    
        /**
         * Creates a plain object from a CMsg_CVars message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CMsg_CVars
         * @static
         * @param {CMsg_CVars} message CMsg_CVars
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CMsg_CVars.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.cvars = [];
            if (message.cvars && message.cvars.length) {
                object.cvars = [];
                for (var j = 0; j < message.cvars.length; ++j)
                    object.cvars[j] = $root.CMsg_CVars.CVar.toObject(message.cvars[j], options);
            }
            return object;
        };
    
        /**
         * Converts this CMsg_CVars to JSON.
         * @function toJSON
         * @memberof CMsg_CVars
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CMsg_CVars.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * Gets the default type url for CMsg_CVars
         * @function getTypeUrl
         * @memberof CMsg_CVars
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        CMsg_CVars.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/CMsg_CVars";
        };
    
        CMsg_CVars.CVar = (function() {
    
            /**
             * Properties of a CVar.
             * @memberof CMsg_CVars
             * @interface ICVar
             * @property {string|null} [name] CVar name
             * @property {string|null} [value] CVar value
             */
    
            /**
             * Constructs a new CVar.
             * @memberof CMsg_CVars
             * @classdesc Represents a CVar.
             * @implements ICVar
             * @constructor
             * @param {CMsg_CVars.ICVar=} [properties] Properties to set
             */
            function CVar(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * CVar name.
             * @member {string} name
             * @memberof CMsg_CVars.CVar
             * @instance
             */
            CVar.prototype.name = "";
    
            /**
             * CVar value.
             * @member {string} value
             * @memberof CMsg_CVars.CVar
             * @instance
             */
            CVar.prototype.value = "";
    
            /**
             * Creates a new CVar instance using the specified properties.
             * @function create
             * @memberof CMsg_CVars.CVar
             * @static
             * @param {CMsg_CVars.ICVar=} [properties] Properties to set
             * @returns {CMsg_CVars.CVar} CVar instance
             */
            CVar.create = function create(properties) {
                return new CVar(properties);
            };
    
            /**
             * Encodes the specified CVar message. Does not implicitly {@link CMsg_CVars.CVar.verify|verify} messages.
             * @function encode
             * @memberof CMsg_CVars.CVar
             * @static
             * @param {CMsg_CVars.ICVar} message CVar message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CVar.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                if (message.value != null && Object.hasOwnProperty.call(message, "value"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.value);
                return writer;
            };
    
            /**
             * Encodes the specified CVar message, length delimited. Does not implicitly {@link CMsg_CVars.CVar.verify|verify} messages.
             * @function encodeDelimited
             * @memberof CMsg_CVars.CVar
             * @static
             * @param {CMsg_CVars.ICVar} message CVar message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CVar.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a CVar message from the specified reader or buffer.
             * @function decode
             * @memberof CMsg_CVars.CVar
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {CMsg_CVars.CVar} CVar
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CVar.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsg_CVars.CVar();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.name = reader.string();
                            break;
                        }
                    case 2: {
                            message.value = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a CVar message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof CMsg_CVars.CVar
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {CMsg_CVars.CVar} CVar
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CVar.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a CVar message.
             * @function verify
             * @memberof CMsg_CVars.CVar
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            CVar.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                if (message.value != null && message.hasOwnProperty("value"))
                    if (!$util.isString(message.value))
                        return "value: string expected";
                return null;
            };
    
            /**
             * Creates a CVar message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof CMsg_CVars.CVar
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {CMsg_CVars.CVar} CVar
             */
            CVar.fromObject = function fromObject(object) {
                if (object instanceof $root.CMsg_CVars.CVar)
                    return object;
                var message = new $root.CMsg_CVars.CVar();
                if (object.name != null)
                    message.name = String(object.name);
                if (object.value != null)
                    message.value = String(object.value);
                return message;
            };
    
            /**
             * Creates a plain object from a CVar message. Also converts values to other types if specified.
             * @function toObject
             * @memberof CMsg_CVars.CVar
             * @static
             * @param {CMsg_CVars.CVar} message CVar
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            CVar.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.name = "";
                    object.value = "";
                }
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                if (message.value != null && message.hasOwnProperty("value"))
                    object.value = message.value;
                return object;
            };
    
            /**
             * Converts this CVar to JSON.
             * @function toJSON
             * @memberof CMsg_CVars.CVar
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            CVar.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            /**
             * Gets the default type url for CVar
             * @function getTypeUrl
             * @memberof CMsg_CVars.CVar
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            CVar.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/CMsg_CVars.CVar";
            };
    
            return CVar;
        })();
    
        return CMsg_CVars;
    })();
    
    $root.CNETMsg_NOP = (function() {
    
        /**
         * Properties of a CNETMsg_NOP.
         * @exports ICNETMsg_NOP
         * @interface ICNETMsg_NOP
         */
    
        /**
         * Constructs a new CNETMsg_NOP.
         * @exports CNETMsg_NOP
         * @classdesc Represents a CNETMsg_NOP.
         * @implements ICNETMsg_NOP
         * @constructor
         * @param {ICNETMsg_NOP=} [properties] Properties to set
         */
        function CNETMsg_NOP(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * Creates a new CNETMsg_NOP instance using the specified properties.
         * @function create
         * @memberof CNETMsg_NOP
         * @static
         * @param {ICNETMsg_NOP=} [properties] Properties to set
         * @returns {CNETMsg_NOP} CNETMsg_NOP instance
         */
        CNETMsg_NOP.create = function create(properties) {
            return new CNETMsg_NOP(properties);
        };
    
        /**
         * Encodes the specified CNETMsg_NOP message. Does not implicitly {@link CNETMsg_NOP.verify|verify} messages.
         * @function encode
         * @memberof CNETMsg_NOP
         * @static
         * @param {ICNETMsg_NOP} message CNETMsg_NOP message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CNETMsg_NOP.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };
    
        /**
         * Encodes the specified CNETMsg_NOP message, length delimited. Does not implicitly {@link CNETMsg_NOP.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CNETMsg_NOP
         * @static
         * @param {ICNETMsg_NOP} message CNETMsg_NOP message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CNETMsg_NOP.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CNETMsg_NOP message from the specified reader or buffer.
         * @function decode
         * @memberof CNETMsg_NOP
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CNETMsg_NOP} CNETMsg_NOP
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CNETMsg_NOP.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CNETMsg_NOP();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CNETMsg_NOP message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CNETMsg_NOP
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CNETMsg_NOP} CNETMsg_NOP
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CNETMsg_NOP.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CNETMsg_NOP message.
         * @function verify
         * @memberof CNETMsg_NOP
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CNETMsg_NOP.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };
    
        /**
         * Creates a CNETMsg_NOP message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CNETMsg_NOP
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CNETMsg_NOP} CNETMsg_NOP
         */
        CNETMsg_NOP.fromObject = function fromObject(object) {
            if (object instanceof $root.CNETMsg_NOP)
                return object;
            return new $root.CNETMsg_NOP();
        };
    
        /**
         * Creates a plain object from a CNETMsg_NOP message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CNETMsg_NOP
         * @static
         * @param {CNETMsg_NOP} message CNETMsg_NOP
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CNETMsg_NOP.toObject = function toObject() {
            return {};
        };
    
        /**
         * Converts this CNETMsg_NOP to JSON.
         * @function toJSON
         * @memberof CNETMsg_NOP
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CNETMsg_NOP.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * Gets the default type url for CNETMsg_NOP
         * @function getTypeUrl
         * @memberof CNETMsg_NOP
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        CNETMsg_NOP.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/CNETMsg_NOP";
        };
    
        return CNETMsg_NOP;
    })();
    
    $root.CNETMsg_SplitScreenUser = (function() {
    
        /**
         * Properties of a CNETMsg_SplitScreenUser.
         * @exports ICNETMsg_SplitScreenUser
         * @interface ICNETMsg_SplitScreenUser
         * @property {number|null} [slot] CNETMsg_SplitScreenUser slot
         */
    
        /**
         * Constructs a new CNETMsg_SplitScreenUser.
         * @exports CNETMsg_SplitScreenUser
         * @classdesc Represents a CNETMsg_SplitScreenUser.
         * @implements ICNETMsg_SplitScreenUser
         * @constructor
         * @param {ICNETMsg_SplitScreenUser=} [properties] Properties to set
         */
        function CNETMsg_SplitScreenUser(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CNETMsg_SplitScreenUser slot.
         * @member {number} slot
         * @memberof CNETMsg_SplitScreenUser
         * @instance
         */
        CNETMsg_SplitScreenUser.prototype.slot = 0;
    
        /**
         * Creates a new CNETMsg_SplitScreenUser instance using the specified properties.
         * @function create
         * @memberof CNETMsg_SplitScreenUser
         * @static
         * @param {ICNETMsg_SplitScreenUser=} [properties] Properties to set
         * @returns {CNETMsg_SplitScreenUser} CNETMsg_SplitScreenUser instance
         */
        CNETMsg_SplitScreenUser.create = function create(properties) {
            return new CNETMsg_SplitScreenUser(properties);
        };
    
        /**
         * Encodes the specified CNETMsg_SplitScreenUser message. Does not implicitly {@link CNETMsg_SplitScreenUser.verify|verify} messages.
         * @function encode
         * @memberof CNETMsg_SplitScreenUser
         * @static
         * @param {ICNETMsg_SplitScreenUser} message CNETMsg_SplitScreenUser message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CNETMsg_SplitScreenUser.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.slot != null && Object.hasOwnProperty.call(message, "slot"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.slot);
            return writer;
        };
    
        /**
         * Encodes the specified CNETMsg_SplitScreenUser message, length delimited. Does not implicitly {@link CNETMsg_SplitScreenUser.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CNETMsg_SplitScreenUser
         * @static
         * @param {ICNETMsg_SplitScreenUser} message CNETMsg_SplitScreenUser message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CNETMsg_SplitScreenUser.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CNETMsg_SplitScreenUser message from the specified reader or buffer.
         * @function decode
         * @memberof CNETMsg_SplitScreenUser
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CNETMsg_SplitScreenUser} CNETMsg_SplitScreenUser
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CNETMsg_SplitScreenUser.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CNETMsg_SplitScreenUser();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.slot = reader.int32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CNETMsg_SplitScreenUser message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CNETMsg_SplitScreenUser
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CNETMsg_SplitScreenUser} CNETMsg_SplitScreenUser
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CNETMsg_SplitScreenUser.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CNETMsg_SplitScreenUser message.
         * @function verify
         * @memberof CNETMsg_SplitScreenUser
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CNETMsg_SplitScreenUser.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.slot != null && message.hasOwnProperty("slot"))
                if (!$util.isInteger(message.slot))
                    return "slot: integer expected";
            return null;
        };
    
        /**
         * Creates a CNETMsg_SplitScreenUser message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CNETMsg_SplitScreenUser
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CNETMsg_SplitScreenUser} CNETMsg_SplitScreenUser
         */
        CNETMsg_SplitScreenUser.fromObject = function fromObject(object) {
            if (object instanceof $root.CNETMsg_SplitScreenUser)
                return object;
            var message = new $root.CNETMsg_SplitScreenUser();
            if (object.slot != null)
                message.slot = object.slot | 0;
            return message;
        };
    
        /**
         * Creates a plain object from a CNETMsg_SplitScreenUser message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CNETMsg_SplitScreenUser
         * @static
         * @param {CNETMsg_SplitScreenUser} message CNETMsg_SplitScreenUser
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CNETMsg_SplitScreenUser.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.slot = 0;
            if (message.slot != null && message.hasOwnProperty("slot"))
                object.slot = message.slot;
            return object;
        };
    
        /**
         * Converts this CNETMsg_SplitScreenUser to JSON.
         * @function toJSON
         * @memberof CNETMsg_SplitScreenUser
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CNETMsg_SplitScreenUser.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * Gets the default type url for CNETMsg_SplitScreenUser
         * @function getTypeUrl
         * @memberof CNETMsg_SplitScreenUser
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        CNETMsg_SplitScreenUser.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/CNETMsg_SplitScreenUser";
        };
    
        return CNETMsg_SplitScreenUser;
    })();
    
    $root.CNETMsg_Disconnect = (function() {
    
        /**
         * Properties of a CNETMsg_Disconnect.
         * @exports ICNETMsg_Disconnect
         * @interface ICNETMsg_Disconnect
         * @property {ENetworkDisconnectionReason|null} [reason] CNETMsg_Disconnect reason
         */
    
        /**
         * Constructs a new CNETMsg_Disconnect.
         * @exports CNETMsg_Disconnect
         * @classdesc Represents a CNETMsg_Disconnect.
         * @implements ICNETMsg_Disconnect
         * @constructor
         * @param {ICNETMsg_Disconnect=} [properties] Properties to set
         */
        function CNETMsg_Disconnect(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CNETMsg_Disconnect reason.
         * @member {ENetworkDisconnectionReason} reason
         * @memberof CNETMsg_Disconnect
         * @instance
         */
        CNETMsg_Disconnect.prototype.reason = 0;
    
        /**
         * Creates a new CNETMsg_Disconnect instance using the specified properties.
         * @function create
         * @memberof CNETMsg_Disconnect
         * @static
         * @param {ICNETMsg_Disconnect=} [properties] Properties to set
         * @returns {CNETMsg_Disconnect} CNETMsg_Disconnect instance
         */
        CNETMsg_Disconnect.create = function create(properties) {
            return new CNETMsg_Disconnect(properties);
        };
    
        /**
         * Encodes the specified CNETMsg_Disconnect message. Does not implicitly {@link CNETMsg_Disconnect.verify|verify} messages.
         * @function encode
         * @memberof CNETMsg_Disconnect
         * @static
         * @param {ICNETMsg_Disconnect} message CNETMsg_Disconnect message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CNETMsg_Disconnect.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.reason != null && Object.hasOwnProperty.call(message, "reason"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.reason);
            return writer;
        };
    
        /**
         * Encodes the specified CNETMsg_Disconnect message, length delimited. Does not implicitly {@link CNETMsg_Disconnect.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CNETMsg_Disconnect
         * @static
         * @param {ICNETMsg_Disconnect} message CNETMsg_Disconnect message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CNETMsg_Disconnect.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CNETMsg_Disconnect message from the specified reader or buffer.
         * @function decode
         * @memberof CNETMsg_Disconnect
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CNETMsg_Disconnect} CNETMsg_Disconnect
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CNETMsg_Disconnect.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CNETMsg_Disconnect();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 2: {
                        message.reason = reader.int32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CNETMsg_Disconnect message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CNETMsg_Disconnect
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CNETMsg_Disconnect} CNETMsg_Disconnect
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CNETMsg_Disconnect.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CNETMsg_Disconnect message.
         * @function verify
         * @memberof CNETMsg_Disconnect
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CNETMsg_Disconnect.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.reason != null && message.hasOwnProperty("reason"))
                switch (message.reason) {
                default:
                    return "reason: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                case 7:
                case 8:
                case 9:
                case 10:
                case 11:
                case 12:
                case 13:
                case 14:
                case 15:
                case 16:
                case 17:
                case 18:
                case 19:
                case 20:
                case 21:
                case 22:
                case 23:
                case 24:
                case 25:
                case 26:
                case 27:
                case 28:
                case 29:
                case 30:
                case 31:
                case 32:
                case 33:
                case 34:
                case 35:
                case 36:
                case 37:
                case 38:
                case 39:
                case 40:
                case 41:
                case 42:
                case 43:
                case 44:
                case 45:
                case 46:
                case 47:
                case 48:
                case 49:
                case 50:
                case 51:
                case 52:
                case 53:
                case 54:
                case 55:
                case 56:
                case 57:
                case 58:
                case 59:
                case 60:
                case 61:
                case 62:
                case 63:
                case 64:
                case 65:
                case 66:
                case 67:
                case 68:
                case 69:
                case 71:
                case 72:
                case 73:
                case 74:
                case 75:
                case 76:
                case 77:
                case 79:
                case 80:
                case 81:
                case 82:
                case 83:
                case 84:
                case 85:
                case 128:
                case 129:
                case 130:
                case 131:
                case 132:
                case 133:
                case 134:
                case 135:
                case 136:
                case 137:
                case 138:
                case 139:
                case 140:
                case 141:
                case 142:
                case 143:
                case 144:
                case 145:
                case 146:
                case 147:
                case 148:
                case 149:
                case 150:
                case 151:
                case 152:
                case 153:
                case 154:
                case 155:
                case 156:
                case 157:
                case 158:
                case 159:
                case 160:
                case 161:
                    break;
                }
            return null;
        };
    
        /**
         * Creates a CNETMsg_Disconnect message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CNETMsg_Disconnect
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CNETMsg_Disconnect} CNETMsg_Disconnect
         */
        CNETMsg_Disconnect.fromObject = function fromObject(object) {
            if (object instanceof $root.CNETMsg_Disconnect)
                return object;
            var message = new $root.CNETMsg_Disconnect();
            switch (object.reason) {
            default:
                if (typeof object.reason === "number") {
                    message.reason = object.reason;
                    break;
                }
                break;
            case "NETWORK_DISCONNECT_INVALID":
            case 0:
                message.reason = 0;
                break;
            case "NETWORK_DISCONNECT_SHUTDOWN":
            case 1:
                message.reason = 1;
                break;
            case "NETWORK_DISCONNECT_DISCONNECT_BY_USER":
            case 2:
                message.reason = 2;
                break;
            case "NETWORK_DISCONNECT_DISCONNECT_BY_SERVER":
            case 3:
                message.reason = 3;
                break;
            case "NETWORK_DISCONNECT_LOST":
            case 4:
                message.reason = 4;
                break;
            case "NETWORK_DISCONNECT_OVERFLOW":
            case 5:
                message.reason = 5;
                break;
            case "NETWORK_DISCONNECT_STEAM_BANNED":
            case 6:
                message.reason = 6;
                break;
            case "NETWORK_DISCONNECT_STEAM_INUSE":
            case 7:
                message.reason = 7;
                break;
            case "NETWORK_DISCONNECT_STEAM_TICKET":
            case 8:
                message.reason = 8;
                break;
            case "NETWORK_DISCONNECT_STEAM_LOGON":
            case 9:
                message.reason = 9;
                break;
            case "NETWORK_DISCONNECT_STEAM_AUTHCANCELLED":
            case 10:
                message.reason = 10;
                break;
            case "NETWORK_DISCONNECT_STEAM_AUTHALREADYUSED":
            case 11:
                message.reason = 11;
                break;
            case "NETWORK_DISCONNECT_STEAM_AUTHINVALID":
            case 12:
                message.reason = 12;
                break;
            case "NETWORK_DISCONNECT_STEAM_VACBANSTATE":
            case 13:
                message.reason = 13;
                break;
            case "NETWORK_DISCONNECT_STEAM_LOGGED_IN_ELSEWHERE":
            case 14:
                message.reason = 14;
                break;
            case "NETWORK_DISCONNECT_STEAM_VAC_CHECK_TIMEDOUT":
            case 15:
                message.reason = 15;
                break;
            case "NETWORK_DISCONNECT_STEAM_DROPPED":
            case 16:
                message.reason = 16;
                break;
            case "NETWORK_DISCONNECT_STEAM_OWNERSHIP":
            case 17:
                message.reason = 17;
                break;
            case "NETWORK_DISCONNECT_SERVERINFO_OVERFLOW":
            case 18:
                message.reason = 18;
                break;
            case "NETWORK_DISCONNECT_TICKMSG_OVERFLOW":
            case 19:
                message.reason = 19;
                break;
            case "NETWORK_DISCONNECT_STRINGTABLEMSG_OVERFLOW":
            case 20:
                message.reason = 20;
                break;
            case "NETWORK_DISCONNECT_DELTAENTMSG_OVERFLOW":
            case 21:
                message.reason = 21;
                break;
            case "NETWORK_DISCONNECT_TEMPENTMSG_OVERFLOW":
            case 22:
                message.reason = 22;
                break;
            case "NETWORK_DISCONNECT_SOUNDSMSG_OVERFLOW":
            case 23:
                message.reason = 23;
                break;
            case "NETWORK_DISCONNECT_SNAPSHOTOVERFLOW":
            case 24:
                message.reason = 24;
                break;
            case "NETWORK_DISCONNECT_SNAPSHOTERROR":
            case 25:
                message.reason = 25;
                break;
            case "NETWORK_DISCONNECT_RELIABLEOVERFLOW":
            case 26:
                message.reason = 26;
                break;
            case "NETWORK_DISCONNECT_BADDELTATICK":
            case 27:
                message.reason = 27;
                break;
            case "NETWORK_DISCONNECT_NOMORESPLITS":
            case 28:
                message.reason = 28;
                break;
            case "NETWORK_DISCONNECT_TIMEDOUT":
            case 29:
                message.reason = 29;
                break;
            case "NETWORK_DISCONNECT_DISCONNECTED":
            case 30:
                message.reason = 30;
                break;
            case "NETWORK_DISCONNECT_LEAVINGSPLIT":
            case 31:
                message.reason = 31;
                break;
            case "NETWORK_DISCONNECT_DIFFERENTCLASSTABLES":
            case 32:
                message.reason = 32;
                break;
            case "NETWORK_DISCONNECT_BADRELAYPASSWORD":
            case 33:
                message.reason = 33;
                break;
            case "NETWORK_DISCONNECT_BADSPECTATORPASSWORD":
            case 34:
                message.reason = 34;
                break;
            case "NETWORK_DISCONNECT_HLTVRESTRICTED":
            case 35:
                message.reason = 35;
                break;
            case "NETWORK_DISCONNECT_NOSPECTATORS":
            case 36:
                message.reason = 36;
                break;
            case "NETWORK_DISCONNECT_HLTVUNAVAILABLE":
            case 37:
                message.reason = 37;
                break;
            case "NETWORK_DISCONNECT_HLTVSTOP":
            case 38:
                message.reason = 38;
                break;
            case "NETWORK_DISCONNECT_KICKED":
            case 39:
                message.reason = 39;
                break;
            case "NETWORK_DISCONNECT_BANADDED":
            case 40:
                message.reason = 40;
                break;
            case "NETWORK_DISCONNECT_KICKBANADDED":
            case 41:
                message.reason = 41;
                break;
            case "NETWORK_DISCONNECT_HLTVDIRECT":
            case 42:
                message.reason = 42;
                break;
            case "NETWORK_DISCONNECT_PURESERVER_CLIENTEXTRA":
            case 43:
                message.reason = 43;
                break;
            case "NETWORK_DISCONNECT_PURESERVER_MISMATCH":
            case 44:
                message.reason = 44;
                break;
            case "NETWORK_DISCONNECT_USERCMD":
            case 45:
                message.reason = 45;
                break;
            case "NETWORK_DISCONNECT_REJECTED_BY_GAME":
            case 46:
                message.reason = 46;
                break;
            case "NETWORK_DISCONNECT_MESSAGE_PARSE_ERROR":
            case 47:
                message.reason = 47;
                break;
            case "NETWORK_DISCONNECT_INVALID_MESSAGE_ERROR":
            case 48:
                message.reason = 48;
                break;
            case "NETWORK_DISCONNECT_BAD_SERVER_PASSWORD":
            case 49:
                message.reason = 49;
                break;
            case "NETWORK_DISCONNECT_DIRECT_CONNECT_RESERVATION":
            case 50:
                message.reason = 50;
                break;
            case "NETWORK_DISCONNECT_CONNECTION_FAILURE":
            case 51:
                message.reason = 51;
                break;
            case "NETWORK_DISCONNECT_NO_PEER_GROUP_HANDLERS":
            case 52:
                message.reason = 52;
                break;
            case "NETWORK_DISCONNECT_RECONNECTION":
            case 53:
                message.reason = 53;
                break;
            case "NETWORK_DISCONNECT_LOOPSHUTDOWN":
            case 54:
                message.reason = 54;
                break;
            case "NETWORK_DISCONNECT_LOOPDEACTIVATE":
            case 55:
                message.reason = 55;
                break;
            case "NETWORK_DISCONNECT_HOST_ENDGAME":
            case 56:
                message.reason = 56;
                break;
            case "NETWORK_DISCONNECT_LOOP_LEVELLOAD_ACTIVATE":
            case 57:
                message.reason = 57;
                break;
            case "NETWORK_DISCONNECT_CREATE_SERVER_FAILED":
            case 58:
                message.reason = 58;
                break;
            case "NETWORK_DISCONNECT_EXITING":
            case 59:
                message.reason = 59;
                break;
            case "NETWORK_DISCONNECT_REQUEST_HOSTSTATE_IDLE":
            case 60:
                message.reason = 60;
                break;
            case "NETWORK_DISCONNECT_REQUEST_HOSTSTATE_HLTVRELAY":
            case 61:
                message.reason = 61;
                break;
            case "NETWORK_DISCONNECT_CLIENT_CONSISTENCY_FAIL":
            case 62:
                message.reason = 62;
                break;
            case "NETWORK_DISCONNECT_CLIENT_UNABLE_TO_CRC_MAP":
            case 63:
                message.reason = 63;
                break;
            case "NETWORK_DISCONNECT_CLIENT_NO_MAP":
            case 64:
                message.reason = 64;
                break;
            case "NETWORK_DISCONNECT_CLIENT_DIFFERENT_MAP":
            case 65:
                message.reason = 65;
                break;
            case "NETWORK_DISCONNECT_SERVER_REQUIRES_STEAM":
            case 66:
                message.reason = 66;
                break;
            case "NETWORK_DISCONNECT_STEAM_DENY_MISC":
            case 67:
                message.reason = 67;
                break;
            case "NETWORK_DISCONNECT_STEAM_DENY_BAD_ANTI_CHEAT":
            case 68:
                message.reason = 68;
                break;
            case "NETWORK_DISCONNECT_SERVER_SHUTDOWN":
            case 69:
                message.reason = 69;
                break;
            case "NETWORK_DISCONNECT_REPLAY_INCOMPATIBLE":
            case 71:
                message.reason = 71;
                break;
            case "NETWORK_DISCONNECT_CONNECT_REQUEST_TIMEDOUT":
            case 72:
                message.reason = 72;
                break;
            case "NETWORK_DISCONNECT_SERVER_INCOMPATIBLE":
            case 73:
                message.reason = 73;
                break;
            case "NETWORK_DISCONNECT_LOCALPROBLEM_MANYRELAYS":
            case 74:
                message.reason = 74;
                break;
            case "NETWORK_DISCONNECT_LOCALPROBLEM_HOSTEDSERVERPRIMARYRELAY":
            case 75:
                message.reason = 75;
                break;
            case "NETWORK_DISCONNECT_LOCALPROBLEM_NETWORKCONFIG":
            case 76:
                message.reason = 76;
                break;
            case "NETWORK_DISCONNECT_LOCALPROBLEM_OTHER":
            case 77:
                message.reason = 77;
                break;
            case "NETWORK_DISCONNECT_REMOTE_TIMEOUT":
            case 79:
                message.reason = 79;
                break;
            case "NETWORK_DISCONNECT_REMOTE_TIMEOUT_CONNECTING":
            case 80:
                message.reason = 80;
                break;
            case "NETWORK_DISCONNECT_REMOTE_OTHER":
            case 81:
                message.reason = 81;
                break;
            case "NETWORK_DISCONNECT_REMOTE_BADCRYPT":
            case 82:
                message.reason = 82;
                break;
            case "NETWORK_DISCONNECT_REMOTE_CERTNOTTRUSTED":
            case 83:
                message.reason = 83;
                break;
            case "NETWORK_DISCONNECT_UNUSUAL":
            case 84:
                message.reason = 84;
                break;
            case "NETWORK_DISCONNECT_INTERNAL_ERROR":
            case 85:
                message.reason = 85;
                break;
            case "NETWORK_DISCONNECT_REJECT_BADCHALLENGE":
            case 128:
                message.reason = 128;
                break;
            case "NETWORK_DISCONNECT_REJECT_NOLOBBY":
            case 129:
                message.reason = 129;
                break;
            case "NETWORK_DISCONNECT_REJECT_BACKGROUND_MAP":
            case 130:
                message.reason = 130;
                break;
            case "NETWORK_DISCONNECT_REJECT_SINGLE_PLAYER":
            case 131:
                message.reason = 131;
                break;
            case "NETWORK_DISCONNECT_REJECT_HIDDEN_GAME":
            case 132:
                message.reason = 132;
                break;
            case "NETWORK_DISCONNECT_REJECT_LANRESTRICT":
            case 133:
                message.reason = 133;
                break;
            case "NETWORK_DISCONNECT_REJECT_BADPASSWORD":
            case 134:
                message.reason = 134;
                break;
            case "NETWORK_DISCONNECT_REJECT_SERVERFULL":
            case 135:
                message.reason = 135;
                break;
            case "NETWORK_DISCONNECT_REJECT_INVALIDRESERVATION":
            case 136:
                message.reason = 136;
                break;
            case "NETWORK_DISCONNECT_REJECT_FAILEDCHANNEL":
            case 137:
                message.reason = 137;
                break;
            case "NETWORK_DISCONNECT_REJECT_CONNECT_FROM_LOBBY":
            case 138:
                message.reason = 138;
                break;
            case "NETWORK_DISCONNECT_REJECT_RESERVED_FOR_LOBBY":
            case 139:
                message.reason = 139;
                break;
            case "NETWORK_DISCONNECT_REJECT_INVALIDKEYLENGTH":
            case 140:
                message.reason = 140;
                break;
            case "NETWORK_DISCONNECT_REJECT_OLDPROTOCOL":
            case 141:
                message.reason = 141;
                break;
            case "NETWORK_DISCONNECT_REJECT_NEWPROTOCOL":
            case 142:
                message.reason = 142;
                break;
            case "NETWORK_DISCONNECT_REJECT_INVALIDCONNECTION":
            case 143:
                message.reason = 143;
                break;
            case "NETWORK_DISCONNECT_REJECT_INVALIDCERTLEN":
            case 144:
                message.reason = 144;
                break;
            case "NETWORK_DISCONNECT_REJECT_INVALIDSTEAMCERTLEN":
            case 145:
                message.reason = 145;
                break;
            case "NETWORK_DISCONNECT_REJECT_STEAM":
            case 146:
                message.reason = 146;
                break;
            case "NETWORK_DISCONNECT_REJECT_SERVERAUTHDISABLED":
            case 147:
                message.reason = 147;
                break;
            case "NETWORK_DISCONNECT_REJECT_SERVERCDKEYAUTHINVALID":
            case 148:
                message.reason = 148;
                break;
            case "NETWORK_DISCONNECT_REJECT_BANNED":
            case 149:
                message.reason = 149;
                break;
            case "NETWORK_DISCONNECT_KICKED_TEAMKILLING":
            case 150:
                message.reason = 150;
                break;
            case "NETWORK_DISCONNECT_KICKED_TK_START":
            case 151:
                message.reason = 151;
                break;
            case "NETWORK_DISCONNECT_KICKED_UNTRUSTEDACCOUNT":
            case 152:
                message.reason = 152;
                break;
            case "NETWORK_DISCONNECT_KICKED_CONVICTEDACCOUNT":
            case 153:
                message.reason = 153;
                break;
            case "NETWORK_DISCONNECT_KICKED_COMPETITIVECOOLDOWN":
            case 154:
                message.reason = 154;
                break;
            case "NETWORK_DISCONNECT_KICKED_TEAMHURTING":
            case 155:
                message.reason = 155;
                break;
            case "NETWORK_DISCONNECT_KICKED_HOSTAGEKILLING":
            case 156:
                message.reason = 156;
                break;
            case "NETWORK_DISCONNECT_KICKED_VOTEDOFF":
            case 157:
                message.reason = 157;
                break;
            case "NETWORK_DISCONNECT_KICKED_IDLE":
            case 158:
                message.reason = 158;
                break;
            case "NETWORK_DISCONNECT_KICKED_SUICIDE":
            case 159:
                message.reason = 159;
                break;
            case "NETWORK_DISCONNECT_KICKED_NOSTEAMLOGIN":
            case 160:
                message.reason = 160;
                break;
            case "NETWORK_DISCONNECT_KICKED_NOSTEAMTICKET":
            case 161:
                message.reason = 161;
                break;
            }
            return message;
        };
    
        /**
         * Creates a plain object from a CNETMsg_Disconnect message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CNETMsg_Disconnect
         * @static
         * @param {CNETMsg_Disconnect} message CNETMsg_Disconnect
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CNETMsg_Disconnect.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.reason = options.enums === String ? "NETWORK_DISCONNECT_INVALID" : 0;
            if (message.reason != null && message.hasOwnProperty("reason"))
                object.reason = options.enums === String ? $root.ENetworkDisconnectionReason[message.reason] === undefined ? message.reason : $root.ENetworkDisconnectionReason[message.reason] : message.reason;
            return object;
        };
    
        /**
         * Converts this CNETMsg_Disconnect to JSON.
         * @function toJSON
         * @memberof CNETMsg_Disconnect
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CNETMsg_Disconnect.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * Gets the default type url for CNETMsg_Disconnect
         * @function getTypeUrl
         * @memberof CNETMsg_Disconnect
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        CNETMsg_Disconnect.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/CNETMsg_Disconnect";
        };
    
        return CNETMsg_Disconnect;
    })();
    
    $root.CNETMsg_Tick = (function() {
    
        /**
         * Properties of a CNETMsg_Tick.
         * @exports ICNETMsg_Tick
         * @interface ICNETMsg_Tick
         * @property {number|null} [tick] CNETMsg_Tick tick
         * @property {number|null} [hostFrametime] CNETMsg_Tick hostFrametime
         * @property {number|null} [hostFrametimeStdDeviation] CNETMsg_Tick hostFrametimeStdDeviation
         * @property {number|null} [hostComputationtime] CNETMsg_Tick hostComputationtime
         * @property {number|null} [hostComputationtimeStdDeviation] CNETMsg_Tick hostComputationtimeStdDeviation
         * @property {number|null} [hostFramestarttimeStdDeviation] CNETMsg_Tick hostFramestarttimeStdDeviation
         * @property {number|null} [hostLoss] CNETMsg_Tick hostLoss
         * @property {number|null} [hostUnfilteredFrametime] CNETMsg_Tick hostUnfilteredFrametime
         * @property {number|null} [hltvReplayFlags] CNETMsg_Tick hltvReplayFlags
         */
    
        /**
         * Constructs a new CNETMsg_Tick.
         * @exports CNETMsg_Tick
         * @classdesc Represents a CNETMsg_Tick.
         * @implements ICNETMsg_Tick
         * @constructor
         * @param {ICNETMsg_Tick=} [properties] Properties to set
         */
        function CNETMsg_Tick(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CNETMsg_Tick tick.
         * @member {number} tick
         * @memberof CNETMsg_Tick
         * @instance
         */
        CNETMsg_Tick.prototype.tick = 0;
    
        /**
         * CNETMsg_Tick hostFrametime.
         * @member {number} hostFrametime
         * @memberof CNETMsg_Tick
         * @instance
         */
        CNETMsg_Tick.prototype.hostFrametime = 0;
    
        /**
         * CNETMsg_Tick hostFrametimeStdDeviation.
         * @member {number} hostFrametimeStdDeviation
         * @memberof CNETMsg_Tick
         * @instance
         */
        CNETMsg_Tick.prototype.hostFrametimeStdDeviation = 0;
    
        /**
         * CNETMsg_Tick hostComputationtime.
         * @member {number} hostComputationtime
         * @memberof CNETMsg_Tick
         * @instance
         */
        CNETMsg_Tick.prototype.hostComputationtime = 0;
    
        /**
         * CNETMsg_Tick hostComputationtimeStdDeviation.
         * @member {number} hostComputationtimeStdDeviation
         * @memberof CNETMsg_Tick
         * @instance
         */
        CNETMsg_Tick.prototype.hostComputationtimeStdDeviation = 0;
    
        /**
         * CNETMsg_Tick hostFramestarttimeStdDeviation.
         * @member {number} hostFramestarttimeStdDeviation
         * @memberof CNETMsg_Tick
         * @instance
         */
        CNETMsg_Tick.prototype.hostFramestarttimeStdDeviation = 0;
    
        /**
         * CNETMsg_Tick hostLoss.
         * @member {number} hostLoss
         * @memberof CNETMsg_Tick
         * @instance
         */
        CNETMsg_Tick.prototype.hostLoss = 0;
    
        /**
         * CNETMsg_Tick hostUnfilteredFrametime.
         * @member {number} hostUnfilteredFrametime
         * @memberof CNETMsg_Tick
         * @instance
         */
        CNETMsg_Tick.prototype.hostUnfilteredFrametime = 0;
    
        /**
         * CNETMsg_Tick hltvReplayFlags.
         * @member {number} hltvReplayFlags
         * @memberof CNETMsg_Tick
         * @instance
         */
        CNETMsg_Tick.prototype.hltvReplayFlags = 0;
    
        /**
         * Creates a new CNETMsg_Tick instance using the specified properties.
         * @function create
         * @memberof CNETMsg_Tick
         * @static
         * @param {ICNETMsg_Tick=} [properties] Properties to set
         * @returns {CNETMsg_Tick} CNETMsg_Tick instance
         */
        CNETMsg_Tick.create = function create(properties) {
            return new CNETMsg_Tick(properties);
        };
    
        /**
         * Encodes the specified CNETMsg_Tick message. Does not implicitly {@link CNETMsg_Tick.verify|verify} messages.
         * @function encode
         * @memberof CNETMsg_Tick
         * @static
         * @param {ICNETMsg_Tick} message CNETMsg_Tick message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CNETMsg_Tick.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.tick != null && Object.hasOwnProperty.call(message, "tick"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.tick);
            if (message.hostFrametime != null && Object.hasOwnProperty.call(message, "hostFrametime"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.hostFrametime);
            if (message.hostFrametimeStdDeviation != null && Object.hasOwnProperty.call(message, "hostFrametimeStdDeviation"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.hostFrametimeStdDeviation);
            if (message.hostComputationtime != null && Object.hasOwnProperty.call(message, "hostComputationtime"))
                writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.hostComputationtime);
            if (message.hostComputationtimeStdDeviation != null && Object.hasOwnProperty.call(message, "hostComputationtimeStdDeviation"))
                writer.uint32(/* id 5, wireType 0 =*/40).uint32(message.hostComputationtimeStdDeviation);
            if (message.hostFramestarttimeStdDeviation != null && Object.hasOwnProperty.call(message, "hostFramestarttimeStdDeviation"))
                writer.uint32(/* id 6, wireType 0 =*/48).uint32(message.hostFramestarttimeStdDeviation);
            if (message.hostLoss != null && Object.hasOwnProperty.call(message, "hostLoss"))
                writer.uint32(/* id 7, wireType 0 =*/56).uint32(message.hostLoss);
            if (message.hostUnfilteredFrametime != null && Object.hasOwnProperty.call(message, "hostUnfilteredFrametime"))
                writer.uint32(/* id 8, wireType 0 =*/64).uint32(message.hostUnfilteredFrametime);
            if (message.hltvReplayFlags != null && Object.hasOwnProperty.call(message, "hltvReplayFlags"))
                writer.uint32(/* id 9, wireType 0 =*/72).uint32(message.hltvReplayFlags);
            return writer;
        };
    
        /**
         * Encodes the specified CNETMsg_Tick message, length delimited. Does not implicitly {@link CNETMsg_Tick.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CNETMsg_Tick
         * @static
         * @param {ICNETMsg_Tick} message CNETMsg_Tick message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CNETMsg_Tick.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CNETMsg_Tick message from the specified reader or buffer.
         * @function decode
         * @memberof CNETMsg_Tick
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CNETMsg_Tick} CNETMsg_Tick
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CNETMsg_Tick.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CNETMsg_Tick();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.tick = reader.uint32();
                        break;
                    }
                case 2: {
                        message.hostFrametime = reader.uint32();
                        break;
                    }
                case 3: {
                        message.hostFrametimeStdDeviation = reader.uint32();
                        break;
                    }
                case 4: {
                        message.hostComputationtime = reader.uint32();
                        break;
                    }
                case 5: {
                        message.hostComputationtimeStdDeviation = reader.uint32();
                        break;
                    }
                case 6: {
                        message.hostFramestarttimeStdDeviation = reader.uint32();
                        break;
                    }
                case 7: {
                        message.hostLoss = reader.uint32();
                        break;
                    }
                case 8: {
                        message.hostUnfilteredFrametime = reader.uint32();
                        break;
                    }
                case 9: {
                        message.hltvReplayFlags = reader.uint32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CNETMsg_Tick message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CNETMsg_Tick
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CNETMsg_Tick} CNETMsg_Tick
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CNETMsg_Tick.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CNETMsg_Tick message.
         * @function verify
         * @memberof CNETMsg_Tick
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CNETMsg_Tick.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.tick != null && message.hasOwnProperty("tick"))
                if (!$util.isInteger(message.tick))
                    return "tick: integer expected";
            if (message.hostFrametime != null && message.hasOwnProperty("hostFrametime"))
                if (!$util.isInteger(message.hostFrametime))
                    return "hostFrametime: integer expected";
            if (message.hostFrametimeStdDeviation != null && message.hasOwnProperty("hostFrametimeStdDeviation"))
                if (!$util.isInteger(message.hostFrametimeStdDeviation))
                    return "hostFrametimeStdDeviation: integer expected";
            if (message.hostComputationtime != null && message.hasOwnProperty("hostComputationtime"))
                if (!$util.isInteger(message.hostComputationtime))
                    return "hostComputationtime: integer expected";
            if (message.hostComputationtimeStdDeviation != null && message.hasOwnProperty("hostComputationtimeStdDeviation"))
                if (!$util.isInteger(message.hostComputationtimeStdDeviation))
                    return "hostComputationtimeStdDeviation: integer expected";
            if (message.hostFramestarttimeStdDeviation != null && message.hasOwnProperty("hostFramestarttimeStdDeviation"))
                if (!$util.isInteger(message.hostFramestarttimeStdDeviation))
                    return "hostFramestarttimeStdDeviation: integer expected";
            if (message.hostLoss != null && message.hasOwnProperty("hostLoss"))
                if (!$util.isInteger(message.hostLoss))
                    return "hostLoss: integer expected";
            if (message.hostUnfilteredFrametime != null && message.hasOwnProperty("hostUnfilteredFrametime"))
                if (!$util.isInteger(message.hostUnfilteredFrametime))
                    return "hostUnfilteredFrametime: integer expected";
            if (message.hltvReplayFlags != null && message.hasOwnProperty("hltvReplayFlags"))
                if (!$util.isInteger(message.hltvReplayFlags))
                    return "hltvReplayFlags: integer expected";
            return null;
        };
    
        /**
         * Creates a CNETMsg_Tick message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CNETMsg_Tick
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CNETMsg_Tick} CNETMsg_Tick
         */
        CNETMsg_Tick.fromObject = function fromObject(object) {
            if (object instanceof $root.CNETMsg_Tick)
                return object;
            var message = new $root.CNETMsg_Tick();
            if (object.tick != null)
                message.tick = object.tick >>> 0;
            if (object.hostFrametime != null)
                message.hostFrametime = object.hostFrametime >>> 0;
            if (object.hostFrametimeStdDeviation != null)
                message.hostFrametimeStdDeviation = object.hostFrametimeStdDeviation >>> 0;
            if (object.hostComputationtime != null)
                message.hostComputationtime = object.hostComputationtime >>> 0;
            if (object.hostComputationtimeStdDeviation != null)
                message.hostComputationtimeStdDeviation = object.hostComputationtimeStdDeviation >>> 0;
            if (object.hostFramestarttimeStdDeviation != null)
                message.hostFramestarttimeStdDeviation = object.hostFramestarttimeStdDeviation >>> 0;
            if (object.hostLoss != null)
                message.hostLoss = object.hostLoss >>> 0;
            if (object.hostUnfilteredFrametime != null)
                message.hostUnfilteredFrametime = object.hostUnfilteredFrametime >>> 0;
            if (object.hltvReplayFlags != null)
                message.hltvReplayFlags = object.hltvReplayFlags >>> 0;
            return message;
        };
    
        /**
         * Creates a plain object from a CNETMsg_Tick message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CNETMsg_Tick
         * @static
         * @param {CNETMsg_Tick} message CNETMsg_Tick
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CNETMsg_Tick.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.tick = 0;
                object.hostFrametime = 0;
                object.hostFrametimeStdDeviation = 0;
                object.hostComputationtime = 0;
                object.hostComputationtimeStdDeviation = 0;
                object.hostFramestarttimeStdDeviation = 0;
                object.hostLoss = 0;
                object.hostUnfilteredFrametime = 0;
                object.hltvReplayFlags = 0;
            }
            if (message.tick != null && message.hasOwnProperty("tick"))
                object.tick = message.tick;
            if (message.hostFrametime != null && message.hasOwnProperty("hostFrametime"))
                object.hostFrametime = message.hostFrametime;
            if (message.hostFrametimeStdDeviation != null && message.hasOwnProperty("hostFrametimeStdDeviation"))
                object.hostFrametimeStdDeviation = message.hostFrametimeStdDeviation;
            if (message.hostComputationtime != null && message.hasOwnProperty("hostComputationtime"))
                object.hostComputationtime = message.hostComputationtime;
            if (message.hostComputationtimeStdDeviation != null && message.hasOwnProperty("hostComputationtimeStdDeviation"))
                object.hostComputationtimeStdDeviation = message.hostComputationtimeStdDeviation;
            if (message.hostFramestarttimeStdDeviation != null && message.hasOwnProperty("hostFramestarttimeStdDeviation"))
                object.hostFramestarttimeStdDeviation = message.hostFramestarttimeStdDeviation;
            if (message.hostLoss != null && message.hasOwnProperty("hostLoss"))
                object.hostLoss = message.hostLoss;
            if (message.hostUnfilteredFrametime != null && message.hasOwnProperty("hostUnfilteredFrametime"))
                object.hostUnfilteredFrametime = message.hostUnfilteredFrametime;
            if (message.hltvReplayFlags != null && message.hasOwnProperty("hltvReplayFlags"))
                object.hltvReplayFlags = message.hltvReplayFlags;
            return object;
        };
    
        /**
         * Converts this CNETMsg_Tick to JSON.
         * @function toJSON
         * @memberof CNETMsg_Tick
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CNETMsg_Tick.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * Gets the default type url for CNETMsg_Tick
         * @function getTypeUrl
         * @memberof CNETMsg_Tick
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        CNETMsg_Tick.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/CNETMsg_Tick";
        };
    
        return CNETMsg_Tick;
    })();
    
    $root.CNETMsg_StringCmd = (function() {
    
        /**
         * Properties of a CNETMsg_StringCmd.
         * @exports ICNETMsg_StringCmd
         * @interface ICNETMsg_StringCmd
         * @property {string|null} [command] CNETMsg_StringCmd command
         * @property {number|null} [predictionSync] CNETMsg_StringCmd predictionSync
         */
    
        /**
         * Constructs a new CNETMsg_StringCmd.
         * @exports CNETMsg_StringCmd
         * @classdesc Represents a CNETMsg_StringCmd.
         * @implements ICNETMsg_StringCmd
         * @constructor
         * @param {ICNETMsg_StringCmd=} [properties] Properties to set
         */
        function CNETMsg_StringCmd(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CNETMsg_StringCmd command.
         * @member {string} command
         * @memberof CNETMsg_StringCmd
         * @instance
         */
        CNETMsg_StringCmd.prototype.command = "";
    
        /**
         * CNETMsg_StringCmd predictionSync.
         * @member {number} predictionSync
         * @memberof CNETMsg_StringCmd
         * @instance
         */
        CNETMsg_StringCmd.prototype.predictionSync = 0;
    
        /**
         * Creates a new CNETMsg_StringCmd instance using the specified properties.
         * @function create
         * @memberof CNETMsg_StringCmd
         * @static
         * @param {ICNETMsg_StringCmd=} [properties] Properties to set
         * @returns {CNETMsg_StringCmd} CNETMsg_StringCmd instance
         */
        CNETMsg_StringCmd.create = function create(properties) {
            return new CNETMsg_StringCmd(properties);
        };
    
        /**
         * Encodes the specified CNETMsg_StringCmd message. Does not implicitly {@link CNETMsg_StringCmd.verify|verify} messages.
         * @function encode
         * @memberof CNETMsg_StringCmd
         * @static
         * @param {ICNETMsg_StringCmd} message CNETMsg_StringCmd message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CNETMsg_StringCmd.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.command != null && Object.hasOwnProperty.call(message, "command"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.command);
            if (message.predictionSync != null && Object.hasOwnProperty.call(message, "predictionSync"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.predictionSync);
            return writer;
        };
    
        /**
         * Encodes the specified CNETMsg_StringCmd message, length delimited. Does not implicitly {@link CNETMsg_StringCmd.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CNETMsg_StringCmd
         * @static
         * @param {ICNETMsg_StringCmd} message CNETMsg_StringCmd message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CNETMsg_StringCmd.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CNETMsg_StringCmd message from the specified reader or buffer.
         * @function decode
         * @memberof CNETMsg_StringCmd
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CNETMsg_StringCmd} CNETMsg_StringCmd
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CNETMsg_StringCmd.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CNETMsg_StringCmd();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.command = reader.string();
                        break;
                    }
                case 2: {
                        message.predictionSync = reader.uint32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CNETMsg_StringCmd message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CNETMsg_StringCmd
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CNETMsg_StringCmd} CNETMsg_StringCmd
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CNETMsg_StringCmd.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CNETMsg_StringCmd message.
         * @function verify
         * @memberof CNETMsg_StringCmd
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CNETMsg_StringCmd.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.command != null && message.hasOwnProperty("command"))
                if (!$util.isString(message.command))
                    return "command: string expected";
            if (message.predictionSync != null && message.hasOwnProperty("predictionSync"))
                if (!$util.isInteger(message.predictionSync))
                    return "predictionSync: integer expected";
            return null;
        };
    
        /**
         * Creates a CNETMsg_StringCmd message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CNETMsg_StringCmd
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CNETMsg_StringCmd} CNETMsg_StringCmd
         */
        CNETMsg_StringCmd.fromObject = function fromObject(object) {
            if (object instanceof $root.CNETMsg_StringCmd)
                return object;
            var message = new $root.CNETMsg_StringCmd();
            if (object.command != null)
                message.command = String(object.command);
            if (object.predictionSync != null)
                message.predictionSync = object.predictionSync >>> 0;
            return message;
        };
    
        /**
         * Creates a plain object from a CNETMsg_StringCmd message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CNETMsg_StringCmd
         * @static
         * @param {CNETMsg_StringCmd} message CNETMsg_StringCmd
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CNETMsg_StringCmd.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.command = "";
                object.predictionSync = 0;
            }
            if (message.command != null && message.hasOwnProperty("command"))
                object.command = message.command;
            if (message.predictionSync != null && message.hasOwnProperty("predictionSync"))
                object.predictionSync = message.predictionSync;
            return object;
        };
    
        /**
         * Converts this CNETMsg_StringCmd to JSON.
         * @function toJSON
         * @memberof CNETMsg_StringCmd
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CNETMsg_StringCmd.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * Gets the default type url for CNETMsg_StringCmd
         * @function getTypeUrl
         * @memberof CNETMsg_StringCmd
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        CNETMsg_StringCmd.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/CNETMsg_StringCmd";
        };
    
        return CNETMsg_StringCmd;
    })();
    
    $root.CNETMsg_SetConVar = (function() {
    
        /**
         * Properties of a CNETMsg_SetConVar.
         * @exports ICNETMsg_SetConVar
         * @interface ICNETMsg_SetConVar
         * @property {ICMsg_CVars|null} [convars] CNETMsg_SetConVar convars
         */
    
        /**
         * Constructs a new CNETMsg_SetConVar.
         * @exports CNETMsg_SetConVar
         * @classdesc Represents a CNETMsg_SetConVar.
         * @implements ICNETMsg_SetConVar
         * @constructor
         * @param {ICNETMsg_SetConVar=} [properties] Properties to set
         */
        function CNETMsg_SetConVar(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CNETMsg_SetConVar convars.
         * @member {ICMsg_CVars|null|undefined} convars
         * @memberof CNETMsg_SetConVar
         * @instance
         */
        CNETMsg_SetConVar.prototype.convars = null;
    
        /**
         * Creates a new CNETMsg_SetConVar instance using the specified properties.
         * @function create
         * @memberof CNETMsg_SetConVar
         * @static
         * @param {ICNETMsg_SetConVar=} [properties] Properties to set
         * @returns {CNETMsg_SetConVar} CNETMsg_SetConVar instance
         */
        CNETMsg_SetConVar.create = function create(properties) {
            return new CNETMsg_SetConVar(properties);
        };
    
        /**
         * Encodes the specified CNETMsg_SetConVar message. Does not implicitly {@link CNETMsg_SetConVar.verify|verify} messages.
         * @function encode
         * @memberof CNETMsg_SetConVar
         * @static
         * @param {ICNETMsg_SetConVar} message CNETMsg_SetConVar message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CNETMsg_SetConVar.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.convars != null && Object.hasOwnProperty.call(message, "convars"))
                $root.CMsg_CVars.encode(message.convars, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };
    
        /**
         * Encodes the specified CNETMsg_SetConVar message, length delimited. Does not implicitly {@link CNETMsg_SetConVar.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CNETMsg_SetConVar
         * @static
         * @param {ICNETMsg_SetConVar} message CNETMsg_SetConVar message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CNETMsg_SetConVar.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CNETMsg_SetConVar message from the specified reader or buffer.
         * @function decode
         * @memberof CNETMsg_SetConVar
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CNETMsg_SetConVar} CNETMsg_SetConVar
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CNETMsg_SetConVar.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CNETMsg_SetConVar();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.convars = $root.CMsg_CVars.decode(reader, reader.uint32());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CNETMsg_SetConVar message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CNETMsg_SetConVar
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CNETMsg_SetConVar} CNETMsg_SetConVar
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CNETMsg_SetConVar.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CNETMsg_SetConVar message.
         * @function verify
         * @memberof CNETMsg_SetConVar
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CNETMsg_SetConVar.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.convars != null && message.hasOwnProperty("convars")) {
                var error = $root.CMsg_CVars.verify(message.convars);
                if (error)
                    return "convars." + error;
            }
            return null;
        };
    
        /**
         * Creates a CNETMsg_SetConVar message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CNETMsg_SetConVar
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CNETMsg_SetConVar} CNETMsg_SetConVar
         */
        CNETMsg_SetConVar.fromObject = function fromObject(object) {
            if (object instanceof $root.CNETMsg_SetConVar)
                return object;
            var message = new $root.CNETMsg_SetConVar();
            if (object.convars != null) {
                if (typeof object.convars !== "object")
                    throw TypeError(".CNETMsg_SetConVar.convars: object expected");
                message.convars = $root.CMsg_CVars.fromObject(object.convars);
            }
            return message;
        };
    
        /**
         * Creates a plain object from a CNETMsg_SetConVar message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CNETMsg_SetConVar
         * @static
         * @param {CNETMsg_SetConVar} message CNETMsg_SetConVar
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CNETMsg_SetConVar.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.convars = null;
            if (message.convars != null && message.hasOwnProperty("convars"))
                object.convars = $root.CMsg_CVars.toObject(message.convars, options);
            return object;
        };
    
        /**
         * Converts this CNETMsg_SetConVar to JSON.
         * @function toJSON
         * @memberof CNETMsg_SetConVar
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CNETMsg_SetConVar.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * Gets the default type url for CNETMsg_SetConVar
         * @function getTypeUrl
         * @memberof CNETMsg_SetConVar
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        CNETMsg_SetConVar.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/CNETMsg_SetConVar";
        };
    
        return CNETMsg_SetConVar;
    })();
    
    $root.CNETMsg_SignonState = (function() {
    
        /**
         * Properties of a CNETMsg_SignonState.
         * @exports ICNETMsg_SignonState
         * @interface ICNETMsg_SignonState
         * @property {SignonState_t|null} [signonState] CNETMsg_SignonState signonState
         * @property {number|null} [spawnCount] CNETMsg_SignonState spawnCount
         * @property {number|null} [numServerPlayers] CNETMsg_SignonState numServerPlayers
         * @property {Array.<string>|null} [playersNetworkids] CNETMsg_SignonState playersNetworkids
         * @property {string|null} [mapName] CNETMsg_SignonState mapName
         * @property {string|null} [addons] CNETMsg_SignonState addons
         */
    
        /**
         * Constructs a new CNETMsg_SignonState.
         * @exports CNETMsg_SignonState
         * @classdesc Represents a CNETMsg_SignonState.
         * @implements ICNETMsg_SignonState
         * @constructor
         * @param {ICNETMsg_SignonState=} [properties] Properties to set
         */
        function CNETMsg_SignonState(properties) {
            this.playersNetworkids = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CNETMsg_SignonState signonState.
         * @member {SignonState_t} signonState
         * @memberof CNETMsg_SignonState
         * @instance
         */
        CNETMsg_SignonState.prototype.signonState = 0;
    
        /**
         * CNETMsg_SignonState spawnCount.
         * @member {number} spawnCount
         * @memberof CNETMsg_SignonState
         * @instance
         */
        CNETMsg_SignonState.prototype.spawnCount = 0;
    
        /**
         * CNETMsg_SignonState numServerPlayers.
         * @member {number} numServerPlayers
         * @memberof CNETMsg_SignonState
         * @instance
         */
        CNETMsg_SignonState.prototype.numServerPlayers = 0;
    
        /**
         * CNETMsg_SignonState playersNetworkids.
         * @member {Array.<string>} playersNetworkids
         * @memberof CNETMsg_SignonState
         * @instance
         */
        CNETMsg_SignonState.prototype.playersNetworkids = $util.emptyArray;
    
        /**
         * CNETMsg_SignonState mapName.
         * @member {string} mapName
         * @memberof CNETMsg_SignonState
         * @instance
         */
        CNETMsg_SignonState.prototype.mapName = "";
    
        /**
         * CNETMsg_SignonState addons.
         * @member {string} addons
         * @memberof CNETMsg_SignonState
         * @instance
         */
        CNETMsg_SignonState.prototype.addons = "";
    
        /**
         * Creates a new CNETMsg_SignonState instance using the specified properties.
         * @function create
         * @memberof CNETMsg_SignonState
         * @static
         * @param {ICNETMsg_SignonState=} [properties] Properties to set
         * @returns {CNETMsg_SignonState} CNETMsg_SignonState instance
         */
        CNETMsg_SignonState.create = function create(properties) {
            return new CNETMsg_SignonState(properties);
        };
    
        /**
         * Encodes the specified CNETMsg_SignonState message. Does not implicitly {@link CNETMsg_SignonState.verify|verify} messages.
         * @function encode
         * @memberof CNETMsg_SignonState
         * @static
         * @param {ICNETMsg_SignonState} message CNETMsg_SignonState message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CNETMsg_SignonState.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.signonState != null && Object.hasOwnProperty.call(message, "signonState"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.signonState);
            if (message.spawnCount != null && Object.hasOwnProperty.call(message, "spawnCount"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.spawnCount);
            if (message.numServerPlayers != null && Object.hasOwnProperty.call(message, "numServerPlayers"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.numServerPlayers);
            if (message.playersNetworkids != null && message.playersNetworkids.length)
                for (var i = 0; i < message.playersNetworkids.length; ++i)
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.playersNetworkids[i]);
            if (message.mapName != null && Object.hasOwnProperty.call(message, "mapName"))
                writer.uint32(/* id 5, wireType 2 =*/42).string(message.mapName);
            if (message.addons != null && Object.hasOwnProperty.call(message, "addons"))
                writer.uint32(/* id 6, wireType 2 =*/50).string(message.addons);
            return writer;
        };
    
        /**
         * Encodes the specified CNETMsg_SignonState message, length delimited. Does not implicitly {@link CNETMsg_SignonState.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CNETMsg_SignonState
         * @static
         * @param {ICNETMsg_SignonState} message CNETMsg_SignonState message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CNETMsg_SignonState.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CNETMsg_SignonState message from the specified reader or buffer.
         * @function decode
         * @memberof CNETMsg_SignonState
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CNETMsg_SignonState} CNETMsg_SignonState
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CNETMsg_SignonState.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CNETMsg_SignonState();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.signonState = reader.int32();
                        break;
                    }
                case 2: {
                        message.spawnCount = reader.uint32();
                        break;
                    }
                case 3: {
                        message.numServerPlayers = reader.uint32();
                        break;
                    }
                case 4: {
                        if (!(message.playersNetworkids && message.playersNetworkids.length))
                            message.playersNetworkids = [];
                        message.playersNetworkids.push(reader.string());
                        break;
                    }
                case 5: {
                        message.mapName = reader.string();
                        break;
                    }
                case 6: {
                        message.addons = reader.string();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CNETMsg_SignonState message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CNETMsg_SignonState
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CNETMsg_SignonState} CNETMsg_SignonState
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CNETMsg_SignonState.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CNETMsg_SignonState message.
         * @function verify
         * @memberof CNETMsg_SignonState
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CNETMsg_SignonState.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.signonState != null && message.hasOwnProperty("signonState"))
                switch (message.signonState) {
                default:
                    return "signonState: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                case 7:
                    break;
                }
            if (message.spawnCount != null && message.hasOwnProperty("spawnCount"))
                if (!$util.isInteger(message.spawnCount))
                    return "spawnCount: integer expected";
            if (message.numServerPlayers != null && message.hasOwnProperty("numServerPlayers"))
                if (!$util.isInteger(message.numServerPlayers))
                    return "numServerPlayers: integer expected";
            if (message.playersNetworkids != null && message.hasOwnProperty("playersNetworkids")) {
                if (!Array.isArray(message.playersNetworkids))
                    return "playersNetworkids: array expected";
                for (var i = 0; i < message.playersNetworkids.length; ++i)
                    if (!$util.isString(message.playersNetworkids[i]))
                        return "playersNetworkids: string[] expected";
            }
            if (message.mapName != null && message.hasOwnProperty("mapName"))
                if (!$util.isString(message.mapName))
                    return "mapName: string expected";
            if (message.addons != null && message.hasOwnProperty("addons"))
                if (!$util.isString(message.addons))
                    return "addons: string expected";
            return null;
        };
    
        /**
         * Creates a CNETMsg_SignonState message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CNETMsg_SignonState
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CNETMsg_SignonState} CNETMsg_SignonState
         */
        CNETMsg_SignonState.fromObject = function fromObject(object) {
            if (object instanceof $root.CNETMsg_SignonState)
                return object;
            var message = new $root.CNETMsg_SignonState();
            switch (object.signonState) {
            default:
                if (typeof object.signonState === "number") {
                    message.signonState = object.signonState;
                    break;
                }
                break;
            case "SIGNONSTATE_NONE":
            case 0:
                message.signonState = 0;
                break;
            case "SIGNONSTATE_CHALLENGE":
            case 1:
                message.signonState = 1;
                break;
            case "SIGNONSTATE_CONNECTED":
            case 2:
                message.signonState = 2;
                break;
            case "SIGNONSTATE_NEW":
            case 3:
                message.signonState = 3;
                break;
            case "SIGNONSTATE_PRESPAWN":
            case 4:
                message.signonState = 4;
                break;
            case "SIGNONSTATE_SPAWN":
            case 5:
                message.signonState = 5;
                break;
            case "SIGNONSTATE_FULL":
            case 6:
                message.signonState = 6;
                break;
            case "SIGNONSTATE_CHANGELEVEL":
            case 7:
                message.signonState = 7;
                break;
            }
            if (object.spawnCount != null)
                message.spawnCount = object.spawnCount >>> 0;
            if (object.numServerPlayers != null)
                message.numServerPlayers = object.numServerPlayers >>> 0;
            if (object.playersNetworkids) {
                if (!Array.isArray(object.playersNetworkids))
                    throw TypeError(".CNETMsg_SignonState.playersNetworkids: array expected");
                message.playersNetworkids = [];
                for (var i = 0; i < object.playersNetworkids.length; ++i)
                    message.playersNetworkids[i] = String(object.playersNetworkids[i]);
            }
            if (object.mapName != null)
                message.mapName = String(object.mapName);
            if (object.addons != null)
                message.addons = String(object.addons);
            return message;
        };
    
        /**
         * Creates a plain object from a CNETMsg_SignonState message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CNETMsg_SignonState
         * @static
         * @param {CNETMsg_SignonState} message CNETMsg_SignonState
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CNETMsg_SignonState.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.playersNetworkids = [];
            if (options.defaults) {
                object.signonState = options.enums === String ? "SIGNONSTATE_NONE" : 0;
                object.spawnCount = 0;
                object.numServerPlayers = 0;
                object.mapName = "";
                object.addons = "";
            }
            if (message.signonState != null && message.hasOwnProperty("signonState"))
                object.signonState = options.enums === String ? $root.SignonState_t[message.signonState] === undefined ? message.signonState : $root.SignonState_t[message.signonState] : message.signonState;
            if (message.spawnCount != null && message.hasOwnProperty("spawnCount"))
                object.spawnCount = message.spawnCount;
            if (message.numServerPlayers != null && message.hasOwnProperty("numServerPlayers"))
                object.numServerPlayers = message.numServerPlayers;
            if (message.playersNetworkids && message.playersNetworkids.length) {
                object.playersNetworkids = [];
                for (var j = 0; j < message.playersNetworkids.length; ++j)
                    object.playersNetworkids[j] = message.playersNetworkids[j];
            }
            if (message.mapName != null && message.hasOwnProperty("mapName"))
                object.mapName = message.mapName;
            if (message.addons != null && message.hasOwnProperty("addons"))
                object.addons = message.addons;
            return object;
        };
    
        /**
         * Converts this CNETMsg_SignonState to JSON.
         * @function toJSON
         * @memberof CNETMsg_SignonState
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CNETMsg_SignonState.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * Gets the default type url for CNETMsg_SignonState
         * @function getTypeUrl
         * @memberof CNETMsg_SignonState
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        CNETMsg_SignonState.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/CNETMsg_SignonState";
        };
    
        return CNETMsg_SignonState;
    })();
    
    $root.CSVCMsg_GameEvent = (function() {
    
        /**
         * Properties of a CSVCMsg_GameEvent.
         * @exports ICSVCMsg_GameEvent
         * @interface ICSVCMsg_GameEvent
         * @property {string|null} [eventName] CSVCMsg_GameEvent eventName
         * @property {number|null} [eventid] CSVCMsg_GameEvent eventid
         * @property {Array.<CSVCMsg_GameEvent.Ikey_t>|null} [keys] CSVCMsg_GameEvent keys
         */
    
        /**
         * Constructs a new CSVCMsg_GameEvent.
         * @exports CSVCMsg_GameEvent
         * @classdesc Represents a CSVCMsg_GameEvent.
         * @implements ICSVCMsg_GameEvent
         * @constructor
         * @param {ICSVCMsg_GameEvent=} [properties] Properties to set
         */
        function CSVCMsg_GameEvent(properties) {
            this.keys = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CSVCMsg_GameEvent eventName.
         * @member {string} eventName
         * @memberof CSVCMsg_GameEvent
         * @instance
         */
        CSVCMsg_GameEvent.prototype.eventName = "";
    
        /**
         * CSVCMsg_GameEvent eventid.
         * @member {number} eventid
         * @memberof CSVCMsg_GameEvent
         * @instance
         */
        CSVCMsg_GameEvent.prototype.eventid = 0;
    
        /**
         * CSVCMsg_GameEvent keys.
         * @member {Array.<CSVCMsg_GameEvent.Ikey_t>} keys
         * @memberof CSVCMsg_GameEvent
         * @instance
         */
        CSVCMsg_GameEvent.prototype.keys = $util.emptyArray;
    
        /**
         * Creates a new CSVCMsg_GameEvent instance using the specified properties.
         * @function create
         * @memberof CSVCMsg_GameEvent
         * @static
         * @param {ICSVCMsg_GameEvent=} [properties] Properties to set
         * @returns {CSVCMsg_GameEvent} CSVCMsg_GameEvent instance
         */
        CSVCMsg_GameEvent.create = function create(properties) {
            return new CSVCMsg_GameEvent(properties);
        };
    
        /**
         * Encodes the specified CSVCMsg_GameEvent message. Does not implicitly {@link CSVCMsg_GameEvent.verify|verify} messages.
         * @function encode
         * @memberof CSVCMsg_GameEvent
         * @static
         * @param {ICSVCMsg_GameEvent} message CSVCMsg_GameEvent message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CSVCMsg_GameEvent.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.eventName != null && Object.hasOwnProperty.call(message, "eventName"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.eventName);
            if (message.eventid != null && Object.hasOwnProperty.call(message, "eventid"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.eventid);
            if (message.keys != null && message.keys.length)
                for (var i = 0; i < message.keys.length; ++i)
                    $root.CSVCMsg_GameEvent.key_t.encode(message.keys[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            return writer;
        };
    
        /**
         * Encodes the specified CSVCMsg_GameEvent message, length delimited. Does not implicitly {@link CSVCMsg_GameEvent.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CSVCMsg_GameEvent
         * @static
         * @param {ICSVCMsg_GameEvent} message CSVCMsg_GameEvent message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CSVCMsg_GameEvent.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CSVCMsg_GameEvent message from the specified reader or buffer.
         * @function decode
         * @memberof CSVCMsg_GameEvent
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CSVCMsg_GameEvent} CSVCMsg_GameEvent
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CSVCMsg_GameEvent.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CSVCMsg_GameEvent();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.eventName = reader.string();
                        break;
                    }
                case 2: {
                        message.eventid = reader.int32();
                        break;
                    }
                case 3: {
                        if (!(message.keys && message.keys.length))
                            message.keys = [];
                        message.keys.push($root.CSVCMsg_GameEvent.key_t.decode(reader, reader.uint32()));
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CSVCMsg_GameEvent message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CSVCMsg_GameEvent
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CSVCMsg_GameEvent} CSVCMsg_GameEvent
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CSVCMsg_GameEvent.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CSVCMsg_GameEvent message.
         * @function verify
         * @memberof CSVCMsg_GameEvent
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CSVCMsg_GameEvent.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.eventName != null && message.hasOwnProperty("eventName"))
                if (!$util.isString(message.eventName))
                    return "eventName: string expected";
            if (message.eventid != null && message.hasOwnProperty("eventid"))
                if (!$util.isInteger(message.eventid))
                    return "eventid: integer expected";
            if (message.keys != null && message.hasOwnProperty("keys")) {
                if (!Array.isArray(message.keys))
                    return "keys: array expected";
                for (var i = 0; i < message.keys.length; ++i) {
                    var error = $root.CSVCMsg_GameEvent.key_t.verify(message.keys[i]);
                    if (error)
                        return "keys." + error;
                }
            }
            return null;
        };
    
        /**
         * Creates a CSVCMsg_GameEvent message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CSVCMsg_GameEvent
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CSVCMsg_GameEvent} CSVCMsg_GameEvent
         */
        CSVCMsg_GameEvent.fromObject = function fromObject(object) {
            if (object instanceof $root.CSVCMsg_GameEvent)
                return object;
            var message = new $root.CSVCMsg_GameEvent();
            if (object.eventName != null)
                message.eventName = String(object.eventName);
            if (object.eventid != null)
                message.eventid = object.eventid | 0;
            if (object.keys) {
                if (!Array.isArray(object.keys))
                    throw TypeError(".CSVCMsg_GameEvent.keys: array expected");
                message.keys = [];
                for (var i = 0; i < object.keys.length; ++i) {
                    if (typeof object.keys[i] !== "object")
                        throw TypeError(".CSVCMsg_GameEvent.keys: object expected");
                    message.keys[i] = $root.CSVCMsg_GameEvent.key_t.fromObject(object.keys[i]);
                }
            }
            return message;
        };
    
        /**
         * Creates a plain object from a CSVCMsg_GameEvent message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CSVCMsg_GameEvent
         * @static
         * @param {CSVCMsg_GameEvent} message CSVCMsg_GameEvent
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CSVCMsg_GameEvent.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.keys = [];
            if (options.defaults) {
                object.eventName = "";
                object.eventid = 0;
            }
            if (message.eventName != null && message.hasOwnProperty("eventName"))
                object.eventName = message.eventName;
            if (message.eventid != null && message.hasOwnProperty("eventid"))
                object.eventid = message.eventid;
            if (message.keys && message.keys.length) {
                object.keys = [];
                for (var j = 0; j < message.keys.length; ++j)
                    object.keys[j] = $root.CSVCMsg_GameEvent.key_t.toObject(message.keys[j], options);
            }
            return object;
        };
    
        /**
         * Converts this CSVCMsg_GameEvent to JSON.
         * @function toJSON
         * @memberof CSVCMsg_GameEvent
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CSVCMsg_GameEvent.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * Gets the default type url for CSVCMsg_GameEvent
         * @function getTypeUrl
         * @memberof CSVCMsg_GameEvent
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        CSVCMsg_GameEvent.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/CSVCMsg_GameEvent";
        };
    
        CSVCMsg_GameEvent.key_t = (function() {
    
            /**
             * Properties of a key_t.
             * @memberof CSVCMsg_GameEvent
             * @interface Ikey_t
             * @property {number|null} [type] key_t type
             * @property {string|null} [valString] key_t valString
             * @property {number|null} [valFloat] key_t valFloat
             * @property {number|null} [valLong] key_t valLong
             * @property {number|null} [valShort] key_t valShort
             * @property {number|null} [valByte] key_t valByte
             * @property {boolean|null} [valBool] key_t valBool
             * @property {number|Long|null} [valUint64] key_t valUint64
             */
    
            /**
             * Constructs a new key_t.
             * @memberof CSVCMsg_GameEvent
             * @classdesc Represents a key_t.
             * @implements Ikey_t
             * @constructor
             * @param {CSVCMsg_GameEvent.Ikey_t=} [properties] Properties to set
             */
            function key_t(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * key_t type.
             * @member {number} type
             * @memberof CSVCMsg_GameEvent.key_t
             * @instance
             */
            key_t.prototype.type = 0;
    
            /**
             * key_t valString.
             * @member {string} valString
             * @memberof CSVCMsg_GameEvent.key_t
             * @instance
             */
            key_t.prototype.valString = "";
    
            /**
             * key_t valFloat.
             * @member {number} valFloat
             * @memberof CSVCMsg_GameEvent.key_t
             * @instance
             */
            key_t.prototype.valFloat = 0;
    
            /**
             * key_t valLong.
             * @member {number} valLong
             * @memberof CSVCMsg_GameEvent.key_t
             * @instance
             */
            key_t.prototype.valLong = 0;
    
            /**
             * key_t valShort.
             * @member {number} valShort
             * @memberof CSVCMsg_GameEvent.key_t
             * @instance
             */
            key_t.prototype.valShort = 0;
    
            /**
             * key_t valByte.
             * @member {number} valByte
             * @memberof CSVCMsg_GameEvent.key_t
             * @instance
             */
            key_t.prototype.valByte = 0;
    
            /**
             * key_t valBool.
             * @member {boolean} valBool
             * @memberof CSVCMsg_GameEvent.key_t
             * @instance
             */
            key_t.prototype.valBool = false;
    
            /**
             * key_t valUint64.
             * @member {number|Long} valUint64
             * @memberof CSVCMsg_GameEvent.key_t
             * @instance
             */
            key_t.prototype.valUint64 = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
            /**
             * Creates a new key_t instance using the specified properties.
             * @function create
             * @memberof CSVCMsg_GameEvent.key_t
             * @static
             * @param {CSVCMsg_GameEvent.Ikey_t=} [properties] Properties to set
             * @returns {CSVCMsg_GameEvent.key_t} key_t instance
             */
            key_t.create = function create(properties) {
                return new key_t(properties);
            };
    
            /**
             * Encodes the specified key_t message. Does not implicitly {@link CSVCMsg_GameEvent.key_t.verify|verify} messages.
             * @function encode
             * @memberof CSVCMsg_GameEvent.key_t
             * @static
             * @param {CSVCMsg_GameEvent.Ikey_t} message key_t message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            key_t.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
                if (message.valString != null && Object.hasOwnProperty.call(message, "valString"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.valString);
                if (message.valFloat != null && Object.hasOwnProperty.call(message, "valFloat"))
                    writer.uint32(/* id 3, wireType 5 =*/29).float(message.valFloat);
                if (message.valLong != null && Object.hasOwnProperty.call(message, "valLong"))
                    writer.uint32(/* id 4, wireType 0 =*/32).int32(message.valLong);
                if (message.valShort != null && Object.hasOwnProperty.call(message, "valShort"))
                    writer.uint32(/* id 5, wireType 0 =*/40).int32(message.valShort);
                if (message.valByte != null && Object.hasOwnProperty.call(message, "valByte"))
                    writer.uint32(/* id 6, wireType 0 =*/48).int32(message.valByte);
                if (message.valBool != null && Object.hasOwnProperty.call(message, "valBool"))
                    writer.uint32(/* id 7, wireType 0 =*/56).bool(message.valBool);
                if (message.valUint64 != null && Object.hasOwnProperty.call(message, "valUint64"))
                    writer.uint32(/* id 8, wireType 0 =*/64).uint64(message.valUint64);
                return writer;
            };
    
            /**
             * Encodes the specified key_t message, length delimited. Does not implicitly {@link CSVCMsg_GameEvent.key_t.verify|verify} messages.
             * @function encodeDelimited
             * @memberof CSVCMsg_GameEvent.key_t
             * @static
             * @param {CSVCMsg_GameEvent.Ikey_t} message key_t message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            key_t.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a key_t message from the specified reader or buffer.
             * @function decode
             * @memberof CSVCMsg_GameEvent.key_t
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {CSVCMsg_GameEvent.key_t} key_t
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            key_t.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CSVCMsg_GameEvent.key_t();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.type = reader.int32();
                            break;
                        }
                    case 2: {
                            message.valString = reader.string();
                            break;
                        }
                    case 3: {
                            message.valFloat = reader.float();
                            break;
                        }
                    case 4: {
                            message.valLong = reader.int32();
                            break;
                        }
                    case 5: {
                            message.valShort = reader.int32();
                            break;
                        }
                    case 6: {
                            message.valByte = reader.int32();
                            break;
                        }
                    case 7: {
                            message.valBool = reader.bool();
                            break;
                        }
                    case 8: {
                            message.valUint64 = reader.uint64();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a key_t message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof CSVCMsg_GameEvent.key_t
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {CSVCMsg_GameEvent.key_t} key_t
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            key_t.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a key_t message.
             * @function verify
             * @memberof CSVCMsg_GameEvent.key_t
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            key_t.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.type != null && message.hasOwnProperty("type"))
                    if (!$util.isInteger(message.type))
                        return "type: integer expected";
                if (message.valString != null && message.hasOwnProperty("valString"))
                    if (!$util.isString(message.valString))
                        return "valString: string expected";
                if (message.valFloat != null && message.hasOwnProperty("valFloat"))
                    if (typeof message.valFloat !== "number")
                        return "valFloat: number expected";
                if (message.valLong != null && message.hasOwnProperty("valLong"))
                    if (!$util.isInteger(message.valLong))
                        return "valLong: integer expected";
                if (message.valShort != null && message.hasOwnProperty("valShort"))
                    if (!$util.isInteger(message.valShort))
                        return "valShort: integer expected";
                if (message.valByte != null && message.hasOwnProperty("valByte"))
                    if (!$util.isInteger(message.valByte))
                        return "valByte: integer expected";
                if (message.valBool != null && message.hasOwnProperty("valBool"))
                    if (typeof message.valBool !== "boolean")
                        return "valBool: boolean expected";
                if (message.valUint64 != null && message.hasOwnProperty("valUint64"))
                    if (!$util.isInteger(message.valUint64) && !(message.valUint64 && $util.isInteger(message.valUint64.low) && $util.isInteger(message.valUint64.high)))
                        return "valUint64: integer|Long expected";
                return null;
            };
    
            /**
             * Creates a key_t message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof CSVCMsg_GameEvent.key_t
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {CSVCMsg_GameEvent.key_t} key_t
             */
            key_t.fromObject = function fromObject(object) {
                if (object instanceof $root.CSVCMsg_GameEvent.key_t)
                    return object;
                var message = new $root.CSVCMsg_GameEvent.key_t();
                if (object.type != null)
                    message.type = object.type | 0;
                if (object.valString != null)
                    message.valString = String(object.valString);
                if (object.valFloat != null)
                    message.valFloat = Number(object.valFloat);
                if (object.valLong != null)
                    message.valLong = object.valLong | 0;
                if (object.valShort != null)
                    message.valShort = object.valShort | 0;
                if (object.valByte != null)
                    message.valByte = object.valByte | 0;
                if (object.valBool != null)
                    message.valBool = Boolean(object.valBool);
                if (object.valUint64 != null)
                    if ($util.Long)
                        (message.valUint64 = $util.Long.fromValue(object.valUint64)).unsigned = true;
                    else if (typeof object.valUint64 === "string")
                        message.valUint64 = parseInt(object.valUint64, 10);
                    else if (typeof object.valUint64 === "number")
                        message.valUint64 = object.valUint64;
                    else if (typeof object.valUint64 === "object")
                        message.valUint64 = new $util.LongBits(object.valUint64.low >>> 0, object.valUint64.high >>> 0).toNumber(true);
                return message;
            };
    
            /**
             * Creates a plain object from a key_t message. Also converts values to other types if specified.
             * @function toObject
             * @memberof CSVCMsg_GameEvent.key_t
             * @static
             * @param {CSVCMsg_GameEvent.key_t} message key_t
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            key_t.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.type = 0;
                    object.valString = "";
                    object.valFloat = 0;
                    object.valLong = 0;
                    object.valShort = 0;
                    object.valByte = 0;
                    object.valBool = false;
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, true);
                        object.valUint64 = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.valUint64 = options.longs === String ? "0" : 0;
                }
                if (message.type != null && message.hasOwnProperty("type"))
                    object.type = message.type;
                if (message.valString != null && message.hasOwnProperty("valString"))
                    object.valString = message.valString;
                if (message.valFloat != null && message.hasOwnProperty("valFloat"))
                    object.valFloat = options.json && !isFinite(message.valFloat) ? String(message.valFloat) : message.valFloat;
                if (message.valLong != null && message.hasOwnProperty("valLong"))
                    object.valLong = message.valLong;
                if (message.valShort != null && message.hasOwnProperty("valShort"))
                    object.valShort = message.valShort;
                if (message.valByte != null && message.hasOwnProperty("valByte"))
                    object.valByte = message.valByte;
                if (message.valBool != null && message.hasOwnProperty("valBool"))
                    object.valBool = message.valBool;
                if (message.valUint64 != null && message.hasOwnProperty("valUint64"))
                    if (typeof message.valUint64 === "number")
                        object.valUint64 = options.longs === String ? String(message.valUint64) : message.valUint64;
                    else
                        object.valUint64 = options.longs === String ? $util.Long.prototype.toString.call(message.valUint64) : options.longs === Number ? new $util.LongBits(message.valUint64.low >>> 0, message.valUint64.high >>> 0).toNumber(true) : message.valUint64;
                return object;
            };
    
            /**
             * Converts this key_t to JSON.
             * @function toJSON
             * @memberof CSVCMsg_GameEvent.key_t
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            key_t.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            /**
             * Gets the default type url for key_t
             * @function getTypeUrl
             * @memberof CSVCMsg_GameEvent.key_t
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            key_t.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/CSVCMsg_GameEvent.key_t";
            };
    
            return key_t;
        })();
    
        return CSVCMsg_GameEvent;
    })();
    
    $root.CSVCMsgList_GameEvents = (function() {
    
        /**
         * Properties of a CSVCMsgList_GameEvents.
         * @exports ICSVCMsgList_GameEvents
         * @interface ICSVCMsgList_GameEvents
         * @property {Array.<CSVCMsgList_GameEvents.Ievent_t>|null} [events] CSVCMsgList_GameEvents events
         */
    
        /**
         * Constructs a new CSVCMsgList_GameEvents.
         * @exports CSVCMsgList_GameEvents
         * @classdesc Represents a CSVCMsgList_GameEvents.
         * @implements ICSVCMsgList_GameEvents
         * @constructor
         * @param {ICSVCMsgList_GameEvents=} [properties] Properties to set
         */
        function CSVCMsgList_GameEvents(properties) {
            this.events = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CSVCMsgList_GameEvents events.
         * @member {Array.<CSVCMsgList_GameEvents.Ievent_t>} events
         * @memberof CSVCMsgList_GameEvents
         * @instance
         */
        CSVCMsgList_GameEvents.prototype.events = $util.emptyArray;
    
        /**
         * Creates a new CSVCMsgList_GameEvents instance using the specified properties.
         * @function create
         * @memberof CSVCMsgList_GameEvents
         * @static
         * @param {ICSVCMsgList_GameEvents=} [properties] Properties to set
         * @returns {CSVCMsgList_GameEvents} CSVCMsgList_GameEvents instance
         */
        CSVCMsgList_GameEvents.create = function create(properties) {
            return new CSVCMsgList_GameEvents(properties);
        };
    
        /**
         * Encodes the specified CSVCMsgList_GameEvents message. Does not implicitly {@link CSVCMsgList_GameEvents.verify|verify} messages.
         * @function encode
         * @memberof CSVCMsgList_GameEvents
         * @static
         * @param {ICSVCMsgList_GameEvents} message CSVCMsgList_GameEvents message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CSVCMsgList_GameEvents.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.events != null && message.events.length)
                for (var i = 0; i < message.events.length; ++i)
                    $root.CSVCMsgList_GameEvents.event_t.encode(message.events[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };
    
        /**
         * Encodes the specified CSVCMsgList_GameEvents message, length delimited. Does not implicitly {@link CSVCMsgList_GameEvents.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CSVCMsgList_GameEvents
         * @static
         * @param {ICSVCMsgList_GameEvents} message CSVCMsgList_GameEvents message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CSVCMsgList_GameEvents.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CSVCMsgList_GameEvents message from the specified reader or buffer.
         * @function decode
         * @memberof CSVCMsgList_GameEvents
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CSVCMsgList_GameEvents} CSVCMsgList_GameEvents
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CSVCMsgList_GameEvents.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CSVCMsgList_GameEvents();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        if (!(message.events && message.events.length))
                            message.events = [];
                        message.events.push($root.CSVCMsgList_GameEvents.event_t.decode(reader, reader.uint32()));
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CSVCMsgList_GameEvents message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CSVCMsgList_GameEvents
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CSVCMsgList_GameEvents} CSVCMsgList_GameEvents
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CSVCMsgList_GameEvents.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CSVCMsgList_GameEvents message.
         * @function verify
         * @memberof CSVCMsgList_GameEvents
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CSVCMsgList_GameEvents.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.events != null && message.hasOwnProperty("events")) {
                if (!Array.isArray(message.events))
                    return "events: array expected";
                for (var i = 0; i < message.events.length; ++i) {
                    var error = $root.CSVCMsgList_GameEvents.event_t.verify(message.events[i]);
                    if (error)
                        return "events." + error;
                }
            }
            return null;
        };
    
        /**
         * Creates a CSVCMsgList_GameEvents message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CSVCMsgList_GameEvents
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CSVCMsgList_GameEvents} CSVCMsgList_GameEvents
         */
        CSVCMsgList_GameEvents.fromObject = function fromObject(object) {
            if (object instanceof $root.CSVCMsgList_GameEvents)
                return object;
            var message = new $root.CSVCMsgList_GameEvents();
            if (object.events) {
                if (!Array.isArray(object.events))
                    throw TypeError(".CSVCMsgList_GameEvents.events: array expected");
                message.events = [];
                for (var i = 0; i < object.events.length; ++i) {
                    if (typeof object.events[i] !== "object")
                        throw TypeError(".CSVCMsgList_GameEvents.events: object expected");
                    message.events[i] = $root.CSVCMsgList_GameEvents.event_t.fromObject(object.events[i]);
                }
            }
            return message;
        };
    
        /**
         * Creates a plain object from a CSVCMsgList_GameEvents message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CSVCMsgList_GameEvents
         * @static
         * @param {CSVCMsgList_GameEvents} message CSVCMsgList_GameEvents
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CSVCMsgList_GameEvents.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.events = [];
            if (message.events && message.events.length) {
                object.events = [];
                for (var j = 0; j < message.events.length; ++j)
                    object.events[j] = $root.CSVCMsgList_GameEvents.event_t.toObject(message.events[j], options);
            }
            return object;
        };
    
        /**
         * Converts this CSVCMsgList_GameEvents to JSON.
         * @function toJSON
         * @memberof CSVCMsgList_GameEvents
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CSVCMsgList_GameEvents.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * Gets the default type url for CSVCMsgList_GameEvents
         * @function getTypeUrl
         * @memberof CSVCMsgList_GameEvents
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        CSVCMsgList_GameEvents.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/CSVCMsgList_GameEvents";
        };
    
        CSVCMsgList_GameEvents.event_t = (function() {
    
            /**
             * Properties of an event_t.
             * @memberof CSVCMsgList_GameEvents
             * @interface Ievent_t
             * @property {number|null} [tick] event_t tick
             * @property {ICSVCMsg_GameEvent|null} [event] event_t event
             */
    
            /**
             * Constructs a new event_t.
             * @memberof CSVCMsgList_GameEvents
             * @classdesc Represents an event_t.
             * @implements Ievent_t
             * @constructor
             * @param {CSVCMsgList_GameEvents.Ievent_t=} [properties] Properties to set
             */
            function event_t(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * event_t tick.
             * @member {number} tick
             * @memberof CSVCMsgList_GameEvents.event_t
             * @instance
             */
            event_t.prototype.tick = 0;
    
            /**
             * event_t event.
             * @member {ICSVCMsg_GameEvent|null|undefined} event
             * @memberof CSVCMsgList_GameEvents.event_t
             * @instance
             */
            event_t.prototype.event = null;
    
            /**
             * Creates a new event_t instance using the specified properties.
             * @function create
             * @memberof CSVCMsgList_GameEvents.event_t
             * @static
             * @param {CSVCMsgList_GameEvents.Ievent_t=} [properties] Properties to set
             * @returns {CSVCMsgList_GameEvents.event_t} event_t instance
             */
            event_t.create = function create(properties) {
                return new event_t(properties);
            };
    
            /**
             * Encodes the specified event_t message. Does not implicitly {@link CSVCMsgList_GameEvents.event_t.verify|verify} messages.
             * @function encode
             * @memberof CSVCMsgList_GameEvents.event_t
             * @static
             * @param {CSVCMsgList_GameEvents.Ievent_t} message event_t message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            event_t.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.tick != null && Object.hasOwnProperty.call(message, "tick"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.tick);
                if (message.event != null && Object.hasOwnProperty.call(message, "event"))
                    $root.CSVCMsg_GameEvent.encode(message.event, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };
    
            /**
             * Encodes the specified event_t message, length delimited. Does not implicitly {@link CSVCMsgList_GameEvents.event_t.verify|verify} messages.
             * @function encodeDelimited
             * @memberof CSVCMsgList_GameEvents.event_t
             * @static
             * @param {CSVCMsgList_GameEvents.Ievent_t} message event_t message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            event_t.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes an event_t message from the specified reader or buffer.
             * @function decode
             * @memberof CSVCMsgList_GameEvents.event_t
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {CSVCMsgList_GameEvents.event_t} event_t
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            event_t.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CSVCMsgList_GameEvents.event_t();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.tick = reader.int32();
                            break;
                        }
                    case 2: {
                            message.event = $root.CSVCMsg_GameEvent.decode(reader, reader.uint32());
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes an event_t message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof CSVCMsgList_GameEvents.event_t
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {CSVCMsgList_GameEvents.event_t} event_t
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            event_t.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies an event_t message.
             * @function verify
             * @memberof CSVCMsgList_GameEvents.event_t
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            event_t.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.tick != null && message.hasOwnProperty("tick"))
                    if (!$util.isInteger(message.tick))
                        return "tick: integer expected";
                if (message.event != null && message.hasOwnProperty("event")) {
                    var error = $root.CSVCMsg_GameEvent.verify(message.event);
                    if (error)
                        return "event." + error;
                }
                return null;
            };
    
            /**
             * Creates an event_t message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof CSVCMsgList_GameEvents.event_t
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {CSVCMsgList_GameEvents.event_t} event_t
             */
            event_t.fromObject = function fromObject(object) {
                if (object instanceof $root.CSVCMsgList_GameEvents.event_t)
                    return object;
                var message = new $root.CSVCMsgList_GameEvents.event_t();
                if (object.tick != null)
                    message.tick = object.tick | 0;
                if (object.event != null) {
                    if (typeof object.event !== "object")
                        throw TypeError(".CSVCMsgList_GameEvents.event_t.event: object expected");
                    message.event = $root.CSVCMsg_GameEvent.fromObject(object.event);
                }
                return message;
            };
    
            /**
             * Creates a plain object from an event_t message. Also converts values to other types if specified.
             * @function toObject
             * @memberof CSVCMsgList_GameEvents.event_t
             * @static
             * @param {CSVCMsgList_GameEvents.event_t} message event_t
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            event_t.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.tick = 0;
                    object.event = null;
                }
                if (message.tick != null && message.hasOwnProperty("tick"))
                    object.tick = message.tick;
                if (message.event != null && message.hasOwnProperty("event"))
                    object.event = $root.CSVCMsg_GameEvent.toObject(message.event, options);
                return object;
            };
    
            /**
             * Converts this event_t to JSON.
             * @function toJSON
             * @memberof CSVCMsgList_GameEvents.event_t
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            event_t.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            /**
             * Gets the default type url for event_t
             * @function getTypeUrl
             * @memberof CSVCMsgList_GameEvents.event_t
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            event_t.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/CSVCMsgList_GameEvents.event_t";
            };
    
            return event_t;
        })();
    
        return CSVCMsgList_GameEvents;
    })();
    
    $root.CNETMsg_SpawnGroup_Load = (function() {
    
        /**
         * Properties of a CNETMsg_SpawnGroup_Load.
         * @exports ICNETMsg_SpawnGroup_Load
         * @interface ICNETMsg_SpawnGroup_Load
         * @property {string|null} [worldname] CNETMsg_SpawnGroup_Load worldname
         * @property {string|null} [entitylumpname] CNETMsg_SpawnGroup_Load entitylumpname
         * @property {string|null} [entityfiltername] CNETMsg_SpawnGroup_Load entityfiltername
         * @property {number|null} [spawngrouphandle] CNETMsg_SpawnGroup_Load spawngrouphandle
         * @property {number|null} [spawngroupownerhandle] CNETMsg_SpawnGroup_Load spawngroupownerhandle
         * @property {ICMsgVector|null} [worldOffsetPos] CNETMsg_SpawnGroup_Load worldOffsetPos
         * @property {ICMsgQAngle|null} [worldOffsetAngle] CNETMsg_SpawnGroup_Load worldOffsetAngle
         * @property {Uint8Array|null} [spawngroupmanifest] CNETMsg_SpawnGroup_Load spawngroupmanifest
         * @property {number|null} [flags] CNETMsg_SpawnGroup_Load flags
         * @property {number|null} [tickcount] CNETMsg_SpawnGroup_Load tickcount
         * @property {boolean|null} [manifestincomplete] CNETMsg_SpawnGroup_Load manifestincomplete
         * @property {string|null} [localnamefixup] CNETMsg_SpawnGroup_Load localnamefixup
         * @property {string|null} [parentnamefixup] CNETMsg_SpawnGroup_Load parentnamefixup
         * @property {number|null} [manifestloadpriority] CNETMsg_SpawnGroup_Load manifestloadpriority
         * @property {number|null} [worldgroupid] CNETMsg_SpawnGroup_Load worldgroupid
         * @property {number|null} [creationsequence] CNETMsg_SpawnGroup_Load creationsequence
         * @property {string|null} [savegamefilename] CNETMsg_SpawnGroup_Load savegamefilename
         * @property {number|null} [spawngroupparenthandle] CNETMsg_SpawnGroup_Load spawngroupparenthandle
         * @property {boolean|null} [leveltransition] CNETMsg_SpawnGroup_Load leveltransition
         * @property {string|null} [worldgroupname] CNETMsg_SpawnGroup_Load worldgroupname
         */
    
        /**
         * Constructs a new CNETMsg_SpawnGroup_Load.
         * @exports CNETMsg_SpawnGroup_Load
         * @classdesc Represents a CNETMsg_SpawnGroup_Load.
         * @implements ICNETMsg_SpawnGroup_Load
         * @constructor
         * @param {ICNETMsg_SpawnGroup_Load=} [properties] Properties to set
         */
        function CNETMsg_SpawnGroup_Load(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CNETMsg_SpawnGroup_Load worldname.
         * @member {string} worldname
         * @memberof CNETMsg_SpawnGroup_Load
         * @instance
         */
        CNETMsg_SpawnGroup_Load.prototype.worldname = "";
    
        /**
         * CNETMsg_SpawnGroup_Load entitylumpname.
         * @member {string} entitylumpname
         * @memberof CNETMsg_SpawnGroup_Load
         * @instance
         */
        CNETMsg_SpawnGroup_Load.prototype.entitylumpname = "";
    
        /**
         * CNETMsg_SpawnGroup_Load entityfiltername.
         * @member {string} entityfiltername
         * @memberof CNETMsg_SpawnGroup_Load
         * @instance
         */
        CNETMsg_SpawnGroup_Load.prototype.entityfiltername = "";
    
        /**
         * CNETMsg_SpawnGroup_Load spawngrouphandle.
         * @member {number} spawngrouphandle
         * @memberof CNETMsg_SpawnGroup_Load
         * @instance
         */
        CNETMsg_SpawnGroup_Load.prototype.spawngrouphandle = 0;
    
        /**
         * CNETMsg_SpawnGroup_Load spawngroupownerhandle.
         * @member {number} spawngroupownerhandle
         * @memberof CNETMsg_SpawnGroup_Load
         * @instance
         */
        CNETMsg_SpawnGroup_Load.prototype.spawngroupownerhandle = 0;
    
        /**
         * CNETMsg_SpawnGroup_Load worldOffsetPos.
         * @member {ICMsgVector|null|undefined} worldOffsetPos
         * @memberof CNETMsg_SpawnGroup_Load
         * @instance
         */
        CNETMsg_SpawnGroup_Load.prototype.worldOffsetPos = null;
    
        /**
         * CNETMsg_SpawnGroup_Load worldOffsetAngle.
         * @member {ICMsgQAngle|null|undefined} worldOffsetAngle
         * @memberof CNETMsg_SpawnGroup_Load
         * @instance
         */
        CNETMsg_SpawnGroup_Load.prototype.worldOffsetAngle = null;
    
        /**
         * CNETMsg_SpawnGroup_Load spawngroupmanifest.
         * @member {Uint8Array} spawngroupmanifest
         * @memberof CNETMsg_SpawnGroup_Load
         * @instance
         */
        CNETMsg_SpawnGroup_Load.prototype.spawngroupmanifest = $util.newBuffer([]);
    
        /**
         * CNETMsg_SpawnGroup_Load flags.
         * @member {number} flags
         * @memberof CNETMsg_SpawnGroup_Load
         * @instance
         */
        CNETMsg_SpawnGroup_Load.prototype.flags = 0;
    
        /**
         * CNETMsg_SpawnGroup_Load tickcount.
         * @member {number} tickcount
         * @memberof CNETMsg_SpawnGroup_Load
         * @instance
         */
        CNETMsg_SpawnGroup_Load.prototype.tickcount = 0;
    
        /**
         * CNETMsg_SpawnGroup_Load manifestincomplete.
         * @member {boolean} manifestincomplete
         * @memberof CNETMsg_SpawnGroup_Load
         * @instance
         */
        CNETMsg_SpawnGroup_Load.prototype.manifestincomplete = false;
    
        /**
         * CNETMsg_SpawnGroup_Load localnamefixup.
         * @member {string} localnamefixup
         * @memberof CNETMsg_SpawnGroup_Load
         * @instance
         */
        CNETMsg_SpawnGroup_Load.prototype.localnamefixup = "";
    
        /**
         * CNETMsg_SpawnGroup_Load parentnamefixup.
         * @member {string} parentnamefixup
         * @memberof CNETMsg_SpawnGroup_Load
         * @instance
         */
        CNETMsg_SpawnGroup_Load.prototype.parentnamefixup = "";
    
        /**
         * CNETMsg_SpawnGroup_Load manifestloadpriority.
         * @member {number} manifestloadpriority
         * @memberof CNETMsg_SpawnGroup_Load
         * @instance
         */
        CNETMsg_SpawnGroup_Load.prototype.manifestloadpriority = 0;
    
        /**
         * CNETMsg_SpawnGroup_Load worldgroupid.
         * @member {number} worldgroupid
         * @memberof CNETMsg_SpawnGroup_Load
         * @instance
         */
        CNETMsg_SpawnGroup_Load.prototype.worldgroupid = 0;
    
        /**
         * CNETMsg_SpawnGroup_Load creationsequence.
         * @member {number} creationsequence
         * @memberof CNETMsg_SpawnGroup_Load
         * @instance
         */
        CNETMsg_SpawnGroup_Load.prototype.creationsequence = 0;
    
        /**
         * CNETMsg_SpawnGroup_Load savegamefilename.
         * @member {string} savegamefilename
         * @memberof CNETMsg_SpawnGroup_Load
         * @instance
         */
        CNETMsg_SpawnGroup_Load.prototype.savegamefilename = "";
    
        /**
         * CNETMsg_SpawnGroup_Load spawngroupparenthandle.
         * @member {number} spawngroupparenthandle
         * @memberof CNETMsg_SpawnGroup_Load
         * @instance
         */
        CNETMsg_SpawnGroup_Load.prototype.spawngroupparenthandle = 0;
    
        /**
         * CNETMsg_SpawnGroup_Load leveltransition.
         * @member {boolean} leveltransition
         * @memberof CNETMsg_SpawnGroup_Load
         * @instance
         */
        CNETMsg_SpawnGroup_Load.prototype.leveltransition = false;
    
        /**
         * CNETMsg_SpawnGroup_Load worldgroupname.
         * @member {string} worldgroupname
         * @memberof CNETMsg_SpawnGroup_Load
         * @instance
         */
        CNETMsg_SpawnGroup_Load.prototype.worldgroupname = "";
    
        /**
         * Creates a new CNETMsg_SpawnGroup_Load instance using the specified properties.
         * @function create
         * @memberof CNETMsg_SpawnGroup_Load
         * @static
         * @param {ICNETMsg_SpawnGroup_Load=} [properties] Properties to set
         * @returns {CNETMsg_SpawnGroup_Load} CNETMsg_SpawnGroup_Load instance
         */
        CNETMsg_SpawnGroup_Load.create = function create(properties) {
            return new CNETMsg_SpawnGroup_Load(properties);
        };
    
        /**
         * Encodes the specified CNETMsg_SpawnGroup_Load message. Does not implicitly {@link CNETMsg_SpawnGroup_Load.verify|verify} messages.
         * @function encode
         * @memberof CNETMsg_SpawnGroup_Load
         * @static
         * @param {ICNETMsg_SpawnGroup_Load} message CNETMsg_SpawnGroup_Load message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CNETMsg_SpawnGroup_Load.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.worldname != null && Object.hasOwnProperty.call(message, "worldname"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.worldname);
            if (message.entitylumpname != null && Object.hasOwnProperty.call(message, "entitylumpname"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.entitylumpname);
            if (message.entityfiltername != null && Object.hasOwnProperty.call(message, "entityfiltername"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.entityfiltername);
            if (message.spawngrouphandle != null && Object.hasOwnProperty.call(message, "spawngrouphandle"))
                writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.spawngrouphandle);
            if (message.spawngroupownerhandle != null && Object.hasOwnProperty.call(message, "spawngroupownerhandle"))
                writer.uint32(/* id 5, wireType 0 =*/40).uint32(message.spawngroupownerhandle);
            if (message.worldOffsetPos != null && Object.hasOwnProperty.call(message, "worldOffsetPos"))
                $root.CMsgVector.encode(message.worldOffsetPos, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
            if (message.worldOffsetAngle != null && Object.hasOwnProperty.call(message, "worldOffsetAngle"))
                $root.CMsgQAngle.encode(message.worldOffsetAngle, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
            if (message.spawngroupmanifest != null && Object.hasOwnProperty.call(message, "spawngroupmanifest"))
                writer.uint32(/* id 8, wireType 2 =*/66).bytes(message.spawngroupmanifest);
            if (message.flags != null && Object.hasOwnProperty.call(message, "flags"))
                writer.uint32(/* id 9, wireType 0 =*/72).uint32(message.flags);
            if (message.tickcount != null && Object.hasOwnProperty.call(message, "tickcount"))
                writer.uint32(/* id 10, wireType 0 =*/80).int32(message.tickcount);
            if (message.manifestincomplete != null && Object.hasOwnProperty.call(message, "manifestincomplete"))
                writer.uint32(/* id 11, wireType 0 =*/88).bool(message.manifestincomplete);
            if (message.localnamefixup != null && Object.hasOwnProperty.call(message, "localnamefixup"))
                writer.uint32(/* id 12, wireType 2 =*/98).string(message.localnamefixup);
            if (message.parentnamefixup != null && Object.hasOwnProperty.call(message, "parentnamefixup"))
                writer.uint32(/* id 13, wireType 2 =*/106).string(message.parentnamefixup);
            if (message.manifestloadpriority != null && Object.hasOwnProperty.call(message, "manifestloadpriority"))
                writer.uint32(/* id 14, wireType 0 =*/112).int32(message.manifestloadpriority);
            if (message.worldgroupid != null && Object.hasOwnProperty.call(message, "worldgroupid"))
                writer.uint32(/* id 15, wireType 0 =*/120).uint32(message.worldgroupid);
            if (message.creationsequence != null && Object.hasOwnProperty.call(message, "creationsequence"))
                writer.uint32(/* id 16, wireType 0 =*/128).uint32(message.creationsequence);
            if (message.savegamefilename != null && Object.hasOwnProperty.call(message, "savegamefilename"))
                writer.uint32(/* id 17, wireType 2 =*/138).string(message.savegamefilename);
            if (message.spawngroupparenthandle != null && Object.hasOwnProperty.call(message, "spawngroupparenthandle"))
                writer.uint32(/* id 18, wireType 0 =*/144).uint32(message.spawngroupparenthandle);
            if (message.leveltransition != null && Object.hasOwnProperty.call(message, "leveltransition"))
                writer.uint32(/* id 19, wireType 0 =*/152).bool(message.leveltransition);
            if (message.worldgroupname != null && Object.hasOwnProperty.call(message, "worldgroupname"))
                writer.uint32(/* id 20, wireType 2 =*/162).string(message.worldgroupname);
            return writer;
        };
    
        /**
         * Encodes the specified CNETMsg_SpawnGroup_Load message, length delimited. Does not implicitly {@link CNETMsg_SpawnGroup_Load.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CNETMsg_SpawnGroup_Load
         * @static
         * @param {ICNETMsg_SpawnGroup_Load} message CNETMsg_SpawnGroup_Load message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CNETMsg_SpawnGroup_Load.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CNETMsg_SpawnGroup_Load message from the specified reader or buffer.
         * @function decode
         * @memberof CNETMsg_SpawnGroup_Load
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CNETMsg_SpawnGroup_Load} CNETMsg_SpawnGroup_Load
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CNETMsg_SpawnGroup_Load.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CNETMsg_SpawnGroup_Load();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.worldname = reader.string();
                        break;
                    }
                case 2: {
                        message.entitylumpname = reader.string();
                        break;
                    }
                case 3: {
                        message.entityfiltername = reader.string();
                        break;
                    }
                case 4: {
                        message.spawngrouphandle = reader.uint32();
                        break;
                    }
                case 5: {
                        message.spawngroupownerhandle = reader.uint32();
                        break;
                    }
                case 6: {
                        message.worldOffsetPos = $root.CMsgVector.decode(reader, reader.uint32());
                        break;
                    }
                case 7: {
                        message.worldOffsetAngle = $root.CMsgQAngle.decode(reader, reader.uint32());
                        break;
                    }
                case 8: {
                        message.spawngroupmanifest = reader.bytes();
                        break;
                    }
                case 9: {
                        message.flags = reader.uint32();
                        break;
                    }
                case 10: {
                        message.tickcount = reader.int32();
                        break;
                    }
                case 11: {
                        message.manifestincomplete = reader.bool();
                        break;
                    }
                case 12: {
                        message.localnamefixup = reader.string();
                        break;
                    }
                case 13: {
                        message.parentnamefixup = reader.string();
                        break;
                    }
                case 14: {
                        message.manifestloadpriority = reader.int32();
                        break;
                    }
                case 15: {
                        message.worldgroupid = reader.uint32();
                        break;
                    }
                case 16: {
                        message.creationsequence = reader.uint32();
                        break;
                    }
                case 17: {
                        message.savegamefilename = reader.string();
                        break;
                    }
                case 18: {
                        message.spawngroupparenthandle = reader.uint32();
                        break;
                    }
                case 19: {
                        message.leveltransition = reader.bool();
                        break;
                    }
                case 20: {
                        message.worldgroupname = reader.string();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CNETMsg_SpawnGroup_Load message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CNETMsg_SpawnGroup_Load
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CNETMsg_SpawnGroup_Load} CNETMsg_SpawnGroup_Load
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CNETMsg_SpawnGroup_Load.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CNETMsg_SpawnGroup_Load message.
         * @function verify
         * @memberof CNETMsg_SpawnGroup_Load
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CNETMsg_SpawnGroup_Load.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.worldname != null && message.hasOwnProperty("worldname"))
                if (!$util.isString(message.worldname))
                    return "worldname: string expected";
            if (message.entitylumpname != null && message.hasOwnProperty("entitylumpname"))
                if (!$util.isString(message.entitylumpname))
                    return "entitylumpname: string expected";
            if (message.entityfiltername != null && message.hasOwnProperty("entityfiltername"))
                if (!$util.isString(message.entityfiltername))
                    return "entityfiltername: string expected";
            if (message.spawngrouphandle != null && message.hasOwnProperty("spawngrouphandle"))
                if (!$util.isInteger(message.spawngrouphandle))
                    return "spawngrouphandle: integer expected";
            if (message.spawngroupownerhandle != null && message.hasOwnProperty("spawngroupownerhandle"))
                if (!$util.isInteger(message.spawngroupownerhandle))
                    return "spawngroupownerhandle: integer expected";
            if (message.worldOffsetPos != null && message.hasOwnProperty("worldOffsetPos")) {
                var error = $root.CMsgVector.verify(message.worldOffsetPos);
                if (error)
                    return "worldOffsetPos." + error;
            }
            if (message.worldOffsetAngle != null && message.hasOwnProperty("worldOffsetAngle")) {
                var error = $root.CMsgQAngle.verify(message.worldOffsetAngle);
                if (error)
                    return "worldOffsetAngle." + error;
            }
            if (message.spawngroupmanifest != null && message.hasOwnProperty("spawngroupmanifest"))
                if (!(message.spawngroupmanifest && typeof message.spawngroupmanifest.length === "number" || $util.isString(message.spawngroupmanifest)))
                    return "spawngroupmanifest: buffer expected";
            if (message.flags != null && message.hasOwnProperty("flags"))
                if (!$util.isInteger(message.flags))
                    return "flags: integer expected";
            if (message.tickcount != null && message.hasOwnProperty("tickcount"))
                if (!$util.isInteger(message.tickcount))
                    return "tickcount: integer expected";
            if (message.manifestincomplete != null && message.hasOwnProperty("manifestincomplete"))
                if (typeof message.manifestincomplete !== "boolean")
                    return "manifestincomplete: boolean expected";
            if (message.localnamefixup != null && message.hasOwnProperty("localnamefixup"))
                if (!$util.isString(message.localnamefixup))
                    return "localnamefixup: string expected";
            if (message.parentnamefixup != null && message.hasOwnProperty("parentnamefixup"))
                if (!$util.isString(message.parentnamefixup))
                    return "parentnamefixup: string expected";
            if (message.manifestloadpriority != null && message.hasOwnProperty("manifestloadpriority"))
                if (!$util.isInteger(message.manifestloadpriority))
                    return "manifestloadpriority: integer expected";
            if (message.worldgroupid != null && message.hasOwnProperty("worldgroupid"))
                if (!$util.isInteger(message.worldgroupid))
                    return "worldgroupid: integer expected";
            if (message.creationsequence != null && message.hasOwnProperty("creationsequence"))
                if (!$util.isInteger(message.creationsequence))
                    return "creationsequence: integer expected";
            if (message.savegamefilename != null && message.hasOwnProperty("savegamefilename"))
                if (!$util.isString(message.savegamefilename))
                    return "savegamefilename: string expected";
            if (message.spawngroupparenthandle != null && message.hasOwnProperty("spawngroupparenthandle"))
                if (!$util.isInteger(message.spawngroupparenthandle))
                    return "spawngroupparenthandle: integer expected";
            if (message.leveltransition != null && message.hasOwnProperty("leveltransition"))
                if (typeof message.leveltransition !== "boolean")
                    return "leveltransition: boolean expected";
            if (message.worldgroupname != null && message.hasOwnProperty("worldgroupname"))
                if (!$util.isString(message.worldgroupname))
                    return "worldgroupname: string expected";
            return null;
        };
    
        /**
         * Creates a CNETMsg_SpawnGroup_Load message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CNETMsg_SpawnGroup_Load
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CNETMsg_SpawnGroup_Load} CNETMsg_SpawnGroup_Load
         */
        CNETMsg_SpawnGroup_Load.fromObject = function fromObject(object) {
            if (object instanceof $root.CNETMsg_SpawnGroup_Load)
                return object;
            var message = new $root.CNETMsg_SpawnGroup_Load();
            if (object.worldname != null)
                message.worldname = String(object.worldname);
            if (object.entitylumpname != null)
                message.entitylumpname = String(object.entitylumpname);
            if (object.entityfiltername != null)
                message.entityfiltername = String(object.entityfiltername);
            if (object.spawngrouphandle != null)
                message.spawngrouphandle = object.spawngrouphandle >>> 0;
            if (object.spawngroupownerhandle != null)
                message.spawngroupownerhandle = object.spawngroupownerhandle >>> 0;
            if (object.worldOffsetPos != null) {
                if (typeof object.worldOffsetPos !== "object")
                    throw TypeError(".CNETMsg_SpawnGroup_Load.worldOffsetPos: object expected");
                message.worldOffsetPos = $root.CMsgVector.fromObject(object.worldOffsetPos);
            }
            if (object.worldOffsetAngle != null) {
                if (typeof object.worldOffsetAngle !== "object")
                    throw TypeError(".CNETMsg_SpawnGroup_Load.worldOffsetAngle: object expected");
                message.worldOffsetAngle = $root.CMsgQAngle.fromObject(object.worldOffsetAngle);
            }
            if (object.spawngroupmanifest != null)
                if (typeof object.spawngroupmanifest === "string")
                    $util.base64.decode(object.spawngroupmanifest, message.spawngroupmanifest = $util.newBuffer($util.base64.length(object.spawngroupmanifest)), 0);
                else if (object.spawngroupmanifest.length >= 0)
                    message.spawngroupmanifest = object.spawngroupmanifest;
            if (object.flags != null)
                message.flags = object.flags >>> 0;
            if (object.tickcount != null)
                message.tickcount = object.tickcount | 0;
            if (object.manifestincomplete != null)
                message.manifestincomplete = Boolean(object.manifestincomplete);
            if (object.localnamefixup != null)
                message.localnamefixup = String(object.localnamefixup);
            if (object.parentnamefixup != null)
                message.parentnamefixup = String(object.parentnamefixup);
            if (object.manifestloadpriority != null)
                message.manifestloadpriority = object.manifestloadpriority | 0;
            if (object.worldgroupid != null)
                message.worldgroupid = object.worldgroupid >>> 0;
            if (object.creationsequence != null)
                message.creationsequence = object.creationsequence >>> 0;
            if (object.savegamefilename != null)
                message.savegamefilename = String(object.savegamefilename);
            if (object.spawngroupparenthandle != null)
                message.spawngroupparenthandle = object.spawngroupparenthandle >>> 0;
            if (object.leveltransition != null)
                message.leveltransition = Boolean(object.leveltransition);
            if (object.worldgroupname != null)
                message.worldgroupname = String(object.worldgroupname);
            return message;
        };
    
        /**
         * Creates a plain object from a CNETMsg_SpawnGroup_Load message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CNETMsg_SpawnGroup_Load
         * @static
         * @param {CNETMsg_SpawnGroup_Load} message CNETMsg_SpawnGroup_Load
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CNETMsg_SpawnGroup_Load.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.worldname = "";
                object.entitylumpname = "";
                object.entityfiltername = "";
                object.spawngrouphandle = 0;
                object.spawngroupownerhandle = 0;
                object.worldOffsetPos = null;
                object.worldOffsetAngle = null;
                if (options.bytes === String)
                    object.spawngroupmanifest = "";
                else {
                    object.spawngroupmanifest = [];
                    if (options.bytes !== Array)
                        object.spawngroupmanifest = $util.newBuffer(object.spawngroupmanifest);
                }
                object.flags = 0;
                object.tickcount = 0;
                object.manifestincomplete = false;
                object.localnamefixup = "";
                object.parentnamefixup = "";
                object.manifestloadpriority = 0;
                object.worldgroupid = 0;
                object.creationsequence = 0;
                object.savegamefilename = "";
                object.spawngroupparenthandle = 0;
                object.leveltransition = false;
                object.worldgroupname = "";
            }
            if (message.worldname != null && message.hasOwnProperty("worldname"))
                object.worldname = message.worldname;
            if (message.entitylumpname != null && message.hasOwnProperty("entitylumpname"))
                object.entitylumpname = message.entitylumpname;
            if (message.entityfiltername != null && message.hasOwnProperty("entityfiltername"))
                object.entityfiltername = message.entityfiltername;
            if (message.spawngrouphandle != null && message.hasOwnProperty("spawngrouphandle"))
                object.spawngrouphandle = message.spawngrouphandle;
            if (message.spawngroupownerhandle != null && message.hasOwnProperty("spawngroupownerhandle"))
                object.spawngroupownerhandle = message.spawngroupownerhandle;
            if (message.worldOffsetPos != null && message.hasOwnProperty("worldOffsetPos"))
                object.worldOffsetPos = $root.CMsgVector.toObject(message.worldOffsetPos, options);
            if (message.worldOffsetAngle != null && message.hasOwnProperty("worldOffsetAngle"))
                object.worldOffsetAngle = $root.CMsgQAngle.toObject(message.worldOffsetAngle, options);
            if (message.spawngroupmanifest != null && message.hasOwnProperty("spawngroupmanifest"))
                object.spawngroupmanifest = options.bytes === String ? $util.base64.encode(message.spawngroupmanifest, 0, message.spawngroupmanifest.length) : options.bytes === Array ? Array.prototype.slice.call(message.spawngroupmanifest) : message.spawngroupmanifest;
            if (message.flags != null && message.hasOwnProperty("flags"))
                object.flags = message.flags;
            if (message.tickcount != null && message.hasOwnProperty("tickcount"))
                object.tickcount = message.tickcount;
            if (message.manifestincomplete != null && message.hasOwnProperty("manifestincomplete"))
                object.manifestincomplete = message.manifestincomplete;
            if (message.localnamefixup != null && message.hasOwnProperty("localnamefixup"))
                object.localnamefixup = message.localnamefixup;
            if (message.parentnamefixup != null && message.hasOwnProperty("parentnamefixup"))
                object.parentnamefixup = message.parentnamefixup;
            if (message.manifestloadpriority != null && message.hasOwnProperty("manifestloadpriority"))
                object.manifestloadpriority = message.manifestloadpriority;
            if (message.worldgroupid != null && message.hasOwnProperty("worldgroupid"))
                object.worldgroupid = message.worldgroupid;
            if (message.creationsequence != null && message.hasOwnProperty("creationsequence"))
                object.creationsequence = message.creationsequence;
            if (message.savegamefilename != null && message.hasOwnProperty("savegamefilename"))
                object.savegamefilename = message.savegamefilename;
            if (message.spawngroupparenthandle != null && message.hasOwnProperty("spawngroupparenthandle"))
                object.spawngroupparenthandle = message.spawngroupparenthandle;
            if (message.leveltransition != null && message.hasOwnProperty("leveltransition"))
                object.leveltransition = message.leveltransition;
            if (message.worldgroupname != null && message.hasOwnProperty("worldgroupname"))
                object.worldgroupname = message.worldgroupname;
            return object;
        };
    
        /**
         * Converts this CNETMsg_SpawnGroup_Load to JSON.
         * @function toJSON
         * @memberof CNETMsg_SpawnGroup_Load
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CNETMsg_SpawnGroup_Load.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * Gets the default type url for CNETMsg_SpawnGroup_Load
         * @function getTypeUrl
         * @memberof CNETMsg_SpawnGroup_Load
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        CNETMsg_SpawnGroup_Load.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/CNETMsg_SpawnGroup_Load";
        };
    
        return CNETMsg_SpawnGroup_Load;
    })();
    
    $root.CNETMsg_SpawnGroup_ManifestUpdate = (function() {
    
        /**
         * Properties of a CNETMsg_SpawnGroup_ManifestUpdate.
         * @exports ICNETMsg_SpawnGroup_ManifestUpdate
         * @interface ICNETMsg_SpawnGroup_ManifestUpdate
         * @property {number|null} [spawngrouphandle] CNETMsg_SpawnGroup_ManifestUpdate spawngrouphandle
         * @property {Uint8Array|null} [spawngroupmanifest] CNETMsg_SpawnGroup_ManifestUpdate spawngroupmanifest
         * @property {boolean|null} [manifestincomplete] CNETMsg_SpawnGroup_ManifestUpdate manifestincomplete
         */
    
        /**
         * Constructs a new CNETMsg_SpawnGroup_ManifestUpdate.
         * @exports CNETMsg_SpawnGroup_ManifestUpdate
         * @classdesc Represents a CNETMsg_SpawnGroup_ManifestUpdate.
         * @implements ICNETMsg_SpawnGroup_ManifestUpdate
         * @constructor
         * @param {ICNETMsg_SpawnGroup_ManifestUpdate=} [properties] Properties to set
         */
        function CNETMsg_SpawnGroup_ManifestUpdate(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CNETMsg_SpawnGroup_ManifestUpdate spawngrouphandle.
         * @member {number} spawngrouphandle
         * @memberof CNETMsg_SpawnGroup_ManifestUpdate
         * @instance
         */
        CNETMsg_SpawnGroup_ManifestUpdate.prototype.spawngrouphandle = 0;
    
        /**
         * CNETMsg_SpawnGroup_ManifestUpdate spawngroupmanifest.
         * @member {Uint8Array} spawngroupmanifest
         * @memberof CNETMsg_SpawnGroup_ManifestUpdate
         * @instance
         */
        CNETMsg_SpawnGroup_ManifestUpdate.prototype.spawngroupmanifest = $util.newBuffer([]);
    
        /**
         * CNETMsg_SpawnGroup_ManifestUpdate manifestincomplete.
         * @member {boolean} manifestincomplete
         * @memberof CNETMsg_SpawnGroup_ManifestUpdate
         * @instance
         */
        CNETMsg_SpawnGroup_ManifestUpdate.prototype.manifestincomplete = false;
    
        /**
         * Creates a new CNETMsg_SpawnGroup_ManifestUpdate instance using the specified properties.
         * @function create
         * @memberof CNETMsg_SpawnGroup_ManifestUpdate
         * @static
         * @param {ICNETMsg_SpawnGroup_ManifestUpdate=} [properties] Properties to set
         * @returns {CNETMsg_SpawnGroup_ManifestUpdate} CNETMsg_SpawnGroup_ManifestUpdate instance
         */
        CNETMsg_SpawnGroup_ManifestUpdate.create = function create(properties) {
            return new CNETMsg_SpawnGroup_ManifestUpdate(properties);
        };
    
        /**
         * Encodes the specified CNETMsg_SpawnGroup_ManifestUpdate message. Does not implicitly {@link CNETMsg_SpawnGroup_ManifestUpdate.verify|verify} messages.
         * @function encode
         * @memberof CNETMsg_SpawnGroup_ManifestUpdate
         * @static
         * @param {ICNETMsg_SpawnGroup_ManifestUpdate} message CNETMsg_SpawnGroup_ManifestUpdate message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CNETMsg_SpawnGroup_ManifestUpdate.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.spawngrouphandle != null && Object.hasOwnProperty.call(message, "spawngrouphandle"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.spawngrouphandle);
            if (message.spawngroupmanifest != null && Object.hasOwnProperty.call(message, "spawngroupmanifest"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.spawngroupmanifest);
            if (message.manifestincomplete != null && Object.hasOwnProperty.call(message, "manifestincomplete"))
                writer.uint32(/* id 3, wireType 0 =*/24).bool(message.manifestincomplete);
            return writer;
        };
    
        /**
         * Encodes the specified CNETMsg_SpawnGroup_ManifestUpdate message, length delimited. Does not implicitly {@link CNETMsg_SpawnGroup_ManifestUpdate.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CNETMsg_SpawnGroup_ManifestUpdate
         * @static
         * @param {ICNETMsg_SpawnGroup_ManifestUpdate} message CNETMsg_SpawnGroup_ManifestUpdate message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CNETMsg_SpawnGroup_ManifestUpdate.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CNETMsg_SpawnGroup_ManifestUpdate message from the specified reader or buffer.
         * @function decode
         * @memberof CNETMsg_SpawnGroup_ManifestUpdate
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CNETMsg_SpawnGroup_ManifestUpdate} CNETMsg_SpawnGroup_ManifestUpdate
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CNETMsg_SpawnGroup_ManifestUpdate.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CNETMsg_SpawnGroup_ManifestUpdate();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.spawngrouphandle = reader.uint32();
                        break;
                    }
                case 2: {
                        message.spawngroupmanifest = reader.bytes();
                        break;
                    }
                case 3: {
                        message.manifestincomplete = reader.bool();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CNETMsg_SpawnGroup_ManifestUpdate message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CNETMsg_SpawnGroup_ManifestUpdate
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CNETMsg_SpawnGroup_ManifestUpdate} CNETMsg_SpawnGroup_ManifestUpdate
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CNETMsg_SpawnGroup_ManifestUpdate.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CNETMsg_SpawnGroup_ManifestUpdate message.
         * @function verify
         * @memberof CNETMsg_SpawnGroup_ManifestUpdate
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CNETMsg_SpawnGroup_ManifestUpdate.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.spawngrouphandle != null && message.hasOwnProperty("spawngrouphandle"))
                if (!$util.isInteger(message.spawngrouphandle))
                    return "spawngrouphandle: integer expected";
            if (message.spawngroupmanifest != null && message.hasOwnProperty("spawngroupmanifest"))
                if (!(message.spawngroupmanifest && typeof message.spawngroupmanifest.length === "number" || $util.isString(message.spawngroupmanifest)))
                    return "spawngroupmanifest: buffer expected";
            if (message.manifestincomplete != null && message.hasOwnProperty("manifestincomplete"))
                if (typeof message.manifestincomplete !== "boolean")
                    return "manifestincomplete: boolean expected";
            return null;
        };
    
        /**
         * Creates a CNETMsg_SpawnGroup_ManifestUpdate message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CNETMsg_SpawnGroup_ManifestUpdate
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CNETMsg_SpawnGroup_ManifestUpdate} CNETMsg_SpawnGroup_ManifestUpdate
         */
        CNETMsg_SpawnGroup_ManifestUpdate.fromObject = function fromObject(object) {
            if (object instanceof $root.CNETMsg_SpawnGroup_ManifestUpdate)
                return object;
            var message = new $root.CNETMsg_SpawnGroup_ManifestUpdate();
            if (object.spawngrouphandle != null)
                message.spawngrouphandle = object.spawngrouphandle >>> 0;
            if (object.spawngroupmanifest != null)
                if (typeof object.spawngroupmanifest === "string")
                    $util.base64.decode(object.spawngroupmanifest, message.spawngroupmanifest = $util.newBuffer($util.base64.length(object.spawngroupmanifest)), 0);
                else if (object.spawngroupmanifest.length >= 0)
                    message.spawngroupmanifest = object.spawngroupmanifest;
            if (object.manifestincomplete != null)
                message.manifestincomplete = Boolean(object.manifestincomplete);
            return message;
        };
    
        /**
         * Creates a plain object from a CNETMsg_SpawnGroup_ManifestUpdate message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CNETMsg_SpawnGroup_ManifestUpdate
         * @static
         * @param {CNETMsg_SpawnGroup_ManifestUpdate} message CNETMsg_SpawnGroup_ManifestUpdate
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CNETMsg_SpawnGroup_ManifestUpdate.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.spawngrouphandle = 0;
                if (options.bytes === String)
                    object.spawngroupmanifest = "";
                else {
                    object.spawngroupmanifest = [];
                    if (options.bytes !== Array)
                        object.spawngroupmanifest = $util.newBuffer(object.spawngroupmanifest);
                }
                object.manifestincomplete = false;
            }
            if (message.spawngrouphandle != null && message.hasOwnProperty("spawngrouphandle"))
                object.spawngrouphandle = message.spawngrouphandle;
            if (message.spawngroupmanifest != null && message.hasOwnProperty("spawngroupmanifest"))
                object.spawngroupmanifest = options.bytes === String ? $util.base64.encode(message.spawngroupmanifest, 0, message.spawngroupmanifest.length) : options.bytes === Array ? Array.prototype.slice.call(message.spawngroupmanifest) : message.spawngroupmanifest;
            if (message.manifestincomplete != null && message.hasOwnProperty("manifestincomplete"))
                object.manifestincomplete = message.manifestincomplete;
            return object;
        };
    
        /**
         * Converts this CNETMsg_SpawnGroup_ManifestUpdate to JSON.
         * @function toJSON
         * @memberof CNETMsg_SpawnGroup_ManifestUpdate
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CNETMsg_SpawnGroup_ManifestUpdate.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * Gets the default type url for CNETMsg_SpawnGroup_ManifestUpdate
         * @function getTypeUrl
         * @memberof CNETMsg_SpawnGroup_ManifestUpdate
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        CNETMsg_SpawnGroup_ManifestUpdate.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/CNETMsg_SpawnGroup_ManifestUpdate";
        };
    
        return CNETMsg_SpawnGroup_ManifestUpdate;
    })();
    
    $root.CNETMsg_SpawnGroup_SetCreationTick = (function() {
    
        /**
         * Properties of a CNETMsg_SpawnGroup_SetCreationTick.
         * @exports ICNETMsg_SpawnGroup_SetCreationTick
         * @interface ICNETMsg_SpawnGroup_SetCreationTick
         * @property {number|null} [spawngrouphandle] CNETMsg_SpawnGroup_SetCreationTick spawngrouphandle
         * @property {number|null} [tickcount] CNETMsg_SpawnGroup_SetCreationTick tickcount
         * @property {number|null} [creationsequence] CNETMsg_SpawnGroup_SetCreationTick creationsequence
         */
    
        /**
         * Constructs a new CNETMsg_SpawnGroup_SetCreationTick.
         * @exports CNETMsg_SpawnGroup_SetCreationTick
         * @classdesc Represents a CNETMsg_SpawnGroup_SetCreationTick.
         * @implements ICNETMsg_SpawnGroup_SetCreationTick
         * @constructor
         * @param {ICNETMsg_SpawnGroup_SetCreationTick=} [properties] Properties to set
         */
        function CNETMsg_SpawnGroup_SetCreationTick(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CNETMsg_SpawnGroup_SetCreationTick spawngrouphandle.
         * @member {number} spawngrouphandle
         * @memberof CNETMsg_SpawnGroup_SetCreationTick
         * @instance
         */
        CNETMsg_SpawnGroup_SetCreationTick.prototype.spawngrouphandle = 0;
    
        /**
         * CNETMsg_SpawnGroup_SetCreationTick tickcount.
         * @member {number} tickcount
         * @memberof CNETMsg_SpawnGroup_SetCreationTick
         * @instance
         */
        CNETMsg_SpawnGroup_SetCreationTick.prototype.tickcount = 0;
    
        /**
         * CNETMsg_SpawnGroup_SetCreationTick creationsequence.
         * @member {number} creationsequence
         * @memberof CNETMsg_SpawnGroup_SetCreationTick
         * @instance
         */
        CNETMsg_SpawnGroup_SetCreationTick.prototype.creationsequence = 0;
    
        /**
         * Creates a new CNETMsg_SpawnGroup_SetCreationTick instance using the specified properties.
         * @function create
         * @memberof CNETMsg_SpawnGroup_SetCreationTick
         * @static
         * @param {ICNETMsg_SpawnGroup_SetCreationTick=} [properties] Properties to set
         * @returns {CNETMsg_SpawnGroup_SetCreationTick} CNETMsg_SpawnGroup_SetCreationTick instance
         */
        CNETMsg_SpawnGroup_SetCreationTick.create = function create(properties) {
            return new CNETMsg_SpawnGroup_SetCreationTick(properties);
        };
    
        /**
         * Encodes the specified CNETMsg_SpawnGroup_SetCreationTick message. Does not implicitly {@link CNETMsg_SpawnGroup_SetCreationTick.verify|verify} messages.
         * @function encode
         * @memberof CNETMsg_SpawnGroup_SetCreationTick
         * @static
         * @param {ICNETMsg_SpawnGroup_SetCreationTick} message CNETMsg_SpawnGroup_SetCreationTick message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CNETMsg_SpawnGroup_SetCreationTick.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.spawngrouphandle != null && Object.hasOwnProperty.call(message, "spawngrouphandle"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.spawngrouphandle);
            if (message.tickcount != null && Object.hasOwnProperty.call(message, "tickcount"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.tickcount);
            if (message.creationsequence != null && Object.hasOwnProperty.call(message, "creationsequence"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.creationsequence);
            return writer;
        };
    
        /**
         * Encodes the specified CNETMsg_SpawnGroup_SetCreationTick message, length delimited. Does not implicitly {@link CNETMsg_SpawnGroup_SetCreationTick.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CNETMsg_SpawnGroup_SetCreationTick
         * @static
         * @param {ICNETMsg_SpawnGroup_SetCreationTick} message CNETMsg_SpawnGroup_SetCreationTick message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CNETMsg_SpawnGroup_SetCreationTick.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CNETMsg_SpawnGroup_SetCreationTick message from the specified reader or buffer.
         * @function decode
         * @memberof CNETMsg_SpawnGroup_SetCreationTick
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CNETMsg_SpawnGroup_SetCreationTick} CNETMsg_SpawnGroup_SetCreationTick
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CNETMsg_SpawnGroup_SetCreationTick.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CNETMsg_SpawnGroup_SetCreationTick();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.spawngrouphandle = reader.uint32();
                        break;
                    }
                case 2: {
                        message.tickcount = reader.int32();
                        break;
                    }
                case 3: {
                        message.creationsequence = reader.uint32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CNETMsg_SpawnGroup_SetCreationTick message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CNETMsg_SpawnGroup_SetCreationTick
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CNETMsg_SpawnGroup_SetCreationTick} CNETMsg_SpawnGroup_SetCreationTick
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CNETMsg_SpawnGroup_SetCreationTick.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CNETMsg_SpawnGroup_SetCreationTick message.
         * @function verify
         * @memberof CNETMsg_SpawnGroup_SetCreationTick
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CNETMsg_SpawnGroup_SetCreationTick.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.spawngrouphandle != null && message.hasOwnProperty("spawngrouphandle"))
                if (!$util.isInteger(message.spawngrouphandle))
                    return "spawngrouphandle: integer expected";
            if (message.tickcount != null && message.hasOwnProperty("tickcount"))
                if (!$util.isInteger(message.tickcount))
                    return "tickcount: integer expected";
            if (message.creationsequence != null && message.hasOwnProperty("creationsequence"))
                if (!$util.isInteger(message.creationsequence))
                    return "creationsequence: integer expected";
            return null;
        };
    
        /**
         * Creates a CNETMsg_SpawnGroup_SetCreationTick message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CNETMsg_SpawnGroup_SetCreationTick
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CNETMsg_SpawnGroup_SetCreationTick} CNETMsg_SpawnGroup_SetCreationTick
         */
        CNETMsg_SpawnGroup_SetCreationTick.fromObject = function fromObject(object) {
            if (object instanceof $root.CNETMsg_SpawnGroup_SetCreationTick)
                return object;
            var message = new $root.CNETMsg_SpawnGroup_SetCreationTick();
            if (object.spawngrouphandle != null)
                message.spawngrouphandle = object.spawngrouphandle >>> 0;
            if (object.tickcount != null)
                message.tickcount = object.tickcount | 0;
            if (object.creationsequence != null)
                message.creationsequence = object.creationsequence >>> 0;
            return message;
        };
    
        /**
         * Creates a plain object from a CNETMsg_SpawnGroup_SetCreationTick message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CNETMsg_SpawnGroup_SetCreationTick
         * @static
         * @param {CNETMsg_SpawnGroup_SetCreationTick} message CNETMsg_SpawnGroup_SetCreationTick
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CNETMsg_SpawnGroup_SetCreationTick.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.spawngrouphandle = 0;
                object.tickcount = 0;
                object.creationsequence = 0;
            }
            if (message.spawngrouphandle != null && message.hasOwnProperty("spawngrouphandle"))
                object.spawngrouphandle = message.spawngrouphandle;
            if (message.tickcount != null && message.hasOwnProperty("tickcount"))
                object.tickcount = message.tickcount;
            if (message.creationsequence != null && message.hasOwnProperty("creationsequence"))
                object.creationsequence = message.creationsequence;
            return object;
        };
    
        /**
         * Converts this CNETMsg_SpawnGroup_SetCreationTick to JSON.
         * @function toJSON
         * @memberof CNETMsg_SpawnGroup_SetCreationTick
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CNETMsg_SpawnGroup_SetCreationTick.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * Gets the default type url for CNETMsg_SpawnGroup_SetCreationTick
         * @function getTypeUrl
         * @memberof CNETMsg_SpawnGroup_SetCreationTick
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        CNETMsg_SpawnGroup_SetCreationTick.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/CNETMsg_SpawnGroup_SetCreationTick";
        };
    
        return CNETMsg_SpawnGroup_SetCreationTick;
    })();
    
    $root.CNETMsg_SpawnGroup_Unload = (function() {
    
        /**
         * Properties of a CNETMsg_SpawnGroup_Unload.
         * @exports ICNETMsg_SpawnGroup_Unload
         * @interface ICNETMsg_SpawnGroup_Unload
         * @property {number|null} [spawngrouphandle] CNETMsg_SpawnGroup_Unload spawngrouphandle
         * @property {number|null} [flags] CNETMsg_SpawnGroup_Unload flags
         * @property {number|null} [tickcount] CNETMsg_SpawnGroup_Unload tickcount
         */
    
        /**
         * Constructs a new CNETMsg_SpawnGroup_Unload.
         * @exports CNETMsg_SpawnGroup_Unload
         * @classdesc Represents a CNETMsg_SpawnGroup_Unload.
         * @implements ICNETMsg_SpawnGroup_Unload
         * @constructor
         * @param {ICNETMsg_SpawnGroup_Unload=} [properties] Properties to set
         */
        function CNETMsg_SpawnGroup_Unload(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CNETMsg_SpawnGroup_Unload spawngrouphandle.
         * @member {number} spawngrouphandle
         * @memberof CNETMsg_SpawnGroup_Unload
         * @instance
         */
        CNETMsg_SpawnGroup_Unload.prototype.spawngrouphandle = 0;
    
        /**
         * CNETMsg_SpawnGroup_Unload flags.
         * @member {number} flags
         * @memberof CNETMsg_SpawnGroup_Unload
         * @instance
         */
        CNETMsg_SpawnGroup_Unload.prototype.flags = 0;
    
        /**
         * CNETMsg_SpawnGroup_Unload tickcount.
         * @member {number} tickcount
         * @memberof CNETMsg_SpawnGroup_Unload
         * @instance
         */
        CNETMsg_SpawnGroup_Unload.prototype.tickcount = 0;
    
        /**
         * Creates a new CNETMsg_SpawnGroup_Unload instance using the specified properties.
         * @function create
         * @memberof CNETMsg_SpawnGroup_Unload
         * @static
         * @param {ICNETMsg_SpawnGroup_Unload=} [properties] Properties to set
         * @returns {CNETMsg_SpawnGroup_Unload} CNETMsg_SpawnGroup_Unload instance
         */
        CNETMsg_SpawnGroup_Unload.create = function create(properties) {
            return new CNETMsg_SpawnGroup_Unload(properties);
        };
    
        /**
         * Encodes the specified CNETMsg_SpawnGroup_Unload message. Does not implicitly {@link CNETMsg_SpawnGroup_Unload.verify|verify} messages.
         * @function encode
         * @memberof CNETMsg_SpawnGroup_Unload
         * @static
         * @param {ICNETMsg_SpawnGroup_Unload} message CNETMsg_SpawnGroup_Unload message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CNETMsg_SpawnGroup_Unload.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.spawngrouphandle != null && Object.hasOwnProperty.call(message, "spawngrouphandle"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.spawngrouphandle);
            if (message.flags != null && Object.hasOwnProperty.call(message, "flags"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.flags);
            if (message.tickcount != null && Object.hasOwnProperty.call(message, "tickcount"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.tickcount);
            return writer;
        };
    
        /**
         * Encodes the specified CNETMsg_SpawnGroup_Unload message, length delimited. Does not implicitly {@link CNETMsg_SpawnGroup_Unload.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CNETMsg_SpawnGroup_Unload
         * @static
         * @param {ICNETMsg_SpawnGroup_Unload} message CNETMsg_SpawnGroup_Unload message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CNETMsg_SpawnGroup_Unload.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CNETMsg_SpawnGroup_Unload message from the specified reader or buffer.
         * @function decode
         * @memberof CNETMsg_SpawnGroup_Unload
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CNETMsg_SpawnGroup_Unload} CNETMsg_SpawnGroup_Unload
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CNETMsg_SpawnGroup_Unload.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CNETMsg_SpawnGroup_Unload();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.spawngrouphandle = reader.uint32();
                        break;
                    }
                case 2: {
                        message.flags = reader.uint32();
                        break;
                    }
                case 3: {
                        message.tickcount = reader.int32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CNETMsg_SpawnGroup_Unload message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CNETMsg_SpawnGroup_Unload
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CNETMsg_SpawnGroup_Unload} CNETMsg_SpawnGroup_Unload
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CNETMsg_SpawnGroup_Unload.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CNETMsg_SpawnGroup_Unload message.
         * @function verify
         * @memberof CNETMsg_SpawnGroup_Unload
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CNETMsg_SpawnGroup_Unload.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.spawngrouphandle != null && message.hasOwnProperty("spawngrouphandle"))
                if (!$util.isInteger(message.spawngrouphandle))
                    return "spawngrouphandle: integer expected";
            if (message.flags != null && message.hasOwnProperty("flags"))
                if (!$util.isInteger(message.flags))
                    return "flags: integer expected";
            if (message.tickcount != null && message.hasOwnProperty("tickcount"))
                if (!$util.isInteger(message.tickcount))
                    return "tickcount: integer expected";
            return null;
        };
    
        /**
         * Creates a CNETMsg_SpawnGroup_Unload message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CNETMsg_SpawnGroup_Unload
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CNETMsg_SpawnGroup_Unload} CNETMsg_SpawnGroup_Unload
         */
        CNETMsg_SpawnGroup_Unload.fromObject = function fromObject(object) {
            if (object instanceof $root.CNETMsg_SpawnGroup_Unload)
                return object;
            var message = new $root.CNETMsg_SpawnGroup_Unload();
            if (object.spawngrouphandle != null)
                message.spawngrouphandle = object.spawngrouphandle >>> 0;
            if (object.flags != null)
                message.flags = object.flags >>> 0;
            if (object.tickcount != null)
                message.tickcount = object.tickcount | 0;
            return message;
        };
    
        /**
         * Creates a plain object from a CNETMsg_SpawnGroup_Unload message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CNETMsg_SpawnGroup_Unload
         * @static
         * @param {CNETMsg_SpawnGroup_Unload} message CNETMsg_SpawnGroup_Unload
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CNETMsg_SpawnGroup_Unload.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.spawngrouphandle = 0;
                object.flags = 0;
                object.tickcount = 0;
            }
            if (message.spawngrouphandle != null && message.hasOwnProperty("spawngrouphandle"))
                object.spawngrouphandle = message.spawngrouphandle;
            if (message.flags != null && message.hasOwnProperty("flags"))
                object.flags = message.flags;
            if (message.tickcount != null && message.hasOwnProperty("tickcount"))
                object.tickcount = message.tickcount;
            return object;
        };
    
        /**
         * Converts this CNETMsg_SpawnGroup_Unload to JSON.
         * @function toJSON
         * @memberof CNETMsg_SpawnGroup_Unload
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CNETMsg_SpawnGroup_Unload.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * Gets the default type url for CNETMsg_SpawnGroup_Unload
         * @function getTypeUrl
         * @memberof CNETMsg_SpawnGroup_Unload
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        CNETMsg_SpawnGroup_Unload.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/CNETMsg_SpawnGroup_Unload";
        };
    
        return CNETMsg_SpawnGroup_Unload;
    })();
    
    $root.CNETMsg_SpawnGroup_LoadCompleted = (function() {
    
        /**
         * Properties of a CNETMsg_SpawnGroup_LoadCompleted.
         * @exports ICNETMsg_SpawnGroup_LoadCompleted
         * @interface ICNETMsg_SpawnGroup_LoadCompleted
         * @property {number|null} [spawngrouphandle] CNETMsg_SpawnGroup_LoadCompleted spawngrouphandle
         */
    
        /**
         * Constructs a new CNETMsg_SpawnGroup_LoadCompleted.
         * @exports CNETMsg_SpawnGroup_LoadCompleted
         * @classdesc Represents a CNETMsg_SpawnGroup_LoadCompleted.
         * @implements ICNETMsg_SpawnGroup_LoadCompleted
         * @constructor
         * @param {ICNETMsg_SpawnGroup_LoadCompleted=} [properties] Properties to set
         */
        function CNETMsg_SpawnGroup_LoadCompleted(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CNETMsg_SpawnGroup_LoadCompleted spawngrouphandle.
         * @member {number} spawngrouphandle
         * @memberof CNETMsg_SpawnGroup_LoadCompleted
         * @instance
         */
        CNETMsg_SpawnGroup_LoadCompleted.prototype.spawngrouphandle = 0;
    
        /**
         * Creates a new CNETMsg_SpawnGroup_LoadCompleted instance using the specified properties.
         * @function create
         * @memberof CNETMsg_SpawnGroup_LoadCompleted
         * @static
         * @param {ICNETMsg_SpawnGroup_LoadCompleted=} [properties] Properties to set
         * @returns {CNETMsg_SpawnGroup_LoadCompleted} CNETMsg_SpawnGroup_LoadCompleted instance
         */
        CNETMsg_SpawnGroup_LoadCompleted.create = function create(properties) {
            return new CNETMsg_SpawnGroup_LoadCompleted(properties);
        };
    
        /**
         * Encodes the specified CNETMsg_SpawnGroup_LoadCompleted message. Does not implicitly {@link CNETMsg_SpawnGroup_LoadCompleted.verify|verify} messages.
         * @function encode
         * @memberof CNETMsg_SpawnGroup_LoadCompleted
         * @static
         * @param {ICNETMsg_SpawnGroup_LoadCompleted} message CNETMsg_SpawnGroup_LoadCompleted message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CNETMsg_SpawnGroup_LoadCompleted.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.spawngrouphandle != null && Object.hasOwnProperty.call(message, "spawngrouphandle"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.spawngrouphandle);
            return writer;
        };
    
        /**
         * Encodes the specified CNETMsg_SpawnGroup_LoadCompleted message, length delimited. Does not implicitly {@link CNETMsg_SpawnGroup_LoadCompleted.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CNETMsg_SpawnGroup_LoadCompleted
         * @static
         * @param {ICNETMsg_SpawnGroup_LoadCompleted} message CNETMsg_SpawnGroup_LoadCompleted message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CNETMsg_SpawnGroup_LoadCompleted.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CNETMsg_SpawnGroup_LoadCompleted message from the specified reader or buffer.
         * @function decode
         * @memberof CNETMsg_SpawnGroup_LoadCompleted
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CNETMsg_SpawnGroup_LoadCompleted} CNETMsg_SpawnGroup_LoadCompleted
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CNETMsg_SpawnGroup_LoadCompleted.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CNETMsg_SpawnGroup_LoadCompleted();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.spawngrouphandle = reader.uint32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CNETMsg_SpawnGroup_LoadCompleted message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CNETMsg_SpawnGroup_LoadCompleted
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CNETMsg_SpawnGroup_LoadCompleted} CNETMsg_SpawnGroup_LoadCompleted
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CNETMsg_SpawnGroup_LoadCompleted.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CNETMsg_SpawnGroup_LoadCompleted message.
         * @function verify
         * @memberof CNETMsg_SpawnGroup_LoadCompleted
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CNETMsg_SpawnGroup_LoadCompleted.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.spawngrouphandle != null && message.hasOwnProperty("spawngrouphandle"))
                if (!$util.isInteger(message.spawngrouphandle))
                    return "spawngrouphandle: integer expected";
            return null;
        };
    
        /**
         * Creates a CNETMsg_SpawnGroup_LoadCompleted message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CNETMsg_SpawnGroup_LoadCompleted
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CNETMsg_SpawnGroup_LoadCompleted} CNETMsg_SpawnGroup_LoadCompleted
         */
        CNETMsg_SpawnGroup_LoadCompleted.fromObject = function fromObject(object) {
            if (object instanceof $root.CNETMsg_SpawnGroup_LoadCompleted)
                return object;
            var message = new $root.CNETMsg_SpawnGroup_LoadCompleted();
            if (object.spawngrouphandle != null)
                message.spawngrouphandle = object.spawngrouphandle >>> 0;
            return message;
        };
    
        /**
         * Creates a plain object from a CNETMsg_SpawnGroup_LoadCompleted message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CNETMsg_SpawnGroup_LoadCompleted
         * @static
         * @param {CNETMsg_SpawnGroup_LoadCompleted} message CNETMsg_SpawnGroup_LoadCompleted
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CNETMsg_SpawnGroup_LoadCompleted.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.spawngrouphandle = 0;
            if (message.spawngrouphandle != null && message.hasOwnProperty("spawngrouphandle"))
                object.spawngrouphandle = message.spawngrouphandle;
            return object;
        };
    
        /**
         * Converts this CNETMsg_SpawnGroup_LoadCompleted to JSON.
         * @function toJSON
         * @memberof CNETMsg_SpawnGroup_LoadCompleted
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CNETMsg_SpawnGroup_LoadCompleted.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * Gets the default type url for CNETMsg_SpawnGroup_LoadCompleted
         * @function getTypeUrl
         * @memberof CNETMsg_SpawnGroup_LoadCompleted
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        CNETMsg_SpawnGroup_LoadCompleted.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/CNETMsg_SpawnGroup_LoadCompleted";
        };
    
        return CNETMsg_SpawnGroup_LoadCompleted;
    })();
    
    $root.CSVCMsg_GameSessionConfiguration = (function() {
    
        /**
         * Properties of a CSVCMsg_GameSessionConfiguration.
         * @exports ICSVCMsg_GameSessionConfiguration
         * @interface ICSVCMsg_GameSessionConfiguration
         * @property {boolean|null} [isMultiplayer] CSVCMsg_GameSessionConfiguration isMultiplayer
         * @property {boolean|null} [isLoadsavegame] CSVCMsg_GameSessionConfiguration isLoadsavegame
         * @property {boolean|null} [isBackgroundMap] CSVCMsg_GameSessionConfiguration isBackgroundMap
         * @property {boolean|null} [isHeadless] CSVCMsg_GameSessionConfiguration isHeadless
         * @property {number|null} [minClientLimit] CSVCMsg_GameSessionConfiguration minClientLimit
         * @property {number|null} [maxClientLimit] CSVCMsg_GameSessionConfiguration maxClientLimit
         * @property {number|null} [maxClients] CSVCMsg_GameSessionConfiguration maxClients
         * @property {number|null} [tickInterval] CSVCMsg_GameSessionConfiguration tickInterval
         * @property {string|null} [hostname] CSVCMsg_GameSessionConfiguration hostname
         * @property {string|null} [savegamename] CSVCMsg_GameSessionConfiguration savegamename
         * @property {string|null} [s1Mapname] CSVCMsg_GameSessionConfiguration s1Mapname
         * @property {string|null} [gamemode] CSVCMsg_GameSessionConfiguration gamemode
         * @property {string|null} [serverIpAddress] CSVCMsg_GameSessionConfiguration serverIpAddress
         * @property {Uint8Array|null} [data] CSVCMsg_GameSessionConfiguration data
         * @property {boolean|null} [isLocalonly] CSVCMsg_GameSessionConfiguration isLocalonly
         * @property {boolean|null} [noSteamServer] CSVCMsg_GameSessionConfiguration noSteamServer
         * @property {boolean|null} [isTransition] CSVCMsg_GameSessionConfiguration isTransition
         * @property {string|null} [previouslevel] CSVCMsg_GameSessionConfiguration previouslevel
         * @property {string|null} [landmarkname] CSVCMsg_GameSessionConfiguration landmarkname
         */
    
        /**
         * Constructs a new CSVCMsg_GameSessionConfiguration.
         * @exports CSVCMsg_GameSessionConfiguration
         * @classdesc Represents a CSVCMsg_GameSessionConfiguration.
         * @implements ICSVCMsg_GameSessionConfiguration
         * @constructor
         * @param {ICSVCMsg_GameSessionConfiguration=} [properties] Properties to set
         */
        function CSVCMsg_GameSessionConfiguration(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CSVCMsg_GameSessionConfiguration isMultiplayer.
         * @member {boolean} isMultiplayer
         * @memberof CSVCMsg_GameSessionConfiguration
         * @instance
         */
        CSVCMsg_GameSessionConfiguration.prototype.isMultiplayer = false;
    
        /**
         * CSVCMsg_GameSessionConfiguration isLoadsavegame.
         * @member {boolean} isLoadsavegame
         * @memberof CSVCMsg_GameSessionConfiguration
         * @instance
         */
        CSVCMsg_GameSessionConfiguration.prototype.isLoadsavegame = false;
    
        /**
         * CSVCMsg_GameSessionConfiguration isBackgroundMap.
         * @member {boolean} isBackgroundMap
         * @memberof CSVCMsg_GameSessionConfiguration
         * @instance
         */
        CSVCMsg_GameSessionConfiguration.prototype.isBackgroundMap = false;
    
        /**
         * CSVCMsg_GameSessionConfiguration isHeadless.
         * @member {boolean} isHeadless
         * @memberof CSVCMsg_GameSessionConfiguration
         * @instance
         */
        CSVCMsg_GameSessionConfiguration.prototype.isHeadless = false;
    
        /**
         * CSVCMsg_GameSessionConfiguration minClientLimit.
         * @member {number} minClientLimit
         * @memberof CSVCMsg_GameSessionConfiguration
         * @instance
         */
        CSVCMsg_GameSessionConfiguration.prototype.minClientLimit = 0;
    
        /**
         * CSVCMsg_GameSessionConfiguration maxClientLimit.
         * @member {number} maxClientLimit
         * @memberof CSVCMsg_GameSessionConfiguration
         * @instance
         */
        CSVCMsg_GameSessionConfiguration.prototype.maxClientLimit = 0;
    
        /**
         * CSVCMsg_GameSessionConfiguration maxClients.
         * @member {number} maxClients
         * @memberof CSVCMsg_GameSessionConfiguration
         * @instance
         */
        CSVCMsg_GameSessionConfiguration.prototype.maxClients = 0;
    
        /**
         * CSVCMsg_GameSessionConfiguration tickInterval.
         * @member {number} tickInterval
         * @memberof CSVCMsg_GameSessionConfiguration
         * @instance
         */
        CSVCMsg_GameSessionConfiguration.prototype.tickInterval = 0;
    
        /**
         * CSVCMsg_GameSessionConfiguration hostname.
         * @member {string} hostname
         * @memberof CSVCMsg_GameSessionConfiguration
         * @instance
         */
        CSVCMsg_GameSessionConfiguration.prototype.hostname = "";
    
        /**
         * CSVCMsg_GameSessionConfiguration savegamename.
         * @member {string} savegamename
         * @memberof CSVCMsg_GameSessionConfiguration
         * @instance
         */
        CSVCMsg_GameSessionConfiguration.prototype.savegamename = "";
    
        /**
         * CSVCMsg_GameSessionConfiguration s1Mapname.
         * @member {string} s1Mapname
         * @memberof CSVCMsg_GameSessionConfiguration
         * @instance
         */
        CSVCMsg_GameSessionConfiguration.prototype.s1Mapname = "";
    
        /**
         * CSVCMsg_GameSessionConfiguration gamemode.
         * @member {string} gamemode
         * @memberof CSVCMsg_GameSessionConfiguration
         * @instance
         */
        CSVCMsg_GameSessionConfiguration.prototype.gamemode = "";
    
        /**
         * CSVCMsg_GameSessionConfiguration serverIpAddress.
         * @member {string} serverIpAddress
         * @memberof CSVCMsg_GameSessionConfiguration
         * @instance
         */
        CSVCMsg_GameSessionConfiguration.prototype.serverIpAddress = "";
    
        /**
         * CSVCMsg_GameSessionConfiguration data.
         * @member {Uint8Array} data
         * @memberof CSVCMsg_GameSessionConfiguration
         * @instance
         */
        CSVCMsg_GameSessionConfiguration.prototype.data = $util.newBuffer([]);
    
        /**
         * CSVCMsg_GameSessionConfiguration isLocalonly.
         * @member {boolean} isLocalonly
         * @memberof CSVCMsg_GameSessionConfiguration
         * @instance
         */
        CSVCMsg_GameSessionConfiguration.prototype.isLocalonly = false;
    
        /**
         * CSVCMsg_GameSessionConfiguration noSteamServer.
         * @member {boolean} noSteamServer
         * @memberof CSVCMsg_GameSessionConfiguration
         * @instance
         */
        CSVCMsg_GameSessionConfiguration.prototype.noSteamServer = false;
    
        /**
         * CSVCMsg_GameSessionConfiguration isTransition.
         * @member {boolean} isTransition
         * @memberof CSVCMsg_GameSessionConfiguration
         * @instance
         */
        CSVCMsg_GameSessionConfiguration.prototype.isTransition = false;
    
        /**
         * CSVCMsg_GameSessionConfiguration previouslevel.
         * @member {string} previouslevel
         * @memberof CSVCMsg_GameSessionConfiguration
         * @instance
         */
        CSVCMsg_GameSessionConfiguration.prototype.previouslevel = "";
    
        /**
         * CSVCMsg_GameSessionConfiguration landmarkname.
         * @member {string} landmarkname
         * @memberof CSVCMsg_GameSessionConfiguration
         * @instance
         */
        CSVCMsg_GameSessionConfiguration.prototype.landmarkname = "";
    
        /**
         * Creates a new CSVCMsg_GameSessionConfiguration instance using the specified properties.
         * @function create
         * @memberof CSVCMsg_GameSessionConfiguration
         * @static
         * @param {ICSVCMsg_GameSessionConfiguration=} [properties] Properties to set
         * @returns {CSVCMsg_GameSessionConfiguration} CSVCMsg_GameSessionConfiguration instance
         */
        CSVCMsg_GameSessionConfiguration.create = function create(properties) {
            return new CSVCMsg_GameSessionConfiguration(properties);
        };
    
        /**
         * Encodes the specified CSVCMsg_GameSessionConfiguration message. Does not implicitly {@link CSVCMsg_GameSessionConfiguration.verify|verify} messages.
         * @function encode
         * @memberof CSVCMsg_GameSessionConfiguration
         * @static
         * @param {ICSVCMsg_GameSessionConfiguration} message CSVCMsg_GameSessionConfiguration message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CSVCMsg_GameSessionConfiguration.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.isMultiplayer != null && Object.hasOwnProperty.call(message, "isMultiplayer"))
                writer.uint32(/* id 1, wireType 0 =*/8).bool(message.isMultiplayer);
            if (message.isLoadsavegame != null && Object.hasOwnProperty.call(message, "isLoadsavegame"))
                writer.uint32(/* id 2, wireType 0 =*/16).bool(message.isLoadsavegame);
            if (message.isBackgroundMap != null && Object.hasOwnProperty.call(message, "isBackgroundMap"))
                writer.uint32(/* id 3, wireType 0 =*/24).bool(message.isBackgroundMap);
            if (message.isHeadless != null && Object.hasOwnProperty.call(message, "isHeadless"))
                writer.uint32(/* id 4, wireType 0 =*/32).bool(message.isHeadless);
            if (message.minClientLimit != null && Object.hasOwnProperty.call(message, "minClientLimit"))
                writer.uint32(/* id 5, wireType 0 =*/40).uint32(message.minClientLimit);
            if (message.maxClientLimit != null && Object.hasOwnProperty.call(message, "maxClientLimit"))
                writer.uint32(/* id 6, wireType 0 =*/48).uint32(message.maxClientLimit);
            if (message.maxClients != null && Object.hasOwnProperty.call(message, "maxClients"))
                writer.uint32(/* id 7, wireType 0 =*/56).uint32(message.maxClients);
            if (message.tickInterval != null && Object.hasOwnProperty.call(message, "tickInterval"))
                writer.uint32(/* id 8, wireType 5 =*/69).fixed32(message.tickInterval);
            if (message.hostname != null && Object.hasOwnProperty.call(message, "hostname"))
                writer.uint32(/* id 9, wireType 2 =*/74).string(message.hostname);
            if (message.savegamename != null && Object.hasOwnProperty.call(message, "savegamename"))
                writer.uint32(/* id 10, wireType 2 =*/82).string(message.savegamename);
            if (message.s1Mapname != null && Object.hasOwnProperty.call(message, "s1Mapname"))
                writer.uint32(/* id 11, wireType 2 =*/90).string(message.s1Mapname);
            if (message.gamemode != null && Object.hasOwnProperty.call(message, "gamemode"))
                writer.uint32(/* id 12, wireType 2 =*/98).string(message.gamemode);
            if (message.serverIpAddress != null && Object.hasOwnProperty.call(message, "serverIpAddress"))
                writer.uint32(/* id 13, wireType 2 =*/106).string(message.serverIpAddress);
            if (message.data != null && Object.hasOwnProperty.call(message, "data"))
                writer.uint32(/* id 14, wireType 2 =*/114).bytes(message.data);
            if (message.isLocalonly != null && Object.hasOwnProperty.call(message, "isLocalonly"))
                writer.uint32(/* id 15, wireType 0 =*/120).bool(message.isLocalonly);
            if (message.isTransition != null && Object.hasOwnProperty.call(message, "isTransition"))
                writer.uint32(/* id 16, wireType 0 =*/128).bool(message.isTransition);
            if (message.previouslevel != null && Object.hasOwnProperty.call(message, "previouslevel"))
                writer.uint32(/* id 17, wireType 2 =*/138).string(message.previouslevel);
            if (message.landmarkname != null && Object.hasOwnProperty.call(message, "landmarkname"))
                writer.uint32(/* id 18, wireType 2 =*/146).string(message.landmarkname);
            if (message.noSteamServer != null && Object.hasOwnProperty.call(message, "noSteamServer"))
                writer.uint32(/* id 19, wireType 0 =*/152).bool(message.noSteamServer);
            return writer;
        };
    
        /**
         * Encodes the specified CSVCMsg_GameSessionConfiguration message, length delimited. Does not implicitly {@link CSVCMsg_GameSessionConfiguration.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CSVCMsg_GameSessionConfiguration
         * @static
         * @param {ICSVCMsg_GameSessionConfiguration} message CSVCMsg_GameSessionConfiguration message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CSVCMsg_GameSessionConfiguration.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CSVCMsg_GameSessionConfiguration message from the specified reader or buffer.
         * @function decode
         * @memberof CSVCMsg_GameSessionConfiguration
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CSVCMsg_GameSessionConfiguration} CSVCMsg_GameSessionConfiguration
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CSVCMsg_GameSessionConfiguration.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CSVCMsg_GameSessionConfiguration();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.isMultiplayer = reader.bool();
                        break;
                    }
                case 2: {
                        message.isLoadsavegame = reader.bool();
                        break;
                    }
                case 3: {
                        message.isBackgroundMap = reader.bool();
                        break;
                    }
                case 4: {
                        message.isHeadless = reader.bool();
                        break;
                    }
                case 5: {
                        message.minClientLimit = reader.uint32();
                        break;
                    }
                case 6: {
                        message.maxClientLimit = reader.uint32();
                        break;
                    }
                case 7: {
                        message.maxClients = reader.uint32();
                        break;
                    }
                case 8: {
                        message.tickInterval = reader.fixed32();
                        break;
                    }
                case 9: {
                        message.hostname = reader.string();
                        break;
                    }
                case 10: {
                        message.savegamename = reader.string();
                        break;
                    }
                case 11: {
                        message.s1Mapname = reader.string();
                        break;
                    }
                case 12: {
                        message.gamemode = reader.string();
                        break;
                    }
                case 13: {
                        message.serverIpAddress = reader.string();
                        break;
                    }
                case 14: {
                        message.data = reader.bytes();
                        break;
                    }
                case 15: {
                        message.isLocalonly = reader.bool();
                        break;
                    }
                case 19: {
                        message.noSteamServer = reader.bool();
                        break;
                    }
                case 16: {
                        message.isTransition = reader.bool();
                        break;
                    }
                case 17: {
                        message.previouslevel = reader.string();
                        break;
                    }
                case 18: {
                        message.landmarkname = reader.string();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CSVCMsg_GameSessionConfiguration message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CSVCMsg_GameSessionConfiguration
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CSVCMsg_GameSessionConfiguration} CSVCMsg_GameSessionConfiguration
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CSVCMsg_GameSessionConfiguration.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CSVCMsg_GameSessionConfiguration message.
         * @function verify
         * @memberof CSVCMsg_GameSessionConfiguration
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CSVCMsg_GameSessionConfiguration.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.isMultiplayer != null && message.hasOwnProperty("isMultiplayer"))
                if (typeof message.isMultiplayer !== "boolean")
                    return "isMultiplayer: boolean expected";
            if (message.isLoadsavegame != null && message.hasOwnProperty("isLoadsavegame"))
                if (typeof message.isLoadsavegame !== "boolean")
                    return "isLoadsavegame: boolean expected";
            if (message.isBackgroundMap != null && message.hasOwnProperty("isBackgroundMap"))
                if (typeof message.isBackgroundMap !== "boolean")
                    return "isBackgroundMap: boolean expected";
            if (message.isHeadless != null && message.hasOwnProperty("isHeadless"))
                if (typeof message.isHeadless !== "boolean")
                    return "isHeadless: boolean expected";
            if (message.minClientLimit != null && message.hasOwnProperty("minClientLimit"))
                if (!$util.isInteger(message.minClientLimit))
                    return "minClientLimit: integer expected";
            if (message.maxClientLimit != null && message.hasOwnProperty("maxClientLimit"))
                if (!$util.isInteger(message.maxClientLimit))
                    return "maxClientLimit: integer expected";
            if (message.maxClients != null && message.hasOwnProperty("maxClients"))
                if (!$util.isInteger(message.maxClients))
                    return "maxClients: integer expected";
            if (message.tickInterval != null && message.hasOwnProperty("tickInterval"))
                if (!$util.isInteger(message.tickInterval))
                    return "tickInterval: integer expected";
            if (message.hostname != null && message.hasOwnProperty("hostname"))
                if (!$util.isString(message.hostname))
                    return "hostname: string expected";
            if (message.savegamename != null && message.hasOwnProperty("savegamename"))
                if (!$util.isString(message.savegamename))
                    return "savegamename: string expected";
            if (message.s1Mapname != null && message.hasOwnProperty("s1Mapname"))
                if (!$util.isString(message.s1Mapname))
                    return "s1Mapname: string expected";
            if (message.gamemode != null && message.hasOwnProperty("gamemode"))
                if (!$util.isString(message.gamemode))
                    return "gamemode: string expected";
            if (message.serverIpAddress != null && message.hasOwnProperty("serverIpAddress"))
                if (!$util.isString(message.serverIpAddress))
                    return "serverIpAddress: string expected";
            if (message.data != null && message.hasOwnProperty("data"))
                if (!(message.data && typeof message.data.length === "number" || $util.isString(message.data)))
                    return "data: buffer expected";
            if (message.isLocalonly != null && message.hasOwnProperty("isLocalonly"))
                if (typeof message.isLocalonly !== "boolean")
                    return "isLocalonly: boolean expected";
            if (message.noSteamServer != null && message.hasOwnProperty("noSteamServer"))
                if (typeof message.noSteamServer !== "boolean")
                    return "noSteamServer: boolean expected";
            if (message.isTransition != null && message.hasOwnProperty("isTransition"))
                if (typeof message.isTransition !== "boolean")
                    return "isTransition: boolean expected";
            if (message.previouslevel != null && message.hasOwnProperty("previouslevel"))
                if (!$util.isString(message.previouslevel))
                    return "previouslevel: string expected";
            if (message.landmarkname != null && message.hasOwnProperty("landmarkname"))
                if (!$util.isString(message.landmarkname))
                    return "landmarkname: string expected";
            return null;
        };
    
        /**
         * Creates a CSVCMsg_GameSessionConfiguration message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CSVCMsg_GameSessionConfiguration
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CSVCMsg_GameSessionConfiguration} CSVCMsg_GameSessionConfiguration
         */
        CSVCMsg_GameSessionConfiguration.fromObject = function fromObject(object) {
            if (object instanceof $root.CSVCMsg_GameSessionConfiguration)
                return object;
            var message = new $root.CSVCMsg_GameSessionConfiguration();
            if (object.isMultiplayer != null)
                message.isMultiplayer = Boolean(object.isMultiplayer);
            if (object.isLoadsavegame != null)
                message.isLoadsavegame = Boolean(object.isLoadsavegame);
            if (object.isBackgroundMap != null)
                message.isBackgroundMap = Boolean(object.isBackgroundMap);
            if (object.isHeadless != null)
                message.isHeadless = Boolean(object.isHeadless);
            if (object.minClientLimit != null)
                message.minClientLimit = object.minClientLimit >>> 0;
            if (object.maxClientLimit != null)
                message.maxClientLimit = object.maxClientLimit >>> 0;
            if (object.maxClients != null)
                message.maxClients = object.maxClients >>> 0;
            if (object.tickInterval != null)
                message.tickInterval = object.tickInterval >>> 0;
            if (object.hostname != null)
                message.hostname = String(object.hostname);
            if (object.savegamename != null)
                message.savegamename = String(object.savegamename);
            if (object.s1Mapname != null)
                message.s1Mapname = String(object.s1Mapname);
            if (object.gamemode != null)
                message.gamemode = String(object.gamemode);
            if (object.serverIpAddress != null)
                message.serverIpAddress = String(object.serverIpAddress);
            if (object.data != null)
                if (typeof object.data === "string")
                    $util.base64.decode(object.data, message.data = $util.newBuffer($util.base64.length(object.data)), 0);
                else if (object.data.length >= 0)
                    message.data = object.data;
            if (object.isLocalonly != null)
                message.isLocalonly = Boolean(object.isLocalonly);
            if (object.noSteamServer != null)
                message.noSteamServer = Boolean(object.noSteamServer);
            if (object.isTransition != null)
                message.isTransition = Boolean(object.isTransition);
            if (object.previouslevel != null)
                message.previouslevel = String(object.previouslevel);
            if (object.landmarkname != null)
                message.landmarkname = String(object.landmarkname);
            return message;
        };
    
        /**
         * Creates a plain object from a CSVCMsg_GameSessionConfiguration message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CSVCMsg_GameSessionConfiguration
         * @static
         * @param {CSVCMsg_GameSessionConfiguration} message CSVCMsg_GameSessionConfiguration
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CSVCMsg_GameSessionConfiguration.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.isMultiplayer = false;
                object.isLoadsavegame = false;
                object.isBackgroundMap = false;
                object.isHeadless = false;
                object.minClientLimit = 0;
                object.maxClientLimit = 0;
                object.maxClients = 0;
                object.tickInterval = 0;
                object.hostname = "";
                object.savegamename = "";
                object.s1Mapname = "";
                object.gamemode = "";
                object.serverIpAddress = "";
                if (options.bytes === String)
                    object.data = "";
                else {
                    object.data = [];
                    if (options.bytes !== Array)
                        object.data = $util.newBuffer(object.data);
                }
                object.isLocalonly = false;
                object.isTransition = false;
                object.previouslevel = "";
                object.landmarkname = "";
                object.noSteamServer = false;
            }
            if (message.isMultiplayer != null && message.hasOwnProperty("isMultiplayer"))
                object.isMultiplayer = message.isMultiplayer;
            if (message.isLoadsavegame != null && message.hasOwnProperty("isLoadsavegame"))
                object.isLoadsavegame = message.isLoadsavegame;
            if (message.isBackgroundMap != null && message.hasOwnProperty("isBackgroundMap"))
                object.isBackgroundMap = message.isBackgroundMap;
            if (message.isHeadless != null && message.hasOwnProperty("isHeadless"))
                object.isHeadless = message.isHeadless;
            if (message.minClientLimit != null && message.hasOwnProperty("minClientLimit"))
                object.minClientLimit = message.minClientLimit;
            if (message.maxClientLimit != null && message.hasOwnProperty("maxClientLimit"))
                object.maxClientLimit = message.maxClientLimit;
            if (message.maxClients != null && message.hasOwnProperty("maxClients"))
                object.maxClients = message.maxClients;
            if (message.tickInterval != null && message.hasOwnProperty("tickInterval"))
                object.tickInterval = message.tickInterval;
            if (message.hostname != null && message.hasOwnProperty("hostname"))
                object.hostname = message.hostname;
            if (message.savegamename != null && message.hasOwnProperty("savegamename"))
                object.savegamename = message.savegamename;
            if (message.s1Mapname != null && message.hasOwnProperty("s1Mapname"))
                object.s1Mapname = message.s1Mapname;
            if (message.gamemode != null && message.hasOwnProperty("gamemode"))
                object.gamemode = message.gamemode;
            if (message.serverIpAddress != null && message.hasOwnProperty("serverIpAddress"))
                object.serverIpAddress = message.serverIpAddress;
            if (message.data != null && message.hasOwnProperty("data"))
                object.data = options.bytes === String ? $util.base64.encode(message.data, 0, message.data.length) : options.bytes === Array ? Array.prototype.slice.call(message.data) : message.data;
            if (message.isLocalonly != null && message.hasOwnProperty("isLocalonly"))
                object.isLocalonly = message.isLocalonly;
            if (message.isTransition != null && message.hasOwnProperty("isTransition"))
                object.isTransition = message.isTransition;
            if (message.previouslevel != null && message.hasOwnProperty("previouslevel"))
                object.previouslevel = message.previouslevel;
            if (message.landmarkname != null && message.hasOwnProperty("landmarkname"))
                object.landmarkname = message.landmarkname;
            if (message.noSteamServer != null && message.hasOwnProperty("noSteamServer"))
                object.noSteamServer = message.noSteamServer;
            return object;
        };
    
        /**
         * Converts this CSVCMsg_GameSessionConfiguration to JSON.
         * @function toJSON
         * @memberof CSVCMsg_GameSessionConfiguration
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CSVCMsg_GameSessionConfiguration.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * Gets the default type url for CSVCMsg_GameSessionConfiguration
         * @function getTypeUrl
         * @memberof CSVCMsg_GameSessionConfiguration
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        CSVCMsg_GameSessionConfiguration.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/CSVCMsg_GameSessionConfiguration";
        };
    
        return CSVCMsg_GameSessionConfiguration;
    })();
    
    $root.CNETMsg_DebugOverlay = (function() {
    
        /**
         * Properties of a CNETMsg_DebugOverlay.
         * @exports ICNETMsg_DebugOverlay
         * @interface ICNETMsg_DebugOverlay
         * @property {number|null} [etype] CNETMsg_DebugOverlay etype
         * @property {Array.<ICMsgVector>|null} [vectors] CNETMsg_DebugOverlay vectors
         * @property {Array.<ICMsgRGBA>|null} [colors] CNETMsg_DebugOverlay colors
         * @property {Array.<number>|null} [dimensions] CNETMsg_DebugOverlay dimensions
         * @property {Array.<number>|null} [times] CNETMsg_DebugOverlay times
         * @property {Array.<boolean>|null} [bools] CNETMsg_DebugOverlay bools
         * @property {Array.<number|Long>|null} [uint64s] CNETMsg_DebugOverlay uint64s
         * @property {Array.<string>|null} [strings] CNETMsg_DebugOverlay strings
         */
    
        /**
         * Constructs a new CNETMsg_DebugOverlay.
         * @exports CNETMsg_DebugOverlay
         * @classdesc Represents a CNETMsg_DebugOverlay.
         * @implements ICNETMsg_DebugOverlay
         * @constructor
         * @param {ICNETMsg_DebugOverlay=} [properties] Properties to set
         */
        function CNETMsg_DebugOverlay(properties) {
            this.vectors = [];
            this.colors = [];
            this.dimensions = [];
            this.times = [];
            this.bools = [];
            this.uint64s = [];
            this.strings = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CNETMsg_DebugOverlay etype.
         * @member {number} etype
         * @memberof CNETMsg_DebugOverlay
         * @instance
         */
        CNETMsg_DebugOverlay.prototype.etype = 0;
    
        /**
         * CNETMsg_DebugOverlay vectors.
         * @member {Array.<ICMsgVector>} vectors
         * @memberof CNETMsg_DebugOverlay
         * @instance
         */
        CNETMsg_DebugOverlay.prototype.vectors = $util.emptyArray;
    
        /**
         * CNETMsg_DebugOverlay colors.
         * @member {Array.<ICMsgRGBA>} colors
         * @memberof CNETMsg_DebugOverlay
         * @instance
         */
        CNETMsg_DebugOverlay.prototype.colors = $util.emptyArray;
    
        /**
         * CNETMsg_DebugOverlay dimensions.
         * @member {Array.<number>} dimensions
         * @memberof CNETMsg_DebugOverlay
         * @instance
         */
        CNETMsg_DebugOverlay.prototype.dimensions = $util.emptyArray;
    
        /**
         * CNETMsg_DebugOverlay times.
         * @member {Array.<number>} times
         * @memberof CNETMsg_DebugOverlay
         * @instance
         */
        CNETMsg_DebugOverlay.prototype.times = $util.emptyArray;
    
        /**
         * CNETMsg_DebugOverlay bools.
         * @member {Array.<boolean>} bools
         * @memberof CNETMsg_DebugOverlay
         * @instance
         */
        CNETMsg_DebugOverlay.prototype.bools = $util.emptyArray;
    
        /**
         * CNETMsg_DebugOverlay uint64s.
         * @member {Array.<number|Long>} uint64s
         * @memberof CNETMsg_DebugOverlay
         * @instance
         */
        CNETMsg_DebugOverlay.prototype.uint64s = $util.emptyArray;
    
        /**
         * CNETMsg_DebugOverlay strings.
         * @member {Array.<string>} strings
         * @memberof CNETMsg_DebugOverlay
         * @instance
         */
        CNETMsg_DebugOverlay.prototype.strings = $util.emptyArray;
    
        /**
         * Creates a new CNETMsg_DebugOverlay instance using the specified properties.
         * @function create
         * @memberof CNETMsg_DebugOverlay
         * @static
         * @param {ICNETMsg_DebugOverlay=} [properties] Properties to set
         * @returns {CNETMsg_DebugOverlay} CNETMsg_DebugOverlay instance
         */
        CNETMsg_DebugOverlay.create = function create(properties) {
            return new CNETMsg_DebugOverlay(properties);
        };
    
        /**
         * Encodes the specified CNETMsg_DebugOverlay message. Does not implicitly {@link CNETMsg_DebugOverlay.verify|verify} messages.
         * @function encode
         * @memberof CNETMsg_DebugOverlay
         * @static
         * @param {ICNETMsg_DebugOverlay} message CNETMsg_DebugOverlay message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CNETMsg_DebugOverlay.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.etype != null && Object.hasOwnProperty.call(message, "etype"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.etype);
            if (message.vectors != null && message.vectors.length)
                for (var i = 0; i < message.vectors.length; ++i)
                    $root.CMsgVector.encode(message.vectors[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.colors != null && message.colors.length)
                for (var i = 0; i < message.colors.length; ++i)
                    $root.CMsgRGBA.encode(message.colors[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.dimensions != null && message.dimensions.length)
                for (var i = 0; i < message.dimensions.length; ++i)
                    writer.uint32(/* id 4, wireType 5 =*/37).float(message.dimensions[i]);
            if (message.times != null && message.times.length)
                for (var i = 0; i < message.times.length; ++i)
                    writer.uint32(/* id 5, wireType 5 =*/45).float(message.times[i]);
            if (message.bools != null && message.bools.length)
                for (var i = 0; i < message.bools.length; ++i)
                    writer.uint32(/* id 6, wireType 0 =*/48).bool(message.bools[i]);
            if (message.uint64s != null && message.uint64s.length)
                for (var i = 0; i < message.uint64s.length; ++i)
                    writer.uint32(/* id 7, wireType 0 =*/56).uint64(message.uint64s[i]);
            if (message.strings != null && message.strings.length)
                for (var i = 0; i < message.strings.length; ++i)
                    writer.uint32(/* id 8, wireType 2 =*/66).string(message.strings[i]);
            return writer;
        };
    
        /**
         * Encodes the specified CNETMsg_DebugOverlay message, length delimited. Does not implicitly {@link CNETMsg_DebugOverlay.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CNETMsg_DebugOverlay
         * @static
         * @param {ICNETMsg_DebugOverlay} message CNETMsg_DebugOverlay message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CNETMsg_DebugOverlay.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CNETMsg_DebugOverlay message from the specified reader or buffer.
         * @function decode
         * @memberof CNETMsg_DebugOverlay
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CNETMsg_DebugOverlay} CNETMsg_DebugOverlay
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CNETMsg_DebugOverlay.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CNETMsg_DebugOverlay();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.etype = reader.int32();
                        break;
                    }
                case 2: {
                        if (!(message.vectors && message.vectors.length))
                            message.vectors = [];
                        message.vectors.push($root.CMsgVector.decode(reader, reader.uint32()));
                        break;
                    }
                case 3: {
                        if (!(message.colors && message.colors.length))
                            message.colors = [];
                        message.colors.push($root.CMsgRGBA.decode(reader, reader.uint32()));
                        break;
                    }
                case 4: {
                        if (!(message.dimensions && message.dimensions.length))
                            message.dimensions = [];
                        if ((tag & 7) === 2) {
                            var end2 = reader.uint32() + reader.pos;
                            while (reader.pos < end2)
                                message.dimensions.push(reader.float());
                        } else
                            message.dimensions.push(reader.float());
                        break;
                    }
                case 5: {
                        if (!(message.times && message.times.length))
                            message.times = [];
                        if ((tag & 7) === 2) {
                            var end2 = reader.uint32() + reader.pos;
                            while (reader.pos < end2)
                                message.times.push(reader.float());
                        } else
                            message.times.push(reader.float());
                        break;
                    }
                case 6: {
                        if (!(message.bools && message.bools.length))
                            message.bools = [];
                        if ((tag & 7) === 2) {
                            var end2 = reader.uint32() + reader.pos;
                            while (reader.pos < end2)
                                message.bools.push(reader.bool());
                        } else
                            message.bools.push(reader.bool());
                        break;
                    }
                case 7: {
                        if (!(message.uint64s && message.uint64s.length))
                            message.uint64s = [];
                        if ((tag & 7) === 2) {
                            var end2 = reader.uint32() + reader.pos;
                            while (reader.pos < end2)
                                message.uint64s.push(reader.uint64());
                        } else
                            message.uint64s.push(reader.uint64());
                        break;
                    }
                case 8: {
                        if (!(message.strings && message.strings.length))
                            message.strings = [];
                        message.strings.push(reader.string());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CNETMsg_DebugOverlay message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CNETMsg_DebugOverlay
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CNETMsg_DebugOverlay} CNETMsg_DebugOverlay
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CNETMsg_DebugOverlay.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CNETMsg_DebugOverlay message.
         * @function verify
         * @memberof CNETMsg_DebugOverlay
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CNETMsg_DebugOverlay.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.etype != null && message.hasOwnProperty("etype"))
                if (!$util.isInteger(message.etype))
                    return "etype: integer expected";
            if (message.vectors != null && message.hasOwnProperty("vectors")) {
                if (!Array.isArray(message.vectors))
                    return "vectors: array expected";
                for (var i = 0; i < message.vectors.length; ++i) {
                    var error = $root.CMsgVector.verify(message.vectors[i]);
                    if (error)
                        return "vectors." + error;
                }
            }
            if (message.colors != null && message.hasOwnProperty("colors")) {
                if (!Array.isArray(message.colors))
                    return "colors: array expected";
                for (var i = 0; i < message.colors.length; ++i) {
                    var error = $root.CMsgRGBA.verify(message.colors[i]);
                    if (error)
                        return "colors." + error;
                }
            }
            if (message.dimensions != null && message.hasOwnProperty("dimensions")) {
                if (!Array.isArray(message.dimensions))
                    return "dimensions: array expected";
                for (var i = 0; i < message.dimensions.length; ++i)
                    if (typeof message.dimensions[i] !== "number")
                        return "dimensions: number[] expected";
            }
            if (message.times != null && message.hasOwnProperty("times")) {
                if (!Array.isArray(message.times))
                    return "times: array expected";
                for (var i = 0; i < message.times.length; ++i)
                    if (typeof message.times[i] !== "number")
                        return "times: number[] expected";
            }
            if (message.bools != null && message.hasOwnProperty("bools")) {
                if (!Array.isArray(message.bools))
                    return "bools: array expected";
                for (var i = 0; i < message.bools.length; ++i)
                    if (typeof message.bools[i] !== "boolean")
                        return "bools: boolean[] expected";
            }
            if (message.uint64s != null && message.hasOwnProperty("uint64s")) {
                if (!Array.isArray(message.uint64s))
                    return "uint64s: array expected";
                for (var i = 0; i < message.uint64s.length; ++i)
                    if (!$util.isInteger(message.uint64s[i]) && !(message.uint64s[i] && $util.isInteger(message.uint64s[i].low) && $util.isInteger(message.uint64s[i].high)))
                        return "uint64s: integer|Long[] expected";
            }
            if (message.strings != null && message.hasOwnProperty("strings")) {
                if (!Array.isArray(message.strings))
                    return "strings: array expected";
                for (var i = 0; i < message.strings.length; ++i)
                    if (!$util.isString(message.strings[i]))
                        return "strings: string[] expected";
            }
            return null;
        };
    
        /**
         * Creates a CNETMsg_DebugOverlay message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CNETMsg_DebugOverlay
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CNETMsg_DebugOverlay} CNETMsg_DebugOverlay
         */
        CNETMsg_DebugOverlay.fromObject = function fromObject(object) {
            if (object instanceof $root.CNETMsg_DebugOverlay)
                return object;
            var message = new $root.CNETMsg_DebugOverlay();
            if (object.etype != null)
                message.etype = object.etype | 0;
            if (object.vectors) {
                if (!Array.isArray(object.vectors))
                    throw TypeError(".CNETMsg_DebugOverlay.vectors: array expected");
                message.vectors = [];
                for (var i = 0; i < object.vectors.length; ++i) {
                    if (typeof object.vectors[i] !== "object")
                        throw TypeError(".CNETMsg_DebugOverlay.vectors: object expected");
                    message.vectors[i] = $root.CMsgVector.fromObject(object.vectors[i]);
                }
            }
            if (object.colors) {
                if (!Array.isArray(object.colors))
                    throw TypeError(".CNETMsg_DebugOverlay.colors: array expected");
                message.colors = [];
                for (var i = 0; i < object.colors.length; ++i) {
                    if (typeof object.colors[i] !== "object")
                        throw TypeError(".CNETMsg_DebugOverlay.colors: object expected");
                    message.colors[i] = $root.CMsgRGBA.fromObject(object.colors[i]);
                }
            }
            if (object.dimensions) {
                if (!Array.isArray(object.dimensions))
                    throw TypeError(".CNETMsg_DebugOverlay.dimensions: array expected");
                message.dimensions = [];
                for (var i = 0; i < object.dimensions.length; ++i)
                    message.dimensions[i] = Number(object.dimensions[i]);
            }
            if (object.times) {
                if (!Array.isArray(object.times))
                    throw TypeError(".CNETMsg_DebugOverlay.times: array expected");
                message.times = [];
                for (var i = 0; i < object.times.length; ++i)
                    message.times[i] = Number(object.times[i]);
            }
            if (object.bools) {
                if (!Array.isArray(object.bools))
                    throw TypeError(".CNETMsg_DebugOverlay.bools: array expected");
                message.bools = [];
                for (var i = 0; i < object.bools.length; ++i)
                    message.bools[i] = Boolean(object.bools[i]);
            }
            if (object.uint64s) {
                if (!Array.isArray(object.uint64s))
                    throw TypeError(".CNETMsg_DebugOverlay.uint64s: array expected");
                message.uint64s = [];
                for (var i = 0; i < object.uint64s.length; ++i)
                    if ($util.Long)
                        (message.uint64s[i] = $util.Long.fromValue(object.uint64s[i])).unsigned = true;
                    else if (typeof object.uint64s[i] === "string")
                        message.uint64s[i] = parseInt(object.uint64s[i], 10);
                    else if (typeof object.uint64s[i] === "number")
                        message.uint64s[i] = object.uint64s[i];
                    else if (typeof object.uint64s[i] === "object")
                        message.uint64s[i] = new $util.LongBits(object.uint64s[i].low >>> 0, object.uint64s[i].high >>> 0).toNumber(true);
            }
            if (object.strings) {
                if (!Array.isArray(object.strings))
                    throw TypeError(".CNETMsg_DebugOverlay.strings: array expected");
                message.strings = [];
                for (var i = 0; i < object.strings.length; ++i)
                    message.strings[i] = String(object.strings[i]);
            }
            return message;
        };
    
        /**
         * Creates a plain object from a CNETMsg_DebugOverlay message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CNETMsg_DebugOverlay
         * @static
         * @param {CNETMsg_DebugOverlay} message CNETMsg_DebugOverlay
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CNETMsg_DebugOverlay.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults) {
                object.vectors = [];
                object.colors = [];
                object.dimensions = [];
                object.times = [];
                object.bools = [];
                object.uint64s = [];
                object.strings = [];
            }
            if (options.defaults)
                object.etype = 0;
            if (message.etype != null && message.hasOwnProperty("etype"))
                object.etype = message.etype;
            if (message.vectors && message.vectors.length) {
                object.vectors = [];
                for (var j = 0; j < message.vectors.length; ++j)
                    object.vectors[j] = $root.CMsgVector.toObject(message.vectors[j], options);
            }
            if (message.colors && message.colors.length) {
                object.colors = [];
                for (var j = 0; j < message.colors.length; ++j)
                    object.colors[j] = $root.CMsgRGBA.toObject(message.colors[j], options);
            }
            if (message.dimensions && message.dimensions.length) {
                object.dimensions = [];
                for (var j = 0; j < message.dimensions.length; ++j)
                    object.dimensions[j] = options.json && !isFinite(message.dimensions[j]) ? String(message.dimensions[j]) : message.dimensions[j];
            }
            if (message.times && message.times.length) {
                object.times = [];
                for (var j = 0; j < message.times.length; ++j)
                    object.times[j] = options.json && !isFinite(message.times[j]) ? String(message.times[j]) : message.times[j];
            }
            if (message.bools && message.bools.length) {
                object.bools = [];
                for (var j = 0; j < message.bools.length; ++j)
                    object.bools[j] = message.bools[j];
            }
            if (message.uint64s && message.uint64s.length) {
                object.uint64s = [];
                for (var j = 0; j < message.uint64s.length; ++j)
                    if (typeof message.uint64s[j] === "number")
                        object.uint64s[j] = options.longs === String ? String(message.uint64s[j]) : message.uint64s[j];
                    else
                        object.uint64s[j] = options.longs === String ? $util.Long.prototype.toString.call(message.uint64s[j]) : options.longs === Number ? new $util.LongBits(message.uint64s[j].low >>> 0, message.uint64s[j].high >>> 0).toNumber(true) : message.uint64s[j];
            }
            if (message.strings && message.strings.length) {
                object.strings = [];
                for (var j = 0; j < message.strings.length; ++j)
                    object.strings[j] = message.strings[j];
            }
            return object;
        };
    
        /**
         * Converts this CNETMsg_DebugOverlay to JSON.
         * @function toJSON
         * @memberof CNETMsg_DebugOverlay
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CNETMsg_DebugOverlay.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * Gets the default type url for CNETMsg_DebugOverlay
         * @function getTypeUrl
         * @memberof CNETMsg_DebugOverlay
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        CNETMsg_DebugOverlay.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/CNETMsg_DebugOverlay";
        };
    
        return CNETMsg_DebugOverlay;
    })();
    
    /**
     * ENetworkDisconnectionReason enum.
     * @exports ENetworkDisconnectionReason
     * @enum {number}
     * @property {number} NETWORK_DISCONNECT_INVALID=0 NETWORK_DISCONNECT_INVALID value
     * @property {number} NETWORK_DISCONNECT_SHUTDOWN=1 NETWORK_DISCONNECT_SHUTDOWN value
     * @property {number} NETWORK_DISCONNECT_DISCONNECT_BY_USER=2 NETWORK_DISCONNECT_DISCONNECT_BY_USER value
     * @property {number} NETWORK_DISCONNECT_DISCONNECT_BY_SERVER=3 NETWORK_DISCONNECT_DISCONNECT_BY_SERVER value
     * @property {number} NETWORK_DISCONNECT_LOST=4 NETWORK_DISCONNECT_LOST value
     * @property {number} NETWORK_DISCONNECT_OVERFLOW=5 NETWORK_DISCONNECT_OVERFLOW value
     * @property {number} NETWORK_DISCONNECT_STEAM_BANNED=6 NETWORK_DISCONNECT_STEAM_BANNED value
     * @property {number} NETWORK_DISCONNECT_STEAM_INUSE=7 NETWORK_DISCONNECT_STEAM_INUSE value
     * @property {number} NETWORK_DISCONNECT_STEAM_TICKET=8 NETWORK_DISCONNECT_STEAM_TICKET value
     * @property {number} NETWORK_DISCONNECT_STEAM_LOGON=9 NETWORK_DISCONNECT_STEAM_LOGON value
     * @property {number} NETWORK_DISCONNECT_STEAM_AUTHCANCELLED=10 NETWORK_DISCONNECT_STEAM_AUTHCANCELLED value
     * @property {number} NETWORK_DISCONNECT_STEAM_AUTHALREADYUSED=11 NETWORK_DISCONNECT_STEAM_AUTHALREADYUSED value
     * @property {number} NETWORK_DISCONNECT_STEAM_AUTHINVALID=12 NETWORK_DISCONNECT_STEAM_AUTHINVALID value
     * @property {number} NETWORK_DISCONNECT_STEAM_VACBANSTATE=13 NETWORK_DISCONNECT_STEAM_VACBANSTATE value
     * @property {number} NETWORK_DISCONNECT_STEAM_LOGGED_IN_ELSEWHERE=14 NETWORK_DISCONNECT_STEAM_LOGGED_IN_ELSEWHERE value
     * @property {number} NETWORK_DISCONNECT_STEAM_VAC_CHECK_TIMEDOUT=15 NETWORK_DISCONNECT_STEAM_VAC_CHECK_TIMEDOUT value
     * @property {number} NETWORK_DISCONNECT_STEAM_DROPPED=16 NETWORK_DISCONNECT_STEAM_DROPPED value
     * @property {number} NETWORK_DISCONNECT_STEAM_OWNERSHIP=17 NETWORK_DISCONNECT_STEAM_OWNERSHIP value
     * @property {number} NETWORK_DISCONNECT_SERVERINFO_OVERFLOW=18 NETWORK_DISCONNECT_SERVERINFO_OVERFLOW value
     * @property {number} NETWORK_DISCONNECT_TICKMSG_OVERFLOW=19 NETWORK_DISCONNECT_TICKMSG_OVERFLOW value
     * @property {number} NETWORK_DISCONNECT_STRINGTABLEMSG_OVERFLOW=20 NETWORK_DISCONNECT_STRINGTABLEMSG_OVERFLOW value
     * @property {number} NETWORK_DISCONNECT_DELTAENTMSG_OVERFLOW=21 NETWORK_DISCONNECT_DELTAENTMSG_OVERFLOW value
     * @property {number} NETWORK_DISCONNECT_TEMPENTMSG_OVERFLOW=22 NETWORK_DISCONNECT_TEMPENTMSG_OVERFLOW value
     * @property {number} NETWORK_DISCONNECT_SOUNDSMSG_OVERFLOW=23 NETWORK_DISCONNECT_SOUNDSMSG_OVERFLOW value
     * @property {number} NETWORK_DISCONNECT_SNAPSHOTOVERFLOW=24 NETWORK_DISCONNECT_SNAPSHOTOVERFLOW value
     * @property {number} NETWORK_DISCONNECT_SNAPSHOTERROR=25 NETWORK_DISCONNECT_SNAPSHOTERROR value
     * @property {number} NETWORK_DISCONNECT_RELIABLEOVERFLOW=26 NETWORK_DISCONNECT_RELIABLEOVERFLOW value
     * @property {number} NETWORK_DISCONNECT_BADDELTATICK=27 NETWORK_DISCONNECT_BADDELTATICK value
     * @property {number} NETWORK_DISCONNECT_NOMORESPLITS=28 NETWORK_DISCONNECT_NOMORESPLITS value
     * @property {number} NETWORK_DISCONNECT_TIMEDOUT=29 NETWORK_DISCONNECT_TIMEDOUT value
     * @property {number} NETWORK_DISCONNECT_DISCONNECTED=30 NETWORK_DISCONNECT_DISCONNECTED value
     * @property {number} NETWORK_DISCONNECT_LEAVINGSPLIT=31 NETWORK_DISCONNECT_LEAVINGSPLIT value
     * @property {number} NETWORK_DISCONNECT_DIFFERENTCLASSTABLES=32 NETWORK_DISCONNECT_DIFFERENTCLASSTABLES value
     * @property {number} NETWORK_DISCONNECT_BADRELAYPASSWORD=33 NETWORK_DISCONNECT_BADRELAYPASSWORD value
     * @property {number} NETWORK_DISCONNECT_BADSPECTATORPASSWORD=34 NETWORK_DISCONNECT_BADSPECTATORPASSWORD value
     * @property {number} NETWORK_DISCONNECT_HLTVRESTRICTED=35 NETWORK_DISCONNECT_HLTVRESTRICTED value
     * @property {number} NETWORK_DISCONNECT_NOSPECTATORS=36 NETWORK_DISCONNECT_NOSPECTATORS value
     * @property {number} NETWORK_DISCONNECT_HLTVUNAVAILABLE=37 NETWORK_DISCONNECT_HLTVUNAVAILABLE value
     * @property {number} NETWORK_DISCONNECT_HLTVSTOP=38 NETWORK_DISCONNECT_HLTVSTOP value
     * @property {number} NETWORK_DISCONNECT_KICKED=39 NETWORK_DISCONNECT_KICKED value
     * @property {number} NETWORK_DISCONNECT_BANADDED=40 NETWORK_DISCONNECT_BANADDED value
     * @property {number} NETWORK_DISCONNECT_KICKBANADDED=41 NETWORK_DISCONNECT_KICKBANADDED value
     * @property {number} NETWORK_DISCONNECT_HLTVDIRECT=42 NETWORK_DISCONNECT_HLTVDIRECT value
     * @property {number} NETWORK_DISCONNECT_PURESERVER_CLIENTEXTRA=43 NETWORK_DISCONNECT_PURESERVER_CLIENTEXTRA value
     * @property {number} NETWORK_DISCONNECT_PURESERVER_MISMATCH=44 NETWORK_DISCONNECT_PURESERVER_MISMATCH value
     * @property {number} NETWORK_DISCONNECT_USERCMD=45 NETWORK_DISCONNECT_USERCMD value
     * @property {number} NETWORK_DISCONNECT_REJECTED_BY_GAME=46 NETWORK_DISCONNECT_REJECTED_BY_GAME value
     * @property {number} NETWORK_DISCONNECT_MESSAGE_PARSE_ERROR=47 NETWORK_DISCONNECT_MESSAGE_PARSE_ERROR value
     * @property {number} NETWORK_DISCONNECT_INVALID_MESSAGE_ERROR=48 NETWORK_DISCONNECT_INVALID_MESSAGE_ERROR value
     * @property {number} NETWORK_DISCONNECT_BAD_SERVER_PASSWORD=49 NETWORK_DISCONNECT_BAD_SERVER_PASSWORD value
     * @property {number} NETWORK_DISCONNECT_DIRECT_CONNECT_RESERVATION=50 NETWORK_DISCONNECT_DIRECT_CONNECT_RESERVATION value
     * @property {number} NETWORK_DISCONNECT_CONNECTION_FAILURE=51 NETWORK_DISCONNECT_CONNECTION_FAILURE value
     * @property {number} NETWORK_DISCONNECT_NO_PEER_GROUP_HANDLERS=52 NETWORK_DISCONNECT_NO_PEER_GROUP_HANDLERS value
     * @property {number} NETWORK_DISCONNECT_RECONNECTION=53 NETWORK_DISCONNECT_RECONNECTION value
     * @property {number} NETWORK_DISCONNECT_LOOPSHUTDOWN=54 NETWORK_DISCONNECT_LOOPSHUTDOWN value
     * @property {number} NETWORK_DISCONNECT_LOOPDEACTIVATE=55 NETWORK_DISCONNECT_LOOPDEACTIVATE value
     * @property {number} NETWORK_DISCONNECT_HOST_ENDGAME=56 NETWORK_DISCONNECT_HOST_ENDGAME value
     * @property {number} NETWORK_DISCONNECT_LOOP_LEVELLOAD_ACTIVATE=57 NETWORK_DISCONNECT_LOOP_LEVELLOAD_ACTIVATE value
     * @property {number} NETWORK_DISCONNECT_CREATE_SERVER_FAILED=58 NETWORK_DISCONNECT_CREATE_SERVER_FAILED value
     * @property {number} NETWORK_DISCONNECT_EXITING=59 NETWORK_DISCONNECT_EXITING value
     * @property {number} NETWORK_DISCONNECT_REQUEST_HOSTSTATE_IDLE=60 NETWORK_DISCONNECT_REQUEST_HOSTSTATE_IDLE value
     * @property {number} NETWORK_DISCONNECT_REQUEST_HOSTSTATE_HLTVRELAY=61 NETWORK_DISCONNECT_REQUEST_HOSTSTATE_HLTVRELAY value
     * @property {number} NETWORK_DISCONNECT_CLIENT_CONSISTENCY_FAIL=62 NETWORK_DISCONNECT_CLIENT_CONSISTENCY_FAIL value
     * @property {number} NETWORK_DISCONNECT_CLIENT_UNABLE_TO_CRC_MAP=63 NETWORK_DISCONNECT_CLIENT_UNABLE_TO_CRC_MAP value
     * @property {number} NETWORK_DISCONNECT_CLIENT_NO_MAP=64 NETWORK_DISCONNECT_CLIENT_NO_MAP value
     * @property {number} NETWORK_DISCONNECT_CLIENT_DIFFERENT_MAP=65 NETWORK_DISCONNECT_CLIENT_DIFFERENT_MAP value
     * @property {number} NETWORK_DISCONNECT_SERVER_REQUIRES_STEAM=66 NETWORK_DISCONNECT_SERVER_REQUIRES_STEAM value
     * @property {number} NETWORK_DISCONNECT_STEAM_DENY_MISC=67 NETWORK_DISCONNECT_STEAM_DENY_MISC value
     * @property {number} NETWORK_DISCONNECT_STEAM_DENY_BAD_ANTI_CHEAT=68 NETWORK_DISCONNECT_STEAM_DENY_BAD_ANTI_CHEAT value
     * @property {number} NETWORK_DISCONNECT_SERVER_SHUTDOWN=69 NETWORK_DISCONNECT_SERVER_SHUTDOWN value
     * @property {number} NETWORK_DISCONNECT_REPLAY_INCOMPATIBLE=71 NETWORK_DISCONNECT_REPLAY_INCOMPATIBLE value
     * @property {number} NETWORK_DISCONNECT_CONNECT_REQUEST_TIMEDOUT=72 NETWORK_DISCONNECT_CONNECT_REQUEST_TIMEDOUT value
     * @property {number} NETWORK_DISCONNECT_SERVER_INCOMPATIBLE=73 NETWORK_DISCONNECT_SERVER_INCOMPATIBLE value
     * @property {number} NETWORK_DISCONNECT_LOCALPROBLEM_MANYRELAYS=74 NETWORK_DISCONNECT_LOCALPROBLEM_MANYRELAYS value
     * @property {number} NETWORK_DISCONNECT_LOCALPROBLEM_HOSTEDSERVERPRIMARYRELAY=75 NETWORK_DISCONNECT_LOCALPROBLEM_HOSTEDSERVERPRIMARYRELAY value
     * @property {number} NETWORK_DISCONNECT_LOCALPROBLEM_NETWORKCONFIG=76 NETWORK_DISCONNECT_LOCALPROBLEM_NETWORKCONFIG value
     * @property {number} NETWORK_DISCONNECT_LOCALPROBLEM_OTHER=77 NETWORK_DISCONNECT_LOCALPROBLEM_OTHER value
     * @property {number} NETWORK_DISCONNECT_REMOTE_TIMEOUT=79 NETWORK_DISCONNECT_REMOTE_TIMEOUT value
     * @property {number} NETWORK_DISCONNECT_REMOTE_TIMEOUT_CONNECTING=80 NETWORK_DISCONNECT_REMOTE_TIMEOUT_CONNECTING value
     * @property {number} NETWORK_DISCONNECT_REMOTE_OTHER=81 NETWORK_DISCONNECT_REMOTE_OTHER value
     * @property {number} NETWORK_DISCONNECT_REMOTE_BADCRYPT=82 NETWORK_DISCONNECT_REMOTE_BADCRYPT value
     * @property {number} NETWORK_DISCONNECT_REMOTE_CERTNOTTRUSTED=83 NETWORK_DISCONNECT_REMOTE_CERTNOTTRUSTED value
     * @property {number} NETWORK_DISCONNECT_UNUSUAL=84 NETWORK_DISCONNECT_UNUSUAL value
     * @property {number} NETWORK_DISCONNECT_INTERNAL_ERROR=85 NETWORK_DISCONNECT_INTERNAL_ERROR value
     * @property {number} NETWORK_DISCONNECT_REJECT_BADCHALLENGE=128 NETWORK_DISCONNECT_REJECT_BADCHALLENGE value
     * @property {number} NETWORK_DISCONNECT_REJECT_NOLOBBY=129 NETWORK_DISCONNECT_REJECT_NOLOBBY value
     * @property {number} NETWORK_DISCONNECT_REJECT_BACKGROUND_MAP=130 NETWORK_DISCONNECT_REJECT_BACKGROUND_MAP value
     * @property {number} NETWORK_DISCONNECT_REJECT_SINGLE_PLAYER=131 NETWORK_DISCONNECT_REJECT_SINGLE_PLAYER value
     * @property {number} NETWORK_DISCONNECT_REJECT_HIDDEN_GAME=132 NETWORK_DISCONNECT_REJECT_HIDDEN_GAME value
     * @property {number} NETWORK_DISCONNECT_REJECT_LANRESTRICT=133 NETWORK_DISCONNECT_REJECT_LANRESTRICT value
     * @property {number} NETWORK_DISCONNECT_REJECT_BADPASSWORD=134 NETWORK_DISCONNECT_REJECT_BADPASSWORD value
     * @property {number} NETWORK_DISCONNECT_REJECT_SERVERFULL=135 NETWORK_DISCONNECT_REJECT_SERVERFULL value
     * @property {number} NETWORK_DISCONNECT_REJECT_INVALIDRESERVATION=136 NETWORK_DISCONNECT_REJECT_INVALIDRESERVATION value
     * @property {number} NETWORK_DISCONNECT_REJECT_FAILEDCHANNEL=137 NETWORK_DISCONNECT_REJECT_FAILEDCHANNEL value
     * @property {number} NETWORK_DISCONNECT_REJECT_CONNECT_FROM_LOBBY=138 NETWORK_DISCONNECT_REJECT_CONNECT_FROM_LOBBY value
     * @property {number} NETWORK_DISCONNECT_REJECT_RESERVED_FOR_LOBBY=139 NETWORK_DISCONNECT_REJECT_RESERVED_FOR_LOBBY value
     * @property {number} NETWORK_DISCONNECT_REJECT_INVALIDKEYLENGTH=140 NETWORK_DISCONNECT_REJECT_INVALIDKEYLENGTH value
     * @property {number} NETWORK_DISCONNECT_REJECT_OLDPROTOCOL=141 NETWORK_DISCONNECT_REJECT_OLDPROTOCOL value
     * @property {number} NETWORK_DISCONNECT_REJECT_NEWPROTOCOL=142 NETWORK_DISCONNECT_REJECT_NEWPROTOCOL value
     * @property {number} NETWORK_DISCONNECT_REJECT_INVALIDCONNECTION=143 NETWORK_DISCONNECT_REJECT_INVALIDCONNECTION value
     * @property {number} NETWORK_DISCONNECT_REJECT_INVALIDCERTLEN=144 NETWORK_DISCONNECT_REJECT_INVALIDCERTLEN value
     * @property {number} NETWORK_DISCONNECT_REJECT_INVALIDSTEAMCERTLEN=145 NETWORK_DISCONNECT_REJECT_INVALIDSTEAMCERTLEN value
     * @property {number} NETWORK_DISCONNECT_REJECT_STEAM=146 NETWORK_DISCONNECT_REJECT_STEAM value
     * @property {number} NETWORK_DISCONNECT_REJECT_SERVERAUTHDISABLED=147 NETWORK_DISCONNECT_REJECT_SERVERAUTHDISABLED value
     * @property {number} NETWORK_DISCONNECT_REJECT_SERVERCDKEYAUTHINVALID=148 NETWORK_DISCONNECT_REJECT_SERVERCDKEYAUTHINVALID value
     * @property {number} NETWORK_DISCONNECT_REJECT_BANNED=149 NETWORK_DISCONNECT_REJECT_BANNED value
     * @property {number} NETWORK_DISCONNECT_KICKED_TEAMKILLING=150 NETWORK_DISCONNECT_KICKED_TEAMKILLING value
     * @property {number} NETWORK_DISCONNECT_KICKED_TK_START=151 NETWORK_DISCONNECT_KICKED_TK_START value
     * @property {number} NETWORK_DISCONNECT_KICKED_UNTRUSTEDACCOUNT=152 NETWORK_DISCONNECT_KICKED_UNTRUSTEDACCOUNT value
     * @property {number} NETWORK_DISCONNECT_KICKED_CONVICTEDACCOUNT=153 NETWORK_DISCONNECT_KICKED_CONVICTEDACCOUNT value
     * @property {number} NETWORK_DISCONNECT_KICKED_COMPETITIVECOOLDOWN=154 NETWORK_DISCONNECT_KICKED_COMPETITIVECOOLDOWN value
     * @property {number} NETWORK_DISCONNECT_KICKED_TEAMHURTING=155 NETWORK_DISCONNECT_KICKED_TEAMHURTING value
     * @property {number} NETWORK_DISCONNECT_KICKED_HOSTAGEKILLING=156 NETWORK_DISCONNECT_KICKED_HOSTAGEKILLING value
     * @property {number} NETWORK_DISCONNECT_KICKED_VOTEDOFF=157 NETWORK_DISCONNECT_KICKED_VOTEDOFF value
     * @property {number} NETWORK_DISCONNECT_KICKED_IDLE=158 NETWORK_DISCONNECT_KICKED_IDLE value
     * @property {number} NETWORK_DISCONNECT_KICKED_SUICIDE=159 NETWORK_DISCONNECT_KICKED_SUICIDE value
     * @property {number} NETWORK_DISCONNECT_KICKED_NOSTEAMLOGIN=160 NETWORK_DISCONNECT_KICKED_NOSTEAMLOGIN value
     * @property {number} NETWORK_DISCONNECT_KICKED_NOSTEAMTICKET=161 NETWORK_DISCONNECT_KICKED_NOSTEAMTICKET value
     */
    $root.ENetworkDisconnectionReason = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "NETWORK_DISCONNECT_INVALID"] = 0;
        values[valuesById[1] = "NETWORK_DISCONNECT_SHUTDOWN"] = 1;
        values[valuesById[2] = "NETWORK_DISCONNECT_DISCONNECT_BY_USER"] = 2;
        values[valuesById[3] = "NETWORK_DISCONNECT_DISCONNECT_BY_SERVER"] = 3;
        values[valuesById[4] = "NETWORK_DISCONNECT_LOST"] = 4;
        values[valuesById[5] = "NETWORK_DISCONNECT_OVERFLOW"] = 5;
        values[valuesById[6] = "NETWORK_DISCONNECT_STEAM_BANNED"] = 6;
        values[valuesById[7] = "NETWORK_DISCONNECT_STEAM_INUSE"] = 7;
        values[valuesById[8] = "NETWORK_DISCONNECT_STEAM_TICKET"] = 8;
        values[valuesById[9] = "NETWORK_DISCONNECT_STEAM_LOGON"] = 9;
        values[valuesById[10] = "NETWORK_DISCONNECT_STEAM_AUTHCANCELLED"] = 10;
        values[valuesById[11] = "NETWORK_DISCONNECT_STEAM_AUTHALREADYUSED"] = 11;
        values[valuesById[12] = "NETWORK_DISCONNECT_STEAM_AUTHINVALID"] = 12;
        values[valuesById[13] = "NETWORK_DISCONNECT_STEAM_VACBANSTATE"] = 13;
        values[valuesById[14] = "NETWORK_DISCONNECT_STEAM_LOGGED_IN_ELSEWHERE"] = 14;
        values[valuesById[15] = "NETWORK_DISCONNECT_STEAM_VAC_CHECK_TIMEDOUT"] = 15;
        values[valuesById[16] = "NETWORK_DISCONNECT_STEAM_DROPPED"] = 16;
        values[valuesById[17] = "NETWORK_DISCONNECT_STEAM_OWNERSHIP"] = 17;
        values[valuesById[18] = "NETWORK_DISCONNECT_SERVERINFO_OVERFLOW"] = 18;
        values[valuesById[19] = "NETWORK_DISCONNECT_TICKMSG_OVERFLOW"] = 19;
        values[valuesById[20] = "NETWORK_DISCONNECT_STRINGTABLEMSG_OVERFLOW"] = 20;
        values[valuesById[21] = "NETWORK_DISCONNECT_DELTAENTMSG_OVERFLOW"] = 21;
        values[valuesById[22] = "NETWORK_DISCONNECT_TEMPENTMSG_OVERFLOW"] = 22;
        values[valuesById[23] = "NETWORK_DISCONNECT_SOUNDSMSG_OVERFLOW"] = 23;
        values[valuesById[24] = "NETWORK_DISCONNECT_SNAPSHOTOVERFLOW"] = 24;
        values[valuesById[25] = "NETWORK_DISCONNECT_SNAPSHOTERROR"] = 25;
        values[valuesById[26] = "NETWORK_DISCONNECT_RELIABLEOVERFLOW"] = 26;
        values[valuesById[27] = "NETWORK_DISCONNECT_BADDELTATICK"] = 27;
        values[valuesById[28] = "NETWORK_DISCONNECT_NOMORESPLITS"] = 28;
        values[valuesById[29] = "NETWORK_DISCONNECT_TIMEDOUT"] = 29;
        values[valuesById[30] = "NETWORK_DISCONNECT_DISCONNECTED"] = 30;
        values[valuesById[31] = "NETWORK_DISCONNECT_LEAVINGSPLIT"] = 31;
        values[valuesById[32] = "NETWORK_DISCONNECT_DIFFERENTCLASSTABLES"] = 32;
        values[valuesById[33] = "NETWORK_DISCONNECT_BADRELAYPASSWORD"] = 33;
        values[valuesById[34] = "NETWORK_DISCONNECT_BADSPECTATORPASSWORD"] = 34;
        values[valuesById[35] = "NETWORK_DISCONNECT_HLTVRESTRICTED"] = 35;
        values[valuesById[36] = "NETWORK_DISCONNECT_NOSPECTATORS"] = 36;
        values[valuesById[37] = "NETWORK_DISCONNECT_HLTVUNAVAILABLE"] = 37;
        values[valuesById[38] = "NETWORK_DISCONNECT_HLTVSTOP"] = 38;
        values[valuesById[39] = "NETWORK_DISCONNECT_KICKED"] = 39;
        values[valuesById[40] = "NETWORK_DISCONNECT_BANADDED"] = 40;
        values[valuesById[41] = "NETWORK_DISCONNECT_KICKBANADDED"] = 41;
        values[valuesById[42] = "NETWORK_DISCONNECT_HLTVDIRECT"] = 42;
        values[valuesById[43] = "NETWORK_DISCONNECT_PURESERVER_CLIENTEXTRA"] = 43;
        values[valuesById[44] = "NETWORK_DISCONNECT_PURESERVER_MISMATCH"] = 44;
        values[valuesById[45] = "NETWORK_DISCONNECT_USERCMD"] = 45;
        values[valuesById[46] = "NETWORK_DISCONNECT_REJECTED_BY_GAME"] = 46;
        values[valuesById[47] = "NETWORK_DISCONNECT_MESSAGE_PARSE_ERROR"] = 47;
        values[valuesById[48] = "NETWORK_DISCONNECT_INVALID_MESSAGE_ERROR"] = 48;
        values[valuesById[49] = "NETWORK_DISCONNECT_BAD_SERVER_PASSWORD"] = 49;
        values[valuesById[50] = "NETWORK_DISCONNECT_DIRECT_CONNECT_RESERVATION"] = 50;
        values[valuesById[51] = "NETWORK_DISCONNECT_CONNECTION_FAILURE"] = 51;
        values[valuesById[52] = "NETWORK_DISCONNECT_NO_PEER_GROUP_HANDLERS"] = 52;
        values[valuesById[53] = "NETWORK_DISCONNECT_RECONNECTION"] = 53;
        values[valuesById[54] = "NETWORK_DISCONNECT_LOOPSHUTDOWN"] = 54;
        values[valuesById[55] = "NETWORK_DISCONNECT_LOOPDEACTIVATE"] = 55;
        values[valuesById[56] = "NETWORK_DISCONNECT_HOST_ENDGAME"] = 56;
        values[valuesById[57] = "NETWORK_DISCONNECT_LOOP_LEVELLOAD_ACTIVATE"] = 57;
        values[valuesById[58] = "NETWORK_DISCONNECT_CREATE_SERVER_FAILED"] = 58;
        values[valuesById[59] = "NETWORK_DISCONNECT_EXITING"] = 59;
        values[valuesById[60] = "NETWORK_DISCONNECT_REQUEST_HOSTSTATE_IDLE"] = 60;
        values[valuesById[61] = "NETWORK_DISCONNECT_REQUEST_HOSTSTATE_HLTVRELAY"] = 61;
        values[valuesById[62] = "NETWORK_DISCONNECT_CLIENT_CONSISTENCY_FAIL"] = 62;
        values[valuesById[63] = "NETWORK_DISCONNECT_CLIENT_UNABLE_TO_CRC_MAP"] = 63;
        values[valuesById[64] = "NETWORK_DISCONNECT_CLIENT_NO_MAP"] = 64;
        values[valuesById[65] = "NETWORK_DISCONNECT_CLIENT_DIFFERENT_MAP"] = 65;
        values[valuesById[66] = "NETWORK_DISCONNECT_SERVER_REQUIRES_STEAM"] = 66;
        values[valuesById[67] = "NETWORK_DISCONNECT_STEAM_DENY_MISC"] = 67;
        values[valuesById[68] = "NETWORK_DISCONNECT_STEAM_DENY_BAD_ANTI_CHEAT"] = 68;
        values[valuesById[69] = "NETWORK_DISCONNECT_SERVER_SHUTDOWN"] = 69;
        values[valuesById[71] = "NETWORK_DISCONNECT_REPLAY_INCOMPATIBLE"] = 71;
        values[valuesById[72] = "NETWORK_DISCONNECT_CONNECT_REQUEST_TIMEDOUT"] = 72;
        values[valuesById[73] = "NETWORK_DISCONNECT_SERVER_INCOMPATIBLE"] = 73;
        values[valuesById[74] = "NETWORK_DISCONNECT_LOCALPROBLEM_MANYRELAYS"] = 74;
        values[valuesById[75] = "NETWORK_DISCONNECT_LOCALPROBLEM_HOSTEDSERVERPRIMARYRELAY"] = 75;
        values[valuesById[76] = "NETWORK_DISCONNECT_LOCALPROBLEM_NETWORKCONFIG"] = 76;
        values[valuesById[77] = "NETWORK_DISCONNECT_LOCALPROBLEM_OTHER"] = 77;
        values[valuesById[79] = "NETWORK_DISCONNECT_REMOTE_TIMEOUT"] = 79;
        values[valuesById[80] = "NETWORK_DISCONNECT_REMOTE_TIMEOUT_CONNECTING"] = 80;
        values[valuesById[81] = "NETWORK_DISCONNECT_REMOTE_OTHER"] = 81;
        values[valuesById[82] = "NETWORK_DISCONNECT_REMOTE_BADCRYPT"] = 82;
        values[valuesById[83] = "NETWORK_DISCONNECT_REMOTE_CERTNOTTRUSTED"] = 83;
        values[valuesById[84] = "NETWORK_DISCONNECT_UNUSUAL"] = 84;
        values[valuesById[85] = "NETWORK_DISCONNECT_INTERNAL_ERROR"] = 85;
        values[valuesById[128] = "NETWORK_DISCONNECT_REJECT_BADCHALLENGE"] = 128;
        values[valuesById[129] = "NETWORK_DISCONNECT_REJECT_NOLOBBY"] = 129;
        values[valuesById[130] = "NETWORK_DISCONNECT_REJECT_BACKGROUND_MAP"] = 130;
        values[valuesById[131] = "NETWORK_DISCONNECT_REJECT_SINGLE_PLAYER"] = 131;
        values[valuesById[132] = "NETWORK_DISCONNECT_REJECT_HIDDEN_GAME"] = 132;
        values[valuesById[133] = "NETWORK_DISCONNECT_REJECT_LANRESTRICT"] = 133;
        values[valuesById[134] = "NETWORK_DISCONNECT_REJECT_BADPASSWORD"] = 134;
        values[valuesById[135] = "NETWORK_DISCONNECT_REJECT_SERVERFULL"] = 135;
        values[valuesById[136] = "NETWORK_DISCONNECT_REJECT_INVALIDRESERVATION"] = 136;
        values[valuesById[137] = "NETWORK_DISCONNECT_REJECT_FAILEDCHANNEL"] = 137;
        values[valuesById[138] = "NETWORK_DISCONNECT_REJECT_CONNECT_FROM_LOBBY"] = 138;
        values[valuesById[139] = "NETWORK_DISCONNECT_REJECT_RESERVED_FOR_LOBBY"] = 139;
        values[valuesById[140] = "NETWORK_DISCONNECT_REJECT_INVALIDKEYLENGTH"] = 140;
        values[valuesById[141] = "NETWORK_DISCONNECT_REJECT_OLDPROTOCOL"] = 141;
        values[valuesById[142] = "NETWORK_DISCONNECT_REJECT_NEWPROTOCOL"] = 142;
        values[valuesById[143] = "NETWORK_DISCONNECT_REJECT_INVALIDCONNECTION"] = 143;
        values[valuesById[144] = "NETWORK_DISCONNECT_REJECT_INVALIDCERTLEN"] = 144;
        values[valuesById[145] = "NETWORK_DISCONNECT_REJECT_INVALIDSTEAMCERTLEN"] = 145;
        values[valuesById[146] = "NETWORK_DISCONNECT_REJECT_STEAM"] = 146;
        values[valuesById[147] = "NETWORK_DISCONNECT_REJECT_SERVERAUTHDISABLED"] = 147;
        values[valuesById[148] = "NETWORK_DISCONNECT_REJECT_SERVERCDKEYAUTHINVALID"] = 148;
        values[valuesById[149] = "NETWORK_DISCONNECT_REJECT_BANNED"] = 149;
        values[valuesById[150] = "NETWORK_DISCONNECT_KICKED_TEAMKILLING"] = 150;
        values[valuesById[151] = "NETWORK_DISCONNECT_KICKED_TK_START"] = 151;
        values[valuesById[152] = "NETWORK_DISCONNECT_KICKED_UNTRUSTEDACCOUNT"] = 152;
        values[valuesById[153] = "NETWORK_DISCONNECT_KICKED_CONVICTEDACCOUNT"] = 153;
        values[valuesById[154] = "NETWORK_DISCONNECT_KICKED_COMPETITIVECOOLDOWN"] = 154;
        values[valuesById[155] = "NETWORK_DISCONNECT_KICKED_TEAMHURTING"] = 155;
        values[valuesById[156] = "NETWORK_DISCONNECT_KICKED_HOSTAGEKILLING"] = 156;
        values[valuesById[157] = "NETWORK_DISCONNECT_KICKED_VOTEDOFF"] = 157;
        values[valuesById[158] = "NETWORK_DISCONNECT_KICKED_IDLE"] = 158;
        values[valuesById[159] = "NETWORK_DISCONNECT_KICKED_SUICIDE"] = 159;
        values[valuesById[160] = "NETWORK_DISCONNECT_KICKED_NOSTEAMLOGIN"] = 160;
        values[valuesById[161] = "NETWORK_DISCONNECT_KICKED_NOSTEAMTICKET"] = 161;
        return values;
    })();
    
    $root.google = (function() {
    
        /**
         * Namespace google.
         * @exports google
         * @namespace
         */
        var google = {};
    
        google.protobuf = (function() {
    
            /**
             * Namespace protobuf.
             * @memberof google
             * @namespace
             */
            var protobuf = {};
    
            protobuf.FileDescriptorSet = (function() {
    
                /**
                 * Properties of a FileDescriptorSet.
                 * @memberof google.protobuf
                 * @interface IFileDescriptorSet
                 * @property {Array.<google.protobuf.IFileDescriptorProto>|null} [file] FileDescriptorSet file
                 */
    
                /**
                 * Constructs a new FileDescriptorSet.
                 * @memberof google.protobuf
                 * @classdesc Represents a FileDescriptorSet.
                 * @implements IFileDescriptorSet
                 * @constructor
                 * @param {google.protobuf.IFileDescriptorSet=} [properties] Properties to set
                 */
                function FileDescriptorSet(properties) {
                    this.file = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * FileDescriptorSet file.
                 * @member {Array.<google.protobuf.IFileDescriptorProto>} file
                 * @memberof google.protobuf.FileDescriptorSet
                 * @instance
                 */
                FileDescriptorSet.prototype.file = $util.emptyArray;
    
                /**
                 * Creates a new FileDescriptorSet instance using the specified properties.
                 * @function create
                 * @memberof google.protobuf.FileDescriptorSet
                 * @static
                 * @param {google.protobuf.IFileDescriptorSet=} [properties] Properties to set
                 * @returns {google.protobuf.FileDescriptorSet} FileDescriptorSet instance
                 */
                FileDescriptorSet.create = function create(properties) {
                    return new FileDescriptorSet(properties);
                };
    
                /**
                 * Encodes the specified FileDescriptorSet message. Does not implicitly {@link google.protobuf.FileDescriptorSet.verify|verify} messages.
                 * @function encode
                 * @memberof google.protobuf.FileDescriptorSet
                 * @static
                 * @param {google.protobuf.IFileDescriptorSet} message FileDescriptorSet message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                FileDescriptorSet.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.file != null && message.file.length)
                        for (var i = 0; i < message.file.length; ++i)
                            $root.google.protobuf.FileDescriptorProto.encode(message.file[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified FileDescriptorSet message, length delimited. Does not implicitly {@link google.protobuf.FileDescriptorSet.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof google.protobuf.FileDescriptorSet
                 * @static
                 * @param {google.protobuf.IFileDescriptorSet} message FileDescriptorSet message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                FileDescriptorSet.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a FileDescriptorSet message from the specified reader or buffer.
                 * @function decode
                 * @memberof google.protobuf.FileDescriptorSet
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {google.protobuf.FileDescriptorSet} FileDescriptorSet
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                FileDescriptorSet.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.FileDescriptorSet();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1: {
                                if (!(message.file && message.file.length))
                                    message.file = [];
                                message.file.push($root.google.protobuf.FileDescriptorProto.decode(reader, reader.uint32()));
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a FileDescriptorSet message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof google.protobuf.FileDescriptorSet
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {google.protobuf.FileDescriptorSet} FileDescriptorSet
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                FileDescriptorSet.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a FileDescriptorSet message.
                 * @function verify
                 * @memberof google.protobuf.FileDescriptorSet
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                FileDescriptorSet.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.file != null && message.hasOwnProperty("file")) {
                        if (!Array.isArray(message.file))
                            return "file: array expected";
                        for (var i = 0; i < message.file.length; ++i) {
                            var error = $root.google.protobuf.FileDescriptorProto.verify(message.file[i]);
                            if (error)
                                return "file." + error;
                        }
                    }
                    return null;
                };
    
                /**
                 * Creates a FileDescriptorSet message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof google.protobuf.FileDescriptorSet
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {google.protobuf.FileDescriptorSet} FileDescriptorSet
                 */
                FileDescriptorSet.fromObject = function fromObject(object) {
                    if (object instanceof $root.google.protobuf.FileDescriptorSet)
                        return object;
                    var message = new $root.google.protobuf.FileDescriptorSet();
                    if (object.file) {
                        if (!Array.isArray(object.file))
                            throw TypeError(".google.protobuf.FileDescriptorSet.file: array expected");
                        message.file = [];
                        for (var i = 0; i < object.file.length; ++i) {
                            if (typeof object.file[i] !== "object")
                                throw TypeError(".google.protobuf.FileDescriptorSet.file: object expected");
                            message.file[i] = $root.google.protobuf.FileDescriptorProto.fromObject(object.file[i]);
                        }
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a FileDescriptorSet message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof google.protobuf.FileDescriptorSet
                 * @static
                 * @param {google.protobuf.FileDescriptorSet} message FileDescriptorSet
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                FileDescriptorSet.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.file = [];
                    if (message.file && message.file.length) {
                        object.file = [];
                        for (var j = 0; j < message.file.length; ++j)
                            object.file[j] = $root.google.protobuf.FileDescriptorProto.toObject(message.file[j], options);
                    }
                    return object;
                };
    
                /**
                 * Converts this FileDescriptorSet to JSON.
                 * @function toJSON
                 * @memberof google.protobuf.FileDescriptorSet
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                FileDescriptorSet.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                /**
                 * Gets the default type url for FileDescriptorSet
                 * @function getTypeUrl
                 * @memberof google.protobuf.FileDescriptorSet
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                FileDescriptorSet.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/google.protobuf.FileDescriptorSet";
                };
    
                return FileDescriptorSet;
            })();
    
            protobuf.FileDescriptorProto = (function() {
    
                /**
                 * Properties of a FileDescriptorProto.
                 * @memberof google.protobuf
                 * @interface IFileDescriptorProto
                 * @property {string|null} [name] FileDescriptorProto name
                 * @property {string|null} ["package"] FileDescriptorProto package
                 * @property {Array.<string>|null} [dependency] FileDescriptorProto dependency
                 * @property {Array.<number>|null} [publicDependency] FileDescriptorProto publicDependency
                 * @property {Array.<number>|null} [weakDependency] FileDescriptorProto weakDependency
                 * @property {Array.<google.protobuf.IDescriptorProto>|null} [messageType] FileDescriptorProto messageType
                 * @property {Array.<google.protobuf.IEnumDescriptorProto>|null} [enumType] FileDescriptorProto enumType
                 * @property {Array.<google.protobuf.IServiceDescriptorProto>|null} [service] FileDescriptorProto service
                 * @property {Array.<google.protobuf.IFieldDescriptorProto>|null} [extension] FileDescriptorProto extension
                 * @property {google.protobuf.IFileOptions|null} [options] FileDescriptorProto options
                 * @property {google.protobuf.ISourceCodeInfo|null} [sourceCodeInfo] FileDescriptorProto sourceCodeInfo
                 * @property {string|null} [syntax] FileDescriptorProto syntax
                 */
    
                /**
                 * Constructs a new FileDescriptorProto.
                 * @memberof google.protobuf
                 * @classdesc Represents a FileDescriptorProto.
                 * @implements IFileDescriptorProto
                 * @constructor
                 * @param {google.protobuf.IFileDescriptorProto=} [properties] Properties to set
                 */
                function FileDescriptorProto(properties) {
                    this.dependency = [];
                    this.publicDependency = [];
                    this.weakDependency = [];
                    this.messageType = [];
                    this.enumType = [];
                    this.service = [];
                    this.extension = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * FileDescriptorProto name.
                 * @member {string} name
                 * @memberof google.protobuf.FileDescriptorProto
                 * @instance
                 */
                FileDescriptorProto.prototype.name = "";
    
                /**
                 * FileDescriptorProto package.
                 * @member {string} package
                 * @memberof google.protobuf.FileDescriptorProto
                 * @instance
                 */
                FileDescriptorProto.prototype["package"] = "";
    
                /**
                 * FileDescriptorProto dependency.
                 * @member {Array.<string>} dependency
                 * @memberof google.protobuf.FileDescriptorProto
                 * @instance
                 */
                FileDescriptorProto.prototype.dependency = $util.emptyArray;
    
                /**
                 * FileDescriptorProto publicDependency.
                 * @member {Array.<number>} publicDependency
                 * @memberof google.protobuf.FileDescriptorProto
                 * @instance
                 */
                FileDescriptorProto.prototype.publicDependency = $util.emptyArray;
    
                /**
                 * FileDescriptorProto weakDependency.
                 * @member {Array.<number>} weakDependency
                 * @memberof google.protobuf.FileDescriptorProto
                 * @instance
                 */
                FileDescriptorProto.prototype.weakDependency = $util.emptyArray;
    
                /**
                 * FileDescriptorProto messageType.
                 * @member {Array.<google.protobuf.IDescriptorProto>} messageType
                 * @memberof google.protobuf.FileDescriptorProto
                 * @instance
                 */
                FileDescriptorProto.prototype.messageType = $util.emptyArray;
    
                /**
                 * FileDescriptorProto enumType.
                 * @member {Array.<google.protobuf.IEnumDescriptorProto>} enumType
                 * @memberof google.protobuf.FileDescriptorProto
                 * @instance
                 */
                FileDescriptorProto.prototype.enumType = $util.emptyArray;
    
                /**
                 * FileDescriptorProto service.
                 * @member {Array.<google.protobuf.IServiceDescriptorProto>} service
                 * @memberof google.protobuf.FileDescriptorProto
                 * @instance
                 */
                FileDescriptorProto.prototype.service = $util.emptyArray;
    
                /**
                 * FileDescriptorProto extension.
                 * @member {Array.<google.protobuf.IFieldDescriptorProto>} extension
                 * @memberof google.protobuf.FileDescriptorProto
                 * @instance
                 */
                FileDescriptorProto.prototype.extension = $util.emptyArray;
    
                /**
                 * FileDescriptorProto options.
                 * @member {google.protobuf.IFileOptions|null|undefined} options
                 * @memberof google.protobuf.FileDescriptorProto
                 * @instance
                 */
                FileDescriptorProto.prototype.options = null;
    
                /**
                 * FileDescriptorProto sourceCodeInfo.
                 * @member {google.protobuf.ISourceCodeInfo|null|undefined} sourceCodeInfo
                 * @memberof google.protobuf.FileDescriptorProto
                 * @instance
                 */
                FileDescriptorProto.prototype.sourceCodeInfo = null;
    
                /**
                 * FileDescriptorProto syntax.
                 * @member {string} syntax
                 * @memberof google.protobuf.FileDescriptorProto
                 * @instance
                 */
                FileDescriptorProto.prototype.syntax = "";
    
                /**
                 * Creates a new FileDescriptorProto instance using the specified properties.
                 * @function create
                 * @memberof google.protobuf.FileDescriptorProto
                 * @static
                 * @param {google.protobuf.IFileDescriptorProto=} [properties] Properties to set
                 * @returns {google.protobuf.FileDescriptorProto} FileDescriptorProto instance
                 */
                FileDescriptorProto.create = function create(properties) {
                    return new FileDescriptorProto(properties);
                };
    
                /**
                 * Encodes the specified FileDescriptorProto message. Does not implicitly {@link google.protobuf.FileDescriptorProto.verify|verify} messages.
                 * @function encode
                 * @memberof google.protobuf.FileDescriptorProto
                 * @static
                 * @param {google.protobuf.IFileDescriptorProto} message FileDescriptorProto message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                FileDescriptorProto.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                    if (message["package"] != null && Object.hasOwnProperty.call(message, "package"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message["package"]);
                    if (message.dependency != null && message.dependency.length)
                        for (var i = 0; i < message.dependency.length; ++i)
                            writer.uint32(/* id 3, wireType 2 =*/26).string(message.dependency[i]);
                    if (message.messageType != null && message.messageType.length)
                        for (var i = 0; i < message.messageType.length; ++i)
                            $root.google.protobuf.DescriptorProto.encode(message.messageType[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                    if (message.enumType != null && message.enumType.length)
                        for (var i = 0; i < message.enumType.length; ++i)
                            $root.google.protobuf.EnumDescriptorProto.encode(message.enumType[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                    if (message.service != null && message.service.length)
                        for (var i = 0; i < message.service.length; ++i)
                            $root.google.protobuf.ServiceDescriptorProto.encode(message.service[i], writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                    if (message.extension != null && message.extension.length)
                        for (var i = 0; i < message.extension.length; ++i)
                            $root.google.protobuf.FieldDescriptorProto.encode(message.extension[i], writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
                    if (message.options != null && Object.hasOwnProperty.call(message, "options"))
                        $root.google.protobuf.FileOptions.encode(message.options, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
                    if (message.sourceCodeInfo != null && Object.hasOwnProperty.call(message, "sourceCodeInfo"))
                        $root.google.protobuf.SourceCodeInfo.encode(message.sourceCodeInfo, writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
                    if (message.publicDependency != null && message.publicDependency.length)
                        for (var i = 0; i < message.publicDependency.length; ++i)
                            writer.uint32(/* id 10, wireType 0 =*/80).int32(message.publicDependency[i]);
                    if (message.weakDependency != null && message.weakDependency.length)
                        for (var i = 0; i < message.weakDependency.length; ++i)
                            writer.uint32(/* id 11, wireType 0 =*/88).int32(message.weakDependency[i]);
                    if (message.syntax != null && Object.hasOwnProperty.call(message, "syntax"))
                        writer.uint32(/* id 12, wireType 2 =*/98).string(message.syntax);
                    return writer;
                };
    
                /**
                 * Encodes the specified FileDescriptorProto message, length delimited. Does not implicitly {@link google.protobuf.FileDescriptorProto.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof google.protobuf.FileDescriptorProto
                 * @static
                 * @param {google.protobuf.IFileDescriptorProto} message FileDescriptorProto message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                FileDescriptorProto.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a FileDescriptorProto message from the specified reader or buffer.
                 * @function decode
                 * @memberof google.protobuf.FileDescriptorProto
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {google.protobuf.FileDescriptorProto} FileDescriptorProto
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                FileDescriptorProto.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.FileDescriptorProto();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1: {
                                message.name = reader.string();
                                break;
                            }
                        case 2: {
                                message["package"] = reader.string();
                                break;
                            }
                        case 3: {
                                if (!(message.dependency && message.dependency.length))
                                    message.dependency = [];
                                message.dependency.push(reader.string());
                                break;
                            }
                        case 10: {
                                if (!(message.publicDependency && message.publicDependency.length))
                                    message.publicDependency = [];
                                if ((tag & 7) === 2) {
                                    var end2 = reader.uint32() + reader.pos;
                                    while (reader.pos < end2)
                                        message.publicDependency.push(reader.int32());
                                } else
                                    message.publicDependency.push(reader.int32());
                                break;
                            }
                        case 11: {
                                if (!(message.weakDependency && message.weakDependency.length))
                                    message.weakDependency = [];
                                if ((tag & 7) === 2) {
                                    var end2 = reader.uint32() + reader.pos;
                                    while (reader.pos < end2)
                                        message.weakDependency.push(reader.int32());
                                } else
                                    message.weakDependency.push(reader.int32());
                                break;
                            }
                        case 4: {
                                if (!(message.messageType && message.messageType.length))
                                    message.messageType = [];
                                message.messageType.push($root.google.protobuf.DescriptorProto.decode(reader, reader.uint32()));
                                break;
                            }
                        case 5: {
                                if (!(message.enumType && message.enumType.length))
                                    message.enumType = [];
                                message.enumType.push($root.google.protobuf.EnumDescriptorProto.decode(reader, reader.uint32()));
                                break;
                            }
                        case 6: {
                                if (!(message.service && message.service.length))
                                    message.service = [];
                                message.service.push($root.google.protobuf.ServiceDescriptorProto.decode(reader, reader.uint32()));
                                break;
                            }
                        case 7: {
                                if (!(message.extension && message.extension.length))
                                    message.extension = [];
                                message.extension.push($root.google.protobuf.FieldDescriptorProto.decode(reader, reader.uint32()));
                                break;
                            }
                        case 8: {
                                message.options = $root.google.protobuf.FileOptions.decode(reader, reader.uint32());
                                break;
                            }
                        case 9: {
                                message.sourceCodeInfo = $root.google.protobuf.SourceCodeInfo.decode(reader, reader.uint32());
                                break;
                            }
                        case 12: {
                                message.syntax = reader.string();
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a FileDescriptorProto message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof google.protobuf.FileDescriptorProto
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {google.protobuf.FileDescriptorProto} FileDescriptorProto
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                FileDescriptorProto.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a FileDescriptorProto message.
                 * @function verify
                 * @memberof google.protobuf.FileDescriptorProto
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                FileDescriptorProto.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.name != null && message.hasOwnProperty("name"))
                        if (!$util.isString(message.name))
                            return "name: string expected";
                    if (message["package"] != null && message.hasOwnProperty("package"))
                        if (!$util.isString(message["package"]))
                            return "package: string expected";
                    if (message.dependency != null && message.hasOwnProperty("dependency")) {
                        if (!Array.isArray(message.dependency))
                            return "dependency: array expected";
                        for (var i = 0; i < message.dependency.length; ++i)
                            if (!$util.isString(message.dependency[i]))
                                return "dependency: string[] expected";
                    }
                    if (message.publicDependency != null && message.hasOwnProperty("publicDependency")) {
                        if (!Array.isArray(message.publicDependency))
                            return "publicDependency: array expected";
                        for (var i = 0; i < message.publicDependency.length; ++i)
                            if (!$util.isInteger(message.publicDependency[i]))
                                return "publicDependency: integer[] expected";
                    }
                    if (message.weakDependency != null && message.hasOwnProperty("weakDependency")) {
                        if (!Array.isArray(message.weakDependency))
                            return "weakDependency: array expected";
                        for (var i = 0; i < message.weakDependency.length; ++i)
                            if (!$util.isInteger(message.weakDependency[i]))
                                return "weakDependency: integer[] expected";
                    }
                    if (message.messageType != null && message.hasOwnProperty("messageType")) {
                        if (!Array.isArray(message.messageType))
                            return "messageType: array expected";
                        for (var i = 0; i < message.messageType.length; ++i) {
                            var error = $root.google.protobuf.DescriptorProto.verify(message.messageType[i]);
                            if (error)
                                return "messageType." + error;
                        }
                    }
                    if (message.enumType != null && message.hasOwnProperty("enumType")) {
                        if (!Array.isArray(message.enumType))
                            return "enumType: array expected";
                        for (var i = 0; i < message.enumType.length; ++i) {
                            var error = $root.google.protobuf.EnumDescriptorProto.verify(message.enumType[i]);
                            if (error)
                                return "enumType." + error;
                        }
                    }
                    if (message.service != null && message.hasOwnProperty("service")) {
                        if (!Array.isArray(message.service))
                            return "service: array expected";
                        for (var i = 0; i < message.service.length; ++i) {
                            var error = $root.google.protobuf.ServiceDescriptorProto.verify(message.service[i]);
                            if (error)
                                return "service." + error;
                        }
                    }
                    if (message.extension != null && message.hasOwnProperty("extension")) {
                        if (!Array.isArray(message.extension))
                            return "extension: array expected";
                        for (var i = 0; i < message.extension.length; ++i) {
                            var error = $root.google.protobuf.FieldDescriptorProto.verify(message.extension[i]);
                            if (error)
                                return "extension." + error;
                        }
                    }
                    if (message.options != null && message.hasOwnProperty("options")) {
                        var error = $root.google.protobuf.FileOptions.verify(message.options);
                        if (error)
                            return "options." + error;
                    }
                    if (message.sourceCodeInfo != null && message.hasOwnProperty("sourceCodeInfo")) {
                        var error = $root.google.protobuf.SourceCodeInfo.verify(message.sourceCodeInfo);
                        if (error)
                            return "sourceCodeInfo." + error;
                    }
                    if (message.syntax != null && message.hasOwnProperty("syntax"))
                        if (!$util.isString(message.syntax))
                            return "syntax: string expected";
                    return null;
                };
    
                /**
                 * Creates a FileDescriptorProto message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof google.protobuf.FileDescriptorProto
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {google.protobuf.FileDescriptorProto} FileDescriptorProto
                 */
                FileDescriptorProto.fromObject = function fromObject(object) {
                    if (object instanceof $root.google.protobuf.FileDescriptorProto)
                        return object;
                    var message = new $root.google.protobuf.FileDescriptorProto();
                    if (object.name != null)
                        message.name = String(object.name);
                    if (object["package"] != null)
                        message["package"] = String(object["package"]);
                    if (object.dependency) {
                        if (!Array.isArray(object.dependency))
                            throw TypeError(".google.protobuf.FileDescriptorProto.dependency: array expected");
                        message.dependency = [];
                        for (var i = 0; i < object.dependency.length; ++i)
                            message.dependency[i] = String(object.dependency[i]);
                    }
                    if (object.publicDependency) {
                        if (!Array.isArray(object.publicDependency))
                            throw TypeError(".google.protobuf.FileDescriptorProto.publicDependency: array expected");
                        message.publicDependency = [];
                        for (var i = 0; i < object.publicDependency.length; ++i)
                            message.publicDependency[i] = object.publicDependency[i] | 0;
                    }
                    if (object.weakDependency) {
                        if (!Array.isArray(object.weakDependency))
                            throw TypeError(".google.protobuf.FileDescriptorProto.weakDependency: array expected");
                        message.weakDependency = [];
                        for (var i = 0; i < object.weakDependency.length; ++i)
                            message.weakDependency[i] = object.weakDependency[i] | 0;
                    }
                    if (object.messageType) {
                        if (!Array.isArray(object.messageType))
                            throw TypeError(".google.protobuf.FileDescriptorProto.messageType: array expected");
                        message.messageType = [];
                        for (var i = 0; i < object.messageType.length; ++i) {
                            if (typeof object.messageType[i] !== "object")
                                throw TypeError(".google.protobuf.FileDescriptorProto.messageType: object expected");
                            message.messageType[i] = $root.google.protobuf.DescriptorProto.fromObject(object.messageType[i]);
                        }
                    }
                    if (object.enumType) {
                        if (!Array.isArray(object.enumType))
                            throw TypeError(".google.protobuf.FileDescriptorProto.enumType: array expected");
                        message.enumType = [];
                        for (var i = 0; i < object.enumType.length; ++i) {
                            if (typeof object.enumType[i] !== "object")
                                throw TypeError(".google.protobuf.FileDescriptorProto.enumType: object expected");
                            message.enumType[i] = $root.google.protobuf.EnumDescriptorProto.fromObject(object.enumType[i]);
                        }
                    }
                    if (object.service) {
                        if (!Array.isArray(object.service))
                            throw TypeError(".google.protobuf.FileDescriptorProto.service: array expected");
                        message.service = [];
                        for (var i = 0; i < object.service.length; ++i) {
                            if (typeof object.service[i] !== "object")
                                throw TypeError(".google.protobuf.FileDescriptorProto.service: object expected");
                            message.service[i] = $root.google.protobuf.ServiceDescriptorProto.fromObject(object.service[i]);
                        }
                    }
                    if (object.extension) {
                        if (!Array.isArray(object.extension))
                            throw TypeError(".google.protobuf.FileDescriptorProto.extension: array expected");
                        message.extension = [];
                        for (var i = 0; i < object.extension.length; ++i) {
                            if (typeof object.extension[i] !== "object")
                                throw TypeError(".google.protobuf.FileDescriptorProto.extension: object expected");
                            message.extension[i] = $root.google.protobuf.FieldDescriptorProto.fromObject(object.extension[i]);
                        }
                    }
                    if (object.options != null) {
                        if (typeof object.options !== "object")
                            throw TypeError(".google.protobuf.FileDescriptorProto.options: object expected");
                        message.options = $root.google.protobuf.FileOptions.fromObject(object.options);
                    }
                    if (object.sourceCodeInfo != null) {
                        if (typeof object.sourceCodeInfo !== "object")
                            throw TypeError(".google.protobuf.FileDescriptorProto.sourceCodeInfo: object expected");
                        message.sourceCodeInfo = $root.google.protobuf.SourceCodeInfo.fromObject(object.sourceCodeInfo);
                    }
                    if (object.syntax != null)
                        message.syntax = String(object.syntax);
                    return message;
                };
    
                /**
                 * Creates a plain object from a FileDescriptorProto message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof google.protobuf.FileDescriptorProto
                 * @static
                 * @param {google.protobuf.FileDescriptorProto} message FileDescriptorProto
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                FileDescriptorProto.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults) {
                        object.dependency = [];
                        object.messageType = [];
                        object.enumType = [];
                        object.service = [];
                        object.extension = [];
                        object.publicDependency = [];
                        object.weakDependency = [];
                    }
                    if (options.defaults) {
                        object.name = "";
                        object["package"] = "";
                        object.options = null;
                        object.sourceCodeInfo = null;
                        object.syntax = "";
                    }
                    if (message.name != null && message.hasOwnProperty("name"))
                        object.name = message.name;
                    if (message["package"] != null && message.hasOwnProperty("package"))
                        object["package"] = message["package"];
                    if (message.dependency && message.dependency.length) {
                        object.dependency = [];
                        for (var j = 0; j < message.dependency.length; ++j)
                            object.dependency[j] = message.dependency[j];
                    }
                    if (message.messageType && message.messageType.length) {
                        object.messageType = [];
                        for (var j = 0; j < message.messageType.length; ++j)
                            object.messageType[j] = $root.google.protobuf.DescriptorProto.toObject(message.messageType[j], options);
                    }
                    if (message.enumType && message.enumType.length) {
                        object.enumType = [];
                        for (var j = 0; j < message.enumType.length; ++j)
                            object.enumType[j] = $root.google.protobuf.EnumDescriptorProto.toObject(message.enumType[j], options);
                    }
                    if (message.service && message.service.length) {
                        object.service = [];
                        for (var j = 0; j < message.service.length; ++j)
                            object.service[j] = $root.google.protobuf.ServiceDescriptorProto.toObject(message.service[j], options);
                    }
                    if (message.extension && message.extension.length) {
                        object.extension = [];
                        for (var j = 0; j < message.extension.length; ++j)
                            object.extension[j] = $root.google.protobuf.FieldDescriptorProto.toObject(message.extension[j], options);
                    }
                    if (message.options != null && message.hasOwnProperty("options"))
                        object.options = $root.google.protobuf.FileOptions.toObject(message.options, options);
                    if (message.sourceCodeInfo != null && message.hasOwnProperty("sourceCodeInfo"))
                        object.sourceCodeInfo = $root.google.protobuf.SourceCodeInfo.toObject(message.sourceCodeInfo, options);
                    if (message.publicDependency && message.publicDependency.length) {
                        object.publicDependency = [];
                        for (var j = 0; j < message.publicDependency.length; ++j)
                            object.publicDependency[j] = message.publicDependency[j];
                    }
                    if (message.weakDependency && message.weakDependency.length) {
                        object.weakDependency = [];
                        for (var j = 0; j < message.weakDependency.length; ++j)
                            object.weakDependency[j] = message.weakDependency[j];
                    }
                    if (message.syntax != null && message.hasOwnProperty("syntax"))
                        object.syntax = message.syntax;
                    return object;
                };
    
                /**
                 * Converts this FileDescriptorProto to JSON.
                 * @function toJSON
                 * @memberof google.protobuf.FileDescriptorProto
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                FileDescriptorProto.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                /**
                 * Gets the default type url for FileDescriptorProto
                 * @function getTypeUrl
                 * @memberof google.protobuf.FileDescriptorProto
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                FileDescriptorProto.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/google.protobuf.FileDescriptorProto";
                };
    
                return FileDescriptorProto;
            })();
    
            protobuf.DescriptorProto = (function() {
    
                /**
                 * Properties of a DescriptorProto.
                 * @memberof google.protobuf
                 * @interface IDescriptorProto
                 * @property {string|null} [name] DescriptorProto name
                 * @property {Array.<google.protobuf.IFieldDescriptorProto>|null} [field] DescriptorProto field
                 * @property {Array.<google.protobuf.IFieldDescriptorProto>|null} [extension] DescriptorProto extension
                 * @property {Array.<google.protobuf.IDescriptorProto>|null} [nestedType] DescriptorProto nestedType
                 * @property {Array.<google.protobuf.IEnumDescriptorProto>|null} [enumType] DescriptorProto enumType
                 * @property {Array.<google.protobuf.DescriptorProto.IExtensionRange>|null} [extensionRange] DescriptorProto extensionRange
                 * @property {Array.<google.protobuf.IOneofDescriptorProto>|null} [oneofDecl] DescriptorProto oneofDecl
                 * @property {google.protobuf.IMessageOptions|null} [options] DescriptorProto options
                 * @property {Array.<google.protobuf.DescriptorProto.IReservedRange>|null} [reservedRange] DescriptorProto reservedRange
                 * @property {Array.<string>|null} [reservedName] DescriptorProto reservedName
                 */
    
                /**
                 * Constructs a new DescriptorProto.
                 * @memberof google.protobuf
                 * @classdesc Represents a DescriptorProto.
                 * @implements IDescriptorProto
                 * @constructor
                 * @param {google.protobuf.IDescriptorProto=} [properties] Properties to set
                 */
                function DescriptorProto(properties) {
                    this.field = [];
                    this.extension = [];
                    this.nestedType = [];
                    this.enumType = [];
                    this.extensionRange = [];
                    this.oneofDecl = [];
                    this.reservedRange = [];
                    this.reservedName = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * DescriptorProto name.
                 * @member {string} name
                 * @memberof google.protobuf.DescriptorProto
                 * @instance
                 */
                DescriptorProto.prototype.name = "";
    
                /**
                 * DescriptorProto field.
                 * @member {Array.<google.protobuf.IFieldDescriptorProto>} field
                 * @memberof google.protobuf.DescriptorProto
                 * @instance
                 */
                DescriptorProto.prototype.field = $util.emptyArray;
    
                /**
                 * DescriptorProto extension.
                 * @member {Array.<google.protobuf.IFieldDescriptorProto>} extension
                 * @memberof google.protobuf.DescriptorProto
                 * @instance
                 */
                DescriptorProto.prototype.extension = $util.emptyArray;
    
                /**
                 * DescriptorProto nestedType.
                 * @member {Array.<google.protobuf.IDescriptorProto>} nestedType
                 * @memberof google.protobuf.DescriptorProto
                 * @instance
                 */
                DescriptorProto.prototype.nestedType = $util.emptyArray;
    
                /**
                 * DescriptorProto enumType.
                 * @member {Array.<google.protobuf.IEnumDescriptorProto>} enumType
                 * @memberof google.protobuf.DescriptorProto
                 * @instance
                 */
                DescriptorProto.prototype.enumType = $util.emptyArray;
    
                /**
                 * DescriptorProto extensionRange.
                 * @member {Array.<google.protobuf.DescriptorProto.IExtensionRange>} extensionRange
                 * @memberof google.protobuf.DescriptorProto
                 * @instance
                 */
                DescriptorProto.prototype.extensionRange = $util.emptyArray;
    
                /**
                 * DescriptorProto oneofDecl.
                 * @member {Array.<google.protobuf.IOneofDescriptorProto>} oneofDecl
                 * @memberof google.protobuf.DescriptorProto
                 * @instance
                 */
                DescriptorProto.prototype.oneofDecl = $util.emptyArray;
    
                /**
                 * DescriptorProto options.
                 * @member {google.protobuf.IMessageOptions|null|undefined} options
                 * @memberof google.protobuf.DescriptorProto
                 * @instance
                 */
                DescriptorProto.prototype.options = null;
    
                /**
                 * DescriptorProto reservedRange.
                 * @member {Array.<google.protobuf.DescriptorProto.IReservedRange>} reservedRange
                 * @memberof google.protobuf.DescriptorProto
                 * @instance
                 */
                DescriptorProto.prototype.reservedRange = $util.emptyArray;
    
                /**
                 * DescriptorProto reservedName.
                 * @member {Array.<string>} reservedName
                 * @memberof google.protobuf.DescriptorProto
                 * @instance
                 */
                DescriptorProto.prototype.reservedName = $util.emptyArray;
    
                /**
                 * Creates a new DescriptorProto instance using the specified properties.
                 * @function create
                 * @memberof google.protobuf.DescriptorProto
                 * @static
                 * @param {google.protobuf.IDescriptorProto=} [properties] Properties to set
                 * @returns {google.protobuf.DescriptorProto} DescriptorProto instance
                 */
                DescriptorProto.create = function create(properties) {
                    return new DescriptorProto(properties);
                };
    
                /**
                 * Encodes the specified DescriptorProto message. Does not implicitly {@link google.protobuf.DescriptorProto.verify|verify} messages.
                 * @function encode
                 * @memberof google.protobuf.DescriptorProto
                 * @static
                 * @param {google.protobuf.IDescriptorProto} message DescriptorProto message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                DescriptorProto.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                    if (message.field != null && message.field.length)
                        for (var i = 0; i < message.field.length; ++i)
                            $root.google.protobuf.FieldDescriptorProto.encode(message.field[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    if (message.nestedType != null && message.nestedType.length)
                        for (var i = 0; i < message.nestedType.length; ++i)
                            $root.google.protobuf.DescriptorProto.encode(message.nestedType[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    if (message.enumType != null && message.enumType.length)
                        for (var i = 0; i < message.enumType.length; ++i)
                            $root.google.protobuf.EnumDescriptorProto.encode(message.enumType[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                    if (message.extensionRange != null && message.extensionRange.length)
                        for (var i = 0; i < message.extensionRange.length; ++i)
                            $root.google.protobuf.DescriptorProto.ExtensionRange.encode(message.extensionRange[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                    if (message.extension != null && message.extension.length)
                        for (var i = 0; i < message.extension.length; ++i)
                            $root.google.protobuf.FieldDescriptorProto.encode(message.extension[i], writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                    if (message.options != null && Object.hasOwnProperty.call(message, "options"))
                        $root.google.protobuf.MessageOptions.encode(message.options, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
                    if (message.oneofDecl != null && message.oneofDecl.length)
                        for (var i = 0; i < message.oneofDecl.length; ++i)
                            $root.google.protobuf.OneofDescriptorProto.encode(message.oneofDecl[i], writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
                    if (message.reservedRange != null && message.reservedRange.length)
                        for (var i = 0; i < message.reservedRange.length; ++i)
                            $root.google.protobuf.DescriptorProto.ReservedRange.encode(message.reservedRange[i], writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
                    if (message.reservedName != null && message.reservedName.length)
                        for (var i = 0; i < message.reservedName.length; ++i)
                            writer.uint32(/* id 10, wireType 2 =*/82).string(message.reservedName[i]);
                    return writer;
                };
    
                /**
                 * Encodes the specified DescriptorProto message, length delimited. Does not implicitly {@link google.protobuf.DescriptorProto.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof google.protobuf.DescriptorProto
                 * @static
                 * @param {google.protobuf.IDescriptorProto} message DescriptorProto message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                DescriptorProto.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a DescriptorProto message from the specified reader or buffer.
                 * @function decode
                 * @memberof google.protobuf.DescriptorProto
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {google.protobuf.DescriptorProto} DescriptorProto
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                DescriptorProto.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.DescriptorProto();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1: {
                                message.name = reader.string();
                                break;
                            }
                        case 2: {
                                if (!(message.field && message.field.length))
                                    message.field = [];
                                message.field.push($root.google.protobuf.FieldDescriptorProto.decode(reader, reader.uint32()));
                                break;
                            }
                        case 6: {
                                if (!(message.extension && message.extension.length))
                                    message.extension = [];
                                message.extension.push($root.google.protobuf.FieldDescriptorProto.decode(reader, reader.uint32()));
                                break;
                            }
                        case 3: {
                                if (!(message.nestedType && message.nestedType.length))
                                    message.nestedType = [];
                                message.nestedType.push($root.google.protobuf.DescriptorProto.decode(reader, reader.uint32()));
                                break;
                            }
                        case 4: {
                                if (!(message.enumType && message.enumType.length))
                                    message.enumType = [];
                                message.enumType.push($root.google.protobuf.EnumDescriptorProto.decode(reader, reader.uint32()));
                                break;
                            }
                        case 5: {
                                if (!(message.extensionRange && message.extensionRange.length))
                                    message.extensionRange = [];
                                message.extensionRange.push($root.google.protobuf.DescriptorProto.ExtensionRange.decode(reader, reader.uint32()));
                                break;
                            }
                        case 8: {
                                if (!(message.oneofDecl && message.oneofDecl.length))
                                    message.oneofDecl = [];
                                message.oneofDecl.push($root.google.protobuf.OneofDescriptorProto.decode(reader, reader.uint32()));
                                break;
                            }
                        case 7: {
                                message.options = $root.google.protobuf.MessageOptions.decode(reader, reader.uint32());
                                break;
                            }
                        case 9: {
                                if (!(message.reservedRange && message.reservedRange.length))
                                    message.reservedRange = [];
                                message.reservedRange.push($root.google.protobuf.DescriptorProto.ReservedRange.decode(reader, reader.uint32()));
                                break;
                            }
                        case 10: {
                                if (!(message.reservedName && message.reservedName.length))
                                    message.reservedName = [];
                                message.reservedName.push(reader.string());
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a DescriptorProto message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof google.protobuf.DescriptorProto
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {google.protobuf.DescriptorProto} DescriptorProto
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                DescriptorProto.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a DescriptorProto message.
                 * @function verify
                 * @memberof google.protobuf.DescriptorProto
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                DescriptorProto.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.name != null && message.hasOwnProperty("name"))
                        if (!$util.isString(message.name))
                            return "name: string expected";
                    if (message.field != null && message.hasOwnProperty("field")) {
                        if (!Array.isArray(message.field))
                            return "field: array expected";
                        for (var i = 0; i < message.field.length; ++i) {
                            var error = $root.google.protobuf.FieldDescriptorProto.verify(message.field[i]);
                            if (error)
                                return "field." + error;
                        }
                    }
                    if (message.extension != null && message.hasOwnProperty("extension")) {
                        if (!Array.isArray(message.extension))
                            return "extension: array expected";
                        for (var i = 0; i < message.extension.length; ++i) {
                            var error = $root.google.protobuf.FieldDescriptorProto.verify(message.extension[i]);
                            if (error)
                                return "extension." + error;
                        }
                    }
                    if (message.nestedType != null && message.hasOwnProperty("nestedType")) {
                        if (!Array.isArray(message.nestedType))
                            return "nestedType: array expected";
                        for (var i = 0; i < message.nestedType.length; ++i) {
                            var error = $root.google.protobuf.DescriptorProto.verify(message.nestedType[i]);
                            if (error)
                                return "nestedType." + error;
                        }
                    }
                    if (message.enumType != null && message.hasOwnProperty("enumType")) {
                        if (!Array.isArray(message.enumType))
                            return "enumType: array expected";
                        for (var i = 0; i < message.enumType.length; ++i) {
                            var error = $root.google.protobuf.EnumDescriptorProto.verify(message.enumType[i]);
                            if (error)
                                return "enumType." + error;
                        }
                    }
                    if (message.extensionRange != null && message.hasOwnProperty("extensionRange")) {
                        if (!Array.isArray(message.extensionRange))
                            return "extensionRange: array expected";
                        for (var i = 0; i < message.extensionRange.length; ++i) {
                            var error = $root.google.protobuf.DescriptorProto.ExtensionRange.verify(message.extensionRange[i]);
                            if (error)
                                return "extensionRange." + error;
                        }
                    }
                    if (message.oneofDecl != null && message.hasOwnProperty("oneofDecl")) {
                        if (!Array.isArray(message.oneofDecl))
                            return "oneofDecl: array expected";
                        for (var i = 0; i < message.oneofDecl.length; ++i) {
                            var error = $root.google.protobuf.OneofDescriptorProto.verify(message.oneofDecl[i]);
                            if (error)
                                return "oneofDecl." + error;
                        }
                    }
                    if (message.options != null && message.hasOwnProperty("options")) {
                        var error = $root.google.protobuf.MessageOptions.verify(message.options);
                        if (error)
                            return "options." + error;
                    }
                    if (message.reservedRange != null && message.hasOwnProperty("reservedRange")) {
                        if (!Array.isArray(message.reservedRange))
                            return "reservedRange: array expected";
                        for (var i = 0; i < message.reservedRange.length; ++i) {
                            var error = $root.google.protobuf.DescriptorProto.ReservedRange.verify(message.reservedRange[i]);
                            if (error)
                                return "reservedRange." + error;
                        }
                    }
                    if (message.reservedName != null && message.hasOwnProperty("reservedName")) {
                        if (!Array.isArray(message.reservedName))
                            return "reservedName: array expected";
                        for (var i = 0; i < message.reservedName.length; ++i)
                            if (!$util.isString(message.reservedName[i]))
                                return "reservedName: string[] expected";
                    }
                    return null;
                };
    
                /**
                 * Creates a DescriptorProto message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof google.protobuf.DescriptorProto
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {google.protobuf.DescriptorProto} DescriptorProto
                 */
                DescriptorProto.fromObject = function fromObject(object) {
                    if (object instanceof $root.google.protobuf.DescriptorProto)
                        return object;
                    var message = new $root.google.protobuf.DescriptorProto();
                    if (object.name != null)
                        message.name = String(object.name);
                    if (object.field) {
                        if (!Array.isArray(object.field))
                            throw TypeError(".google.protobuf.DescriptorProto.field: array expected");
                        message.field = [];
                        for (var i = 0; i < object.field.length; ++i) {
                            if (typeof object.field[i] !== "object")
                                throw TypeError(".google.protobuf.DescriptorProto.field: object expected");
                            message.field[i] = $root.google.protobuf.FieldDescriptorProto.fromObject(object.field[i]);
                        }
                    }
                    if (object.extension) {
                        if (!Array.isArray(object.extension))
                            throw TypeError(".google.protobuf.DescriptorProto.extension: array expected");
                        message.extension = [];
                        for (var i = 0; i < object.extension.length; ++i) {
                            if (typeof object.extension[i] !== "object")
                                throw TypeError(".google.protobuf.DescriptorProto.extension: object expected");
                            message.extension[i] = $root.google.protobuf.FieldDescriptorProto.fromObject(object.extension[i]);
                        }
                    }
                    if (object.nestedType) {
                        if (!Array.isArray(object.nestedType))
                            throw TypeError(".google.protobuf.DescriptorProto.nestedType: array expected");
                        message.nestedType = [];
                        for (var i = 0; i < object.nestedType.length; ++i) {
                            if (typeof object.nestedType[i] !== "object")
                                throw TypeError(".google.protobuf.DescriptorProto.nestedType: object expected");
                            message.nestedType[i] = $root.google.protobuf.DescriptorProto.fromObject(object.nestedType[i]);
                        }
                    }
                    if (object.enumType) {
                        if (!Array.isArray(object.enumType))
                            throw TypeError(".google.protobuf.DescriptorProto.enumType: array expected");
                        message.enumType = [];
                        for (var i = 0; i < object.enumType.length; ++i) {
                            if (typeof object.enumType[i] !== "object")
                                throw TypeError(".google.protobuf.DescriptorProto.enumType: object expected");
                            message.enumType[i] = $root.google.protobuf.EnumDescriptorProto.fromObject(object.enumType[i]);
                        }
                    }
                    if (object.extensionRange) {
                        if (!Array.isArray(object.extensionRange))
                            throw TypeError(".google.protobuf.DescriptorProto.extensionRange: array expected");
                        message.extensionRange = [];
                        for (var i = 0; i < object.extensionRange.length; ++i) {
                            if (typeof object.extensionRange[i] !== "object")
                                throw TypeError(".google.protobuf.DescriptorProto.extensionRange: object expected");
                            message.extensionRange[i] = $root.google.protobuf.DescriptorProto.ExtensionRange.fromObject(object.extensionRange[i]);
                        }
                    }
                    if (object.oneofDecl) {
                        if (!Array.isArray(object.oneofDecl))
                            throw TypeError(".google.protobuf.DescriptorProto.oneofDecl: array expected");
                        message.oneofDecl = [];
                        for (var i = 0; i < object.oneofDecl.length; ++i) {
                            if (typeof object.oneofDecl[i] !== "object")
                                throw TypeError(".google.protobuf.DescriptorProto.oneofDecl: object expected");
                            message.oneofDecl[i] = $root.google.protobuf.OneofDescriptorProto.fromObject(object.oneofDecl[i]);
                        }
                    }
                    if (object.options != null) {
                        if (typeof object.options !== "object")
                            throw TypeError(".google.protobuf.DescriptorProto.options: object expected");
                        message.options = $root.google.protobuf.MessageOptions.fromObject(object.options);
                    }
                    if (object.reservedRange) {
                        if (!Array.isArray(object.reservedRange))
                            throw TypeError(".google.protobuf.DescriptorProto.reservedRange: array expected");
                        message.reservedRange = [];
                        for (var i = 0; i < object.reservedRange.length; ++i) {
                            if (typeof object.reservedRange[i] !== "object")
                                throw TypeError(".google.protobuf.DescriptorProto.reservedRange: object expected");
                            message.reservedRange[i] = $root.google.protobuf.DescriptorProto.ReservedRange.fromObject(object.reservedRange[i]);
                        }
                    }
                    if (object.reservedName) {
                        if (!Array.isArray(object.reservedName))
                            throw TypeError(".google.protobuf.DescriptorProto.reservedName: array expected");
                        message.reservedName = [];
                        for (var i = 0; i < object.reservedName.length; ++i)
                            message.reservedName[i] = String(object.reservedName[i]);
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a DescriptorProto message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof google.protobuf.DescriptorProto
                 * @static
                 * @param {google.protobuf.DescriptorProto} message DescriptorProto
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                DescriptorProto.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults) {
                        object.field = [];
                        object.nestedType = [];
                        object.enumType = [];
                        object.extensionRange = [];
                        object.extension = [];
                        object.oneofDecl = [];
                        object.reservedRange = [];
                        object.reservedName = [];
                    }
                    if (options.defaults) {
                        object.name = "";
                        object.options = null;
                    }
                    if (message.name != null && message.hasOwnProperty("name"))
                        object.name = message.name;
                    if (message.field && message.field.length) {
                        object.field = [];
                        for (var j = 0; j < message.field.length; ++j)
                            object.field[j] = $root.google.protobuf.FieldDescriptorProto.toObject(message.field[j], options);
                    }
                    if (message.nestedType && message.nestedType.length) {
                        object.nestedType = [];
                        for (var j = 0; j < message.nestedType.length; ++j)
                            object.nestedType[j] = $root.google.protobuf.DescriptorProto.toObject(message.nestedType[j], options);
                    }
                    if (message.enumType && message.enumType.length) {
                        object.enumType = [];
                        for (var j = 0; j < message.enumType.length; ++j)
                            object.enumType[j] = $root.google.protobuf.EnumDescriptorProto.toObject(message.enumType[j], options);
                    }
                    if (message.extensionRange && message.extensionRange.length) {
                        object.extensionRange = [];
                        for (var j = 0; j < message.extensionRange.length; ++j)
                            object.extensionRange[j] = $root.google.protobuf.DescriptorProto.ExtensionRange.toObject(message.extensionRange[j], options);
                    }
                    if (message.extension && message.extension.length) {
                        object.extension = [];
                        for (var j = 0; j < message.extension.length; ++j)
                            object.extension[j] = $root.google.protobuf.FieldDescriptorProto.toObject(message.extension[j], options);
                    }
                    if (message.options != null && message.hasOwnProperty("options"))
                        object.options = $root.google.protobuf.MessageOptions.toObject(message.options, options);
                    if (message.oneofDecl && message.oneofDecl.length) {
                        object.oneofDecl = [];
                        for (var j = 0; j < message.oneofDecl.length; ++j)
                            object.oneofDecl[j] = $root.google.protobuf.OneofDescriptorProto.toObject(message.oneofDecl[j], options);
                    }
                    if (message.reservedRange && message.reservedRange.length) {
                        object.reservedRange = [];
                        for (var j = 0; j < message.reservedRange.length; ++j)
                            object.reservedRange[j] = $root.google.protobuf.DescriptorProto.ReservedRange.toObject(message.reservedRange[j], options);
                    }
                    if (message.reservedName && message.reservedName.length) {
                        object.reservedName = [];
                        for (var j = 0; j < message.reservedName.length; ++j)
                            object.reservedName[j] = message.reservedName[j];
                    }
                    return object;
                };
    
                /**
                 * Converts this DescriptorProto to JSON.
                 * @function toJSON
                 * @memberof google.protobuf.DescriptorProto
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                DescriptorProto.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                /**
                 * Gets the default type url for DescriptorProto
                 * @function getTypeUrl
                 * @memberof google.protobuf.DescriptorProto
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                DescriptorProto.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/google.protobuf.DescriptorProto";
                };
    
                DescriptorProto.ExtensionRange = (function() {
    
                    /**
                     * Properties of an ExtensionRange.
                     * @memberof google.protobuf.DescriptorProto
                     * @interface IExtensionRange
                     * @property {number|null} [start] ExtensionRange start
                     * @property {number|null} [end] ExtensionRange end
                     */
    
                    /**
                     * Constructs a new ExtensionRange.
                     * @memberof google.protobuf.DescriptorProto
                     * @classdesc Represents an ExtensionRange.
                     * @implements IExtensionRange
                     * @constructor
                     * @param {google.protobuf.DescriptorProto.IExtensionRange=} [properties] Properties to set
                     */
                    function ExtensionRange(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * ExtensionRange start.
                     * @member {number} start
                     * @memberof google.protobuf.DescriptorProto.ExtensionRange
                     * @instance
                     */
                    ExtensionRange.prototype.start = 0;
    
                    /**
                     * ExtensionRange end.
                     * @member {number} end
                     * @memberof google.protobuf.DescriptorProto.ExtensionRange
                     * @instance
                     */
                    ExtensionRange.prototype.end = 0;
    
                    /**
                     * Creates a new ExtensionRange instance using the specified properties.
                     * @function create
                     * @memberof google.protobuf.DescriptorProto.ExtensionRange
                     * @static
                     * @param {google.protobuf.DescriptorProto.IExtensionRange=} [properties] Properties to set
                     * @returns {google.protobuf.DescriptorProto.ExtensionRange} ExtensionRange instance
                     */
                    ExtensionRange.create = function create(properties) {
                        return new ExtensionRange(properties);
                    };
    
                    /**
                     * Encodes the specified ExtensionRange message. Does not implicitly {@link google.protobuf.DescriptorProto.ExtensionRange.verify|verify} messages.
                     * @function encode
                     * @memberof google.protobuf.DescriptorProto.ExtensionRange
                     * @static
                     * @param {google.protobuf.DescriptorProto.IExtensionRange} message ExtensionRange message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    ExtensionRange.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.start != null && Object.hasOwnProperty.call(message, "start"))
                            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.start);
                        if (message.end != null && Object.hasOwnProperty.call(message, "end"))
                            writer.uint32(/* id 2, wireType 0 =*/16).int32(message.end);
                        return writer;
                    };
    
                    /**
                     * Encodes the specified ExtensionRange message, length delimited. Does not implicitly {@link google.protobuf.DescriptorProto.ExtensionRange.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof google.protobuf.DescriptorProto.ExtensionRange
                     * @static
                     * @param {google.protobuf.DescriptorProto.IExtensionRange} message ExtensionRange message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    ExtensionRange.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };
    
                    /**
                     * Decodes an ExtensionRange message from the specified reader or buffer.
                     * @function decode
                     * @memberof google.protobuf.DescriptorProto.ExtensionRange
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {google.protobuf.DescriptorProto.ExtensionRange} ExtensionRange
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    ExtensionRange.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.DescriptorProto.ExtensionRange();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1: {
                                    message.start = reader.int32();
                                    break;
                                }
                            case 2: {
                                    message.end = reader.int32();
                                    break;
                                }
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Decodes an ExtensionRange message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof google.protobuf.DescriptorProto.ExtensionRange
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {google.protobuf.DescriptorProto.ExtensionRange} ExtensionRange
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    ExtensionRange.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };
    
                    /**
                     * Verifies an ExtensionRange message.
                     * @function verify
                     * @memberof google.protobuf.DescriptorProto.ExtensionRange
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    ExtensionRange.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.start != null && message.hasOwnProperty("start"))
                            if (!$util.isInteger(message.start))
                                return "start: integer expected";
                        if (message.end != null && message.hasOwnProperty("end"))
                            if (!$util.isInteger(message.end))
                                return "end: integer expected";
                        return null;
                    };
    
                    /**
                     * Creates an ExtensionRange message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof google.protobuf.DescriptorProto.ExtensionRange
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {google.protobuf.DescriptorProto.ExtensionRange} ExtensionRange
                     */
                    ExtensionRange.fromObject = function fromObject(object) {
                        if (object instanceof $root.google.protobuf.DescriptorProto.ExtensionRange)
                            return object;
                        var message = new $root.google.protobuf.DescriptorProto.ExtensionRange();
                        if (object.start != null)
                            message.start = object.start | 0;
                        if (object.end != null)
                            message.end = object.end | 0;
                        return message;
                    };
    
                    /**
                     * Creates a plain object from an ExtensionRange message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof google.protobuf.DescriptorProto.ExtensionRange
                     * @static
                     * @param {google.protobuf.DescriptorProto.ExtensionRange} message ExtensionRange
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    ExtensionRange.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            object.start = 0;
                            object.end = 0;
                        }
                        if (message.start != null && message.hasOwnProperty("start"))
                            object.start = message.start;
                        if (message.end != null && message.hasOwnProperty("end"))
                            object.end = message.end;
                        return object;
                    };
    
                    /**
                     * Converts this ExtensionRange to JSON.
                     * @function toJSON
                     * @memberof google.protobuf.DescriptorProto.ExtensionRange
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    ExtensionRange.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    /**
                     * Gets the default type url for ExtensionRange
                     * @function getTypeUrl
                     * @memberof google.protobuf.DescriptorProto.ExtensionRange
                     * @static
                     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                     * @returns {string} The default type url
                     */
                    ExtensionRange.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                        if (typeUrlPrefix === undefined) {
                            typeUrlPrefix = "type.googleapis.com";
                        }
                        return typeUrlPrefix + "/google.protobuf.DescriptorProto.ExtensionRange";
                    };
    
                    return ExtensionRange;
                })();
    
                DescriptorProto.ReservedRange = (function() {
    
                    /**
                     * Properties of a ReservedRange.
                     * @memberof google.protobuf.DescriptorProto
                     * @interface IReservedRange
                     * @property {number|null} [start] ReservedRange start
                     * @property {number|null} [end] ReservedRange end
                     */
    
                    /**
                     * Constructs a new ReservedRange.
                     * @memberof google.protobuf.DescriptorProto
                     * @classdesc Represents a ReservedRange.
                     * @implements IReservedRange
                     * @constructor
                     * @param {google.protobuf.DescriptorProto.IReservedRange=} [properties] Properties to set
                     */
                    function ReservedRange(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * ReservedRange start.
                     * @member {number} start
                     * @memberof google.protobuf.DescriptorProto.ReservedRange
                     * @instance
                     */
                    ReservedRange.prototype.start = 0;
    
                    /**
                     * ReservedRange end.
                     * @member {number} end
                     * @memberof google.protobuf.DescriptorProto.ReservedRange
                     * @instance
                     */
                    ReservedRange.prototype.end = 0;
    
                    /**
                     * Creates a new ReservedRange instance using the specified properties.
                     * @function create
                     * @memberof google.protobuf.DescriptorProto.ReservedRange
                     * @static
                     * @param {google.protobuf.DescriptorProto.IReservedRange=} [properties] Properties to set
                     * @returns {google.protobuf.DescriptorProto.ReservedRange} ReservedRange instance
                     */
                    ReservedRange.create = function create(properties) {
                        return new ReservedRange(properties);
                    };
    
                    /**
                     * Encodes the specified ReservedRange message. Does not implicitly {@link google.protobuf.DescriptorProto.ReservedRange.verify|verify} messages.
                     * @function encode
                     * @memberof google.protobuf.DescriptorProto.ReservedRange
                     * @static
                     * @param {google.protobuf.DescriptorProto.IReservedRange} message ReservedRange message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    ReservedRange.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.start != null && Object.hasOwnProperty.call(message, "start"))
                            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.start);
                        if (message.end != null && Object.hasOwnProperty.call(message, "end"))
                            writer.uint32(/* id 2, wireType 0 =*/16).int32(message.end);
                        return writer;
                    };
    
                    /**
                     * Encodes the specified ReservedRange message, length delimited. Does not implicitly {@link google.protobuf.DescriptorProto.ReservedRange.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof google.protobuf.DescriptorProto.ReservedRange
                     * @static
                     * @param {google.protobuf.DescriptorProto.IReservedRange} message ReservedRange message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    ReservedRange.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };
    
                    /**
                     * Decodes a ReservedRange message from the specified reader or buffer.
                     * @function decode
                     * @memberof google.protobuf.DescriptorProto.ReservedRange
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {google.protobuf.DescriptorProto.ReservedRange} ReservedRange
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    ReservedRange.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.DescriptorProto.ReservedRange();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1: {
                                    message.start = reader.int32();
                                    break;
                                }
                            case 2: {
                                    message.end = reader.int32();
                                    break;
                                }
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Decodes a ReservedRange message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof google.protobuf.DescriptorProto.ReservedRange
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {google.protobuf.DescriptorProto.ReservedRange} ReservedRange
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    ReservedRange.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };
    
                    /**
                     * Verifies a ReservedRange message.
                     * @function verify
                     * @memberof google.protobuf.DescriptorProto.ReservedRange
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    ReservedRange.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.start != null && message.hasOwnProperty("start"))
                            if (!$util.isInteger(message.start))
                                return "start: integer expected";
                        if (message.end != null && message.hasOwnProperty("end"))
                            if (!$util.isInteger(message.end))
                                return "end: integer expected";
                        return null;
                    };
    
                    /**
                     * Creates a ReservedRange message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof google.protobuf.DescriptorProto.ReservedRange
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {google.protobuf.DescriptorProto.ReservedRange} ReservedRange
                     */
                    ReservedRange.fromObject = function fromObject(object) {
                        if (object instanceof $root.google.protobuf.DescriptorProto.ReservedRange)
                            return object;
                        var message = new $root.google.protobuf.DescriptorProto.ReservedRange();
                        if (object.start != null)
                            message.start = object.start | 0;
                        if (object.end != null)
                            message.end = object.end | 0;
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a ReservedRange message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof google.protobuf.DescriptorProto.ReservedRange
                     * @static
                     * @param {google.protobuf.DescriptorProto.ReservedRange} message ReservedRange
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    ReservedRange.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            object.start = 0;
                            object.end = 0;
                        }
                        if (message.start != null && message.hasOwnProperty("start"))
                            object.start = message.start;
                        if (message.end != null && message.hasOwnProperty("end"))
                            object.end = message.end;
                        return object;
                    };
    
                    /**
                     * Converts this ReservedRange to JSON.
                     * @function toJSON
                     * @memberof google.protobuf.DescriptorProto.ReservedRange
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    ReservedRange.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    /**
                     * Gets the default type url for ReservedRange
                     * @function getTypeUrl
                     * @memberof google.protobuf.DescriptorProto.ReservedRange
                     * @static
                     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                     * @returns {string} The default type url
                     */
                    ReservedRange.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                        if (typeUrlPrefix === undefined) {
                            typeUrlPrefix = "type.googleapis.com";
                        }
                        return typeUrlPrefix + "/google.protobuf.DescriptorProto.ReservedRange";
                    };
    
                    return ReservedRange;
                })();
    
                return DescriptorProto;
            })();
    
            protobuf.FieldDescriptorProto = (function() {
    
                /**
                 * Properties of a FieldDescriptorProto.
                 * @memberof google.protobuf
                 * @interface IFieldDescriptorProto
                 * @property {string|null} [name] FieldDescriptorProto name
                 * @property {number|null} [number] FieldDescriptorProto number
                 * @property {google.protobuf.FieldDescriptorProto.Label|null} [label] FieldDescriptorProto label
                 * @property {google.protobuf.FieldDescriptorProto.Type|null} [type] FieldDescriptorProto type
                 * @property {string|null} [typeName] FieldDescriptorProto typeName
                 * @property {string|null} [extendee] FieldDescriptorProto extendee
                 * @property {string|null} [defaultValue] FieldDescriptorProto defaultValue
                 * @property {number|null} [oneofIndex] FieldDescriptorProto oneofIndex
                 * @property {string|null} [jsonName] FieldDescriptorProto jsonName
                 * @property {google.protobuf.IFieldOptions|null} [options] FieldDescriptorProto options
                 */
    
                /**
                 * Constructs a new FieldDescriptorProto.
                 * @memberof google.protobuf
                 * @classdesc Represents a FieldDescriptorProto.
                 * @implements IFieldDescriptorProto
                 * @constructor
                 * @param {google.protobuf.IFieldDescriptorProto=} [properties] Properties to set
                 */
                function FieldDescriptorProto(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * FieldDescriptorProto name.
                 * @member {string} name
                 * @memberof google.protobuf.FieldDescriptorProto
                 * @instance
                 */
                FieldDescriptorProto.prototype.name = "";
    
                /**
                 * FieldDescriptorProto number.
                 * @member {number} number
                 * @memberof google.protobuf.FieldDescriptorProto
                 * @instance
                 */
                FieldDescriptorProto.prototype.number = 0;
    
                /**
                 * FieldDescriptorProto label.
                 * @member {google.protobuf.FieldDescriptorProto.Label} label
                 * @memberof google.protobuf.FieldDescriptorProto
                 * @instance
                 */
                FieldDescriptorProto.prototype.label = 1;
    
                /**
                 * FieldDescriptorProto type.
                 * @member {google.protobuf.FieldDescriptorProto.Type} type
                 * @memberof google.protobuf.FieldDescriptorProto
                 * @instance
                 */
                FieldDescriptorProto.prototype.type = 1;
    
                /**
                 * FieldDescriptorProto typeName.
                 * @member {string} typeName
                 * @memberof google.protobuf.FieldDescriptorProto
                 * @instance
                 */
                FieldDescriptorProto.prototype.typeName = "";
    
                /**
                 * FieldDescriptorProto extendee.
                 * @member {string} extendee
                 * @memberof google.protobuf.FieldDescriptorProto
                 * @instance
                 */
                FieldDescriptorProto.prototype.extendee = "";
    
                /**
                 * FieldDescriptorProto defaultValue.
                 * @member {string} defaultValue
                 * @memberof google.protobuf.FieldDescriptorProto
                 * @instance
                 */
                FieldDescriptorProto.prototype.defaultValue = "";
    
                /**
                 * FieldDescriptorProto oneofIndex.
                 * @member {number} oneofIndex
                 * @memberof google.protobuf.FieldDescriptorProto
                 * @instance
                 */
                FieldDescriptorProto.prototype.oneofIndex = 0;
    
                /**
                 * FieldDescriptorProto jsonName.
                 * @member {string} jsonName
                 * @memberof google.protobuf.FieldDescriptorProto
                 * @instance
                 */
                FieldDescriptorProto.prototype.jsonName = "";
    
                /**
                 * FieldDescriptorProto options.
                 * @member {google.protobuf.IFieldOptions|null|undefined} options
                 * @memberof google.protobuf.FieldDescriptorProto
                 * @instance
                 */
                FieldDescriptorProto.prototype.options = null;
    
                /**
                 * Creates a new FieldDescriptorProto instance using the specified properties.
                 * @function create
                 * @memberof google.protobuf.FieldDescriptorProto
                 * @static
                 * @param {google.protobuf.IFieldDescriptorProto=} [properties] Properties to set
                 * @returns {google.protobuf.FieldDescriptorProto} FieldDescriptorProto instance
                 */
                FieldDescriptorProto.create = function create(properties) {
                    return new FieldDescriptorProto(properties);
                };
    
                /**
                 * Encodes the specified FieldDescriptorProto message. Does not implicitly {@link google.protobuf.FieldDescriptorProto.verify|verify} messages.
                 * @function encode
                 * @memberof google.protobuf.FieldDescriptorProto
                 * @static
                 * @param {google.protobuf.IFieldDescriptorProto} message FieldDescriptorProto message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                FieldDescriptorProto.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                    if (message.extendee != null && Object.hasOwnProperty.call(message, "extendee"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.extendee);
                    if (message.number != null && Object.hasOwnProperty.call(message, "number"))
                        writer.uint32(/* id 3, wireType 0 =*/24).int32(message.number);
                    if (message.label != null && Object.hasOwnProperty.call(message, "label"))
                        writer.uint32(/* id 4, wireType 0 =*/32).int32(message.label);
                    if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                        writer.uint32(/* id 5, wireType 0 =*/40).int32(message.type);
                    if (message.typeName != null && Object.hasOwnProperty.call(message, "typeName"))
                        writer.uint32(/* id 6, wireType 2 =*/50).string(message.typeName);
                    if (message.defaultValue != null && Object.hasOwnProperty.call(message, "defaultValue"))
                        writer.uint32(/* id 7, wireType 2 =*/58).string(message.defaultValue);
                    if (message.options != null && Object.hasOwnProperty.call(message, "options"))
                        $root.google.protobuf.FieldOptions.encode(message.options, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
                    if (message.oneofIndex != null && Object.hasOwnProperty.call(message, "oneofIndex"))
                        writer.uint32(/* id 9, wireType 0 =*/72).int32(message.oneofIndex);
                    if (message.jsonName != null && Object.hasOwnProperty.call(message, "jsonName"))
                        writer.uint32(/* id 10, wireType 2 =*/82).string(message.jsonName);
                    return writer;
                };
    
                /**
                 * Encodes the specified FieldDescriptorProto message, length delimited. Does not implicitly {@link google.protobuf.FieldDescriptorProto.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof google.protobuf.FieldDescriptorProto
                 * @static
                 * @param {google.protobuf.IFieldDescriptorProto} message FieldDescriptorProto message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                FieldDescriptorProto.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a FieldDescriptorProto message from the specified reader or buffer.
                 * @function decode
                 * @memberof google.protobuf.FieldDescriptorProto
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {google.protobuf.FieldDescriptorProto} FieldDescriptorProto
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                FieldDescriptorProto.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.FieldDescriptorProto();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1: {
                                message.name = reader.string();
                                break;
                            }
                        case 3: {
                                message.number = reader.int32();
                                break;
                            }
                        case 4: {
                                message.label = reader.int32();
                                break;
                            }
                        case 5: {
                                message.type = reader.int32();
                                break;
                            }
                        case 6: {
                                message.typeName = reader.string();
                                break;
                            }
                        case 2: {
                                message.extendee = reader.string();
                                break;
                            }
                        case 7: {
                                message.defaultValue = reader.string();
                                break;
                            }
                        case 9: {
                                message.oneofIndex = reader.int32();
                                break;
                            }
                        case 10: {
                                message.jsonName = reader.string();
                                break;
                            }
                        case 8: {
                                message.options = $root.google.protobuf.FieldOptions.decode(reader, reader.uint32());
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a FieldDescriptorProto message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof google.protobuf.FieldDescriptorProto
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {google.protobuf.FieldDescriptorProto} FieldDescriptorProto
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                FieldDescriptorProto.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a FieldDescriptorProto message.
                 * @function verify
                 * @memberof google.protobuf.FieldDescriptorProto
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                FieldDescriptorProto.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.name != null && message.hasOwnProperty("name"))
                        if (!$util.isString(message.name))
                            return "name: string expected";
                    if (message.number != null && message.hasOwnProperty("number"))
                        if (!$util.isInteger(message.number))
                            return "number: integer expected";
                    if (message.label != null && message.hasOwnProperty("label"))
                        switch (message.label) {
                        default:
                            return "label: enum value expected";
                        case 1:
                        case 2:
                        case 3:
                            break;
                        }
                    if (message.type != null && message.hasOwnProperty("type"))
                        switch (message.type) {
                        default:
                            return "type: enum value expected";
                        case 1:
                        case 2:
                        case 3:
                        case 4:
                        case 5:
                        case 6:
                        case 7:
                        case 8:
                        case 9:
                        case 10:
                        case 11:
                        case 12:
                        case 13:
                        case 14:
                        case 15:
                        case 16:
                        case 17:
                        case 18:
                            break;
                        }
                    if (message.typeName != null && message.hasOwnProperty("typeName"))
                        if (!$util.isString(message.typeName))
                            return "typeName: string expected";
                    if (message.extendee != null && message.hasOwnProperty("extendee"))
                        if (!$util.isString(message.extendee))
                            return "extendee: string expected";
                    if (message.defaultValue != null && message.hasOwnProperty("defaultValue"))
                        if (!$util.isString(message.defaultValue))
                            return "defaultValue: string expected";
                    if (message.oneofIndex != null && message.hasOwnProperty("oneofIndex"))
                        if (!$util.isInteger(message.oneofIndex))
                            return "oneofIndex: integer expected";
                    if (message.jsonName != null && message.hasOwnProperty("jsonName"))
                        if (!$util.isString(message.jsonName))
                            return "jsonName: string expected";
                    if (message.options != null && message.hasOwnProperty("options")) {
                        var error = $root.google.protobuf.FieldOptions.verify(message.options);
                        if (error)
                            return "options." + error;
                    }
                    return null;
                };
    
                /**
                 * Creates a FieldDescriptorProto message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof google.protobuf.FieldDescriptorProto
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {google.protobuf.FieldDescriptorProto} FieldDescriptorProto
                 */
                FieldDescriptorProto.fromObject = function fromObject(object) {
                    if (object instanceof $root.google.protobuf.FieldDescriptorProto)
                        return object;
                    var message = new $root.google.protobuf.FieldDescriptorProto();
                    if (object.name != null)
                        message.name = String(object.name);
                    if (object.number != null)
                        message.number = object.number | 0;
                    switch (object.label) {
                    default:
                        if (typeof object.label === "number") {
                            message.label = object.label;
                            break;
                        }
                        break;
                    case "LABEL_OPTIONAL":
                    case 1:
                        message.label = 1;
                        break;
                    case "LABEL_REQUIRED":
                    case 2:
                        message.label = 2;
                        break;
                    case "LABEL_REPEATED":
                    case 3:
                        message.label = 3;
                        break;
                    }
                    switch (object.type) {
                    default:
                        if (typeof object.type === "number") {
                            message.type = object.type;
                            break;
                        }
                        break;
                    case "TYPE_DOUBLE":
                    case 1:
                        message.type = 1;
                        break;
                    case "TYPE_FLOAT":
                    case 2:
                        message.type = 2;
                        break;
                    case "TYPE_INT64":
                    case 3:
                        message.type = 3;
                        break;
                    case "TYPE_UINT64":
                    case 4:
                        message.type = 4;
                        break;
                    case "TYPE_INT32":
                    case 5:
                        message.type = 5;
                        break;
                    case "TYPE_FIXED64":
                    case 6:
                        message.type = 6;
                        break;
                    case "TYPE_FIXED32":
                    case 7:
                        message.type = 7;
                        break;
                    case "TYPE_BOOL":
                    case 8:
                        message.type = 8;
                        break;
                    case "TYPE_STRING":
                    case 9:
                        message.type = 9;
                        break;
                    case "TYPE_GROUP":
                    case 10:
                        message.type = 10;
                        break;
                    case "TYPE_MESSAGE":
                    case 11:
                        message.type = 11;
                        break;
                    case "TYPE_BYTES":
                    case 12:
                        message.type = 12;
                        break;
                    case "TYPE_UINT32":
                    case 13:
                        message.type = 13;
                        break;
                    case "TYPE_ENUM":
                    case 14:
                        message.type = 14;
                        break;
                    case "TYPE_SFIXED32":
                    case 15:
                        message.type = 15;
                        break;
                    case "TYPE_SFIXED64":
                    case 16:
                        message.type = 16;
                        break;
                    case "TYPE_SINT32":
                    case 17:
                        message.type = 17;
                        break;
                    case "TYPE_SINT64":
                    case 18:
                        message.type = 18;
                        break;
                    }
                    if (object.typeName != null)
                        message.typeName = String(object.typeName);
                    if (object.extendee != null)
                        message.extendee = String(object.extendee);
                    if (object.defaultValue != null)
                        message.defaultValue = String(object.defaultValue);
                    if (object.oneofIndex != null)
                        message.oneofIndex = object.oneofIndex | 0;
                    if (object.jsonName != null)
                        message.jsonName = String(object.jsonName);
                    if (object.options != null) {
                        if (typeof object.options !== "object")
                            throw TypeError(".google.protobuf.FieldDescriptorProto.options: object expected");
                        message.options = $root.google.protobuf.FieldOptions.fromObject(object.options);
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a FieldDescriptorProto message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof google.protobuf.FieldDescriptorProto
                 * @static
                 * @param {google.protobuf.FieldDescriptorProto} message FieldDescriptorProto
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                FieldDescriptorProto.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.name = "";
                        object.extendee = "";
                        object.number = 0;
                        object.label = options.enums === String ? "LABEL_OPTIONAL" : 1;
                        object.type = options.enums === String ? "TYPE_DOUBLE" : 1;
                        object.typeName = "";
                        object.defaultValue = "";
                        object.options = null;
                        object.oneofIndex = 0;
                        object.jsonName = "";
                    }
                    if (message.name != null && message.hasOwnProperty("name"))
                        object.name = message.name;
                    if (message.extendee != null && message.hasOwnProperty("extendee"))
                        object.extendee = message.extendee;
                    if (message.number != null && message.hasOwnProperty("number"))
                        object.number = message.number;
                    if (message.label != null && message.hasOwnProperty("label"))
                        object.label = options.enums === String ? $root.google.protobuf.FieldDescriptorProto.Label[message.label] === undefined ? message.label : $root.google.protobuf.FieldDescriptorProto.Label[message.label] : message.label;
                    if (message.type != null && message.hasOwnProperty("type"))
                        object.type = options.enums === String ? $root.google.protobuf.FieldDescriptorProto.Type[message.type] === undefined ? message.type : $root.google.protobuf.FieldDescriptorProto.Type[message.type] : message.type;
                    if (message.typeName != null && message.hasOwnProperty("typeName"))
                        object.typeName = message.typeName;
                    if (message.defaultValue != null && message.hasOwnProperty("defaultValue"))
                        object.defaultValue = message.defaultValue;
                    if (message.options != null && message.hasOwnProperty("options"))
                        object.options = $root.google.protobuf.FieldOptions.toObject(message.options, options);
                    if (message.oneofIndex != null && message.hasOwnProperty("oneofIndex"))
                        object.oneofIndex = message.oneofIndex;
                    if (message.jsonName != null && message.hasOwnProperty("jsonName"))
                        object.jsonName = message.jsonName;
                    return object;
                };
    
                /**
                 * Converts this FieldDescriptorProto to JSON.
                 * @function toJSON
                 * @memberof google.protobuf.FieldDescriptorProto
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                FieldDescriptorProto.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                /**
                 * Gets the default type url for FieldDescriptorProto
                 * @function getTypeUrl
                 * @memberof google.protobuf.FieldDescriptorProto
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                FieldDescriptorProto.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/google.protobuf.FieldDescriptorProto";
                };
    
                /**
                 * Type enum.
                 * @name google.protobuf.FieldDescriptorProto.Type
                 * @enum {number}
                 * @property {number} TYPE_DOUBLE=1 TYPE_DOUBLE value
                 * @property {number} TYPE_FLOAT=2 TYPE_FLOAT value
                 * @property {number} TYPE_INT64=3 TYPE_INT64 value
                 * @property {number} TYPE_UINT64=4 TYPE_UINT64 value
                 * @property {number} TYPE_INT32=5 TYPE_INT32 value
                 * @property {number} TYPE_FIXED64=6 TYPE_FIXED64 value
                 * @property {number} TYPE_FIXED32=7 TYPE_FIXED32 value
                 * @property {number} TYPE_BOOL=8 TYPE_BOOL value
                 * @property {number} TYPE_STRING=9 TYPE_STRING value
                 * @property {number} TYPE_GROUP=10 TYPE_GROUP value
                 * @property {number} TYPE_MESSAGE=11 TYPE_MESSAGE value
                 * @property {number} TYPE_BYTES=12 TYPE_BYTES value
                 * @property {number} TYPE_UINT32=13 TYPE_UINT32 value
                 * @property {number} TYPE_ENUM=14 TYPE_ENUM value
                 * @property {number} TYPE_SFIXED32=15 TYPE_SFIXED32 value
                 * @property {number} TYPE_SFIXED64=16 TYPE_SFIXED64 value
                 * @property {number} TYPE_SINT32=17 TYPE_SINT32 value
                 * @property {number} TYPE_SINT64=18 TYPE_SINT64 value
                 */
                FieldDescriptorProto.Type = (function() {
                    var valuesById = {}, values = Object.create(valuesById);
                    values[valuesById[1] = "TYPE_DOUBLE"] = 1;
                    values[valuesById[2] = "TYPE_FLOAT"] = 2;
                    values[valuesById[3] = "TYPE_INT64"] = 3;
                    values[valuesById[4] = "TYPE_UINT64"] = 4;
                    values[valuesById[5] = "TYPE_INT32"] = 5;
                    values[valuesById[6] = "TYPE_FIXED64"] = 6;
                    values[valuesById[7] = "TYPE_FIXED32"] = 7;
                    values[valuesById[8] = "TYPE_BOOL"] = 8;
                    values[valuesById[9] = "TYPE_STRING"] = 9;
                    values[valuesById[10] = "TYPE_GROUP"] = 10;
                    values[valuesById[11] = "TYPE_MESSAGE"] = 11;
                    values[valuesById[12] = "TYPE_BYTES"] = 12;
                    values[valuesById[13] = "TYPE_UINT32"] = 13;
                    values[valuesById[14] = "TYPE_ENUM"] = 14;
                    values[valuesById[15] = "TYPE_SFIXED32"] = 15;
                    values[valuesById[16] = "TYPE_SFIXED64"] = 16;
                    values[valuesById[17] = "TYPE_SINT32"] = 17;
                    values[valuesById[18] = "TYPE_SINT64"] = 18;
                    return values;
                })();
    
                /**
                 * Label enum.
                 * @name google.protobuf.FieldDescriptorProto.Label
                 * @enum {number}
                 * @property {number} LABEL_OPTIONAL=1 LABEL_OPTIONAL value
                 * @property {number} LABEL_REQUIRED=2 LABEL_REQUIRED value
                 * @property {number} LABEL_REPEATED=3 LABEL_REPEATED value
                 */
                FieldDescriptorProto.Label = (function() {
                    var valuesById = {}, values = Object.create(valuesById);
                    values[valuesById[1] = "LABEL_OPTIONAL"] = 1;
                    values[valuesById[2] = "LABEL_REQUIRED"] = 2;
                    values[valuesById[3] = "LABEL_REPEATED"] = 3;
                    return values;
                })();
    
                return FieldDescriptorProto;
            })();
    
            protobuf.OneofDescriptorProto = (function() {
    
                /**
                 * Properties of an OneofDescriptorProto.
                 * @memberof google.protobuf
                 * @interface IOneofDescriptorProto
                 * @property {string|null} [name] OneofDescriptorProto name
                 * @property {google.protobuf.IOneofOptions|null} [options] OneofDescriptorProto options
                 */
    
                /**
                 * Constructs a new OneofDescriptorProto.
                 * @memberof google.protobuf
                 * @classdesc Represents an OneofDescriptorProto.
                 * @implements IOneofDescriptorProto
                 * @constructor
                 * @param {google.protobuf.IOneofDescriptorProto=} [properties] Properties to set
                 */
                function OneofDescriptorProto(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * OneofDescriptorProto name.
                 * @member {string} name
                 * @memberof google.protobuf.OneofDescriptorProto
                 * @instance
                 */
                OneofDescriptorProto.prototype.name = "";
    
                /**
                 * OneofDescriptorProto options.
                 * @member {google.protobuf.IOneofOptions|null|undefined} options
                 * @memberof google.protobuf.OneofDescriptorProto
                 * @instance
                 */
                OneofDescriptorProto.prototype.options = null;
    
                /**
                 * Creates a new OneofDescriptorProto instance using the specified properties.
                 * @function create
                 * @memberof google.protobuf.OneofDescriptorProto
                 * @static
                 * @param {google.protobuf.IOneofDescriptorProto=} [properties] Properties to set
                 * @returns {google.protobuf.OneofDescriptorProto} OneofDescriptorProto instance
                 */
                OneofDescriptorProto.create = function create(properties) {
                    return new OneofDescriptorProto(properties);
                };
    
                /**
                 * Encodes the specified OneofDescriptorProto message. Does not implicitly {@link google.protobuf.OneofDescriptorProto.verify|verify} messages.
                 * @function encode
                 * @memberof google.protobuf.OneofDescriptorProto
                 * @static
                 * @param {google.protobuf.IOneofDescriptorProto} message OneofDescriptorProto message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                OneofDescriptorProto.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                    if (message.options != null && Object.hasOwnProperty.call(message, "options"))
                        $root.google.protobuf.OneofOptions.encode(message.options, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified OneofDescriptorProto message, length delimited. Does not implicitly {@link google.protobuf.OneofDescriptorProto.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof google.protobuf.OneofDescriptorProto
                 * @static
                 * @param {google.protobuf.IOneofDescriptorProto} message OneofDescriptorProto message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                OneofDescriptorProto.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes an OneofDescriptorProto message from the specified reader or buffer.
                 * @function decode
                 * @memberof google.protobuf.OneofDescriptorProto
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {google.protobuf.OneofDescriptorProto} OneofDescriptorProto
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                OneofDescriptorProto.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.OneofDescriptorProto();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1: {
                                message.name = reader.string();
                                break;
                            }
                        case 2: {
                                message.options = $root.google.protobuf.OneofOptions.decode(reader, reader.uint32());
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes an OneofDescriptorProto message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof google.protobuf.OneofDescriptorProto
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {google.protobuf.OneofDescriptorProto} OneofDescriptorProto
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                OneofDescriptorProto.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies an OneofDescriptorProto message.
                 * @function verify
                 * @memberof google.protobuf.OneofDescriptorProto
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                OneofDescriptorProto.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.name != null && message.hasOwnProperty("name"))
                        if (!$util.isString(message.name))
                            return "name: string expected";
                    if (message.options != null && message.hasOwnProperty("options")) {
                        var error = $root.google.protobuf.OneofOptions.verify(message.options);
                        if (error)
                            return "options." + error;
                    }
                    return null;
                };
    
                /**
                 * Creates an OneofDescriptorProto message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof google.protobuf.OneofDescriptorProto
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {google.protobuf.OneofDescriptorProto} OneofDescriptorProto
                 */
                OneofDescriptorProto.fromObject = function fromObject(object) {
                    if (object instanceof $root.google.protobuf.OneofDescriptorProto)
                        return object;
                    var message = new $root.google.protobuf.OneofDescriptorProto();
                    if (object.name != null)
                        message.name = String(object.name);
                    if (object.options != null) {
                        if (typeof object.options !== "object")
                            throw TypeError(".google.protobuf.OneofDescriptorProto.options: object expected");
                        message.options = $root.google.protobuf.OneofOptions.fromObject(object.options);
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from an OneofDescriptorProto message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof google.protobuf.OneofDescriptorProto
                 * @static
                 * @param {google.protobuf.OneofDescriptorProto} message OneofDescriptorProto
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                OneofDescriptorProto.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.name = "";
                        object.options = null;
                    }
                    if (message.name != null && message.hasOwnProperty("name"))
                        object.name = message.name;
                    if (message.options != null && message.hasOwnProperty("options"))
                        object.options = $root.google.protobuf.OneofOptions.toObject(message.options, options);
                    return object;
                };
    
                /**
                 * Converts this OneofDescriptorProto to JSON.
                 * @function toJSON
                 * @memberof google.protobuf.OneofDescriptorProto
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                OneofDescriptorProto.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                /**
                 * Gets the default type url for OneofDescriptorProto
                 * @function getTypeUrl
                 * @memberof google.protobuf.OneofDescriptorProto
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                OneofDescriptorProto.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/google.protobuf.OneofDescriptorProto";
                };
    
                return OneofDescriptorProto;
            })();
    
            protobuf.EnumDescriptorProto = (function() {
    
                /**
                 * Properties of an EnumDescriptorProto.
                 * @memberof google.protobuf
                 * @interface IEnumDescriptorProto
                 * @property {string|null} [name] EnumDescriptorProto name
                 * @property {Array.<google.protobuf.IEnumValueDescriptorProto>|null} [value] EnumDescriptorProto value
                 * @property {google.protobuf.IEnumOptions|null} [options] EnumDescriptorProto options
                 */
    
                /**
                 * Constructs a new EnumDescriptorProto.
                 * @memberof google.protobuf
                 * @classdesc Represents an EnumDescriptorProto.
                 * @implements IEnumDescriptorProto
                 * @constructor
                 * @param {google.protobuf.IEnumDescriptorProto=} [properties] Properties to set
                 */
                function EnumDescriptorProto(properties) {
                    this.value = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * EnumDescriptorProto name.
                 * @member {string} name
                 * @memberof google.protobuf.EnumDescriptorProto
                 * @instance
                 */
                EnumDescriptorProto.prototype.name = "";
    
                /**
                 * EnumDescriptorProto value.
                 * @member {Array.<google.protobuf.IEnumValueDescriptorProto>} value
                 * @memberof google.protobuf.EnumDescriptorProto
                 * @instance
                 */
                EnumDescriptorProto.prototype.value = $util.emptyArray;
    
                /**
                 * EnumDescriptorProto options.
                 * @member {google.protobuf.IEnumOptions|null|undefined} options
                 * @memberof google.protobuf.EnumDescriptorProto
                 * @instance
                 */
                EnumDescriptorProto.prototype.options = null;
    
                /**
                 * Creates a new EnumDescriptorProto instance using the specified properties.
                 * @function create
                 * @memberof google.protobuf.EnumDescriptorProto
                 * @static
                 * @param {google.protobuf.IEnumDescriptorProto=} [properties] Properties to set
                 * @returns {google.protobuf.EnumDescriptorProto} EnumDescriptorProto instance
                 */
                EnumDescriptorProto.create = function create(properties) {
                    return new EnumDescriptorProto(properties);
                };
    
                /**
                 * Encodes the specified EnumDescriptorProto message. Does not implicitly {@link google.protobuf.EnumDescriptorProto.verify|verify} messages.
                 * @function encode
                 * @memberof google.protobuf.EnumDescriptorProto
                 * @static
                 * @param {google.protobuf.IEnumDescriptorProto} message EnumDescriptorProto message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                EnumDescriptorProto.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                    if (message.value != null && message.value.length)
                        for (var i = 0; i < message.value.length; ++i)
                            $root.google.protobuf.EnumValueDescriptorProto.encode(message.value[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    if (message.options != null && Object.hasOwnProperty.call(message, "options"))
                        $root.google.protobuf.EnumOptions.encode(message.options, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified EnumDescriptorProto message, length delimited. Does not implicitly {@link google.protobuf.EnumDescriptorProto.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof google.protobuf.EnumDescriptorProto
                 * @static
                 * @param {google.protobuf.IEnumDescriptorProto} message EnumDescriptorProto message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                EnumDescriptorProto.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes an EnumDescriptorProto message from the specified reader or buffer.
                 * @function decode
                 * @memberof google.protobuf.EnumDescriptorProto
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {google.protobuf.EnumDescriptorProto} EnumDescriptorProto
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                EnumDescriptorProto.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.EnumDescriptorProto();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1: {
                                message.name = reader.string();
                                break;
                            }
                        case 2: {
                                if (!(message.value && message.value.length))
                                    message.value = [];
                                message.value.push($root.google.protobuf.EnumValueDescriptorProto.decode(reader, reader.uint32()));
                                break;
                            }
                        case 3: {
                                message.options = $root.google.protobuf.EnumOptions.decode(reader, reader.uint32());
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes an EnumDescriptorProto message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof google.protobuf.EnumDescriptorProto
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {google.protobuf.EnumDescriptorProto} EnumDescriptorProto
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                EnumDescriptorProto.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies an EnumDescriptorProto message.
                 * @function verify
                 * @memberof google.protobuf.EnumDescriptorProto
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                EnumDescriptorProto.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.name != null && message.hasOwnProperty("name"))
                        if (!$util.isString(message.name))
                            return "name: string expected";
                    if (message.value != null && message.hasOwnProperty("value")) {
                        if (!Array.isArray(message.value))
                            return "value: array expected";
                        for (var i = 0; i < message.value.length; ++i) {
                            var error = $root.google.protobuf.EnumValueDescriptorProto.verify(message.value[i]);
                            if (error)
                                return "value." + error;
                        }
                    }
                    if (message.options != null && message.hasOwnProperty("options")) {
                        var error = $root.google.protobuf.EnumOptions.verify(message.options);
                        if (error)
                            return "options." + error;
                    }
                    return null;
                };
    
                /**
                 * Creates an EnumDescriptorProto message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof google.protobuf.EnumDescriptorProto
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {google.protobuf.EnumDescriptorProto} EnumDescriptorProto
                 */
                EnumDescriptorProto.fromObject = function fromObject(object) {
                    if (object instanceof $root.google.protobuf.EnumDescriptorProto)
                        return object;
                    var message = new $root.google.protobuf.EnumDescriptorProto();
                    if (object.name != null)
                        message.name = String(object.name);
                    if (object.value) {
                        if (!Array.isArray(object.value))
                            throw TypeError(".google.protobuf.EnumDescriptorProto.value: array expected");
                        message.value = [];
                        for (var i = 0; i < object.value.length; ++i) {
                            if (typeof object.value[i] !== "object")
                                throw TypeError(".google.protobuf.EnumDescriptorProto.value: object expected");
                            message.value[i] = $root.google.protobuf.EnumValueDescriptorProto.fromObject(object.value[i]);
                        }
                    }
                    if (object.options != null) {
                        if (typeof object.options !== "object")
                            throw TypeError(".google.protobuf.EnumDescriptorProto.options: object expected");
                        message.options = $root.google.protobuf.EnumOptions.fromObject(object.options);
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from an EnumDescriptorProto message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof google.protobuf.EnumDescriptorProto
                 * @static
                 * @param {google.protobuf.EnumDescriptorProto} message EnumDescriptorProto
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                EnumDescriptorProto.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.value = [];
                    if (options.defaults) {
                        object.name = "";
                        object.options = null;
                    }
                    if (message.name != null && message.hasOwnProperty("name"))
                        object.name = message.name;
                    if (message.value && message.value.length) {
                        object.value = [];
                        for (var j = 0; j < message.value.length; ++j)
                            object.value[j] = $root.google.protobuf.EnumValueDescriptorProto.toObject(message.value[j], options);
                    }
                    if (message.options != null && message.hasOwnProperty("options"))
                        object.options = $root.google.protobuf.EnumOptions.toObject(message.options, options);
                    return object;
                };
    
                /**
                 * Converts this EnumDescriptorProto to JSON.
                 * @function toJSON
                 * @memberof google.protobuf.EnumDescriptorProto
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                EnumDescriptorProto.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                /**
                 * Gets the default type url for EnumDescriptorProto
                 * @function getTypeUrl
                 * @memberof google.protobuf.EnumDescriptorProto
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                EnumDescriptorProto.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/google.protobuf.EnumDescriptorProto";
                };
    
                return EnumDescriptorProto;
            })();
    
            protobuf.EnumValueDescriptorProto = (function() {
    
                /**
                 * Properties of an EnumValueDescriptorProto.
                 * @memberof google.protobuf
                 * @interface IEnumValueDescriptorProto
                 * @property {string|null} [name] EnumValueDescriptorProto name
                 * @property {number|null} [number] EnumValueDescriptorProto number
                 * @property {google.protobuf.IEnumValueOptions|null} [options] EnumValueDescriptorProto options
                 */
    
                /**
                 * Constructs a new EnumValueDescriptorProto.
                 * @memberof google.protobuf
                 * @classdesc Represents an EnumValueDescriptorProto.
                 * @implements IEnumValueDescriptorProto
                 * @constructor
                 * @param {google.protobuf.IEnumValueDescriptorProto=} [properties] Properties to set
                 */
                function EnumValueDescriptorProto(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * EnumValueDescriptorProto name.
                 * @member {string} name
                 * @memberof google.protobuf.EnumValueDescriptorProto
                 * @instance
                 */
                EnumValueDescriptorProto.prototype.name = "";
    
                /**
                 * EnumValueDescriptorProto number.
                 * @member {number} number
                 * @memberof google.protobuf.EnumValueDescriptorProto
                 * @instance
                 */
                EnumValueDescriptorProto.prototype.number = 0;
    
                /**
                 * EnumValueDescriptorProto options.
                 * @member {google.protobuf.IEnumValueOptions|null|undefined} options
                 * @memberof google.protobuf.EnumValueDescriptorProto
                 * @instance
                 */
                EnumValueDescriptorProto.prototype.options = null;
    
                /**
                 * Creates a new EnumValueDescriptorProto instance using the specified properties.
                 * @function create
                 * @memberof google.protobuf.EnumValueDescriptorProto
                 * @static
                 * @param {google.protobuf.IEnumValueDescriptorProto=} [properties] Properties to set
                 * @returns {google.protobuf.EnumValueDescriptorProto} EnumValueDescriptorProto instance
                 */
                EnumValueDescriptorProto.create = function create(properties) {
                    return new EnumValueDescriptorProto(properties);
                };
    
                /**
                 * Encodes the specified EnumValueDescriptorProto message. Does not implicitly {@link google.protobuf.EnumValueDescriptorProto.verify|verify} messages.
                 * @function encode
                 * @memberof google.protobuf.EnumValueDescriptorProto
                 * @static
                 * @param {google.protobuf.IEnumValueDescriptorProto} message EnumValueDescriptorProto message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                EnumValueDescriptorProto.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                    if (message.number != null && Object.hasOwnProperty.call(message, "number"))
                        writer.uint32(/* id 2, wireType 0 =*/16).int32(message.number);
                    if (message.options != null && Object.hasOwnProperty.call(message, "options"))
                        $root.google.protobuf.EnumValueOptions.encode(message.options, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified EnumValueDescriptorProto message, length delimited. Does not implicitly {@link google.protobuf.EnumValueDescriptorProto.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof google.protobuf.EnumValueDescriptorProto
                 * @static
                 * @param {google.protobuf.IEnumValueDescriptorProto} message EnumValueDescriptorProto message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                EnumValueDescriptorProto.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes an EnumValueDescriptorProto message from the specified reader or buffer.
                 * @function decode
                 * @memberof google.protobuf.EnumValueDescriptorProto
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {google.protobuf.EnumValueDescriptorProto} EnumValueDescriptorProto
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                EnumValueDescriptorProto.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.EnumValueDescriptorProto();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1: {
                                message.name = reader.string();
                                break;
                            }
                        case 2: {
                                message.number = reader.int32();
                                break;
                            }
                        case 3: {
                                message.options = $root.google.protobuf.EnumValueOptions.decode(reader, reader.uint32());
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes an EnumValueDescriptorProto message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof google.protobuf.EnumValueDescriptorProto
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {google.protobuf.EnumValueDescriptorProto} EnumValueDescriptorProto
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                EnumValueDescriptorProto.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies an EnumValueDescriptorProto message.
                 * @function verify
                 * @memberof google.protobuf.EnumValueDescriptorProto
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                EnumValueDescriptorProto.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.name != null && message.hasOwnProperty("name"))
                        if (!$util.isString(message.name))
                            return "name: string expected";
                    if (message.number != null && message.hasOwnProperty("number"))
                        if (!$util.isInteger(message.number))
                            return "number: integer expected";
                    if (message.options != null && message.hasOwnProperty("options")) {
                        var error = $root.google.protobuf.EnumValueOptions.verify(message.options);
                        if (error)
                            return "options." + error;
                    }
                    return null;
                };
    
                /**
                 * Creates an EnumValueDescriptorProto message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof google.protobuf.EnumValueDescriptorProto
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {google.protobuf.EnumValueDescriptorProto} EnumValueDescriptorProto
                 */
                EnumValueDescriptorProto.fromObject = function fromObject(object) {
                    if (object instanceof $root.google.protobuf.EnumValueDescriptorProto)
                        return object;
                    var message = new $root.google.protobuf.EnumValueDescriptorProto();
                    if (object.name != null)
                        message.name = String(object.name);
                    if (object.number != null)
                        message.number = object.number | 0;
                    if (object.options != null) {
                        if (typeof object.options !== "object")
                            throw TypeError(".google.protobuf.EnumValueDescriptorProto.options: object expected");
                        message.options = $root.google.protobuf.EnumValueOptions.fromObject(object.options);
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from an EnumValueDescriptorProto message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof google.protobuf.EnumValueDescriptorProto
                 * @static
                 * @param {google.protobuf.EnumValueDescriptorProto} message EnumValueDescriptorProto
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                EnumValueDescriptorProto.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.name = "";
                        object.number = 0;
                        object.options = null;
                    }
                    if (message.name != null && message.hasOwnProperty("name"))
                        object.name = message.name;
                    if (message.number != null && message.hasOwnProperty("number"))
                        object.number = message.number;
                    if (message.options != null && message.hasOwnProperty("options"))
                        object.options = $root.google.protobuf.EnumValueOptions.toObject(message.options, options);
                    return object;
                };
    
                /**
                 * Converts this EnumValueDescriptorProto to JSON.
                 * @function toJSON
                 * @memberof google.protobuf.EnumValueDescriptorProto
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                EnumValueDescriptorProto.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                /**
                 * Gets the default type url for EnumValueDescriptorProto
                 * @function getTypeUrl
                 * @memberof google.protobuf.EnumValueDescriptorProto
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                EnumValueDescriptorProto.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/google.protobuf.EnumValueDescriptorProto";
                };
    
                return EnumValueDescriptorProto;
            })();
    
            protobuf.ServiceDescriptorProto = (function() {
    
                /**
                 * Properties of a ServiceDescriptorProto.
                 * @memberof google.protobuf
                 * @interface IServiceDescriptorProto
                 * @property {string|null} [name] ServiceDescriptorProto name
                 * @property {Array.<google.protobuf.IMethodDescriptorProto>|null} [method] ServiceDescriptorProto method
                 * @property {google.protobuf.IServiceOptions|null} [options] ServiceDescriptorProto options
                 */
    
                /**
                 * Constructs a new ServiceDescriptorProto.
                 * @memberof google.protobuf
                 * @classdesc Represents a ServiceDescriptorProto.
                 * @implements IServiceDescriptorProto
                 * @constructor
                 * @param {google.protobuf.IServiceDescriptorProto=} [properties] Properties to set
                 */
                function ServiceDescriptorProto(properties) {
                    this.method = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * ServiceDescriptorProto name.
                 * @member {string} name
                 * @memberof google.protobuf.ServiceDescriptorProto
                 * @instance
                 */
                ServiceDescriptorProto.prototype.name = "";
    
                /**
                 * ServiceDescriptorProto method.
                 * @member {Array.<google.protobuf.IMethodDescriptorProto>} method
                 * @memberof google.protobuf.ServiceDescriptorProto
                 * @instance
                 */
                ServiceDescriptorProto.prototype.method = $util.emptyArray;
    
                /**
                 * ServiceDescriptorProto options.
                 * @member {google.protobuf.IServiceOptions|null|undefined} options
                 * @memberof google.protobuf.ServiceDescriptorProto
                 * @instance
                 */
                ServiceDescriptorProto.prototype.options = null;
    
                /**
                 * Creates a new ServiceDescriptorProto instance using the specified properties.
                 * @function create
                 * @memberof google.protobuf.ServiceDescriptorProto
                 * @static
                 * @param {google.protobuf.IServiceDescriptorProto=} [properties] Properties to set
                 * @returns {google.protobuf.ServiceDescriptorProto} ServiceDescriptorProto instance
                 */
                ServiceDescriptorProto.create = function create(properties) {
                    return new ServiceDescriptorProto(properties);
                };
    
                /**
                 * Encodes the specified ServiceDescriptorProto message. Does not implicitly {@link google.protobuf.ServiceDescriptorProto.verify|verify} messages.
                 * @function encode
                 * @memberof google.protobuf.ServiceDescriptorProto
                 * @static
                 * @param {google.protobuf.IServiceDescriptorProto} message ServiceDescriptorProto message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ServiceDescriptorProto.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                    if (message.method != null && message.method.length)
                        for (var i = 0; i < message.method.length; ++i)
                            $root.google.protobuf.MethodDescriptorProto.encode(message.method[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    if (message.options != null && Object.hasOwnProperty.call(message, "options"))
                        $root.google.protobuf.ServiceOptions.encode(message.options, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified ServiceDescriptorProto message, length delimited. Does not implicitly {@link google.protobuf.ServiceDescriptorProto.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof google.protobuf.ServiceDescriptorProto
                 * @static
                 * @param {google.protobuf.IServiceDescriptorProto} message ServiceDescriptorProto message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ServiceDescriptorProto.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a ServiceDescriptorProto message from the specified reader or buffer.
                 * @function decode
                 * @memberof google.protobuf.ServiceDescriptorProto
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {google.protobuf.ServiceDescriptorProto} ServiceDescriptorProto
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ServiceDescriptorProto.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.ServiceDescriptorProto();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1: {
                                message.name = reader.string();
                                break;
                            }
                        case 2: {
                                if (!(message.method && message.method.length))
                                    message.method = [];
                                message.method.push($root.google.protobuf.MethodDescriptorProto.decode(reader, reader.uint32()));
                                break;
                            }
                        case 3: {
                                message.options = $root.google.protobuf.ServiceOptions.decode(reader, reader.uint32());
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a ServiceDescriptorProto message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof google.protobuf.ServiceDescriptorProto
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {google.protobuf.ServiceDescriptorProto} ServiceDescriptorProto
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ServiceDescriptorProto.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a ServiceDescriptorProto message.
                 * @function verify
                 * @memberof google.protobuf.ServiceDescriptorProto
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                ServiceDescriptorProto.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.name != null && message.hasOwnProperty("name"))
                        if (!$util.isString(message.name))
                            return "name: string expected";
                    if (message.method != null && message.hasOwnProperty("method")) {
                        if (!Array.isArray(message.method))
                            return "method: array expected";
                        for (var i = 0; i < message.method.length; ++i) {
                            var error = $root.google.protobuf.MethodDescriptorProto.verify(message.method[i]);
                            if (error)
                                return "method." + error;
                        }
                    }
                    if (message.options != null && message.hasOwnProperty("options")) {
                        var error = $root.google.protobuf.ServiceOptions.verify(message.options);
                        if (error)
                            return "options." + error;
                    }
                    return null;
                };
    
                /**
                 * Creates a ServiceDescriptorProto message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof google.protobuf.ServiceDescriptorProto
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {google.protobuf.ServiceDescriptorProto} ServiceDescriptorProto
                 */
                ServiceDescriptorProto.fromObject = function fromObject(object) {
                    if (object instanceof $root.google.protobuf.ServiceDescriptorProto)
                        return object;
                    var message = new $root.google.protobuf.ServiceDescriptorProto();
                    if (object.name != null)
                        message.name = String(object.name);
                    if (object.method) {
                        if (!Array.isArray(object.method))
                            throw TypeError(".google.protobuf.ServiceDescriptorProto.method: array expected");
                        message.method = [];
                        for (var i = 0; i < object.method.length; ++i) {
                            if (typeof object.method[i] !== "object")
                                throw TypeError(".google.protobuf.ServiceDescriptorProto.method: object expected");
                            message.method[i] = $root.google.protobuf.MethodDescriptorProto.fromObject(object.method[i]);
                        }
                    }
                    if (object.options != null) {
                        if (typeof object.options !== "object")
                            throw TypeError(".google.protobuf.ServiceDescriptorProto.options: object expected");
                        message.options = $root.google.protobuf.ServiceOptions.fromObject(object.options);
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a ServiceDescriptorProto message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof google.protobuf.ServiceDescriptorProto
                 * @static
                 * @param {google.protobuf.ServiceDescriptorProto} message ServiceDescriptorProto
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                ServiceDescriptorProto.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.method = [];
                    if (options.defaults) {
                        object.name = "";
                        object.options = null;
                    }
                    if (message.name != null && message.hasOwnProperty("name"))
                        object.name = message.name;
                    if (message.method && message.method.length) {
                        object.method = [];
                        for (var j = 0; j < message.method.length; ++j)
                            object.method[j] = $root.google.protobuf.MethodDescriptorProto.toObject(message.method[j], options);
                    }
                    if (message.options != null && message.hasOwnProperty("options"))
                        object.options = $root.google.protobuf.ServiceOptions.toObject(message.options, options);
                    return object;
                };
    
                /**
                 * Converts this ServiceDescriptorProto to JSON.
                 * @function toJSON
                 * @memberof google.protobuf.ServiceDescriptorProto
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                ServiceDescriptorProto.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                /**
                 * Gets the default type url for ServiceDescriptorProto
                 * @function getTypeUrl
                 * @memberof google.protobuf.ServiceDescriptorProto
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                ServiceDescriptorProto.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/google.protobuf.ServiceDescriptorProto";
                };
    
                return ServiceDescriptorProto;
            })();
    
            protobuf.MethodDescriptorProto = (function() {
    
                /**
                 * Properties of a MethodDescriptorProto.
                 * @memberof google.protobuf
                 * @interface IMethodDescriptorProto
                 * @property {string|null} [name] MethodDescriptorProto name
                 * @property {string|null} [inputType] MethodDescriptorProto inputType
                 * @property {string|null} [outputType] MethodDescriptorProto outputType
                 * @property {google.protobuf.IMethodOptions|null} [options] MethodDescriptorProto options
                 * @property {boolean|null} [clientStreaming] MethodDescriptorProto clientStreaming
                 * @property {boolean|null} [serverStreaming] MethodDescriptorProto serverStreaming
                 */
    
                /**
                 * Constructs a new MethodDescriptorProto.
                 * @memberof google.protobuf
                 * @classdesc Represents a MethodDescriptorProto.
                 * @implements IMethodDescriptorProto
                 * @constructor
                 * @param {google.protobuf.IMethodDescriptorProto=} [properties] Properties to set
                 */
                function MethodDescriptorProto(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * MethodDescriptorProto name.
                 * @member {string} name
                 * @memberof google.protobuf.MethodDescriptorProto
                 * @instance
                 */
                MethodDescriptorProto.prototype.name = "";
    
                /**
                 * MethodDescriptorProto inputType.
                 * @member {string} inputType
                 * @memberof google.protobuf.MethodDescriptorProto
                 * @instance
                 */
                MethodDescriptorProto.prototype.inputType = "";
    
                /**
                 * MethodDescriptorProto outputType.
                 * @member {string} outputType
                 * @memberof google.protobuf.MethodDescriptorProto
                 * @instance
                 */
                MethodDescriptorProto.prototype.outputType = "";
    
                /**
                 * MethodDescriptorProto options.
                 * @member {google.protobuf.IMethodOptions|null|undefined} options
                 * @memberof google.protobuf.MethodDescriptorProto
                 * @instance
                 */
                MethodDescriptorProto.prototype.options = null;
    
                /**
                 * MethodDescriptorProto clientStreaming.
                 * @member {boolean} clientStreaming
                 * @memberof google.protobuf.MethodDescriptorProto
                 * @instance
                 */
                MethodDescriptorProto.prototype.clientStreaming = false;
    
                /**
                 * MethodDescriptorProto serverStreaming.
                 * @member {boolean} serverStreaming
                 * @memberof google.protobuf.MethodDescriptorProto
                 * @instance
                 */
                MethodDescriptorProto.prototype.serverStreaming = false;
    
                /**
                 * Creates a new MethodDescriptorProto instance using the specified properties.
                 * @function create
                 * @memberof google.protobuf.MethodDescriptorProto
                 * @static
                 * @param {google.protobuf.IMethodDescriptorProto=} [properties] Properties to set
                 * @returns {google.protobuf.MethodDescriptorProto} MethodDescriptorProto instance
                 */
                MethodDescriptorProto.create = function create(properties) {
                    return new MethodDescriptorProto(properties);
                };
    
                /**
                 * Encodes the specified MethodDescriptorProto message. Does not implicitly {@link google.protobuf.MethodDescriptorProto.verify|verify} messages.
                 * @function encode
                 * @memberof google.protobuf.MethodDescriptorProto
                 * @static
                 * @param {google.protobuf.IMethodDescriptorProto} message MethodDescriptorProto message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MethodDescriptorProto.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                    if (message.inputType != null && Object.hasOwnProperty.call(message, "inputType"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.inputType);
                    if (message.outputType != null && Object.hasOwnProperty.call(message, "outputType"))
                        writer.uint32(/* id 3, wireType 2 =*/26).string(message.outputType);
                    if (message.options != null && Object.hasOwnProperty.call(message, "options"))
                        $root.google.protobuf.MethodOptions.encode(message.options, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                    if (message.clientStreaming != null && Object.hasOwnProperty.call(message, "clientStreaming"))
                        writer.uint32(/* id 5, wireType 0 =*/40).bool(message.clientStreaming);
                    if (message.serverStreaming != null && Object.hasOwnProperty.call(message, "serverStreaming"))
                        writer.uint32(/* id 6, wireType 0 =*/48).bool(message.serverStreaming);
                    return writer;
                };
    
                /**
                 * Encodes the specified MethodDescriptorProto message, length delimited. Does not implicitly {@link google.protobuf.MethodDescriptorProto.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof google.protobuf.MethodDescriptorProto
                 * @static
                 * @param {google.protobuf.IMethodDescriptorProto} message MethodDescriptorProto message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MethodDescriptorProto.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a MethodDescriptorProto message from the specified reader or buffer.
                 * @function decode
                 * @memberof google.protobuf.MethodDescriptorProto
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {google.protobuf.MethodDescriptorProto} MethodDescriptorProto
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MethodDescriptorProto.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.MethodDescriptorProto();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1: {
                                message.name = reader.string();
                                break;
                            }
                        case 2: {
                                message.inputType = reader.string();
                                break;
                            }
                        case 3: {
                                message.outputType = reader.string();
                                break;
                            }
                        case 4: {
                                message.options = $root.google.protobuf.MethodOptions.decode(reader, reader.uint32());
                                break;
                            }
                        case 5: {
                                message.clientStreaming = reader.bool();
                                break;
                            }
                        case 6: {
                                message.serverStreaming = reader.bool();
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a MethodDescriptorProto message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof google.protobuf.MethodDescriptorProto
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {google.protobuf.MethodDescriptorProto} MethodDescriptorProto
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MethodDescriptorProto.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a MethodDescriptorProto message.
                 * @function verify
                 * @memberof google.protobuf.MethodDescriptorProto
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                MethodDescriptorProto.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.name != null && message.hasOwnProperty("name"))
                        if (!$util.isString(message.name))
                            return "name: string expected";
                    if (message.inputType != null && message.hasOwnProperty("inputType"))
                        if (!$util.isString(message.inputType))
                            return "inputType: string expected";
                    if (message.outputType != null && message.hasOwnProperty("outputType"))
                        if (!$util.isString(message.outputType))
                            return "outputType: string expected";
                    if (message.options != null && message.hasOwnProperty("options")) {
                        var error = $root.google.protobuf.MethodOptions.verify(message.options);
                        if (error)
                            return "options." + error;
                    }
                    if (message.clientStreaming != null && message.hasOwnProperty("clientStreaming"))
                        if (typeof message.clientStreaming !== "boolean")
                            return "clientStreaming: boolean expected";
                    if (message.serverStreaming != null && message.hasOwnProperty("serverStreaming"))
                        if (typeof message.serverStreaming !== "boolean")
                            return "serverStreaming: boolean expected";
                    return null;
                };
    
                /**
                 * Creates a MethodDescriptorProto message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof google.protobuf.MethodDescriptorProto
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {google.protobuf.MethodDescriptorProto} MethodDescriptorProto
                 */
                MethodDescriptorProto.fromObject = function fromObject(object) {
                    if (object instanceof $root.google.protobuf.MethodDescriptorProto)
                        return object;
                    var message = new $root.google.protobuf.MethodDescriptorProto();
                    if (object.name != null)
                        message.name = String(object.name);
                    if (object.inputType != null)
                        message.inputType = String(object.inputType);
                    if (object.outputType != null)
                        message.outputType = String(object.outputType);
                    if (object.options != null) {
                        if (typeof object.options !== "object")
                            throw TypeError(".google.protobuf.MethodDescriptorProto.options: object expected");
                        message.options = $root.google.protobuf.MethodOptions.fromObject(object.options);
                    }
                    if (object.clientStreaming != null)
                        message.clientStreaming = Boolean(object.clientStreaming);
                    if (object.serverStreaming != null)
                        message.serverStreaming = Boolean(object.serverStreaming);
                    return message;
                };
    
                /**
                 * Creates a plain object from a MethodDescriptorProto message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof google.protobuf.MethodDescriptorProto
                 * @static
                 * @param {google.protobuf.MethodDescriptorProto} message MethodDescriptorProto
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                MethodDescriptorProto.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.name = "";
                        object.inputType = "";
                        object.outputType = "";
                        object.options = null;
                        object.clientStreaming = false;
                        object.serverStreaming = false;
                    }
                    if (message.name != null && message.hasOwnProperty("name"))
                        object.name = message.name;
                    if (message.inputType != null && message.hasOwnProperty("inputType"))
                        object.inputType = message.inputType;
                    if (message.outputType != null && message.hasOwnProperty("outputType"))
                        object.outputType = message.outputType;
                    if (message.options != null && message.hasOwnProperty("options"))
                        object.options = $root.google.protobuf.MethodOptions.toObject(message.options, options);
                    if (message.clientStreaming != null && message.hasOwnProperty("clientStreaming"))
                        object.clientStreaming = message.clientStreaming;
                    if (message.serverStreaming != null && message.hasOwnProperty("serverStreaming"))
                        object.serverStreaming = message.serverStreaming;
                    return object;
                };
    
                /**
                 * Converts this MethodDescriptorProto to JSON.
                 * @function toJSON
                 * @memberof google.protobuf.MethodDescriptorProto
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                MethodDescriptorProto.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                /**
                 * Gets the default type url for MethodDescriptorProto
                 * @function getTypeUrl
                 * @memberof google.protobuf.MethodDescriptorProto
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                MethodDescriptorProto.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/google.protobuf.MethodDescriptorProto";
                };
    
                return MethodDescriptorProto;
            })();
    
            protobuf.FileOptions = (function() {
    
                /**
                 * Properties of a FileOptions.
                 * @memberof google.protobuf
                 * @interface IFileOptions
                 * @property {string|null} [javaPackage] FileOptions javaPackage
                 * @property {string|null} [javaOuterClassname] FileOptions javaOuterClassname
                 * @property {boolean|null} [javaMultipleFiles] FileOptions javaMultipleFiles
                 * @property {boolean|null} [javaGenerateEqualsAndHash] FileOptions javaGenerateEqualsAndHash
                 * @property {boolean|null} [javaStringCheckUtf8] FileOptions javaStringCheckUtf8
                 * @property {google.protobuf.FileOptions.OptimizeMode|null} [optimizeFor] FileOptions optimizeFor
                 * @property {string|null} [goPackage] FileOptions goPackage
                 * @property {boolean|null} [ccGenericServices] FileOptions ccGenericServices
                 * @property {boolean|null} [javaGenericServices] FileOptions javaGenericServices
                 * @property {boolean|null} [pyGenericServices] FileOptions pyGenericServices
                 * @property {boolean|null} [deprecated] FileOptions deprecated
                 * @property {boolean|null} [ccEnableArenas] FileOptions ccEnableArenas
                 * @property {string|null} [objcClassPrefix] FileOptions objcClassPrefix
                 * @property {string|null} [csharpNamespace] FileOptions csharpNamespace
                 * @property {Array.<google.protobuf.IUninterpretedOption>|null} [uninterpretedOption] FileOptions uninterpretedOption
                 */
    
                /**
                 * Constructs a new FileOptions.
                 * @memberof google.protobuf
                 * @classdesc Represents a FileOptions.
                 * @implements IFileOptions
                 * @constructor
                 * @param {google.protobuf.IFileOptions=} [properties] Properties to set
                 */
                function FileOptions(properties) {
                    this.uninterpretedOption = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * FileOptions javaPackage.
                 * @member {string} javaPackage
                 * @memberof google.protobuf.FileOptions
                 * @instance
                 */
                FileOptions.prototype.javaPackage = "";
    
                /**
                 * FileOptions javaOuterClassname.
                 * @member {string} javaOuterClassname
                 * @memberof google.protobuf.FileOptions
                 * @instance
                 */
                FileOptions.prototype.javaOuterClassname = "";
    
                /**
                 * FileOptions javaMultipleFiles.
                 * @member {boolean} javaMultipleFiles
                 * @memberof google.protobuf.FileOptions
                 * @instance
                 */
                FileOptions.prototype.javaMultipleFiles = false;
    
                /**
                 * FileOptions javaGenerateEqualsAndHash.
                 * @member {boolean} javaGenerateEqualsAndHash
                 * @memberof google.protobuf.FileOptions
                 * @instance
                 */
                FileOptions.prototype.javaGenerateEqualsAndHash = false;
    
                /**
                 * FileOptions javaStringCheckUtf8.
                 * @member {boolean} javaStringCheckUtf8
                 * @memberof google.protobuf.FileOptions
                 * @instance
                 */
                FileOptions.prototype.javaStringCheckUtf8 = false;
    
                /**
                 * FileOptions optimizeFor.
                 * @member {google.protobuf.FileOptions.OptimizeMode} optimizeFor
                 * @memberof google.protobuf.FileOptions
                 * @instance
                 */
                FileOptions.prototype.optimizeFor = 1;
    
                /**
                 * FileOptions goPackage.
                 * @member {string} goPackage
                 * @memberof google.protobuf.FileOptions
                 * @instance
                 */
                FileOptions.prototype.goPackage = "";
    
                /**
                 * FileOptions ccGenericServices.
                 * @member {boolean} ccGenericServices
                 * @memberof google.protobuf.FileOptions
                 * @instance
                 */
                FileOptions.prototype.ccGenericServices = false;
    
                /**
                 * FileOptions javaGenericServices.
                 * @member {boolean} javaGenericServices
                 * @memberof google.protobuf.FileOptions
                 * @instance
                 */
                FileOptions.prototype.javaGenericServices = false;
    
                /**
                 * FileOptions pyGenericServices.
                 * @member {boolean} pyGenericServices
                 * @memberof google.protobuf.FileOptions
                 * @instance
                 */
                FileOptions.prototype.pyGenericServices = false;
    
                /**
                 * FileOptions deprecated.
                 * @member {boolean} deprecated
                 * @memberof google.protobuf.FileOptions
                 * @instance
                 */
                FileOptions.prototype.deprecated = false;
    
                /**
                 * FileOptions ccEnableArenas.
                 * @member {boolean} ccEnableArenas
                 * @memberof google.protobuf.FileOptions
                 * @instance
                 */
                FileOptions.prototype.ccEnableArenas = false;
    
                /**
                 * FileOptions objcClassPrefix.
                 * @member {string} objcClassPrefix
                 * @memberof google.protobuf.FileOptions
                 * @instance
                 */
                FileOptions.prototype.objcClassPrefix = "";
    
                /**
                 * FileOptions csharpNamespace.
                 * @member {string} csharpNamespace
                 * @memberof google.protobuf.FileOptions
                 * @instance
                 */
                FileOptions.prototype.csharpNamespace = "";
    
                /**
                 * FileOptions uninterpretedOption.
                 * @member {Array.<google.protobuf.IUninterpretedOption>} uninterpretedOption
                 * @memberof google.protobuf.FileOptions
                 * @instance
                 */
                FileOptions.prototype.uninterpretedOption = $util.emptyArray;
    
                /**
                 * Creates a new FileOptions instance using the specified properties.
                 * @function create
                 * @memberof google.protobuf.FileOptions
                 * @static
                 * @param {google.protobuf.IFileOptions=} [properties] Properties to set
                 * @returns {google.protobuf.FileOptions} FileOptions instance
                 */
                FileOptions.create = function create(properties) {
                    return new FileOptions(properties);
                };
    
                /**
                 * Encodes the specified FileOptions message. Does not implicitly {@link google.protobuf.FileOptions.verify|verify} messages.
                 * @function encode
                 * @memberof google.protobuf.FileOptions
                 * @static
                 * @param {google.protobuf.IFileOptions} message FileOptions message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                FileOptions.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.javaPackage != null && Object.hasOwnProperty.call(message, "javaPackage"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.javaPackage);
                    if (message.javaOuterClassname != null && Object.hasOwnProperty.call(message, "javaOuterClassname"))
                        writer.uint32(/* id 8, wireType 2 =*/66).string(message.javaOuterClassname);
                    if (message.optimizeFor != null && Object.hasOwnProperty.call(message, "optimizeFor"))
                        writer.uint32(/* id 9, wireType 0 =*/72).int32(message.optimizeFor);
                    if (message.javaMultipleFiles != null && Object.hasOwnProperty.call(message, "javaMultipleFiles"))
                        writer.uint32(/* id 10, wireType 0 =*/80).bool(message.javaMultipleFiles);
                    if (message.goPackage != null && Object.hasOwnProperty.call(message, "goPackage"))
                        writer.uint32(/* id 11, wireType 2 =*/90).string(message.goPackage);
                    if (message.ccGenericServices != null && Object.hasOwnProperty.call(message, "ccGenericServices"))
                        writer.uint32(/* id 16, wireType 0 =*/128).bool(message.ccGenericServices);
                    if (message.javaGenericServices != null && Object.hasOwnProperty.call(message, "javaGenericServices"))
                        writer.uint32(/* id 17, wireType 0 =*/136).bool(message.javaGenericServices);
                    if (message.pyGenericServices != null && Object.hasOwnProperty.call(message, "pyGenericServices"))
                        writer.uint32(/* id 18, wireType 0 =*/144).bool(message.pyGenericServices);
                    if (message.javaGenerateEqualsAndHash != null && Object.hasOwnProperty.call(message, "javaGenerateEqualsAndHash"))
                        writer.uint32(/* id 20, wireType 0 =*/160).bool(message.javaGenerateEqualsAndHash);
                    if (message.deprecated != null && Object.hasOwnProperty.call(message, "deprecated"))
                        writer.uint32(/* id 23, wireType 0 =*/184).bool(message.deprecated);
                    if (message.javaStringCheckUtf8 != null && Object.hasOwnProperty.call(message, "javaStringCheckUtf8"))
                        writer.uint32(/* id 27, wireType 0 =*/216).bool(message.javaStringCheckUtf8);
                    if (message.ccEnableArenas != null && Object.hasOwnProperty.call(message, "ccEnableArenas"))
                        writer.uint32(/* id 31, wireType 0 =*/248).bool(message.ccEnableArenas);
                    if (message.objcClassPrefix != null && Object.hasOwnProperty.call(message, "objcClassPrefix"))
                        writer.uint32(/* id 36, wireType 2 =*/290).string(message.objcClassPrefix);
                    if (message.csharpNamespace != null && Object.hasOwnProperty.call(message, "csharpNamespace"))
                        writer.uint32(/* id 37, wireType 2 =*/298).string(message.csharpNamespace);
                    if (message.uninterpretedOption != null && message.uninterpretedOption.length)
                        for (var i = 0; i < message.uninterpretedOption.length; ++i)
                            $root.google.protobuf.UninterpretedOption.encode(message.uninterpretedOption[i], writer.uint32(/* id 999, wireType 2 =*/7994).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified FileOptions message, length delimited. Does not implicitly {@link google.protobuf.FileOptions.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof google.protobuf.FileOptions
                 * @static
                 * @param {google.protobuf.IFileOptions} message FileOptions message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                FileOptions.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a FileOptions message from the specified reader or buffer.
                 * @function decode
                 * @memberof google.protobuf.FileOptions
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {google.protobuf.FileOptions} FileOptions
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                FileOptions.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.FileOptions();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1: {
                                message.javaPackage = reader.string();
                                break;
                            }
                        case 8: {
                                message.javaOuterClassname = reader.string();
                                break;
                            }
                        case 10: {
                                message.javaMultipleFiles = reader.bool();
                                break;
                            }
                        case 20: {
                                message.javaGenerateEqualsAndHash = reader.bool();
                                break;
                            }
                        case 27: {
                                message.javaStringCheckUtf8 = reader.bool();
                                break;
                            }
                        case 9: {
                                message.optimizeFor = reader.int32();
                                break;
                            }
                        case 11: {
                                message.goPackage = reader.string();
                                break;
                            }
                        case 16: {
                                message.ccGenericServices = reader.bool();
                                break;
                            }
                        case 17: {
                                message.javaGenericServices = reader.bool();
                                break;
                            }
                        case 18: {
                                message.pyGenericServices = reader.bool();
                                break;
                            }
                        case 23: {
                                message.deprecated = reader.bool();
                                break;
                            }
                        case 31: {
                                message.ccEnableArenas = reader.bool();
                                break;
                            }
                        case 36: {
                                message.objcClassPrefix = reader.string();
                                break;
                            }
                        case 37: {
                                message.csharpNamespace = reader.string();
                                break;
                            }
                        case 999: {
                                if (!(message.uninterpretedOption && message.uninterpretedOption.length))
                                    message.uninterpretedOption = [];
                                message.uninterpretedOption.push($root.google.protobuf.UninterpretedOption.decode(reader, reader.uint32()));
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a FileOptions message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof google.protobuf.FileOptions
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {google.protobuf.FileOptions} FileOptions
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                FileOptions.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a FileOptions message.
                 * @function verify
                 * @memberof google.protobuf.FileOptions
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                FileOptions.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.javaPackage != null && message.hasOwnProperty("javaPackage"))
                        if (!$util.isString(message.javaPackage))
                            return "javaPackage: string expected";
                    if (message.javaOuterClassname != null && message.hasOwnProperty("javaOuterClassname"))
                        if (!$util.isString(message.javaOuterClassname))
                            return "javaOuterClassname: string expected";
                    if (message.javaMultipleFiles != null && message.hasOwnProperty("javaMultipleFiles"))
                        if (typeof message.javaMultipleFiles !== "boolean")
                            return "javaMultipleFiles: boolean expected";
                    if (message.javaGenerateEqualsAndHash != null && message.hasOwnProperty("javaGenerateEqualsAndHash"))
                        if (typeof message.javaGenerateEqualsAndHash !== "boolean")
                            return "javaGenerateEqualsAndHash: boolean expected";
                    if (message.javaStringCheckUtf8 != null && message.hasOwnProperty("javaStringCheckUtf8"))
                        if (typeof message.javaStringCheckUtf8 !== "boolean")
                            return "javaStringCheckUtf8: boolean expected";
                    if (message.optimizeFor != null && message.hasOwnProperty("optimizeFor"))
                        switch (message.optimizeFor) {
                        default:
                            return "optimizeFor: enum value expected";
                        case 1:
                        case 2:
                        case 3:
                            break;
                        }
                    if (message.goPackage != null && message.hasOwnProperty("goPackage"))
                        if (!$util.isString(message.goPackage))
                            return "goPackage: string expected";
                    if (message.ccGenericServices != null && message.hasOwnProperty("ccGenericServices"))
                        if (typeof message.ccGenericServices !== "boolean")
                            return "ccGenericServices: boolean expected";
                    if (message.javaGenericServices != null && message.hasOwnProperty("javaGenericServices"))
                        if (typeof message.javaGenericServices !== "boolean")
                            return "javaGenericServices: boolean expected";
                    if (message.pyGenericServices != null && message.hasOwnProperty("pyGenericServices"))
                        if (typeof message.pyGenericServices !== "boolean")
                            return "pyGenericServices: boolean expected";
                    if (message.deprecated != null && message.hasOwnProperty("deprecated"))
                        if (typeof message.deprecated !== "boolean")
                            return "deprecated: boolean expected";
                    if (message.ccEnableArenas != null && message.hasOwnProperty("ccEnableArenas"))
                        if (typeof message.ccEnableArenas !== "boolean")
                            return "ccEnableArenas: boolean expected";
                    if (message.objcClassPrefix != null && message.hasOwnProperty("objcClassPrefix"))
                        if (!$util.isString(message.objcClassPrefix))
                            return "objcClassPrefix: string expected";
                    if (message.csharpNamespace != null && message.hasOwnProperty("csharpNamespace"))
                        if (!$util.isString(message.csharpNamespace))
                            return "csharpNamespace: string expected";
                    if (message.uninterpretedOption != null && message.hasOwnProperty("uninterpretedOption")) {
                        if (!Array.isArray(message.uninterpretedOption))
                            return "uninterpretedOption: array expected";
                        for (var i = 0; i < message.uninterpretedOption.length; ++i) {
                            var error = $root.google.protobuf.UninterpretedOption.verify(message.uninterpretedOption[i]);
                            if (error)
                                return "uninterpretedOption." + error;
                        }
                    }
                    return null;
                };
    
                /**
                 * Creates a FileOptions message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof google.protobuf.FileOptions
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {google.protobuf.FileOptions} FileOptions
                 */
                FileOptions.fromObject = function fromObject(object) {
                    if (object instanceof $root.google.protobuf.FileOptions)
                        return object;
                    var message = new $root.google.protobuf.FileOptions();
                    if (object.javaPackage != null)
                        message.javaPackage = String(object.javaPackage);
                    if (object.javaOuterClassname != null)
                        message.javaOuterClassname = String(object.javaOuterClassname);
                    if (object.javaMultipleFiles != null)
                        message.javaMultipleFiles = Boolean(object.javaMultipleFiles);
                    if (object.javaGenerateEqualsAndHash != null)
                        message.javaGenerateEqualsAndHash = Boolean(object.javaGenerateEqualsAndHash);
                    if (object.javaStringCheckUtf8 != null)
                        message.javaStringCheckUtf8 = Boolean(object.javaStringCheckUtf8);
                    switch (object.optimizeFor) {
                    default:
                        if (typeof object.optimizeFor === "number") {
                            message.optimizeFor = object.optimizeFor;
                            break;
                        }
                        break;
                    case "SPEED":
                    case 1:
                        message.optimizeFor = 1;
                        break;
                    case "CODE_SIZE":
                    case 2:
                        message.optimizeFor = 2;
                        break;
                    case "LITE_RUNTIME":
                    case 3:
                        message.optimizeFor = 3;
                        break;
                    }
                    if (object.goPackage != null)
                        message.goPackage = String(object.goPackage);
                    if (object.ccGenericServices != null)
                        message.ccGenericServices = Boolean(object.ccGenericServices);
                    if (object.javaGenericServices != null)
                        message.javaGenericServices = Boolean(object.javaGenericServices);
                    if (object.pyGenericServices != null)
                        message.pyGenericServices = Boolean(object.pyGenericServices);
                    if (object.deprecated != null)
                        message.deprecated = Boolean(object.deprecated);
                    if (object.ccEnableArenas != null)
                        message.ccEnableArenas = Boolean(object.ccEnableArenas);
                    if (object.objcClassPrefix != null)
                        message.objcClassPrefix = String(object.objcClassPrefix);
                    if (object.csharpNamespace != null)
                        message.csharpNamespace = String(object.csharpNamespace);
                    if (object.uninterpretedOption) {
                        if (!Array.isArray(object.uninterpretedOption))
                            throw TypeError(".google.protobuf.FileOptions.uninterpretedOption: array expected");
                        message.uninterpretedOption = [];
                        for (var i = 0; i < object.uninterpretedOption.length; ++i) {
                            if (typeof object.uninterpretedOption[i] !== "object")
                                throw TypeError(".google.protobuf.FileOptions.uninterpretedOption: object expected");
                            message.uninterpretedOption[i] = $root.google.protobuf.UninterpretedOption.fromObject(object.uninterpretedOption[i]);
                        }
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a FileOptions message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof google.protobuf.FileOptions
                 * @static
                 * @param {google.protobuf.FileOptions} message FileOptions
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                FileOptions.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.uninterpretedOption = [];
                    if (options.defaults) {
                        object.javaPackage = "";
                        object.javaOuterClassname = "";
                        object.optimizeFor = options.enums === String ? "SPEED" : 1;
                        object.javaMultipleFiles = false;
                        object.goPackage = "";
                        object.ccGenericServices = false;
                        object.javaGenericServices = false;
                        object.pyGenericServices = false;
                        object.javaGenerateEqualsAndHash = false;
                        object.deprecated = false;
                        object.javaStringCheckUtf8 = false;
                        object.ccEnableArenas = false;
                        object.objcClassPrefix = "";
                        object.csharpNamespace = "";
                    }
                    if (message.javaPackage != null && message.hasOwnProperty("javaPackage"))
                        object.javaPackage = message.javaPackage;
                    if (message.javaOuterClassname != null && message.hasOwnProperty("javaOuterClassname"))
                        object.javaOuterClassname = message.javaOuterClassname;
                    if (message.optimizeFor != null && message.hasOwnProperty("optimizeFor"))
                        object.optimizeFor = options.enums === String ? $root.google.protobuf.FileOptions.OptimizeMode[message.optimizeFor] === undefined ? message.optimizeFor : $root.google.protobuf.FileOptions.OptimizeMode[message.optimizeFor] : message.optimizeFor;
                    if (message.javaMultipleFiles != null && message.hasOwnProperty("javaMultipleFiles"))
                        object.javaMultipleFiles = message.javaMultipleFiles;
                    if (message.goPackage != null && message.hasOwnProperty("goPackage"))
                        object.goPackage = message.goPackage;
                    if (message.ccGenericServices != null && message.hasOwnProperty("ccGenericServices"))
                        object.ccGenericServices = message.ccGenericServices;
                    if (message.javaGenericServices != null && message.hasOwnProperty("javaGenericServices"))
                        object.javaGenericServices = message.javaGenericServices;
                    if (message.pyGenericServices != null && message.hasOwnProperty("pyGenericServices"))
                        object.pyGenericServices = message.pyGenericServices;
                    if (message.javaGenerateEqualsAndHash != null && message.hasOwnProperty("javaGenerateEqualsAndHash"))
                        object.javaGenerateEqualsAndHash = message.javaGenerateEqualsAndHash;
                    if (message.deprecated != null && message.hasOwnProperty("deprecated"))
                        object.deprecated = message.deprecated;
                    if (message.javaStringCheckUtf8 != null && message.hasOwnProperty("javaStringCheckUtf8"))
                        object.javaStringCheckUtf8 = message.javaStringCheckUtf8;
                    if (message.ccEnableArenas != null && message.hasOwnProperty("ccEnableArenas"))
                        object.ccEnableArenas = message.ccEnableArenas;
                    if (message.objcClassPrefix != null && message.hasOwnProperty("objcClassPrefix"))
                        object.objcClassPrefix = message.objcClassPrefix;
                    if (message.csharpNamespace != null && message.hasOwnProperty("csharpNamespace"))
                        object.csharpNamespace = message.csharpNamespace;
                    if (message.uninterpretedOption && message.uninterpretedOption.length) {
                        object.uninterpretedOption = [];
                        for (var j = 0; j < message.uninterpretedOption.length; ++j)
                            object.uninterpretedOption[j] = $root.google.protobuf.UninterpretedOption.toObject(message.uninterpretedOption[j], options);
                    }
                    return object;
                };
    
                /**
                 * Converts this FileOptions to JSON.
                 * @function toJSON
                 * @memberof google.protobuf.FileOptions
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                FileOptions.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                /**
                 * Gets the default type url for FileOptions
                 * @function getTypeUrl
                 * @memberof google.protobuf.FileOptions
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                FileOptions.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/google.protobuf.FileOptions";
                };
    
                /**
                 * OptimizeMode enum.
                 * @name google.protobuf.FileOptions.OptimizeMode
                 * @enum {number}
                 * @property {number} SPEED=1 SPEED value
                 * @property {number} CODE_SIZE=2 CODE_SIZE value
                 * @property {number} LITE_RUNTIME=3 LITE_RUNTIME value
                 */
                FileOptions.OptimizeMode = (function() {
                    var valuesById = {}, values = Object.create(valuesById);
                    values[valuesById[1] = "SPEED"] = 1;
                    values[valuesById[2] = "CODE_SIZE"] = 2;
                    values[valuesById[3] = "LITE_RUNTIME"] = 3;
                    return values;
                })();
    
                return FileOptions;
            })();
    
            protobuf.MessageOptions = (function() {
    
                /**
                 * Properties of a MessageOptions.
                 * @memberof google.protobuf
                 * @interface IMessageOptions
                 * @property {boolean|null} [messageSetWireFormat] MessageOptions messageSetWireFormat
                 * @property {boolean|null} [noStandardDescriptorAccessor] MessageOptions noStandardDescriptorAccessor
                 * @property {boolean|null} [deprecated] MessageOptions deprecated
                 * @property {boolean|null} [mapEntry] MessageOptions mapEntry
                 * @property {Array.<google.protobuf.IUninterpretedOption>|null} [uninterpretedOption] MessageOptions uninterpretedOption
                 */
    
                /**
                 * Constructs a new MessageOptions.
                 * @memberof google.protobuf
                 * @classdesc Represents a MessageOptions.
                 * @implements IMessageOptions
                 * @constructor
                 * @param {google.protobuf.IMessageOptions=} [properties] Properties to set
                 */
                function MessageOptions(properties) {
                    this.uninterpretedOption = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * MessageOptions messageSetWireFormat.
                 * @member {boolean} messageSetWireFormat
                 * @memberof google.protobuf.MessageOptions
                 * @instance
                 */
                MessageOptions.prototype.messageSetWireFormat = false;
    
                /**
                 * MessageOptions noStandardDescriptorAccessor.
                 * @member {boolean} noStandardDescriptorAccessor
                 * @memberof google.protobuf.MessageOptions
                 * @instance
                 */
                MessageOptions.prototype.noStandardDescriptorAccessor = false;
    
                /**
                 * MessageOptions deprecated.
                 * @member {boolean} deprecated
                 * @memberof google.protobuf.MessageOptions
                 * @instance
                 */
                MessageOptions.prototype.deprecated = false;
    
                /**
                 * MessageOptions mapEntry.
                 * @member {boolean} mapEntry
                 * @memberof google.protobuf.MessageOptions
                 * @instance
                 */
                MessageOptions.prototype.mapEntry = false;
    
                /**
                 * MessageOptions uninterpretedOption.
                 * @member {Array.<google.protobuf.IUninterpretedOption>} uninterpretedOption
                 * @memberof google.protobuf.MessageOptions
                 * @instance
                 */
                MessageOptions.prototype.uninterpretedOption = $util.emptyArray;
    
                /**
                 * Creates a new MessageOptions instance using the specified properties.
                 * @function create
                 * @memberof google.protobuf.MessageOptions
                 * @static
                 * @param {google.protobuf.IMessageOptions=} [properties] Properties to set
                 * @returns {google.protobuf.MessageOptions} MessageOptions instance
                 */
                MessageOptions.create = function create(properties) {
                    return new MessageOptions(properties);
                };
    
                /**
                 * Encodes the specified MessageOptions message. Does not implicitly {@link google.protobuf.MessageOptions.verify|verify} messages.
                 * @function encode
                 * @memberof google.protobuf.MessageOptions
                 * @static
                 * @param {google.protobuf.IMessageOptions} message MessageOptions message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MessageOptions.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.messageSetWireFormat != null && Object.hasOwnProperty.call(message, "messageSetWireFormat"))
                        writer.uint32(/* id 1, wireType 0 =*/8).bool(message.messageSetWireFormat);
                    if (message.noStandardDescriptorAccessor != null && Object.hasOwnProperty.call(message, "noStandardDescriptorAccessor"))
                        writer.uint32(/* id 2, wireType 0 =*/16).bool(message.noStandardDescriptorAccessor);
                    if (message.deprecated != null && Object.hasOwnProperty.call(message, "deprecated"))
                        writer.uint32(/* id 3, wireType 0 =*/24).bool(message.deprecated);
                    if (message.mapEntry != null && Object.hasOwnProperty.call(message, "mapEntry"))
                        writer.uint32(/* id 7, wireType 0 =*/56).bool(message.mapEntry);
                    if (message.uninterpretedOption != null && message.uninterpretedOption.length)
                        for (var i = 0; i < message.uninterpretedOption.length; ++i)
                            $root.google.protobuf.UninterpretedOption.encode(message.uninterpretedOption[i], writer.uint32(/* id 999, wireType 2 =*/7994).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified MessageOptions message, length delimited. Does not implicitly {@link google.protobuf.MessageOptions.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof google.protobuf.MessageOptions
                 * @static
                 * @param {google.protobuf.IMessageOptions} message MessageOptions message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MessageOptions.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a MessageOptions message from the specified reader or buffer.
                 * @function decode
                 * @memberof google.protobuf.MessageOptions
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {google.protobuf.MessageOptions} MessageOptions
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MessageOptions.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.MessageOptions();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1: {
                                message.messageSetWireFormat = reader.bool();
                                break;
                            }
                        case 2: {
                                message.noStandardDescriptorAccessor = reader.bool();
                                break;
                            }
                        case 3: {
                                message.deprecated = reader.bool();
                                break;
                            }
                        case 7: {
                                message.mapEntry = reader.bool();
                                break;
                            }
                        case 999: {
                                if (!(message.uninterpretedOption && message.uninterpretedOption.length))
                                    message.uninterpretedOption = [];
                                message.uninterpretedOption.push($root.google.protobuf.UninterpretedOption.decode(reader, reader.uint32()));
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a MessageOptions message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof google.protobuf.MessageOptions
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {google.protobuf.MessageOptions} MessageOptions
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MessageOptions.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a MessageOptions message.
                 * @function verify
                 * @memberof google.protobuf.MessageOptions
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                MessageOptions.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.messageSetWireFormat != null && message.hasOwnProperty("messageSetWireFormat"))
                        if (typeof message.messageSetWireFormat !== "boolean")
                            return "messageSetWireFormat: boolean expected";
                    if (message.noStandardDescriptorAccessor != null && message.hasOwnProperty("noStandardDescriptorAccessor"))
                        if (typeof message.noStandardDescriptorAccessor !== "boolean")
                            return "noStandardDescriptorAccessor: boolean expected";
                    if (message.deprecated != null && message.hasOwnProperty("deprecated"))
                        if (typeof message.deprecated !== "boolean")
                            return "deprecated: boolean expected";
                    if (message.mapEntry != null && message.hasOwnProperty("mapEntry"))
                        if (typeof message.mapEntry !== "boolean")
                            return "mapEntry: boolean expected";
                    if (message.uninterpretedOption != null && message.hasOwnProperty("uninterpretedOption")) {
                        if (!Array.isArray(message.uninterpretedOption))
                            return "uninterpretedOption: array expected";
                        for (var i = 0; i < message.uninterpretedOption.length; ++i) {
                            var error = $root.google.protobuf.UninterpretedOption.verify(message.uninterpretedOption[i]);
                            if (error)
                                return "uninterpretedOption." + error;
                        }
                    }
                    return null;
                };
    
                /**
                 * Creates a MessageOptions message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof google.protobuf.MessageOptions
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {google.protobuf.MessageOptions} MessageOptions
                 */
                MessageOptions.fromObject = function fromObject(object) {
                    if (object instanceof $root.google.protobuf.MessageOptions)
                        return object;
                    var message = new $root.google.protobuf.MessageOptions();
                    if (object.messageSetWireFormat != null)
                        message.messageSetWireFormat = Boolean(object.messageSetWireFormat);
                    if (object.noStandardDescriptorAccessor != null)
                        message.noStandardDescriptorAccessor = Boolean(object.noStandardDescriptorAccessor);
                    if (object.deprecated != null)
                        message.deprecated = Boolean(object.deprecated);
                    if (object.mapEntry != null)
                        message.mapEntry = Boolean(object.mapEntry);
                    if (object.uninterpretedOption) {
                        if (!Array.isArray(object.uninterpretedOption))
                            throw TypeError(".google.protobuf.MessageOptions.uninterpretedOption: array expected");
                        message.uninterpretedOption = [];
                        for (var i = 0; i < object.uninterpretedOption.length; ++i) {
                            if (typeof object.uninterpretedOption[i] !== "object")
                                throw TypeError(".google.protobuf.MessageOptions.uninterpretedOption: object expected");
                            message.uninterpretedOption[i] = $root.google.protobuf.UninterpretedOption.fromObject(object.uninterpretedOption[i]);
                        }
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a MessageOptions message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof google.protobuf.MessageOptions
                 * @static
                 * @param {google.protobuf.MessageOptions} message MessageOptions
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                MessageOptions.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.uninterpretedOption = [];
                    if (options.defaults) {
                        object.messageSetWireFormat = false;
                        object.noStandardDescriptorAccessor = false;
                        object.deprecated = false;
                        object.mapEntry = false;
                    }
                    if (message.messageSetWireFormat != null && message.hasOwnProperty("messageSetWireFormat"))
                        object.messageSetWireFormat = message.messageSetWireFormat;
                    if (message.noStandardDescriptorAccessor != null && message.hasOwnProperty("noStandardDescriptorAccessor"))
                        object.noStandardDescriptorAccessor = message.noStandardDescriptorAccessor;
                    if (message.deprecated != null && message.hasOwnProperty("deprecated"))
                        object.deprecated = message.deprecated;
                    if (message.mapEntry != null && message.hasOwnProperty("mapEntry"))
                        object.mapEntry = message.mapEntry;
                    if (message.uninterpretedOption && message.uninterpretedOption.length) {
                        object.uninterpretedOption = [];
                        for (var j = 0; j < message.uninterpretedOption.length; ++j)
                            object.uninterpretedOption[j] = $root.google.protobuf.UninterpretedOption.toObject(message.uninterpretedOption[j], options);
                    }
                    return object;
                };
    
                /**
                 * Converts this MessageOptions to JSON.
                 * @function toJSON
                 * @memberof google.protobuf.MessageOptions
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                MessageOptions.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                /**
                 * Gets the default type url for MessageOptions
                 * @function getTypeUrl
                 * @memberof google.protobuf.MessageOptions
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                MessageOptions.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/google.protobuf.MessageOptions";
                };
    
                return MessageOptions;
            })();
    
            protobuf.FieldOptions = (function() {
    
                /**
                 * Properties of a FieldOptions.
                 * @memberof google.protobuf
                 * @interface IFieldOptions
                 * @property {google.protobuf.FieldOptions.CType|null} [ctype] FieldOptions ctype
                 * @property {boolean|null} [packed] FieldOptions packed
                 * @property {google.protobuf.FieldOptions.JSType|null} [jstype] FieldOptions jstype
                 * @property {boolean|null} [lazy] FieldOptions lazy
                 * @property {boolean|null} [deprecated] FieldOptions deprecated
                 * @property {boolean|null} [weak] FieldOptions weak
                 * @property {Array.<google.protobuf.IUninterpretedOption>|null} [uninterpretedOption] FieldOptions uninterpretedOption
                 */
    
                /**
                 * Constructs a new FieldOptions.
                 * @memberof google.protobuf
                 * @classdesc Represents a FieldOptions.
                 * @implements IFieldOptions
                 * @constructor
                 * @param {google.protobuf.IFieldOptions=} [properties] Properties to set
                 */
                function FieldOptions(properties) {
                    this.uninterpretedOption = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * FieldOptions ctype.
                 * @member {google.protobuf.FieldOptions.CType} ctype
                 * @memberof google.protobuf.FieldOptions
                 * @instance
                 */
                FieldOptions.prototype.ctype = 0;
    
                /**
                 * FieldOptions packed.
                 * @member {boolean} packed
                 * @memberof google.protobuf.FieldOptions
                 * @instance
                 */
                FieldOptions.prototype.packed = false;
    
                /**
                 * FieldOptions jstype.
                 * @member {google.protobuf.FieldOptions.JSType} jstype
                 * @memberof google.protobuf.FieldOptions
                 * @instance
                 */
                FieldOptions.prototype.jstype = 0;
    
                /**
                 * FieldOptions lazy.
                 * @member {boolean} lazy
                 * @memberof google.protobuf.FieldOptions
                 * @instance
                 */
                FieldOptions.prototype.lazy = false;
    
                /**
                 * FieldOptions deprecated.
                 * @member {boolean} deprecated
                 * @memberof google.protobuf.FieldOptions
                 * @instance
                 */
                FieldOptions.prototype.deprecated = false;
    
                /**
                 * FieldOptions weak.
                 * @member {boolean} weak
                 * @memberof google.protobuf.FieldOptions
                 * @instance
                 */
                FieldOptions.prototype.weak = false;
    
                /**
                 * FieldOptions uninterpretedOption.
                 * @member {Array.<google.protobuf.IUninterpretedOption>} uninterpretedOption
                 * @memberof google.protobuf.FieldOptions
                 * @instance
                 */
                FieldOptions.prototype.uninterpretedOption = $util.emptyArray;
    
                /**
                 * Creates a new FieldOptions instance using the specified properties.
                 * @function create
                 * @memberof google.protobuf.FieldOptions
                 * @static
                 * @param {google.protobuf.IFieldOptions=} [properties] Properties to set
                 * @returns {google.protobuf.FieldOptions} FieldOptions instance
                 */
                FieldOptions.create = function create(properties) {
                    return new FieldOptions(properties);
                };
    
                /**
                 * Encodes the specified FieldOptions message. Does not implicitly {@link google.protobuf.FieldOptions.verify|verify} messages.
                 * @function encode
                 * @memberof google.protobuf.FieldOptions
                 * @static
                 * @param {google.protobuf.IFieldOptions} message FieldOptions message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                FieldOptions.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.ctype != null && Object.hasOwnProperty.call(message, "ctype"))
                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.ctype);
                    if (message.packed != null && Object.hasOwnProperty.call(message, "packed"))
                        writer.uint32(/* id 2, wireType 0 =*/16).bool(message.packed);
                    if (message.deprecated != null && Object.hasOwnProperty.call(message, "deprecated"))
                        writer.uint32(/* id 3, wireType 0 =*/24).bool(message.deprecated);
                    if (message.lazy != null && Object.hasOwnProperty.call(message, "lazy"))
                        writer.uint32(/* id 5, wireType 0 =*/40).bool(message.lazy);
                    if (message.jstype != null && Object.hasOwnProperty.call(message, "jstype"))
                        writer.uint32(/* id 6, wireType 0 =*/48).int32(message.jstype);
                    if (message.weak != null && Object.hasOwnProperty.call(message, "weak"))
                        writer.uint32(/* id 10, wireType 0 =*/80).bool(message.weak);
                    if (message.uninterpretedOption != null && message.uninterpretedOption.length)
                        for (var i = 0; i < message.uninterpretedOption.length; ++i)
                            $root.google.protobuf.UninterpretedOption.encode(message.uninterpretedOption[i], writer.uint32(/* id 999, wireType 2 =*/7994).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified FieldOptions message, length delimited. Does not implicitly {@link google.protobuf.FieldOptions.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof google.protobuf.FieldOptions
                 * @static
                 * @param {google.protobuf.IFieldOptions} message FieldOptions message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                FieldOptions.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a FieldOptions message from the specified reader or buffer.
                 * @function decode
                 * @memberof google.protobuf.FieldOptions
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {google.protobuf.FieldOptions} FieldOptions
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                FieldOptions.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.FieldOptions();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1: {
                                message.ctype = reader.int32();
                                break;
                            }
                        case 2: {
                                message.packed = reader.bool();
                                break;
                            }
                        case 6: {
                                message.jstype = reader.int32();
                                break;
                            }
                        case 5: {
                                message.lazy = reader.bool();
                                break;
                            }
                        case 3: {
                                message.deprecated = reader.bool();
                                break;
                            }
                        case 10: {
                                message.weak = reader.bool();
                                break;
                            }
                        case 999: {
                                if (!(message.uninterpretedOption && message.uninterpretedOption.length))
                                    message.uninterpretedOption = [];
                                message.uninterpretedOption.push($root.google.protobuf.UninterpretedOption.decode(reader, reader.uint32()));
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a FieldOptions message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof google.protobuf.FieldOptions
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {google.protobuf.FieldOptions} FieldOptions
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                FieldOptions.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a FieldOptions message.
                 * @function verify
                 * @memberof google.protobuf.FieldOptions
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                FieldOptions.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.ctype != null && message.hasOwnProperty("ctype"))
                        switch (message.ctype) {
                        default:
                            return "ctype: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                            break;
                        }
                    if (message.packed != null && message.hasOwnProperty("packed"))
                        if (typeof message.packed !== "boolean")
                            return "packed: boolean expected";
                    if (message.jstype != null && message.hasOwnProperty("jstype"))
                        switch (message.jstype) {
                        default:
                            return "jstype: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                            break;
                        }
                    if (message.lazy != null && message.hasOwnProperty("lazy"))
                        if (typeof message.lazy !== "boolean")
                            return "lazy: boolean expected";
                    if (message.deprecated != null && message.hasOwnProperty("deprecated"))
                        if (typeof message.deprecated !== "boolean")
                            return "deprecated: boolean expected";
                    if (message.weak != null && message.hasOwnProperty("weak"))
                        if (typeof message.weak !== "boolean")
                            return "weak: boolean expected";
                    if (message.uninterpretedOption != null && message.hasOwnProperty("uninterpretedOption")) {
                        if (!Array.isArray(message.uninterpretedOption))
                            return "uninterpretedOption: array expected";
                        for (var i = 0; i < message.uninterpretedOption.length; ++i) {
                            var error = $root.google.protobuf.UninterpretedOption.verify(message.uninterpretedOption[i]);
                            if (error)
                                return "uninterpretedOption." + error;
                        }
                    }
                    return null;
                };
    
                /**
                 * Creates a FieldOptions message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof google.protobuf.FieldOptions
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {google.protobuf.FieldOptions} FieldOptions
                 */
                FieldOptions.fromObject = function fromObject(object) {
                    if (object instanceof $root.google.protobuf.FieldOptions)
                        return object;
                    var message = new $root.google.protobuf.FieldOptions();
                    switch (object.ctype) {
                    default:
                        if (typeof object.ctype === "number") {
                            message.ctype = object.ctype;
                            break;
                        }
                        break;
                    case "STRING":
                    case 0:
                        message.ctype = 0;
                        break;
                    case "CORD":
                    case 1:
                        message.ctype = 1;
                        break;
                    case "STRING_PIECE":
                    case 2:
                        message.ctype = 2;
                        break;
                    }
                    if (object.packed != null)
                        message.packed = Boolean(object.packed);
                    switch (object.jstype) {
                    default:
                        if (typeof object.jstype === "number") {
                            message.jstype = object.jstype;
                            break;
                        }
                        break;
                    case "JS_NORMAL":
                    case 0:
                        message.jstype = 0;
                        break;
                    case "JS_STRING":
                    case 1:
                        message.jstype = 1;
                        break;
                    case "JS_NUMBER":
                    case 2:
                        message.jstype = 2;
                        break;
                    }
                    if (object.lazy != null)
                        message.lazy = Boolean(object.lazy);
                    if (object.deprecated != null)
                        message.deprecated = Boolean(object.deprecated);
                    if (object.weak != null)
                        message.weak = Boolean(object.weak);
                    if (object.uninterpretedOption) {
                        if (!Array.isArray(object.uninterpretedOption))
                            throw TypeError(".google.protobuf.FieldOptions.uninterpretedOption: array expected");
                        message.uninterpretedOption = [];
                        for (var i = 0; i < object.uninterpretedOption.length; ++i) {
                            if (typeof object.uninterpretedOption[i] !== "object")
                                throw TypeError(".google.protobuf.FieldOptions.uninterpretedOption: object expected");
                            message.uninterpretedOption[i] = $root.google.protobuf.UninterpretedOption.fromObject(object.uninterpretedOption[i]);
                        }
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a FieldOptions message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof google.protobuf.FieldOptions
                 * @static
                 * @param {google.protobuf.FieldOptions} message FieldOptions
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                FieldOptions.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.uninterpretedOption = [];
                    if (options.defaults) {
                        object.ctype = options.enums === String ? "STRING" : 0;
                        object.packed = false;
                        object.deprecated = false;
                        object.lazy = false;
                        object.jstype = options.enums === String ? "JS_NORMAL" : 0;
                        object.weak = false;
                    }
                    if (message.ctype != null && message.hasOwnProperty("ctype"))
                        object.ctype = options.enums === String ? $root.google.protobuf.FieldOptions.CType[message.ctype] === undefined ? message.ctype : $root.google.protobuf.FieldOptions.CType[message.ctype] : message.ctype;
                    if (message.packed != null && message.hasOwnProperty("packed"))
                        object.packed = message.packed;
                    if (message.deprecated != null && message.hasOwnProperty("deprecated"))
                        object.deprecated = message.deprecated;
                    if (message.lazy != null && message.hasOwnProperty("lazy"))
                        object.lazy = message.lazy;
                    if (message.jstype != null && message.hasOwnProperty("jstype"))
                        object.jstype = options.enums === String ? $root.google.protobuf.FieldOptions.JSType[message.jstype] === undefined ? message.jstype : $root.google.protobuf.FieldOptions.JSType[message.jstype] : message.jstype;
                    if (message.weak != null && message.hasOwnProperty("weak"))
                        object.weak = message.weak;
                    if (message.uninterpretedOption && message.uninterpretedOption.length) {
                        object.uninterpretedOption = [];
                        for (var j = 0; j < message.uninterpretedOption.length; ++j)
                            object.uninterpretedOption[j] = $root.google.protobuf.UninterpretedOption.toObject(message.uninterpretedOption[j], options);
                    }
                    return object;
                };
    
                /**
                 * Converts this FieldOptions to JSON.
                 * @function toJSON
                 * @memberof google.protobuf.FieldOptions
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                FieldOptions.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                /**
                 * Gets the default type url for FieldOptions
                 * @function getTypeUrl
                 * @memberof google.protobuf.FieldOptions
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                FieldOptions.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/google.protobuf.FieldOptions";
                };
    
                /**
                 * CType enum.
                 * @name google.protobuf.FieldOptions.CType
                 * @enum {number}
                 * @property {number} STRING=0 STRING value
                 * @property {number} CORD=1 CORD value
                 * @property {number} STRING_PIECE=2 STRING_PIECE value
                 */
                FieldOptions.CType = (function() {
                    var valuesById = {}, values = Object.create(valuesById);
                    values[valuesById[0] = "STRING"] = 0;
                    values[valuesById[1] = "CORD"] = 1;
                    values[valuesById[2] = "STRING_PIECE"] = 2;
                    return values;
                })();
    
                /**
                 * JSType enum.
                 * @name google.protobuf.FieldOptions.JSType
                 * @enum {number}
                 * @property {number} JS_NORMAL=0 JS_NORMAL value
                 * @property {number} JS_STRING=1 JS_STRING value
                 * @property {number} JS_NUMBER=2 JS_NUMBER value
                 */
                FieldOptions.JSType = (function() {
                    var valuesById = {}, values = Object.create(valuesById);
                    values[valuesById[0] = "JS_NORMAL"] = 0;
                    values[valuesById[1] = "JS_STRING"] = 1;
                    values[valuesById[2] = "JS_NUMBER"] = 2;
                    return values;
                })();
    
                return FieldOptions;
            })();
    
            protobuf.OneofOptions = (function() {
    
                /**
                 * Properties of an OneofOptions.
                 * @memberof google.protobuf
                 * @interface IOneofOptions
                 * @property {Array.<google.protobuf.IUninterpretedOption>|null} [uninterpretedOption] OneofOptions uninterpretedOption
                 */
    
                /**
                 * Constructs a new OneofOptions.
                 * @memberof google.protobuf
                 * @classdesc Represents an OneofOptions.
                 * @implements IOneofOptions
                 * @constructor
                 * @param {google.protobuf.IOneofOptions=} [properties] Properties to set
                 */
                function OneofOptions(properties) {
                    this.uninterpretedOption = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * OneofOptions uninterpretedOption.
                 * @member {Array.<google.protobuf.IUninterpretedOption>} uninterpretedOption
                 * @memberof google.protobuf.OneofOptions
                 * @instance
                 */
                OneofOptions.prototype.uninterpretedOption = $util.emptyArray;
    
                /**
                 * Creates a new OneofOptions instance using the specified properties.
                 * @function create
                 * @memberof google.protobuf.OneofOptions
                 * @static
                 * @param {google.protobuf.IOneofOptions=} [properties] Properties to set
                 * @returns {google.protobuf.OneofOptions} OneofOptions instance
                 */
                OneofOptions.create = function create(properties) {
                    return new OneofOptions(properties);
                };
    
                /**
                 * Encodes the specified OneofOptions message. Does not implicitly {@link google.protobuf.OneofOptions.verify|verify} messages.
                 * @function encode
                 * @memberof google.protobuf.OneofOptions
                 * @static
                 * @param {google.protobuf.IOneofOptions} message OneofOptions message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                OneofOptions.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.uninterpretedOption != null && message.uninterpretedOption.length)
                        for (var i = 0; i < message.uninterpretedOption.length; ++i)
                            $root.google.protobuf.UninterpretedOption.encode(message.uninterpretedOption[i], writer.uint32(/* id 999, wireType 2 =*/7994).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified OneofOptions message, length delimited. Does not implicitly {@link google.protobuf.OneofOptions.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof google.protobuf.OneofOptions
                 * @static
                 * @param {google.protobuf.IOneofOptions} message OneofOptions message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                OneofOptions.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes an OneofOptions message from the specified reader or buffer.
                 * @function decode
                 * @memberof google.protobuf.OneofOptions
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {google.protobuf.OneofOptions} OneofOptions
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                OneofOptions.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.OneofOptions();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 999: {
                                if (!(message.uninterpretedOption && message.uninterpretedOption.length))
                                    message.uninterpretedOption = [];
                                message.uninterpretedOption.push($root.google.protobuf.UninterpretedOption.decode(reader, reader.uint32()));
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes an OneofOptions message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof google.protobuf.OneofOptions
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {google.protobuf.OneofOptions} OneofOptions
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                OneofOptions.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies an OneofOptions message.
                 * @function verify
                 * @memberof google.protobuf.OneofOptions
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                OneofOptions.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.uninterpretedOption != null && message.hasOwnProperty("uninterpretedOption")) {
                        if (!Array.isArray(message.uninterpretedOption))
                            return "uninterpretedOption: array expected";
                        for (var i = 0; i < message.uninterpretedOption.length; ++i) {
                            var error = $root.google.protobuf.UninterpretedOption.verify(message.uninterpretedOption[i]);
                            if (error)
                                return "uninterpretedOption." + error;
                        }
                    }
                    return null;
                };
    
                /**
                 * Creates an OneofOptions message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof google.protobuf.OneofOptions
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {google.protobuf.OneofOptions} OneofOptions
                 */
                OneofOptions.fromObject = function fromObject(object) {
                    if (object instanceof $root.google.protobuf.OneofOptions)
                        return object;
                    var message = new $root.google.protobuf.OneofOptions();
                    if (object.uninterpretedOption) {
                        if (!Array.isArray(object.uninterpretedOption))
                            throw TypeError(".google.protobuf.OneofOptions.uninterpretedOption: array expected");
                        message.uninterpretedOption = [];
                        for (var i = 0; i < object.uninterpretedOption.length; ++i) {
                            if (typeof object.uninterpretedOption[i] !== "object")
                                throw TypeError(".google.protobuf.OneofOptions.uninterpretedOption: object expected");
                            message.uninterpretedOption[i] = $root.google.protobuf.UninterpretedOption.fromObject(object.uninterpretedOption[i]);
                        }
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from an OneofOptions message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof google.protobuf.OneofOptions
                 * @static
                 * @param {google.protobuf.OneofOptions} message OneofOptions
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                OneofOptions.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.uninterpretedOption = [];
                    if (message.uninterpretedOption && message.uninterpretedOption.length) {
                        object.uninterpretedOption = [];
                        for (var j = 0; j < message.uninterpretedOption.length; ++j)
                            object.uninterpretedOption[j] = $root.google.protobuf.UninterpretedOption.toObject(message.uninterpretedOption[j], options);
                    }
                    return object;
                };
    
                /**
                 * Converts this OneofOptions to JSON.
                 * @function toJSON
                 * @memberof google.protobuf.OneofOptions
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                OneofOptions.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                /**
                 * Gets the default type url for OneofOptions
                 * @function getTypeUrl
                 * @memberof google.protobuf.OneofOptions
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                OneofOptions.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/google.protobuf.OneofOptions";
                };
    
                return OneofOptions;
            })();
    
            protobuf.EnumOptions = (function() {
    
                /**
                 * Properties of an EnumOptions.
                 * @memberof google.protobuf
                 * @interface IEnumOptions
                 * @property {boolean|null} [allowAlias] EnumOptions allowAlias
                 * @property {boolean|null} [deprecated] EnumOptions deprecated
                 * @property {Array.<google.protobuf.IUninterpretedOption>|null} [uninterpretedOption] EnumOptions uninterpretedOption
                 */
    
                /**
                 * Constructs a new EnumOptions.
                 * @memberof google.protobuf
                 * @classdesc Represents an EnumOptions.
                 * @implements IEnumOptions
                 * @constructor
                 * @param {google.protobuf.IEnumOptions=} [properties] Properties to set
                 */
                function EnumOptions(properties) {
                    this.uninterpretedOption = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * EnumOptions allowAlias.
                 * @member {boolean} allowAlias
                 * @memberof google.protobuf.EnumOptions
                 * @instance
                 */
                EnumOptions.prototype.allowAlias = false;
    
                /**
                 * EnumOptions deprecated.
                 * @member {boolean} deprecated
                 * @memberof google.protobuf.EnumOptions
                 * @instance
                 */
                EnumOptions.prototype.deprecated = false;
    
                /**
                 * EnumOptions uninterpretedOption.
                 * @member {Array.<google.protobuf.IUninterpretedOption>} uninterpretedOption
                 * @memberof google.protobuf.EnumOptions
                 * @instance
                 */
                EnumOptions.prototype.uninterpretedOption = $util.emptyArray;
    
                /**
                 * Creates a new EnumOptions instance using the specified properties.
                 * @function create
                 * @memberof google.protobuf.EnumOptions
                 * @static
                 * @param {google.protobuf.IEnumOptions=} [properties] Properties to set
                 * @returns {google.protobuf.EnumOptions} EnumOptions instance
                 */
                EnumOptions.create = function create(properties) {
                    return new EnumOptions(properties);
                };
    
                /**
                 * Encodes the specified EnumOptions message. Does not implicitly {@link google.protobuf.EnumOptions.verify|verify} messages.
                 * @function encode
                 * @memberof google.protobuf.EnumOptions
                 * @static
                 * @param {google.protobuf.IEnumOptions} message EnumOptions message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                EnumOptions.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.allowAlias != null && Object.hasOwnProperty.call(message, "allowAlias"))
                        writer.uint32(/* id 2, wireType 0 =*/16).bool(message.allowAlias);
                    if (message.deprecated != null && Object.hasOwnProperty.call(message, "deprecated"))
                        writer.uint32(/* id 3, wireType 0 =*/24).bool(message.deprecated);
                    if (message.uninterpretedOption != null && message.uninterpretedOption.length)
                        for (var i = 0; i < message.uninterpretedOption.length; ++i)
                            $root.google.protobuf.UninterpretedOption.encode(message.uninterpretedOption[i], writer.uint32(/* id 999, wireType 2 =*/7994).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified EnumOptions message, length delimited. Does not implicitly {@link google.protobuf.EnumOptions.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof google.protobuf.EnumOptions
                 * @static
                 * @param {google.protobuf.IEnumOptions} message EnumOptions message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                EnumOptions.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes an EnumOptions message from the specified reader or buffer.
                 * @function decode
                 * @memberof google.protobuf.EnumOptions
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {google.protobuf.EnumOptions} EnumOptions
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                EnumOptions.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.EnumOptions();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 2: {
                                message.allowAlias = reader.bool();
                                break;
                            }
                        case 3: {
                                message.deprecated = reader.bool();
                                break;
                            }
                        case 999: {
                                if (!(message.uninterpretedOption && message.uninterpretedOption.length))
                                    message.uninterpretedOption = [];
                                message.uninterpretedOption.push($root.google.protobuf.UninterpretedOption.decode(reader, reader.uint32()));
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes an EnumOptions message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof google.protobuf.EnumOptions
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {google.protobuf.EnumOptions} EnumOptions
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                EnumOptions.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies an EnumOptions message.
                 * @function verify
                 * @memberof google.protobuf.EnumOptions
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                EnumOptions.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.allowAlias != null && message.hasOwnProperty("allowAlias"))
                        if (typeof message.allowAlias !== "boolean")
                            return "allowAlias: boolean expected";
                    if (message.deprecated != null && message.hasOwnProperty("deprecated"))
                        if (typeof message.deprecated !== "boolean")
                            return "deprecated: boolean expected";
                    if (message.uninterpretedOption != null && message.hasOwnProperty("uninterpretedOption")) {
                        if (!Array.isArray(message.uninterpretedOption))
                            return "uninterpretedOption: array expected";
                        for (var i = 0; i < message.uninterpretedOption.length; ++i) {
                            var error = $root.google.protobuf.UninterpretedOption.verify(message.uninterpretedOption[i]);
                            if (error)
                                return "uninterpretedOption." + error;
                        }
                    }
                    return null;
                };
    
                /**
                 * Creates an EnumOptions message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof google.protobuf.EnumOptions
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {google.protobuf.EnumOptions} EnumOptions
                 */
                EnumOptions.fromObject = function fromObject(object) {
                    if (object instanceof $root.google.protobuf.EnumOptions)
                        return object;
                    var message = new $root.google.protobuf.EnumOptions();
                    if (object.allowAlias != null)
                        message.allowAlias = Boolean(object.allowAlias);
                    if (object.deprecated != null)
                        message.deprecated = Boolean(object.deprecated);
                    if (object.uninterpretedOption) {
                        if (!Array.isArray(object.uninterpretedOption))
                            throw TypeError(".google.protobuf.EnumOptions.uninterpretedOption: array expected");
                        message.uninterpretedOption = [];
                        for (var i = 0; i < object.uninterpretedOption.length; ++i) {
                            if (typeof object.uninterpretedOption[i] !== "object")
                                throw TypeError(".google.protobuf.EnumOptions.uninterpretedOption: object expected");
                            message.uninterpretedOption[i] = $root.google.protobuf.UninterpretedOption.fromObject(object.uninterpretedOption[i]);
                        }
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from an EnumOptions message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof google.protobuf.EnumOptions
                 * @static
                 * @param {google.protobuf.EnumOptions} message EnumOptions
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                EnumOptions.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.uninterpretedOption = [];
                    if (options.defaults) {
                        object.allowAlias = false;
                        object.deprecated = false;
                    }
                    if (message.allowAlias != null && message.hasOwnProperty("allowAlias"))
                        object.allowAlias = message.allowAlias;
                    if (message.deprecated != null && message.hasOwnProperty("deprecated"))
                        object.deprecated = message.deprecated;
                    if (message.uninterpretedOption && message.uninterpretedOption.length) {
                        object.uninterpretedOption = [];
                        for (var j = 0; j < message.uninterpretedOption.length; ++j)
                            object.uninterpretedOption[j] = $root.google.protobuf.UninterpretedOption.toObject(message.uninterpretedOption[j], options);
                    }
                    return object;
                };
    
                /**
                 * Converts this EnumOptions to JSON.
                 * @function toJSON
                 * @memberof google.protobuf.EnumOptions
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                EnumOptions.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                /**
                 * Gets the default type url for EnumOptions
                 * @function getTypeUrl
                 * @memberof google.protobuf.EnumOptions
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                EnumOptions.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/google.protobuf.EnumOptions";
                };
    
                return EnumOptions;
            })();
    
            protobuf.EnumValueOptions = (function() {
    
                /**
                 * Properties of an EnumValueOptions.
                 * @memberof google.protobuf
                 * @interface IEnumValueOptions
                 * @property {boolean|null} [deprecated] EnumValueOptions deprecated
                 * @property {Array.<google.protobuf.IUninterpretedOption>|null} [uninterpretedOption] EnumValueOptions uninterpretedOption
                 * @property {string|null} [".networkConnectionToken"] EnumValueOptions .networkConnectionToken
                 */
    
                /**
                 * Constructs a new EnumValueOptions.
                 * @memberof google.protobuf
                 * @classdesc Represents an EnumValueOptions.
                 * @implements IEnumValueOptions
                 * @constructor
                 * @param {google.protobuf.IEnumValueOptions=} [properties] Properties to set
                 */
                function EnumValueOptions(properties) {
                    this.uninterpretedOption = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * EnumValueOptions deprecated.
                 * @member {boolean} deprecated
                 * @memberof google.protobuf.EnumValueOptions
                 * @instance
                 */
                EnumValueOptions.prototype.deprecated = false;
    
                /**
                 * EnumValueOptions uninterpretedOption.
                 * @member {Array.<google.protobuf.IUninterpretedOption>} uninterpretedOption
                 * @memberof google.protobuf.EnumValueOptions
                 * @instance
                 */
                EnumValueOptions.prototype.uninterpretedOption = $util.emptyArray;
    
                /**
                 * EnumValueOptions .networkConnectionToken.
                 * @member {string} .networkConnectionToken
                 * @memberof google.protobuf.EnumValueOptions
                 * @instance
                 */
                EnumValueOptions.prototype[".networkConnectionToken"] = "";
    
                /**
                 * Creates a new EnumValueOptions instance using the specified properties.
                 * @function create
                 * @memberof google.protobuf.EnumValueOptions
                 * @static
                 * @param {google.protobuf.IEnumValueOptions=} [properties] Properties to set
                 * @returns {google.protobuf.EnumValueOptions} EnumValueOptions instance
                 */
                EnumValueOptions.create = function create(properties) {
                    return new EnumValueOptions(properties);
                };
    
                /**
                 * Encodes the specified EnumValueOptions message. Does not implicitly {@link google.protobuf.EnumValueOptions.verify|verify} messages.
                 * @function encode
                 * @memberof google.protobuf.EnumValueOptions
                 * @static
                 * @param {google.protobuf.IEnumValueOptions} message EnumValueOptions message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                EnumValueOptions.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.deprecated != null && Object.hasOwnProperty.call(message, "deprecated"))
                        writer.uint32(/* id 1, wireType 0 =*/8).bool(message.deprecated);
                    if (message.uninterpretedOption != null && message.uninterpretedOption.length)
                        for (var i = 0; i < message.uninterpretedOption.length; ++i)
                            $root.google.protobuf.UninterpretedOption.encode(message.uninterpretedOption[i], writer.uint32(/* id 999, wireType 2 =*/7994).fork()).ldelim();
                    if (message[".networkConnectionToken"] != null && Object.hasOwnProperty.call(message, ".networkConnectionToken"))
                        writer.uint32(/* id 50500, wireType 2 =*/404002).string(message[".networkConnectionToken"]);
                    return writer;
                };
    
                /**
                 * Encodes the specified EnumValueOptions message, length delimited. Does not implicitly {@link google.protobuf.EnumValueOptions.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof google.protobuf.EnumValueOptions
                 * @static
                 * @param {google.protobuf.IEnumValueOptions} message EnumValueOptions message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                EnumValueOptions.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes an EnumValueOptions message from the specified reader or buffer.
                 * @function decode
                 * @memberof google.protobuf.EnumValueOptions
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {google.protobuf.EnumValueOptions} EnumValueOptions
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                EnumValueOptions.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.EnumValueOptions();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1: {
                                message.deprecated = reader.bool();
                                break;
                            }
                        case 999: {
                                if (!(message.uninterpretedOption && message.uninterpretedOption.length))
                                    message.uninterpretedOption = [];
                                message.uninterpretedOption.push($root.google.protobuf.UninterpretedOption.decode(reader, reader.uint32()));
                                break;
                            }
                        case 50500: {
                                message[".networkConnectionToken"] = reader.string();
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes an EnumValueOptions message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof google.protobuf.EnumValueOptions
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {google.protobuf.EnumValueOptions} EnumValueOptions
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                EnumValueOptions.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies an EnumValueOptions message.
                 * @function verify
                 * @memberof google.protobuf.EnumValueOptions
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                EnumValueOptions.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.deprecated != null && message.hasOwnProperty("deprecated"))
                        if (typeof message.deprecated !== "boolean")
                            return "deprecated: boolean expected";
                    if (message.uninterpretedOption != null && message.hasOwnProperty("uninterpretedOption")) {
                        if (!Array.isArray(message.uninterpretedOption))
                            return "uninterpretedOption: array expected";
                        for (var i = 0; i < message.uninterpretedOption.length; ++i) {
                            var error = $root.google.protobuf.UninterpretedOption.verify(message.uninterpretedOption[i]);
                            if (error)
                                return "uninterpretedOption." + error;
                        }
                    }
                    if (message[".networkConnectionToken"] != null && message.hasOwnProperty(".networkConnectionToken"))
                        if (!$util.isString(message[".networkConnectionToken"]))
                            return ".networkConnectionToken: string expected";
                    return null;
                };
    
                /**
                 * Creates an EnumValueOptions message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof google.protobuf.EnumValueOptions
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {google.protobuf.EnumValueOptions} EnumValueOptions
                 */
                EnumValueOptions.fromObject = function fromObject(object) {
                    if (object instanceof $root.google.protobuf.EnumValueOptions)
                        return object;
                    var message = new $root.google.protobuf.EnumValueOptions();
                    if (object.deprecated != null)
                        message.deprecated = Boolean(object.deprecated);
                    if (object.uninterpretedOption) {
                        if (!Array.isArray(object.uninterpretedOption))
                            throw TypeError(".google.protobuf.EnumValueOptions.uninterpretedOption: array expected");
                        message.uninterpretedOption = [];
                        for (var i = 0; i < object.uninterpretedOption.length; ++i) {
                            if (typeof object.uninterpretedOption[i] !== "object")
                                throw TypeError(".google.protobuf.EnumValueOptions.uninterpretedOption: object expected");
                            message.uninterpretedOption[i] = $root.google.protobuf.UninterpretedOption.fromObject(object.uninterpretedOption[i]);
                        }
                    }
                    if (object[".networkConnectionToken"] != null)
                        message[".networkConnectionToken"] = String(object[".networkConnectionToken"]);
                    return message;
                };
    
                /**
                 * Creates a plain object from an EnumValueOptions message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof google.protobuf.EnumValueOptions
                 * @static
                 * @param {google.protobuf.EnumValueOptions} message EnumValueOptions
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                EnumValueOptions.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.uninterpretedOption = [];
                    if (options.defaults) {
                        object.deprecated = false;
                        object[".networkConnectionToken"] = "";
                    }
                    if (message.deprecated != null && message.hasOwnProperty("deprecated"))
                        object.deprecated = message.deprecated;
                    if (message.uninterpretedOption && message.uninterpretedOption.length) {
                        object.uninterpretedOption = [];
                        for (var j = 0; j < message.uninterpretedOption.length; ++j)
                            object.uninterpretedOption[j] = $root.google.protobuf.UninterpretedOption.toObject(message.uninterpretedOption[j], options);
                    }
                    if (message[".networkConnectionToken"] != null && message.hasOwnProperty(".networkConnectionToken"))
                        object[".networkConnectionToken"] = message[".networkConnectionToken"];
                    return object;
                };
    
                /**
                 * Converts this EnumValueOptions to JSON.
                 * @function toJSON
                 * @memberof google.protobuf.EnumValueOptions
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                EnumValueOptions.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                /**
                 * Gets the default type url for EnumValueOptions
                 * @function getTypeUrl
                 * @memberof google.protobuf.EnumValueOptions
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                EnumValueOptions.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/google.protobuf.EnumValueOptions";
                };
    
                return EnumValueOptions;
            })();
    
            protobuf.ServiceOptions = (function() {
    
                /**
                 * Properties of a ServiceOptions.
                 * @memberof google.protobuf
                 * @interface IServiceOptions
                 * @property {boolean|null} [deprecated] ServiceOptions deprecated
                 * @property {Array.<google.protobuf.IUninterpretedOption>|null} [uninterpretedOption] ServiceOptions uninterpretedOption
                 */
    
                /**
                 * Constructs a new ServiceOptions.
                 * @memberof google.protobuf
                 * @classdesc Represents a ServiceOptions.
                 * @implements IServiceOptions
                 * @constructor
                 * @param {google.protobuf.IServiceOptions=} [properties] Properties to set
                 */
                function ServiceOptions(properties) {
                    this.uninterpretedOption = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * ServiceOptions deprecated.
                 * @member {boolean} deprecated
                 * @memberof google.protobuf.ServiceOptions
                 * @instance
                 */
                ServiceOptions.prototype.deprecated = false;
    
                /**
                 * ServiceOptions uninterpretedOption.
                 * @member {Array.<google.protobuf.IUninterpretedOption>} uninterpretedOption
                 * @memberof google.protobuf.ServiceOptions
                 * @instance
                 */
                ServiceOptions.prototype.uninterpretedOption = $util.emptyArray;
    
                /**
                 * Creates a new ServiceOptions instance using the specified properties.
                 * @function create
                 * @memberof google.protobuf.ServiceOptions
                 * @static
                 * @param {google.protobuf.IServiceOptions=} [properties] Properties to set
                 * @returns {google.protobuf.ServiceOptions} ServiceOptions instance
                 */
                ServiceOptions.create = function create(properties) {
                    return new ServiceOptions(properties);
                };
    
                /**
                 * Encodes the specified ServiceOptions message. Does not implicitly {@link google.protobuf.ServiceOptions.verify|verify} messages.
                 * @function encode
                 * @memberof google.protobuf.ServiceOptions
                 * @static
                 * @param {google.protobuf.IServiceOptions} message ServiceOptions message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ServiceOptions.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.deprecated != null && Object.hasOwnProperty.call(message, "deprecated"))
                        writer.uint32(/* id 33, wireType 0 =*/264).bool(message.deprecated);
                    if (message.uninterpretedOption != null && message.uninterpretedOption.length)
                        for (var i = 0; i < message.uninterpretedOption.length; ++i)
                            $root.google.protobuf.UninterpretedOption.encode(message.uninterpretedOption[i], writer.uint32(/* id 999, wireType 2 =*/7994).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified ServiceOptions message, length delimited. Does not implicitly {@link google.protobuf.ServiceOptions.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof google.protobuf.ServiceOptions
                 * @static
                 * @param {google.protobuf.IServiceOptions} message ServiceOptions message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ServiceOptions.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a ServiceOptions message from the specified reader or buffer.
                 * @function decode
                 * @memberof google.protobuf.ServiceOptions
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {google.protobuf.ServiceOptions} ServiceOptions
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ServiceOptions.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.ServiceOptions();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 33: {
                                message.deprecated = reader.bool();
                                break;
                            }
                        case 999: {
                                if (!(message.uninterpretedOption && message.uninterpretedOption.length))
                                    message.uninterpretedOption = [];
                                message.uninterpretedOption.push($root.google.protobuf.UninterpretedOption.decode(reader, reader.uint32()));
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a ServiceOptions message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof google.protobuf.ServiceOptions
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {google.protobuf.ServiceOptions} ServiceOptions
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ServiceOptions.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a ServiceOptions message.
                 * @function verify
                 * @memberof google.protobuf.ServiceOptions
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                ServiceOptions.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.deprecated != null && message.hasOwnProperty("deprecated"))
                        if (typeof message.deprecated !== "boolean")
                            return "deprecated: boolean expected";
                    if (message.uninterpretedOption != null && message.hasOwnProperty("uninterpretedOption")) {
                        if (!Array.isArray(message.uninterpretedOption))
                            return "uninterpretedOption: array expected";
                        for (var i = 0; i < message.uninterpretedOption.length; ++i) {
                            var error = $root.google.protobuf.UninterpretedOption.verify(message.uninterpretedOption[i]);
                            if (error)
                                return "uninterpretedOption." + error;
                        }
                    }
                    return null;
                };
    
                /**
                 * Creates a ServiceOptions message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof google.protobuf.ServiceOptions
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {google.protobuf.ServiceOptions} ServiceOptions
                 */
                ServiceOptions.fromObject = function fromObject(object) {
                    if (object instanceof $root.google.protobuf.ServiceOptions)
                        return object;
                    var message = new $root.google.protobuf.ServiceOptions();
                    if (object.deprecated != null)
                        message.deprecated = Boolean(object.deprecated);
                    if (object.uninterpretedOption) {
                        if (!Array.isArray(object.uninterpretedOption))
                            throw TypeError(".google.protobuf.ServiceOptions.uninterpretedOption: array expected");
                        message.uninterpretedOption = [];
                        for (var i = 0; i < object.uninterpretedOption.length; ++i) {
                            if (typeof object.uninterpretedOption[i] !== "object")
                                throw TypeError(".google.protobuf.ServiceOptions.uninterpretedOption: object expected");
                            message.uninterpretedOption[i] = $root.google.protobuf.UninterpretedOption.fromObject(object.uninterpretedOption[i]);
                        }
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a ServiceOptions message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof google.protobuf.ServiceOptions
                 * @static
                 * @param {google.protobuf.ServiceOptions} message ServiceOptions
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                ServiceOptions.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.uninterpretedOption = [];
                    if (options.defaults)
                        object.deprecated = false;
                    if (message.deprecated != null && message.hasOwnProperty("deprecated"))
                        object.deprecated = message.deprecated;
                    if (message.uninterpretedOption && message.uninterpretedOption.length) {
                        object.uninterpretedOption = [];
                        for (var j = 0; j < message.uninterpretedOption.length; ++j)
                            object.uninterpretedOption[j] = $root.google.protobuf.UninterpretedOption.toObject(message.uninterpretedOption[j], options);
                    }
                    return object;
                };
    
                /**
                 * Converts this ServiceOptions to JSON.
                 * @function toJSON
                 * @memberof google.protobuf.ServiceOptions
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                ServiceOptions.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                /**
                 * Gets the default type url for ServiceOptions
                 * @function getTypeUrl
                 * @memberof google.protobuf.ServiceOptions
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                ServiceOptions.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/google.protobuf.ServiceOptions";
                };
    
                return ServiceOptions;
            })();
    
            protobuf.MethodOptions = (function() {
    
                /**
                 * Properties of a MethodOptions.
                 * @memberof google.protobuf
                 * @interface IMethodOptions
                 * @property {boolean|null} [deprecated] MethodOptions deprecated
                 * @property {Array.<google.protobuf.IUninterpretedOption>|null} [uninterpretedOption] MethodOptions uninterpretedOption
                 */
    
                /**
                 * Constructs a new MethodOptions.
                 * @memberof google.protobuf
                 * @classdesc Represents a MethodOptions.
                 * @implements IMethodOptions
                 * @constructor
                 * @param {google.protobuf.IMethodOptions=} [properties] Properties to set
                 */
                function MethodOptions(properties) {
                    this.uninterpretedOption = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * MethodOptions deprecated.
                 * @member {boolean} deprecated
                 * @memberof google.protobuf.MethodOptions
                 * @instance
                 */
                MethodOptions.prototype.deprecated = false;
    
                /**
                 * MethodOptions uninterpretedOption.
                 * @member {Array.<google.protobuf.IUninterpretedOption>} uninterpretedOption
                 * @memberof google.protobuf.MethodOptions
                 * @instance
                 */
                MethodOptions.prototype.uninterpretedOption = $util.emptyArray;
    
                /**
                 * Creates a new MethodOptions instance using the specified properties.
                 * @function create
                 * @memberof google.protobuf.MethodOptions
                 * @static
                 * @param {google.protobuf.IMethodOptions=} [properties] Properties to set
                 * @returns {google.protobuf.MethodOptions} MethodOptions instance
                 */
                MethodOptions.create = function create(properties) {
                    return new MethodOptions(properties);
                };
    
                /**
                 * Encodes the specified MethodOptions message. Does not implicitly {@link google.protobuf.MethodOptions.verify|verify} messages.
                 * @function encode
                 * @memberof google.protobuf.MethodOptions
                 * @static
                 * @param {google.protobuf.IMethodOptions} message MethodOptions message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MethodOptions.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.deprecated != null && Object.hasOwnProperty.call(message, "deprecated"))
                        writer.uint32(/* id 33, wireType 0 =*/264).bool(message.deprecated);
                    if (message.uninterpretedOption != null && message.uninterpretedOption.length)
                        for (var i = 0; i < message.uninterpretedOption.length; ++i)
                            $root.google.protobuf.UninterpretedOption.encode(message.uninterpretedOption[i], writer.uint32(/* id 999, wireType 2 =*/7994).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified MethodOptions message, length delimited. Does not implicitly {@link google.protobuf.MethodOptions.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof google.protobuf.MethodOptions
                 * @static
                 * @param {google.protobuf.IMethodOptions} message MethodOptions message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MethodOptions.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a MethodOptions message from the specified reader or buffer.
                 * @function decode
                 * @memberof google.protobuf.MethodOptions
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {google.protobuf.MethodOptions} MethodOptions
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MethodOptions.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.MethodOptions();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 33: {
                                message.deprecated = reader.bool();
                                break;
                            }
                        case 999: {
                                if (!(message.uninterpretedOption && message.uninterpretedOption.length))
                                    message.uninterpretedOption = [];
                                message.uninterpretedOption.push($root.google.protobuf.UninterpretedOption.decode(reader, reader.uint32()));
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a MethodOptions message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof google.protobuf.MethodOptions
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {google.protobuf.MethodOptions} MethodOptions
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MethodOptions.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a MethodOptions message.
                 * @function verify
                 * @memberof google.protobuf.MethodOptions
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                MethodOptions.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.deprecated != null && message.hasOwnProperty("deprecated"))
                        if (typeof message.deprecated !== "boolean")
                            return "deprecated: boolean expected";
                    if (message.uninterpretedOption != null && message.hasOwnProperty("uninterpretedOption")) {
                        if (!Array.isArray(message.uninterpretedOption))
                            return "uninterpretedOption: array expected";
                        for (var i = 0; i < message.uninterpretedOption.length; ++i) {
                            var error = $root.google.protobuf.UninterpretedOption.verify(message.uninterpretedOption[i]);
                            if (error)
                                return "uninterpretedOption." + error;
                        }
                    }
                    return null;
                };
    
                /**
                 * Creates a MethodOptions message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof google.protobuf.MethodOptions
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {google.protobuf.MethodOptions} MethodOptions
                 */
                MethodOptions.fromObject = function fromObject(object) {
                    if (object instanceof $root.google.protobuf.MethodOptions)
                        return object;
                    var message = new $root.google.protobuf.MethodOptions();
                    if (object.deprecated != null)
                        message.deprecated = Boolean(object.deprecated);
                    if (object.uninterpretedOption) {
                        if (!Array.isArray(object.uninterpretedOption))
                            throw TypeError(".google.protobuf.MethodOptions.uninterpretedOption: array expected");
                        message.uninterpretedOption = [];
                        for (var i = 0; i < object.uninterpretedOption.length; ++i) {
                            if (typeof object.uninterpretedOption[i] !== "object")
                                throw TypeError(".google.protobuf.MethodOptions.uninterpretedOption: object expected");
                            message.uninterpretedOption[i] = $root.google.protobuf.UninterpretedOption.fromObject(object.uninterpretedOption[i]);
                        }
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a MethodOptions message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof google.protobuf.MethodOptions
                 * @static
                 * @param {google.protobuf.MethodOptions} message MethodOptions
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                MethodOptions.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.uninterpretedOption = [];
                    if (options.defaults)
                        object.deprecated = false;
                    if (message.deprecated != null && message.hasOwnProperty("deprecated"))
                        object.deprecated = message.deprecated;
                    if (message.uninterpretedOption && message.uninterpretedOption.length) {
                        object.uninterpretedOption = [];
                        for (var j = 0; j < message.uninterpretedOption.length; ++j)
                            object.uninterpretedOption[j] = $root.google.protobuf.UninterpretedOption.toObject(message.uninterpretedOption[j], options);
                    }
                    return object;
                };
    
                /**
                 * Converts this MethodOptions to JSON.
                 * @function toJSON
                 * @memberof google.protobuf.MethodOptions
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                MethodOptions.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                /**
                 * Gets the default type url for MethodOptions
                 * @function getTypeUrl
                 * @memberof google.protobuf.MethodOptions
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                MethodOptions.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/google.protobuf.MethodOptions";
                };
    
                return MethodOptions;
            })();
    
            protobuf.UninterpretedOption = (function() {
    
                /**
                 * Properties of an UninterpretedOption.
                 * @memberof google.protobuf
                 * @interface IUninterpretedOption
                 * @property {Array.<google.protobuf.UninterpretedOption.INamePart>|null} [name] UninterpretedOption name
                 * @property {string|null} [identifierValue] UninterpretedOption identifierValue
                 * @property {number|Long|null} [positiveIntValue] UninterpretedOption positiveIntValue
                 * @property {number|Long|null} [negativeIntValue] UninterpretedOption negativeIntValue
                 * @property {number|null} [doubleValue] UninterpretedOption doubleValue
                 * @property {Uint8Array|null} [stringValue] UninterpretedOption stringValue
                 * @property {string|null} [aggregateValue] UninterpretedOption aggregateValue
                 */
    
                /**
                 * Constructs a new UninterpretedOption.
                 * @memberof google.protobuf
                 * @classdesc Represents an UninterpretedOption.
                 * @implements IUninterpretedOption
                 * @constructor
                 * @param {google.protobuf.IUninterpretedOption=} [properties] Properties to set
                 */
                function UninterpretedOption(properties) {
                    this.name = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * UninterpretedOption name.
                 * @member {Array.<google.protobuf.UninterpretedOption.INamePart>} name
                 * @memberof google.protobuf.UninterpretedOption
                 * @instance
                 */
                UninterpretedOption.prototype.name = $util.emptyArray;
    
                /**
                 * UninterpretedOption identifierValue.
                 * @member {string} identifierValue
                 * @memberof google.protobuf.UninterpretedOption
                 * @instance
                 */
                UninterpretedOption.prototype.identifierValue = "";
    
                /**
                 * UninterpretedOption positiveIntValue.
                 * @member {number|Long} positiveIntValue
                 * @memberof google.protobuf.UninterpretedOption
                 * @instance
                 */
                UninterpretedOption.prototype.positiveIntValue = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
                /**
                 * UninterpretedOption negativeIntValue.
                 * @member {number|Long} negativeIntValue
                 * @memberof google.protobuf.UninterpretedOption
                 * @instance
                 */
                UninterpretedOption.prototype.negativeIntValue = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
                /**
                 * UninterpretedOption doubleValue.
                 * @member {number} doubleValue
                 * @memberof google.protobuf.UninterpretedOption
                 * @instance
                 */
                UninterpretedOption.prototype.doubleValue = 0;
    
                /**
                 * UninterpretedOption stringValue.
                 * @member {Uint8Array} stringValue
                 * @memberof google.protobuf.UninterpretedOption
                 * @instance
                 */
                UninterpretedOption.prototype.stringValue = $util.newBuffer([]);
    
                /**
                 * UninterpretedOption aggregateValue.
                 * @member {string} aggregateValue
                 * @memberof google.protobuf.UninterpretedOption
                 * @instance
                 */
                UninterpretedOption.prototype.aggregateValue = "";
    
                /**
                 * Creates a new UninterpretedOption instance using the specified properties.
                 * @function create
                 * @memberof google.protobuf.UninterpretedOption
                 * @static
                 * @param {google.protobuf.IUninterpretedOption=} [properties] Properties to set
                 * @returns {google.protobuf.UninterpretedOption} UninterpretedOption instance
                 */
                UninterpretedOption.create = function create(properties) {
                    return new UninterpretedOption(properties);
                };
    
                /**
                 * Encodes the specified UninterpretedOption message. Does not implicitly {@link google.protobuf.UninterpretedOption.verify|verify} messages.
                 * @function encode
                 * @memberof google.protobuf.UninterpretedOption
                 * @static
                 * @param {google.protobuf.IUninterpretedOption} message UninterpretedOption message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                UninterpretedOption.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.name != null && message.name.length)
                        for (var i = 0; i < message.name.length; ++i)
                            $root.google.protobuf.UninterpretedOption.NamePart.encode(message.name[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    if (message.identifierValue != null && Object.hasOwnProperty.call(message, "identifierValue"))
                        writer.uint32(/* id 3, wireType 2 =*/26).string(message.identifierValue);
                    if (message.positiveIntValue != null && Object.hasOwnProperty.call(message, "positiveIntValue"))
                        writer.uint32(/* id 4, wireType 0 =*/32).uint64(message.positiveIntValue);
                    if (message.negativeIntValue != null && Object.hasOwnProperty.call(message, "negativeIntValue"))
                        writer.uint32(/* id 5, wireType 0 =*/40).int64(message.negativeIntValue);
                    if (message.doubleValue != null && Object.hasOwnProperty.call(message, "doubleValue"))
                        writer.uint32(/* id 6, wireType 1 =*/49).double(message.doubleValue);
                    if (message.stringValue != null && Object.hasOwnProperty.call(message, "stringValue"))
                        writer.uint32(/* id 7, wireType 2 =*/58).bytes(message.stringValue);
                    if (message.aggregateValue != null && Object.hasOwnProperty.call(message, "aggregateValue"))
                        writer.uint32(/* id 8, wireType 2 =*/66).string(message.aggregateValue);
                    return writer;
                };
    
                /**
                 * Encodes the specified UninterpretedOption message, length delimited. Does not implicitly {@link google.protobuf.UninterpretedOption.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof google.protobuf.UninterpretedOption
                 * @static
                 * @param {google.protobuf.IUninterpretedOption} message UninterpretedOption message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                UninterpretedOption.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes an UninterpretedOption message from the specified reader or buffer.
                 * @function decode
                 * @memberof google.protobuf.UninterpretedOption
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {google.protobuf.UninterpretedOption} UninterpretedOption
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                UninterpretedOption.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.UninterpretedOption();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 2: {
                                if (!(message.name && message.name.length))
                                    message.name = [];
                                message.name.push($root.google.protobuf.UninterpretedOption.NamePart.decode(reader, reader.uint32()));
                                break;
                            }
                        case 3: {
                                message.identifierValue = reader.string();
                                break;
                            }
                        case 4: {
                                message.positiveIntValue = reader.uint64();
                                break;
                            }
                        case 5: {
                                message.negativeIntValue = reader.int64();
                                break;
                            }
                        case 6: {
                                message.doubleValue = reader.double();
                                break;
                            }
                        case 7: {
                                message.stringValue = reader.bytes();
                                break;
                            }
                        case 8: {
                                message.aggregateValue = reader.string();
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes an UninterpretedOption message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof google.protobuf.UninterpretedOption
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {google.protobuf.UninterpretedOption} UninterpretedOption
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                UninterpretedOption.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies an UninterpretedOption message.
                 * @function verify
                 * @memberof google.protobuf.UninterpretedOption
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                UninterpretedOption.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.name != null && message.hasOwnProperty("name")) {
                        if (!Array.isArray(message.name))
                            return "name: array expected";
                        for (var i = 0; i < message.name.length; ++i) {
                            var error = $root.google.protobuf.UninterpretedOption.NamePart.verify(message.name[i]);
                            if (error)
                                return "name." + error;
                        }
                    }
                    if (message.identifierValue != null && message.hasOwnProperty("identifierValue"))
                        if (!$util.isString(message.identifierValue))
                            return "identifierValue: string expected";
                    if (message.positiveIntValue != null && message.hasOwnProperty("positiveIntValue"))
                        if (!$util.isInteger(message.positiveIntValue) && !(message.positiveIntValue && $util.isInteger(message.positiveIntValue.low) && $util.isInteger(message.positiveIntValue.high)))
                            return "positiveIntValue: integer|Long expected";
                    if (message.negativeIntValue != null && message.hasOwnProperty("negativeIntValue"))
                        if (!$util.isInteger(message.negativeIntValue) && !(message.negativeIntValue && $util.isInteger(message.negativeIntValue.low) && $util.isInteger(message.negativeIntValue.high)))
                            return "negativeIntValue: integer|Long expected";
                    if (message.doubleValue != null && message.hasOwnProperty("doubleValue"))
                        if (typeof message.doubleValue !== "number")
                            return "doubleValue: number expected";
                    if (message.stringValue != null && message.hasOwnProperty("stringValue"))
                        if (!(message.stringValue && typeof message.stringValue.length === "number" || $util.isString(message.stringValue)))
                            return "stringValue: buffer expected";
                    if (message.aggregateValue != null && message.hasOwnProperty("aggregateValue"))
                        if (!$util.isString(message.aggregateValue))
                            return "aggregateValue: string expected";
                    return null;
                };
    
                /**
                 * Creates an UninterpretedOption message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof google.protobuf.UninterpretedOption
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {google.protobuf.UninterpretedOption} UninterpretedOption
                 */
                UninterpretedOption.fromObject = function fromObject(object) {
                    if (object instanceof $root.google.protobuf.UninterpretedOption)
                        return object;
                    var message = new $root.google.protobuf.UninterpretedOption();
                    if (object.name) {
                        if (!Array.isArray(object.name))
                            throw TypeError(".google.protobuf.UninterpretedOption.name: array expected");
                        message.name = [];
                        for (var i = 0; i < object.name.length; ++i) {
                            if (typeof object.name[i] !== "object")
                                throw TypeError(".google.protobuf.UninterpretedOption.name: object expected");
                            message.name[i] = $root.google.protobuf.UninterpretedOption.NamePart.fromObject(object.name[i]);
                        }
                    }
                    if (object.identifierValue != null)
                        message.identifierValue = String(object.identifierValue);
                    if (object.positiveIntValue != null)
                        if ($util.Long)
                            (message.positiveIntValue = $util.Long.fromValue(object.positiveIntValue)).unsigned = true;
                        else if (typeof object.positiveIntValue === "string")
                            message.positiveIntValue = parseInt(object.positiveIntValue, 10);
                        else if (typeof object.positiveIntValue === "number")
                            message.positiveIntValue = object.positiveIntValue;
                        else if (typeof object.positiveIntValue === "object")
                            message.positiveIntValue = new $util.LongBits(object.positiveIntValue.low >>> 0, object.positiveIntValue.high >>> 0).toNumber(true);
                    if (object.negativeIntValue != null)
                        if ($util.Long)
                            (message.negativeIntValue = $util.Long.fromValue(object.negativeIntValue)).unsigned = false;
                        else if (typeof object.negativeIntValue === "string")
                            message.negativeIntValue = parseInt(object.negativeIntValue, 10);
                        else if (typeof object.negativeIntValue === "number")
                            message.negativeIntValue = object.negativeIntValue;
                        else if (typeof object.negativeIntValue === "object")
                            message.negativeIntValue = new $util.LongBits(object.negativeIntValue.low >>> 0, object.negativeIntValue.high >>> 0).toNumber();
                    if (object.doubleValue != null)
                        message.doubleValue = Number(object.doubleValue);
                    if (object.stringValue != null)
                        if (typeof object.stringValue === "string")
                            $util.base64.decode(object.stringValue, message.stringValue = $util.newBuffer($util.base64.length(object.stringValue)), 0);
                        else if (object.stringValue.length >= 0)
                            message.stringValue = object.stringValue;
                    if (object.aggregateValue != null)
                        message.aggregateValue = String(object.aggregateValue);
                    return message;
                };
    
                /**
                 * Creates a plain object from an UninterpretedOption message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof google.protobuf.UninterpretedOption
                 * @static
                 * @param {google.protobuf.UninterpretedOption} message UninterpretedOption
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                UninterpretedOption.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.name = [];
                    if (options.defaults) {
                        object.identifierValue = "";
                        if ($util.Long) {
                            var long = new $util.Long(0, 0, true);
                            object.positiveIntValue = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.positiveIntValue = options.longs === String ? "0" : 0;
                        if ($util.Long) {
                            var long = new $util.Long(0, 0, false);
                            object.negativeIntValue = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.negativeIntValue = options.longs === String ? "0" : 0;
                        object.doubleValue = 0;
                        if (options.bytes === String)
                            object.stringValue = "";
                        else {
                            object.stringValue = [];
                            if (options.bytes !== Array)
                                object.stringValue = $util.newBuffer(object.stringValue);
                        }
                        object.aggregateValue = "";
                    }
                    if (message.name && message.name.length) {
                        object.name = [];
                        for (var j = 0; j < message.name.length; ++j)
                            object.name[j] = $root.google.protobuf.UninterpretedOption.NamePart.toObject(message.name[j], options);
                    }
                    if (message.identifierValue != null && message.hasOwnProperty("identifierValue"))
                        object.identifierValue = message.identifierValue;
                    if (message.positiveIntValue != null && message.hasOwnProperty("positiveIntValue"))
                        if (typeof message.positiveIntValue === "number")
                            object.positiveIntValue = options.longs === String ? String(message.positiveIntValue) : message.positiveIntValue;
                        else
                            object.positiveIntValue = options.longs === String ? $util.Long.prototype.toString.call(message.positiveIntValue) : options.longs === Number ? new $util.LongBits(message.positiveIntValue.low >>> 0, message.positiveIntValue.high >>> 0).toNumber(true) : message.positiveIntValue;
                    if (message.negativeIntValue != null && message.hasOwnProperty("negativeIntValue"))
                        if (typeof message.negativeIntValue === "number")
                            object.negativeIntValue = options.longs === String ? String(message.negativeIntValue) : message.negativeIntValue;
                        else
                            object.negativeIntValue = options.longs === String ? $util.Long.prototype.toString.call(message.negativeIntValue) : options.longs === Number ? new $util.LongBits(message.negativeIntValue.low >>> 0, message.negativeIntValue.high >>> 0).toNumber() : message.negativeIntValue;
                    if (message.doubleValue != null && message.hasOwnProperty("doubleValue"))
                        object.doubleValue = options.json && !isFinite(message.doubleValue) ? String(message.doubleValue) : message.doubleValue;
                    if (message.stringValue != null && message.hasOwnProperty("stringValue"))
                        object.stringValue = options.bytes === String ? $util.base64.encode(message.stringValue, 0, message.stringValue.length) : options.bytes === Array ? Array.prototype.slice.call(message.stringValue) : message.stringValue;
                    if (message.aggregateValue != null && message.hasOwnProperty("aggregateValue"))
                        object.aggregateValue = message.aggregateValue;
                    return object;
                };
    
                /**
                 * Converts this UninterpretedOption to JSON.
                 * @function toJSON
                 * @memberof google.protobuf.UninterpretedOption
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                UninterpretedOption.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                /**
                 * Gets the default type url for UninterpretedOption
                 * @function getTypeUrl
                 * @memberof google.protobuf.UninterpretedOption
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                UninterpretedOption.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/google.protobuf.UninterpretedOption";
                };
    
                UninterpretedOption.NamePart = (function() {
    
                    /**
                     * Properties of a NamePart.
                     * @memberof google.protobuf.UninterpretedOption
                     * @interface INamePart
                     * @property {string} namePart NamePart namePart
                     * @property {boolean} isExtension NamePart isExtension
                     */
    
                    /**
                     * Constructs a new NamePart.
                     * @memberof google.protobuf.UninterpretedOption
                     * @classdesc Represents a NamePart.
                     * @implements INamePart
                     * @constructor
                     * @param {google.protobuf.UninterpretedOption.INamePart=} [properties] Properties to set
                     */
                    function NamePart(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * NamePart namePart.
                     * @member {string} namePart
                     * @memberof google.protobuf.UninterpretedOption.NamePart
                     * @instance
                     */
                    NamePart.prototype.namePart = "";
    
                    /**
                     * NamePart isExtension.
                     * @member {boolean} isExtension
                     * @memberof google.protobuf.UninterpretedOption.NamePart
                     * @instance
                     */
                    NamePart.prototype.isExtension = false;
    
                    /**
                     * Creates a new NamePart instance using the specified properties.
                     * @function create
                     * @memberof google.protobuf.UninterpretedOption.NamePart
                     * @static
                     * @param {google.protobuf.UninterpretedOption.INamePart=} [properties] Properties to set
                     * @returns {google.protobuf.UninterpretedOption.NamePart} NamePart instance
                     */
                    NamePart.create = function create(properties) {
                        return new NamePart(properties);
                    };
    
                    /**
                     * Encodes the specified NamePart message. Does not implicitly {@link google.protobuf.UninterpretedOption.NamePart.verify|verify} messages.
                     * @function encode
                     * @memberof google.protobuf.UninterpretedOption.NamePart
                     * @static
                     * @param {google.protobuf.UninterpretedOption.INamePart} message NamePart message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    NamePart.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.namePart);
                        writer.uint32(/* id 2, wireType 0 =*/16).bool(message.isExtension);
                        return writer;
                    };
    
                    /**
                     * Encodes the specified NamePart message, length delimited. Does not implicitly {@link google.protobuf.UninterpretedOption.NamePart.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof google.protobuf.UninterpretedOption.NamePart
                     * @static
                     * @param {google.protobuf.UninterpretedOption.INamePart} message NamePart message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    NamePart.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };
    
                    /**
                     * Decodes a NamePart message from the specified reader or buffer.
                     * @function decode
                     * @memberof google.protobuf.UninterpretedOption.NamePart
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {google.protobuf.UninterpretedOption.NamePart} NamePart
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    NamePart.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.UninterpretedOption.NamePart();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1: {
                                    message.namePart = reader.string();
                                    break;
                                }
                            case 2: {
                                    message.isExtension = reader.bool();
                                    break;
                                }
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        if (!message.hasOwnProperty("namePart"))
                            throw $util.ProtocolError("missing required 'namePart'", { instance: message });
                        if (!message.hasOwnProperty("isExtension"))
                            throw $util.ProtocolError("missing required 'isExtension'", { instance: message });
                        return message;
                    };
    
                    /**
                     * Decodes a NamePart message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof google.protobuf.UninterpretedOption.NamePart
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {google.protobuf.UninterpretedOption.NamePart} NamePart
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    NamePart.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };
    
                    /**
                     * Verifies a NamePart message.
                     * @function verify
                     * @memberof google.protobuf.UninterpretedOption.NamePart
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    NamePart.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (!$util.isString(message.namePart))
                            return "namePart: string expected";
                        if (typeof message.isExtension !== "boolean")
                            return "isExtension: boolean expected";
                        return null;
                    };
    
                    /**
                     * Creates a NamePart message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof google.protobuf.UninterpretedOption.NamePart
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {google.protobuf.UninterpretedOption.NamePart} NamePart
                     */
                    NamePart.fromObject = function fromObject(object) {
                        if (object instanceof $root.google.protobuf.UninterpretedOption.NamePart)
                            return object;
                        var message = new $root.google.protobuf.UninterpretedOption.NamePart();
                        if (object.namePart != null)
                            message.namePart = String(object.namePart);
                        if (object.isExtension != null)
                            message.isExtension = Boolean(object.isExtension);
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a NamePart message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof google.protobuf.UninterpretedOption.NamePart
                     * @static
                     * @param {google.protobuf.UninterpretedOption.NamePart} message NamePart
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    NamePart.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            object.namePart = "";
                            object.isExtension = false;
                        }
                        if (message.namePart != null && message.hasOwnProperty("namePart"))
                            object.namePart = message.namePart;
                        if (message.isExtension != null && message.hasOwnProperty("isExtension"))
                            object.isExtension = message.isExtension;
                        return object;
                    };
    
                    /**
                     * Converts this NamePart to JSON.
                     * @function toJSON
                     * @memberof google.protobuf.UninterpretedOption.NamePart
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    NamePart.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    /**
                     * Gets the default type url for NamePart
                     * @function getTypeUrl
                     * @memberof google.protobuf.UninterpretedOption.NamePart
                     * @static
                     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                     * @returns {string} The default type url
                     */
                    NamePart.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                        if (typeUrlPrefix === undefined) {
                            typeUrlPrefix = "type.googleapis.com";
                        }
                        return typeUrlPrefix + "/google.protobuf.UninterpretedOption.NamePart";
                    };
    
                    return NamePart;
                })();
    
                return UninterpretedOption;
            })();
    
            protobuf.SourceCodeInfo = (function() {
    
                /**
                 * Properties of a SourceCodeInfo.
                 * @memberof google.protobuf
                 * @interface ISourceCodeInfo
                 * @property {Array.<google.protobuf.SourceCodeInfo.ILocation>|null} [location] SourceCodeInfo location
                 */
    
                /**
                 * Constructs a new SourceCodeInfo.
                 * @memberof google.protobuf
                 * @classdesc Represents a SourceCodeInfo.
                 * @implements ISourceCodeInfo
                 * @constructor
                 * @param {google.protobuf.ISourceCodeInfo=} [properties] Properties to set
                 */
                function SourceCodeInfo(properties) {
                    this.location = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * SourceCodeInfo location.
                 * @member {Array.<google.protobuf.SourceCodeInfo.ILocation>} location
                 * @memberof google.protobuf.SourceCodeInfo
                 * @instance
                 */
                SourceCodeInfo.prototype.location = $util.emptyArray;
    
                /**
                 * Creates a new SourceCodeInfo instance using the specified properties.
                 * @function create
                 * @memberof google.protobuf.SourceCodeInfo
                 * @static
                 * @param {google.protobuf.ISourceCodeInfo=} [properties] Properties to set
                 * @returns {google.protobuf.SourceCodeInfo} SourceCodeInfo instance
                 */
                SourceCodeInfo.create = function create(properties) {
                    return new SourceCodeInfo(properties);
                };
    
                /**
                 * Encodes the specified SourceCodeInfo message. Does not implicitly {@link google.protobuf.SourceCodeInfo.verify|verify} messages.
                 * @function encode
                 * @memberof google.protobuf.SourceCodeInfo
                 * @static
                 * @param {google.protobuf.ISourceCodeInfo} message SourceCodeInfo message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                SourceCodeInfo.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.location != null && message.location.length)
                        for (var i = 0; i < message.location.length; ++i)
                            $root.google.protobuf.SourceCodeInfo.Location.encode(message.location[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified SourceCodeInfo message, length delimited. Does not implicitly {@link google.protobuf.SourceCodeInfo.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof google.protobuf.SourceCodeInfo
                 * @static
                 * @param {google.protobuf.ISourceCodeInfo} message SourceCodeInfo message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                SourceCodeInfo.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a SourceCodeInfo message from the specified reader or buffer.
                 * @function decode
                 * @memberof google.protobuf.SourceCodeInfo
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {google.protobuf.SourceCodeInfo} SourceCodeInfo
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                SourceCodeInfo.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.SourceCodeInfo();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1: {
                                if (!(message.location && message.location.length))
                                    message.location = [];
                                message.location.push($root.google.protobuf.SourceCodeInfo.Location.decode(reader, reader.uint32()));
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a SourceCodeInfo message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof google.protobuf.SourceCodeInfo
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {google.protobuf.SourceCodeInfo} SourceCodeInfo
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                SourceCodeInfo.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a SourceCodeInfo message.
                 * @function verify
                 * @memberof google.protobuf.SourceCodeInfo
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                SourceCodeInfo.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.location != null && message.hasOwnProperty("location")) {
                        if (!Array.isArray(message.location))
                            return "location: array expected";
                        for (var i = 0; i < message.location.length; ++i) {
                            var error = $root.google.protobuf.SourceCodeInfo.Location.verify(message.location[i]);
                            if (error)
                                return "location." + error;
                        }
                    }
                    return null;
                };
    
                /**
                 * Creates a SourceCodeInfo message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof google.protobuf.SourceCodeInfo
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {google.protobuf.SourceCodeInfo} SourceCodeInfo
                 */
                SourceCodeInfo.fromObject = function fromObject(object) {
                    if (object instanceof $root.google.protobuf.SourceCodeInfo)
                        return object;
                    var message = new $root.google.protobuf.SourceCodeInfo();
                    if (object.location) {
                        if (!Array.isArray(object.location))
                            throw TypeError(".google.protobuf.SourceCodeInfo.location: array expected");
                        message.location = [];
                        for (var i = 0; i < object.location.length; ++i) {
                            if (typeof object.location[i] !== "object")
                                throw TypeError(".google.protobuf.SourceCodeInfo.location: object expected");
                            message.location[i] = $root.google.protobuf.SourceCodeInfo.Location.fromObject(object.location[i]);
                        }
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a SourceCodeInfo message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof google.protobuf.SourceCodeInfo
                 * @static
                 * @param {google.protobuf.SourceCodeInfo} message SourceCodeInfo
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                SourceCodeInfo.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.location = [];
                    if (message.location && message.location.length) {
                        object.location = [];
                        for (var j = 0; j < message.location.length; ++j)
                            object.location[j] = $root.google.protobuf.SourceCodeInfo.Location.toObject(message.location[j], options);
                    }
                    return object;
                };
    
                /**
                 * Converts this SourceCodeInfo to JSON.
                 * @function toJSON
                 * @memberof google.protobuf.SourceCodeInfo
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                SourceCodeInfo.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                /**
                 * Gets the default type url for SourceCodeInfo
                 * @function getTypeUrl
                 * @memberof google.protobuf.SourceCodeInfo
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                SourceCodeInfo.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/google.protobuf.SourceCodeInfo";
                };
    
                SourceCodeInfo.Location = (function() {
    
                    /**
                     * Properties of a Location.
                     * @memberof google.protobuf.SourceCodeInfo
                     * @interface ILocation
                     * @property {Array.<number>|null} [path] Location path
                     * @property {Array.<number>|null} [span] Location span
                     * @property {string|null} [leadingComments] Location leadingComments
                     * @property {string|null} [trailingComments] Location trailingComments
                     * @property {Array.<string>|null} [leadingDetachedComments] Location leadingDetachedComments
                     */
    
                    /**
                     * Constructs a new Location.
                     * @memberof google.protobuf.SourceCodeInfo
                     * @classdesc Represents a Location.
                     * @implements ILocation
                     * @constructor
                     * @param {google.protobuf.SourceCodeInfo.ILocation=} [properties] Properties to set
                     */
                    function Location(properties) {
                        this.path = [];
                        this.span = [];
                        this.leadingDetachedComments = [];
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * Location path.
                     * @member {Array.<number>} path
                     * @memberof google.protobuf.SourceCodeInfo.Location
                     * @instance
                     */
                    Location.prototype.path = $util.emptyArray;
    
                    /**
                     * Location span.
                     * @member {Array.<number>} span
                     * @memberof google.protobuf.SourceCodeInfo.Location
                     * @instance
                     */
                    Location.prototype.span = $util.emptyArray;
    
                    /**
                     * Location leadingComments.
                     * @member {string} leadingComments
                     * @memberof google.protobuf.SourceCodeInfo.Location
                     * @instance
                     */
                    Location.prototype.leadingComments = "";
    
                    /**
                     * Location trailingComments.
                     * @member {string} trailingComments
                     * @memberof google.protobuf.SourceCodeInfo.Location
                     * @instance
                     */
                    Location.prototype.trailingComments = "";
    
                    /**
                     * Location leadingDetachedComments.
                     * @member {Array.<string>} leadingDetachedComments
                     * @memberof google.protobuf.SourceCodeInfo.Location
                     * @instance
                     */
                    Location.prototype.leadingDetachedComments = $util.emptyArray;
    
                    /**
                     * Creates a new Location instance using the specified properties.
                     * @function create
                     * @memberof google.protobuf.SourceCodeInfo.Location
                     * @static
                     * @param {google.protobuf.SourceCodeInfo.ILocation=} [properties] Properties to set
                     * @returns {google.protobuf.SourceCodeInfo.Location} Location instance
                     */
                    Location.create = function create(properties) {
                        return new Location(properties);
                    };
    
                    /**
                     * Encodes the specified Location message. Does not implicitly {@link google.protobuf.SourceCodeInfo.Location.verify|verify} messages.
                     * @function encode
                     * @memberof google.protobuf.SourceCodeInfo.Location
                     * @static
                     * @param {google.protobuf.SourceCodeInfo.ILocation} message Location message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Location.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.path != null && message.path.length) {
                            writer.uint32(/* id 1, wireType 2 =*/10).fork();
                            for (var i = 0; i < message.path.length; ++i)
                                writer.int32(message.path[i]);
                            writer.ldelim();
                        }
                        if (message.span != null && message.span.length) {
                            writer.uint32(/* id 2, wireType 2 =*/18).fork();
                            for (var i = 0; i < message.span.length; ++i)
                                writer.int32(message.span[i]);
                            writer.ldelim();
                        }
                        if (message.leadingComments != null && Object.hasOwnProperty.call(message, "leadingComments"))
                            writer.uint32(/* id 3, wireType 2 =*/26).string(message.leadingComments);
                        if (message.trailingComments != null && Object.hasOwnProperty.call(message, "trailingComments"))
                            writer.uint32(/* id 4, wireType 2 =*/34).string(message.trailingComments);
                        if (message.leadingDetachedComments != null && message.leadingDetachedComments.length)
                            for (var i = 0; i < message.leadingDetachedComments.length; ++i)
                                writer.uint32(/* id 6, wireType 2 =*/50).string(message.leadingDetachedComments[i]);
                        return writer;
                    };
    
                    /**
                     * Encodes the specified Location message, length delimited. Does not implicitly {@link google.protobuf.SourceCodeInfo.Location.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof google.protobuf.SourceCodeInfo.Location
                     * @static
                     * @param {google.protobuf.SourceCodeInfo.ILocation} message Location message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Location.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };
    
                    /**
                     * Decodes a Location message from the specified reader or buffer.
                     * @function decode
                     * @memberof google.protobuf.SourceCodeInfo.Location
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {google.protobuf.SourceCodeInfo.Location} Location
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Location.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.SourceCodeInfo.Location();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1: {
                                    if (!(message.path && message.path.length))
                                        message.path = [];
                                    if ((tag & 7) === 2) {
                                        var end2 = reader.uint32() + reader.pos;
                                        while (reader.pos < end2)
                                            message.path.push(reader.int32());
                                    } else
                                        message.path.push(reader.int32());
                                    break;
                                }
                            case 2: {
                                    if (!(message.span && message.span.length))
                                        message.span = [];
                                    if ((tag & 7) === 2) {
                                        var end2 = reader.uint32() + reader.pos;
                                        while (reader.pos < end2)
                                            message.span.push(reader.int32());
                                    } else
                                        message.span.push(reader.int32());
                                    break;
                                }
                            case 3: {
                                    message.leadingComments = reader.string();
                                    break;
                                }
                            case 4: {
                                    message.trailingComments = reader.string();
                                    break;
                                }
                            case 6: {
                                    if (!(message.leadingDetachedComments && message.leadingDetachedComments.length))
                                        message.leadingDetachedComments = [];
                                    message.leadingDetachedComments.push(reader.string());
                                    break;
                                }
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Decodes a Location message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof google.protobuf.SourceCodeInfo.Location
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {google.protobuf.SourceCodeInfo.Location} Location
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Location.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };
    
                    /**
                     * Verifies a Location message.
                     * @function verify
                     * @memberof google.protobuf.SourceCodeInfo.Location
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    Location.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.path != null && message.hasOwnProperty("path")) {
                            if (!Array.isArray(message.path))
                                return "path: array expected";
                            for (var i = 0; i < message.path.length; ++i)
                                if (!$util.isInteger(message.path[i]))
                                    return "path: integer[] expected";
                        }
                        if (message.span != null && message.hasOwnProperty("span")) {
                            if (!Array.isArray(message.span))
                                return "span: array expected";
                            for (var i = 0; i < message.span.length; ++i)
                                if (!$util.isInteger(message.span[i]))
                                    return "span: integer[] expected";
                        }
                        if (message.leadingComments != null && message.hasOwnProperty("leadingComments"))
                            if (!$util.isString(message.leadingComments))
                                return "leadingComments: string expected";
                        if (message.trailingComments != null && message.hasOwnProperty("trailingComments"))
                            if (!$util.isString(message.trailingComments))
                                return "trailingComments: string expected";
                        if (message.leadingDetachedComments != null && message.hasOwnProperty("leadingDetachedComments")) {
                            if (!Array.isArray(message.leadingDetachedComments))
                                return "leadingDetachedComments: array expected";
                            for (var i = 0; i < message.leadingDetachedComments.length; ++i)
                                if (!$util.isString(message.leadingDetachedComments[i]))
                                    return "leadingDetachedComments: string[] expected";
                        }
                        return null;
                    };
    
                    /**
                     * Creates a Location message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof google.protobuf.SourceCodeInfo.Location
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {google.protobuf.SourceCodeInfo.Location} Location
                     */
                    Location.fromObject = function fromObject(object) {
                        if (object instanceof $root.google.protobuf.SourceCodeInfo.Location)
                            return object;
                        var message = new $root.google.protobuf.SourceCodeInfo.Location();
                        if (object.path) {
                            if (!Array.isArray(object.path))
                                throw TypeError(".google.protobuf.SourceCodeInfo.Location.path: array expected");
                            message.path = [];
                            for (var i = 0; i < object.path.length; ++i)
                                message.path[i] = object.path[i] | 0;
                        }
                        if (object.span) {
                            if (!Array.isArray(object.span))
                                throw TypeError(".google.protobuf.SourceCodeInfo.Location.span: array expected");
                            message.span = [];
                            for (var i = 0; i < object.span.length; ++i)
                                message.span[i] = object.span[i] | 0;
                        }
                        if (object.leadingComments != null)
                            message.leadingComments = String(object.leadingComments);
                        if (object.trailingComments != null)
                            message.trailingComments = String(object.trailingComments);
                        if (object.leadingDetachedComments) {
                            if (!Array.isArray(object.leadingDetachedComments))
                                throw TypeError(".google.protobuf.SourceCodeInfo.Location.leadingDetachedComments: array expected");
                            message.leadingDetachedComments = [];
                            for (var i = 0; i < object.leadingDetachedComments.length; ++i)
                                message.leadingDetachedComments[i] = String(object.leadingDetachedComments[i]);
                        }
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a Location message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof google.protobuf.SourceCodeInfo.Location
                     * @static
                     * @param {google.protobuf.SourceCodeInfo.Location} message Location
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    Location.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.arrays || options.defaults) {
                            object.path = [];
                            object.span = [];
                            object.leadingDetachedComments = [];
                        }
                        if (options.defaults) {
                            object.leadingComments = "";
                            object.trailingComments = "";
                        }
                        if (message.path && message.path.length) {
                            object.path = [];
                            for (var j = 0; j < message.path.length; ++j)
                                object.path[j] = message.path[j];
                        }
                        if (message.span && message.span.length) {
                            object.span = [];
                            for (var j = 0; j < message.span.length; ++j)
                                object.span[j] = message.span[j];
                        }
                        if (message.leadingComments != null && message.hasOwnProperty("leadingComments"))
                            object.leadingComments = message.leadingComments;
                        if (message.trailingComments != null && message.hasOwnProperty("trailingComments"))
                            object.trailingComments = message.trailingComments;
                        if (message.leadingDetachedComments && message.leadingDetachedComments.length) {
                            object.leadingDetachedComments = [];
                            for (var j = 0; j < message.leadingDetachedComments.length; ++j)
                                object.leadingDetachedComments[j] = message.leadingDetachedComments[j];
                        }
                        return object;
                    };
    
                    /**
                     * Converts this Location to JSON.
                     * @function toJSON
                     * @memberof google.protobuf.SourceCodeInfo.Location
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    Location.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    /**
                     * Gets the default type url for Location
                     * @function getTypeUrl
                     * @memberof google.protobuf.SourceCodeInfo.Location
                     * @static
                     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                     * @returns {string} The default type url
                     */
                    Location.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                        if (typeUrlPrefix === undefined) {
                            typeUrlPrefix = "type.googleapis.com";
                        }
                        return typeUrlPrefix + "/google.protobuf.SourceCodeInfo.Location";
                    };
    
                    return Location;
                })();
    
                return SourceCodeInfo;
            })();
    
            protobuf.GeneratedCodeInfo = (function() {
    
                /**
                 * Properties of a GeneratedCodeInfo.
                 * @memberof google.protobuf
                 * @interface IGeneratedCodeInfo
                 * @property {Array.<google.protobuf.GeneratedCodeInfo.IAnnotation>|null} [annotation] GeneratedCodeInfo annotation
                 */
    
                /**
                 * Constructs a new GeneratedCodeInfo.
                 * @memberof google.protobuf
                 * @classdesc Represents a GeneratedCodeInfo.
                 * @implements IGeneratedCodeInfo
                 * @constructor
                 * @param {google.protobuf.IGeneratedCodeInfo=} [properties] Properties to set
                 */
                function GeneratedCodeInfo(properties) {
                    this.annotation = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * GeneratedCodeInfo annotation.
                 * @member {Array.<google.protobuf.GeneratedCodeInfo.IAnnotation>} annotation
                 * @memberof google.protobuf.GeneratedCodeInfo
                 * @instance
                 */
                GeneratedCodeInfo.prototype.annotation = $util.emptyArray;
    
                /**
                 * Creates a new GeneratedCodeInfo instance using the specified properties.
                 * @function create
                 * @memberof google.protobuf.GeneratedCodeInfo
                 * @static
                 * @param {google.protobuf.IGeneratedCodeInfo=} [properties] Properties to set
                 * @returns {google.protobuf.GeneratedCodeInfo} GeneratedCodeInfo instance
                 */
                GeneratedCodeInfo.create = function create(properties) {
                    return new GeneratedCodeInfo(properties);
                };
    
                /**
                 * Encodes the specified GeneratedCodeInfo message. Does not implicitly {@link google.protobuf.GeneratedCodeInfo.verify|verify} messages.
                 * @function encode
                 * @memberof google.protobuf.GeneratedCodeInfo
                 * @static
                 * @param {google.protobuf.IGeneratedCodeInfo} message GeneratedCodeInfo message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                GeneratedCodeInfo.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.annotation != null && message.annotation.length)
                        for (var i = 0; i < message.annotation.length; ++i)
                            $root.google.protobuf.GeneratedCodeInfo.Annotation.encode(message.annotation[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified GeneratedCodeInfo message, length delimited. Does not implicitly {@link google.protobuf.GeneratedCodeInfo.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof google.protobuf.GeneratedCodeInfo
                 * @static
                 * @param {google.protobuf.IGeneratedCodeInfo} message GeneratedCodeInfo message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                GeneratedCodeInfo.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a GeneratedCodeInfo message from the specified reader or buffer.
                 * @function decode
                 * @memberof google.protobuf.GeneratedCodeInfo
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {google.protobuf.GeneratedCodeInfo} GeneratedCodeInfo
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                GeneratedCodeInfo.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.GeneratedCodeInfo();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1: {
                                if (!(message.annotation && message.annotation.length))
                                    message.annotation = [];
                                message.annotation.push($root.google.protobuf.GeneratedCodeInfo.Annotation.decode(reader, reader.uint32()));
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a GeneratedCodeInfo message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof google.protobuf.GeneratedCodeInfo
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {google.protobuf.GeneratedCodeInfo} GeneratedCodeInfo
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                GeneratedCodeInfo.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a GeneratedCodeInfo message.
                 * @function verify
                 * @memberof google.protobuf.GeneratedCodeInfo
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                GeneratedCodeInfo.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.annotation != null && message.hasOwnProperty("annotation")) {
                        if (!Array.isArray(message.annotation))
                            return "annotation: array expected";
                        for (var i = 0; i < message.annotation.length; ++i) {
                            var error = $root.google.protobuf.GeneratedCodeInfo.Annotation.verify(message.annotation[i]);
                            if (error)
                                return "annotation." + error;
                        }
                    }
                    return null;
                };
    
                /**
                 * Creates a GeneratedCodeInfo message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof google.protobuf.GeneratedCodeInfo
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {google.protobuf.GeneratedCodeInfo} GeneratedCodeInfo
                 */
                GeneratedCodeInfo.fromObject = function fromObject(object) {
                    if (object instanceof $root.google.protobuf.GeneratedCodeInfo)
                        return object;
                    var message = new $root.google.protobuf.GeneratedCodeInfo();
                    if (object.annotation) {
                        if (!Array.isArray(object.annotation))
                            throw TypeError(".google.protobuf.GeneratedCodeInfo.annotation: array expected");
                        message.annotation = [];
                        for (var i = 0; i < object.annotation.length; ++i) {
                            if (typeof object.annotation[i] !== "object")
                                throw TypeError(".google.protobuf.GeneratedCodeInfo.annotation: object expected");
                            message.annotation[i] = $root.google.protobuf.GeneratedCodeInfo.Annotation.fromObject(object.annotation[i]);
                        }
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a GeneratedCodeInfo message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof google.protobuf.GeneratedCodeInfo
                 * @static
                 * @param {google.protobuf.GeneratedCodeInfo} message GeneratedCodeInfo
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                GeneratedCodeInfo.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.annotation = [];
                    if (message.annotation && message.annotation.length) {
                        object.annotation = [];
                        for (var j = 0; j < message.annotation.length; ++j)
                            object.annotation[j] = $root.google.protobuf.GeneratedCodeInfo.Annotation.toObject(message.annotation[j], options);
                    }
                    return object;
                };
    
                /**
                 * Converts this GeneratedCodeInfo to JSON.
                 * @function toJSON
                 * @memberof google.protobuf.GeneratedCodeInfo
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                GeneratedCodeInfo.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                /**
                 * Gets the default type url for GeneratedCodeInfo
                 * @function getTypeUrl
                 * @memberof google.protobuf.GeneratedCodeInfo
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                GeneratedCodeInfo.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/google.protobuf.GeneratedCodeInfo";
                };
    
                GeneratedCodeInfo.Annotation = (function() {
    
                    /**
                     * Properties of an Annotation.
                     * @memberof google.protobuf.GeneratedCodeInfo
                     * @interface IAnnotation
                     * @property {Array.<number>|null} [path] Annotation path
                     * @property {string|null} [sourceFile] Annotation sourceFile
                     * @property {number|null} [begin] Annotation begin
                     * @property {number|null} [end] Annotation end
                     */
    
                    /**
                     * Constructs a new Annotation.
                     * @memberof google.protobuf.GeneratedCodeInfo
                     * @classdesc Represents an Annotation.
                     * @implements IAnnotation
                     * @constructor
                     * @param {google.protobuf.GeneratedCodeInfo.IAnnotation=} [properties] Properties to set
                     */
                    function Annotation(properties) {
                        this.path = [];
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * Annotation path.
                     * @member {Array.<number>} path
                     * @memberof google.protobuf.GeneratedCodeInfo.Annotation
                     * @instance
                     */
                    Annotation.prototype.path = $util.emptyArray;
    
                    /**
                     * Annotation sourceFile.
                     * @member {string} sourceFile
                     * @memberof google.protobuf.GeneratedCodeInfo.Annotation
                     * @instance
                     */
                    Annotation.prototype.sourceFile = "";
    
                    /**
                     * Annotation begin.
                     * @member {number} begin
                     * @memberof google.protobuf.GeneratedCodeInfo.Annotation
                     * @instance
                     */
                    Annotation.prototype.begin = 0;
    
                    /**
                     * Annotation end.
                     * @member {number} end
                     * @memberof google.protobuf.GeneratedCodeInfo.Annotation
                     * @instance
                     */
                    Annotation.prototype.end = 0;
    
                    /**
                     * Creates a new Annotation instance using the specified properties.
                     * @function create
                     * @memberof google.protobuf.GeneratedCodeInfo.Annotation
                     * @static
                     * @param {google.protobuf.GeneratedCodeInfo.IAnnotation=} [properties] Properties to set
                     * @returns {google.protobuf.GeneratedCodeInfo.Annotation} Annotation instance
                     */
                    Annotation.create = function create(properties) {
                        return new Annotation(properties);
                    };
    
                    /**
                     * Encodes the specified Annotation message. Does not implicitly {@link google.protobuf.GeneratedCodeInfo.Annotation.verify|verify} messages.
                     * @function encode
                     * @memberof google.protobuf.GeneratedCodeInfo.Annotation
                     * @static
                     * @param {google.protobuf.GeneratedCodeInfo.IAnnotation} message Annotation message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Annotation.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.path != null && message.path.length) {
                            writer.uint32(/* id 1, wireType 2 =*/10).fork();
                            for (var i = 0; i < message.path.length; ++i)
                                writer.int32(message.path[i]);
                            writer.ldelim();
                        }
                        if (message.sourceFile != null && Object.hasOwnProperty.call(message, "sourceFile"))
                            writer.uint32(/* id 2, wireType 2 =*/18).string(message.sourceFile);
                        if (message.begin != null && Object.hasOwnProperty.call(message, "begin"))
                            writer.uint32(/* id 3, wireType 0 =*/24).int32(message.begin);
                        if (message.end != null && Object.hasOwnProperty.call(message, "end"))
                            writer.uint32(/* id 4, wireType 0 =*/32).int32(message.end);
                        return writer;
                    };
    
                    /**
                     * Encodes the specified Annotation message, length delimited. Does not implicitly {@link google.protobuf.GeneratedCodeInfo.Annotation.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof google.protobuf.GeneratedCodeInfo.Annotation
                     * @static
                     * @param {google.protobuf.GeneratedCodeInfo.IAnnotation} message Annotation message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Annotation.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };
    
                    /**
                     * Decodes an Annotation message from the specified reader or buffer.
                     * @function decode
                     * @memberof google.protobuf.GeneratedCodeInfo.Annotation
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {google.protobuf.GeneratedCodeInfo.Annotation} Annotation
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Annotation.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.GeneratedCodeInfo.Annotation();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1: {
                                    if (!(message.path && message.path.length))
                                        message.path = [];
                                    if ((tag & 7) === 2) {
                                        var end2 = reader.uint32() + reader.pos;
                                        while (reader.pos < end2)
                                            message.path.push(reader.int32());
                                    } else
                                        message.path.push(reader.int32());
                                    break;
                                }
                            case 2: {
                                    message.sourceFile = reader.string();
                                    break;
                                }
                            case 3: {
                                    message.begin = reader.int32();
                                    break;
                                }
                            case 4: {
                                    message.end = reader.int32();
                                    break;
                                }
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Decodes an Annotation message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof google.protobuf.GeneratedCodeInfo.Annotation
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {google.protobuf.GeneratedCodeInfo.Annotation} Annotation
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Annotation.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };
    
                    /**
                     * Verifies an Annotation message.
                     * @function verify
                     * @memberof google.protobuf.GeneratedCodeInfo.Annotation
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    Annotation.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.path != null && message.hasOwnProperty("path")) {
                            if (!Array.isArray(message.path))
                                return "path: array expected";
                            for (var i = 0; i < message.path.length; ++i)
                                if (!$util.isInteger(message.path[i]))
                                    return "path: integer[] expected";
                        }
                        if (message.sourceFile != null && message.hasOwnProperty("sourceFile"))
                            if (!$util.isString(message.sourceFile))
                                return "sourceFile: string expected";
                        if (message.begin != null && message.hasOwnProperty("begin"))
                            if (!$util.isInteger(message.begin))
                                return "begin: integer expected";
                        if (message.end != null && message.hasOwnProperty("end"))
                            if (!$util.isInteger(message.end))
                                return "end: integer expected";
                        return null;
                    };
    
                    /**
                     * Creates an Annotation message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof google.protobuf.GeneratedCodeInfo.Annotation
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {google.protobuf.GeneratedCodeInfo.Annotation} Annotation
                     */
                    Annotation.fromObject = function fromObject(object) {
                        if (object instanceof $root.google.protobuf.GeneratedCodeInfo.Annotation)
                            return object;
                        var message = new $root.google.protobuf.GeneratedCodeInfo.Annotation();
                        if (object.path) {
                            if (!Array.isArray(object.path))
                                throw TypeError(".google.protobuf.GeneratedCodeInfo.Annotation.path: array expected");
                            message.path = [];
                            for (var i = 0; i < object.path.length; ++i)
                                message.path[i] = object.path[i] | 0;
                        }
                        if (object.sourceFile != null)
                            message.sourceFile = String(object.sourceFile);
                        if (object.begin != null)
                            message.begin = object.begin | 0;
                        if (object.end != null)
                            message.end = object.end | 0;
                        return message;
                    };
    
                    /**
                     * Creates a plain object from an Annotation message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof google.protobuf.GeneratedCodeInfo.Annotation
                     * @static
                     * @param {google.protobuf.GeneratedCodeInfo.Annotation} message Annotation
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    Annotation.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.arrays || options.defaults)
                            object.path = [];
                        if (options.defaults) {
                            object.sourceFile = "";
                            object.begin = 0;
                            object.end = 0;
                        }
                        if (message.path && message.path.length) {
                            object.path = [];
                            for (var j = 0; j < message.path.length; ++j)
                                object.path[j] = message.path[j];
                        }
                        if (message.sourceFile != null && message.hasOwnProperty("sourceFile"))
                            object.sourceFile = message.sourceFile;
                        if (message.begin != null && message.hasOwnProperty("begin"))
                            object.begin = message.begin;
                        if (message.end != null && message.hasOwnProperty("end"))
                            object.end = message.end;
                        return object;
                    };
    
                    /**
                     * Converts this Annotation to JSON.
                     * @function toJSON
                     * @memberof google.protobuf.GeneratedCodeInfo.Annotation
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    Annotation.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    /**
                     * Gets the default type url for Annotation
                     * @function getTypeUrl
                     * @memberof google.protobuf.GeneratedCodeInfo.Annotation
                     * @static
                     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                     * @returns {string} The default type url
                     */
                    Annotation.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                        if (typeUrlPrefix === undefined) {
                            typeUrlPrefix = "type.googleapis.com";
                        }
                        return typeUrlPrefix + "/google.protobuf.GeneratedCodeInfo.Annotation";
                    };
    
                    return Annotation;
                })();
    
                return GeneratedCodeInfo;
            })();
    
            return protobuf;
        })();
    
        return google;
    })();

    return $root;
});
