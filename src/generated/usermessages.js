/*eslint-disable block-scoped-var, id-length, no-control-regex, no-magic-numbers, no-prototype-builtins, no-redeclare, no-shadow, no-var, sort-vars*/
(function(global, factory) { /* global define, require, module */

    /* AMD */ if (typeof define === 'function' && define.amd)
        define(["protobufjs/minimal"], factory);

    /* CommonJS */ else if (typeof require === 'function' && typeof module === 'object' && module && module.exports)
        module.exports = factory(require("protobufjs/minimal"));

})(this, function($protobuf) {
    "use strict";

    // Common aliases
    var $Reader = $protobuf.Reader, $Writer = $protobuf.Writer, $util = $protobuf.util;
    
    // Exported root namespace
    var $root = $protobuf.roots["default"] || ($protobuf.roots["default"] = {});
    
    /**
     * EBaseUserMessages enum.
     * @exports EBaseUserMessages
     * @enum {number}
     * @property {number} UM_AchievementEvent=101 UM_AchievementEvent value
     * @property {number} UM_CloseCaption=102 UM_CloseCaption value
     * @property {number} UM_CloseCaptionDirect=103 UM_CloseCaptionDirect value
     * @property {number} UM_CurrentTimescale=104 UM_CurrentTimescale value
     * @property {number} UM_DesiredTimescale=105 UM_DesiredTimescale value
     * @property {number} UM_Fade=106 UM_Fade value
     * @property {number} UM_GameTitle=107 UM_GameTitle value
     * @property {number} UM_HudMsg=110 UM_HudMsg value
     * @property {number} UM_HudText=111 UM_HudText value
     * @property {number} UM_ColoredText=113 UM_ColoredText value
     * @property {number} UM_RequestState=114 UM_RequestState value
     * @property {number} UM_ResetHUD=115 UM_ResetHUD value
     * @property {number} UM_Rumble=116 UM_Rumble value
     * @property {number} UM_SayText=117 UM_SayText value
     * @property {number} UM_SayText2=118 UM_SayText2 value
     * @property {number} UM_SayTextChannel=119 UM_SayTextChannel value
     * @property {number} UM_Shake=120 UM_Shake value
     * @property {number} UM_ShakeDir=121 UM_ShakeDir value
     * @property {number} UM_TextMsg=124 UM_TextMsg value
     * @property {number} UM_ScreenTilt=125 UM_ScreenTilt value
     * @property {number} UM_VoiceMask=128 UM_VoiceMask value
     * @property {number} UM_SendAudio=130 UM_SendAudio value
     * @property {number} UM_ItemPickup=131 UM_ItemPickup value
     * @property {number} UM_AmmoDenied=132 UM_AmmoDenied value
     * @property {number} UM_ShowMenu=134 UM_ShowMenu value
     * @property {number} UM_CreditsMsg=135 UM_CreditsMsg value
     * @property {number} UM_CloseCaptionPlaceholder=142 UM_CloseCaptionPlaceholder value
     * @property {number} UM_CameraTransition=143 UM_CameraTransition value
     * @property {number} UM_AudioParameter=144 UM_AudioParameter value
     * @property {number} UM_ParticleManager=145 UM_ParticleManager value
     * @property {number} UM_HudError=146 UM_HudError value
     * @property {number} UM_CustomGameEvent=148 UM_CustomGameEvent value
     * @property {number} UM_AnimGraphUpdate=149 UM_AnimGraphUpdate value
     * @property {number} UM_HapticsManagerPulse=150 UM_HapticsManagerPulse value
     * @property {number} UM_HapticsManagerEffect=151 UM_HapticsManagerEffect value
     * @property {number} UM_CommandQueueState=152 UM_CommandQueueState value
     * @property {number} UM_UpdateCssClasses=153 UM_UpdateCssClasses value
     * @property {number} UM_ServerFrameTime=154 UM_ServerFrameTime value
     * @property {number} UM_LagCompensationError=155 UM_LagCompensationError value
     * @property {number} UM_RequestDllStatus=156 UM_RequestDllStatus value
     * @property {number} UM_RequestUtilAction=157 UM_RequestUtilAction value
     * @property {number} UM_UtilActionResponse=158 UM_UtilActionResponse value
     * @property {number} UM_DllStatusResponse=159 UM_DllStatusResponse value
     * @property {number} UM_RequestInventory=160 UM_RequestInventory value
     * @property {number} UM_InventoryResponse=161 UM_InventoryResponse value
     * @property {number} UM_RequestDiagnostic=162 UM_RequestDiagnostic value
     * @property {number} UM_DiagnosticResponse=163 UM_DiagnosticResponse value
     * @property {number} UM_ExtraUserData=164 UM_ExtraUserData value
     * @property {number} UM_MAX_BASE=200 UM_MAX_BASE value
     */
    $root.EBaseUserMessages = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[101] = "UM_AchievementEvent"] = 101;
        values[valuesById[102] = "UM_CloseCaption"] = 102;
        values[valuesById[103] = "UM_CloseCaptionDirect"] = 103;
        values[valuesById[104] = "UM_CurrentTimescale"] = 104;
        values[valuesById[105] = "UM_DesiredTimescale"] = 105;
        values[valuesById[106] = "UM_Fade"] = 106;
        values[valuesById[107] = "UM_GameTitle"] = 107;
        values[valuesById[110] = "UM_HudMsg"] = 110;
        values[valuesById[111] = "UM_HudText"] = 111;
        values[valuesById[113] = "UM_ColoredText"] = 113;
        values[valuesById[114] = "UM_RequestState"] = 114;
        values[valuesById[115] = "UM_ResetHUD"] = 115;
        values[valuesById[116] = "UM_Rumble"] = 116;
        values[valuesById[117] = "UM_SayText"] = 117;
        values[valuesById[118] = "UM_SayText2"] = 118;
        values[valuesById[119] = "UM_SayTextChannel"] = 119;
        values[valuesById[120] = "UM_Shake"] = 120;
        values[valuesById[121] = "UM_ShakeDir"] = 121;
        values[valuesById[124] = "UM_TextMsg"] = 124;
        values[valuesById[125] = "UM_ScreenTilt"] = 125;
        values[valuesById[128] = "UM_VoiceMask"] = 128;
        values[valuesById[130] = "UM_SendAudio"] = 130;
        values[valuesById[131] = "UM_ItemPickup"] = 131;
        values[valuesById[132] = "UM_AmmoDenied"] = 132;
        values[valuesById[134] = "UM_ShowMenu"] = 134;
        values[valuesById[135] = "UM_CreditsMsg"] = 135;
        values[valuesById[142] = "UM_CloseCaptionPlaceholder"] = 142;
        values[valuesById[143] = "UM_CameraTransition"] = 143;
        values[valuesById[144] = "UM_AudioParameter"] = 144;
        values[valuesById[145] = "UM_ParticleManager"] = 145;
        values[valuesById[146] = "UM_HudError"] = 146;
        values[valuesById[148] = "UM_CustomGameEvent"] = 148;
        values[valuesById[149] = "UM_AnimGraphUpdate"] = 149;
        values[valuesById[150] = "UM_HapticsManagerPulse"] = 150;
        values[valuesById[151] = "UM_HapticsManagerEffect"] = 151;
        values[valuesById[152] = "UM_CommandQueueState"] = 152;
        values[valuesById[153] = "UM_UpdateCssClasses"] = 153;
        values[valuesById[154] = "UM_ServerFrameTime"] = 154;
        values[valuesById[155] = "UM_LagCompensationError"] = 155;
        values[valuesById[156] = "UM_RequestDllStatus"] = 156;
        values[valuesById[157] = "UM_RequestUtilAction"] = 157;
        values[valuesById[158] = "UM_UtilActionResponse"] = 158;
        values[valuesById[159] = "UM_DllStatusResponse"] = 159;
        values[valuesById[160] = "UM_RequestInventory"] = 160;
        values[valuesById[161] = "UM_InventoryResponse"] = 161;
        values[valuesById[162] = "UM_RequestDiagnostic"] = 162;
        values[valuesById[163] = "UM_DiagnosticResponse"] = 163;
        values[valuesById[164] = "UM_ExtraUserData"] = 164;
        values[valuesById[200] = "UM_MAX_BASE"] = 200;
        return values;
    })();
    
    /**
     * EBaseEntityMessages enum.
     * @exports EBaseEntityMessages
     * @enum {number}
     * @property {number} EM_PlayJingle=136 EM_PlayJingle value
     * @property {number} EM_ScreenOverlay=137 EM_ScreenOverlay value
     * @property {number} EM_RemoveAllDecals=138 EM_RemoveAllDecals value
     * @property {number} EM_PropagateForce=139 EM_PropagateForce value
     * @property {number} EM_DoSpark=140 EM_DoSpark value
     * @property {number} EM_FixAngle=141 EM_FixAngle value
     */
    $root.EBaseEntityMessages = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[136] = "EM_PlayJingle"] = 136;
        values[valuesById[137] = "EM_ScreenOverlay"] = 137;
        values[valuesById[138] = "EM_RemoveAllDecals"] = 138;
        values[valuesById[139] = "EM_PropagateForce"] = 139;
        values[valuesById[140] = "EM_DoSpark"] = 140;
        values[valuesById[141] = "EM_FixAngle"] = 141;
        return values;
    })();
    
    /**
     * eRollType enum.
     * @exports eRollType
     * @enum {number}
     * @property {number} ROLL_NONE=-1 ROLL_NONE value
     * @property {number} ROLL_STATS=0 ROLL_STATS value
     * @property {number} ROLL_CREDITS=1 ROLL_CREDITS value
     * @property {number} ROLL_LATE_JOIN_LOGO=2 ROLL_LATE_JOIN_LOGO value
     * @property {number} ROLL_OUTTRO=3 ROLL_OUTTRO value
     */
    $root.eRollType = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[-1] = "ROLL_NONE"] = -1;
        values[valuesById[0] = "ROLL_STATS"] = 0;
        values[valuesById[1] = "ROLL_CREDITS"] = 1;
        values[valuesById[2] = "ROLL_LATE_JOIN_LOGO"] = 2;
        values[valuesById[3] = "ROLL_OUTTRO"] = 3;
        return values;
    })();
    
    /**
     * PARTICLE_MESSAGE enum.
     * @exports PARTICLE_MESSAGE
     * @enum {number}
     * @property {number} GAME_PARTICLE_MANAGER_EVENT_CREATE=0 GAME_PARTICLE_MANAGER_EVENT_CREATE value
     * @property {number} GAME_PARTICLE_MANAGER_EVENT_UPDATE=1 GAME_PARTICLE_MANAGER_EVENT_UPDATE value
     * @property {number} GAME_PARTICLE_MANAGER_EVENT_UPDATE_FORWARD=2 GAME_PARTICLE_MANAGER_EVENT_UPDATE_FORWARD value
     * @property {number} GAME_PARTICLE_MANAGER_EVENT_UPDATE_ORIENTATION=3 GAME_PARTICLE_MANAGER_EVENT_UPDATE_ORIENTATION value
     * @property {number} GAME_PARTICLE_MANAGER_EVENT_UPDATE_FALLBACK=4 GAME_PARTICLE_MANAGER_EVENT_UPDATE_FALLBACK value
     * @property {number} GAME_PARTICLE_MANAGER_EVENT_UPDATE_ENT=5 GAME_PARTICLE_MANAGER_EVENT_UPDATE_ENT value
     * @property {number} GAME_PARTICLE_MANAGER_EVENT_UPDATE_OFFSET=6 GAME_PARTICLE_MANAGER_EVENT_UPDATE_OFFSET value
     * @property {number} GAME_PARTICLE_MANAGER_EVENT_DESTROY=7 GAME_PARTICLE_MANAGER_EVENT_DESTROY value
     * @property {number} GAME_PARTICLE_MANAGER_EVENT_DESTROY_INVOLVING=8 GAME_PARTICLE_MANAGER_EVENT_DESTROY_INVOLVING value
     * @property {number} GAME_PARTICLE_MANAGER_EVENT_RELEASE=9 GAME_PARTICLE_MANAGER_EVENT_RELEASE value
     * @property {number} GAME_PARTICLE_MANAGER_EVENT_LATENCY=10 GAME_PARTICLE_MANAGER_EVENT_LATENCY value
     * @property {number} GAME_PARTICLE_MANAGER_EVENT_SHOULD_DRAW=11 GAME_PARTICLE_MANAGER_EVENT_SHOULD_DRAW value
     * @property {number} GAME_PARTICLE_MANAGER_EVENT_FROZEN=12 GAME_PARTICLE_MANAGER_EVENT_FROZEN value
     * @property {number} GAME_PARTICLE_MANAGER_EVENT_CHANGE_CONTROL_POINT_ATTACHMENT=13 GAME_PARTICLE_MANAGER_EVENT_CHANGE_CONTROL_POINT_ATTACHMENT value
     * @property {number} GAME_PARTICLE_MANAGER_EVENT_UPDATE_ENTITY_POSITION=14 GAME_PARTICLE_MANAGER_EVENT_UPDATE_ENTITY_POSITION value
     * @property {number} GAME_PARTICLE_MANAGER_EVENT_SET_FOW_PROPERTIES=15 GAME_PARTICLE_MANAGER_EVENT_SET_FOW_PROPERTIES value
     * @property {number} GAME_PARTICLE_MANAGER_EVENT_SET_TEXT=16 GAME_PARTICLE_MANAGER_EVENT_SET_TEXT value
     * @property {number} GAME_PARTICLE_MANAGER_EVENT_SET_SHOULD_CHECK_FOW=17 GAME_PARTICLE_MANAGER_EVENT_SET_SHOULD_CHECK_FOW value
     * @property {number} GAME_PARTICLE_MANAGER_EVENT_SET_CONTROL_POINT_MODEL=18 GAME_PARTICLE_MANAGER_EVENT_SET_CONTROL_POINT_MODEL value
     * @property {number} GAME_PARTICLE_MANAGER_EVENT_SET_CONTROL_POINT_SNAPSHOT=19 GAME_PARTICLE_MANAGER_EVENT_SET_CONTROL_POINT_SNAPSHOT value
     * @property {number} GAME_PARTICLE_MANAGER_EVENT_SET_TEXTURE_ATTRIBUTE=20 GAME_PARTICLE_MANAGER_EVENT_SET_TEXTURE_ATTRIBUTE value
     * @property {number} GAME_PARTICLE_MANAGER_EVENT_SET_SCENE_OBJECT_GENERIC_FLAG=21 GAME_PARTICLE_MANAGER_EVENT_SET_SCENE_OBJECT_GENERIC_FLAG value
     * @property {number} GAME_PARTICLE_MANAGER_EVENT_SET_SCENE_OBJECT_TINT_AND_DESAT=22 GAME_PARTICLE_MANAGER_EVENT_SET_SCENE_OBJECT_TINT_AND_DESAT value
     * @property {number} GAME_PARTICLE_MANAGER_EVENT_DESTROY_NAMED=23 GAME_PARTICLE_MANAGER_EVENT_DESTROY_NAMED value
     * @property {number} GAME_PARTICLE_MANAGER_EVENT_SKIP_TO_TIME=24 GAME_PARTICLE_MANAGER_EVENT_SKIP_TO_TIME value
     * @property {number} GAME_PARTICLE_MANAGER_EVENT_CAN_FREEZE=25 GAME_PARTICLE_MANAGER_EVENT_CAN_FREEZE value
     * @property {number} GAME_PARTICLE_MANAGER_EVENT_SET_NAMED_VALUE_CONTEXT=26 GAME_PARTICLE_MANAGER_EVENT_SET_NAMED_VALUE_CONTEXT value
     * @property {number} GAME_PARTICLE_MANAGER_EVENT_UPDATE_TRANSFORM=27 GAME_PARTICLE_MANAGER_EVENT_UPDATE_TRANSFORM value
     * @property {number} GAME_PARTICLE_MANAGER_EVENT_FREEZE_TRANSITION_OVERRIDE=28 GAME_PARTICLE_MANAGER_EVENT_FREEZE_TRANSITION_OVERRIDE value
     * @property {number} GAME_PARTICLE_MANAGER_EVENT_FREEZE_INVOLVING=29 GAME_PARTICLE_MANAGER_EVENT_FREEZE_INVOLVING value
     */
    $root.PARTICLE_MESSAGE = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "GAME_PARTICLE_MANAGER_EVENT_CREATE"] = 0;
        values[valuesById[1] = "GAME_PARTICLE_MANAGER_EVENT_UPDATE"] = 1;
        values[valuesById[2] = "GAME_PARTICLE_MANAGER_EVENT_UPDATE_FORWARD"] = 2;
        values[valuesById[3] = "GAME_PARTICLE_MANAGER_EVENT_UPDATE_ORIENTATION"] = 3;
        values[valuesById[4] = "GAME_PARTICLE_MANAGER_EVENT_UPDATE_FALLBACK"] = 4;
        values[valuesById[5] = "GAME_PARTICLE_MANAGER_EVENT_UPDATE_ENT"] = 5;
        values[valuesById[6] = "GAME_PARTICLE_MANAGER_EVENT_UPDATE_OFFSET"] = 6;
        values[valuesById[7] = "GAME_PARTICLE_MANAGER_EVENT_DESTROY"] = 7;
        values[valuesById[8] = "GAME_PARTICLE_MANAGER_EVENT_DESTROY_INVOLVING"] = 8;
        values[valuesById[9] = "GAME_PARTICLE_MANAGER_EVENT_RELEASE"] = 9;
        values[valuesById[10] = "GAME_PARTICLE_MANAGER_EVENT_LATENCY"] = 10;
        values[valuesById[11] = "GAME_PARTICLE_MANAGER_EVENT_SHOULD_DRAW"] = 11;
        values[valuesById[12] = "GAME_PARTICLE_MANAGER_EVENT_FROZEN"] = 12;
        values[valuesById[13] = "GAME_PARTICLE_MANAGER_EVENT_CHANGE_CONTROL_POINT_ATTACHMENT"] = 13;
        values[valuesById[14] = "GAME_PARTICLE_MANAGER_EVENT_UPDATE_ENTITY_POSITION"] = 14;
        values[valuesById[15] = "GAME_PARTICLE_MANAGER_EVENT_SET_FOW_PROPERTIES"] = 15;
        values[valuesById[16] = "GAME_PARTICLE_MANAGER_EVENT_SET_TEXT"] = 16;
        values[valuesById[17] = "GAME_PARTICLE_MANAGER_EVENT_SET_SHOULD_CHECK_FOW"] = 17;
        values[valuesById[18] = "GAME_PARTICLE_MANAGER_EVENT_SET_CONTROL_POINT_MODEL"] = 18;
        values[valuesById[19] = "GAME_PARTICLE_MANAGER_EVENT_SET_CONTROL_POINT_SNAPSHOT"] = 19;
        values[valuesById[20] = "GAME_PARTICLE_MANAGER_EVENT_SET_TEXTURE_ATTRIBUTE"] = 20;
        values[valuesById[21] = "GAME_PARTICLE_MANAGER_EVENT_SET_SCENE_OBJECT_GENERIC_FLAG"] = 21;
        values[valuesById[22] = "GAME_PARTICLE_MANAGER_EVENT_SET_SCENE_OBJECT_TINT_AND_DESAT"] = 22;
        values[valuesById[23] = "GAME_PARTICLE_MANAGER_EVENT_DESTROY_NAMED"] = 23;
        values[valuesById[24] = "GAME_PARTICLE_MANAGER_EVENT_SKIP_TO_TIME"] = 24;
        values[valuesById[25] = "GAME_PARTICLE_MANAGER_EVENT_CAN_FREEZE"] = 25;
        values[valuesById[26] = "GAME_PARTICLE_MANAGER_EVENT_SET_NAMED_VALUE_CONTEXT"] = 26;
        values[valuesById[27] = "GAME_PARTICLE_MANAGER_EVENT_UPDATE_TRANSFORM"] = 27;
        values[valuesById[28] = "GAME_PARTICLE_MANAGER_EVENT_FREEZE_TRANSITION_OVERRIDE"] = 28;
        values[valuesById[29] = "GAME_PARTICLE_MANAGER_EVENT_FREEZE_INVOLVING"] = 29;
        return values;
    })();
    
    /**
     * EHapticPulseType enum.
     * @exports EHapticPulseType
     * @enum {number}
     * @property {number} VR_HAND_HAPTIC_PULSE_LIGHT=0 VR_HAND_HAPTIC_PULSE_LIGHT value
     * @property {number} VR_HAND_HAPTIC_PULSE_MEDIUM=1 VR_HAND_HAPTIC_PULSE_MEDIUM value
     * @property {number} VR_HAND_HAPTIC_PULSE_STRONG=2 VR_HAND_HAPTIC_PULSE_STRONG value
     */
    $root.EHapticPulseType = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "VR_HAND_HAPTIC_PULSE_LIGHT"] = 0;
        values[valuesById[1] = "VR_HAND_HAPTIC_PULSE_MEDIUM"] = 1;
        values[valuesById[2] = "VR_HAND_HAPTIC_PULSE_STRONG"] = 2;
        return values;
    })();
    
    $root.CUserMessageAchievementEvent = (function() {
    
        /**
         * Properties of a CUserMessageAchievementEvent.
         * @exports ICUserMessageAchievementEvent
         * @interface ICUserMessageAchievementEvent
         * @property {number|null} [achievement] CUserMessageAchievementEvent achievement
         */
    
        /**
         * Constructs a new CUserMessageAchievementEvent.
         * @exports CUserMessageAchievementEvent
         * @classdesc Represents a CUserMessageAchievementEvent.
         * @implements ICUserMessageAchievementEvent
         * @constructor
         * @param {ICUserMessageAchievementEvent=} [properties] Properties to set
         */
        function CUserMessageAchievementEvent(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CUserMessageAchievementEvent achievement.
         * @member {number} achievement
         * @memberof CUserMessageAchievementEvent
         * @instance
         */
        CUserMessageAchievementEvent.prototype.achievement = 0;
    
        /**
         * Creates a new CUserMessageAchievementEvent instance using the specified properties.
         * @function create
         * @memberof CUserMessageAchievementEvent
         * @static
         * @param {ICUserMessageAchievementEvent=} [properties] Properties to set
         * @returns {CUserMessageAchievementEvent} CUserMessageAchievementEvent instance
         */
        CUserMessageAchievementEvent.create = function create(properties) {
            return new CUserMessageAchievementEvent(properties);
        };
    
        /**
         * Encodes the specified CUserMessageAchievementEvent message. Does not implicitly {@link CUserMessageAchievementEvent.verify|verify} messages.
         * @function encode
         * @memberof CUserMessageAchievementEvent
         * @static
         * @param {ICUserMessageAchievementEvent} message CUserMessageAchievementEvent message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CUserMessageAchievementEvent.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.achievement != null && Object.hasOwnProperty.call(message, "achievement"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.achievement);
            return writer;
        };
    
        /**
         * Encodes the specified CUserMessageAchievementEvent message, length delimited. Does not implicitly {@link CUserMessageAchievementEvent.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CUserMessageAchievementEvent
         * @static
         * @param {ICUserMessageAchievementEvent} message CUserMessageAchievementEvent message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CUserMessageAchievementEvent.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CUserMessageAchievementEvent message from the specified reader or buffer.
         * @function decode
         * @memberof CUserMessageAchievementEvent
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CUserMessageAchievementEvent} CUserMessageAchievementEvent
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CUserMessageAchievementEvent.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CUserMessageAchievementEvent();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.achievement = reader.uint32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CUserMessageAchievementEvent message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CUserMessageAchievementEvent
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CUserMessageAchievementEvent} CUserMessageAchievementEvent
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CUserMessageAchievementEvent.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CUserMessageAchievementEvent message.
         * @function verify
         * @memberof CUserMessageAchievementEvent
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CUserMessageAchievementEvent.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.achievement != null && message.hasOwnProperty("achievement"))
                if (!$util.isInteger(message.achievement))
                    return "achievement: integer expected";
            return null;
        };
    
        /**
         * Creates a CUserMessageAchievementEvent message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CUserMessageAchievementEvent
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CUserMessageAchievementEvent} CUserMessageAchievementEvent
         */
        CUserMessageAchievementEvent.fromObject = function fromObject(object) {
            if (object instanceof $root.CUserMessageAchievementEvent)
                return object;
            var message = new $root.CUserMessageAchievementEvent();
            if (object.achievement != null)
                message.achievement = object.achievement >>> 0;
            return message;
        };
    
        /**
         * Creates a plain object from a CUserMessageAchievementEvent message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CUserMessageAchievementEvent
         * @static
         * @param {CUserMessageAchievementEvent} message CUserMessageAchievementEvent
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CUserMessageAchievementEvent.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.achievement = 0;
            if (message.achievement != null && message.hasOwnProperty("achievement"))
                object.achievement = message.achievement;
            return object;
        };
    
        /**
         * Converts this CUserMessageAchievementEvent to JSON.
         * @function toJSON
         * @memberof CUserMessageAchievementEvent
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CUserMessageAchievementEvent.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * Gets the default type url for CUserMessageAchievementEvent
         * @function getTypeUrl
         * @memberof CUserMessageAchievementEvent
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        CUserMessageAchievementEvent.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/CUserMessageAchievementEvent";
        };
    
        return CUserMessageAchievementEvent;
    })();
    
    $root.CUserMessageCloseCaption = (function() {
    
        /**
         * Properties of a CUserMessageCloseCaption.
         * @exports ICUserMessageCloseCaption
         * @interface ICUserMessageCloseCaption
         * @property {number|null} [hash] CUserMessageCloseCaption hash
         * @property {number|null} [duration] CUserMessageCloseCaption duration
         * @property {boolean|null} [fromPlayer] CUserMessageCloseCaption fromPlayer
         * @property {number|null} [entIndex] CUserMessageCloseCaption entIndex
         */
    
        /**
         * Constructs a new CUserMessageCloseCaption.
         * @exports CUserMessageCloseCaption
         * @classdesc Represents a CUserMessageCloseCaption.
         * @implements ICUserMessageCloseCaption
         * @constructor
         * @param {ICUserMessageCloseCaption=} [properties] Properties to set
         */
        function CUserMessageCloseCaption(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CUserMessageCloseCaption hash.
         * @member {number} hash
         * @memberof CUserMessageCloseCaption
         * @instance
         */
        CUserMessageCloseCaption.prototype.hash = 0;
    
        /**
         * CUserMessageCloseCaption duration.
         * @member {number} duration
         * @memberof CUserMessageCloseCaption
         * @instance
         */
        CUserMessageCloseCaption.prototype.duration = 0;
    
        /**
         * CUserMessageCloseCaption fromPlayer.
         * @member {boolean} fromPlayer
         * @memberof CUserMessageCloseCaption
         * @instance
         */
        CUserMessageCloseCaption.prototype.fromPlayer = false;
    
        /**
         * CUserMessageCloseCaption entIndex.
         * @member {number} entIndex
         * @memberof CUserMessageCloseCaption
         * @instance
         */
        CUserMessageCloseCaption.prototype.entIndex = -1;
    
        /**
         * Creates a new CUserMessageCloseCaption instance using the specified properties.
         * @function create
         * @memberof CUserMessageCloseCaption
         * @static
         * @param {ICUserMessageCloseCaption=} [properties] Properties to set
         * @returns {CUserMessageCloseCaption} CUserMessageCloseCaption instance
         */
        CUserMessageCloseCaption.create = function create(properties) {
            return new CUserMessageCloseCaption(properties);
        };
    
        /**
         * Encodes the specified CUserMessageCloseCaption message. Does not implicitly {@link CUserMessageCloseCaption.verify|verify} messages.
         * @function encode
         * @memberof CUserMessageCloseCaption
         * @static
         * @param {ICUserMessageCloseCaption} message CUserMessageCloseCaption message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CUserMessageCloseCaption.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.hash != null && Object.hasOwnProperty.call(message, "hash"))
                writer.uint32(/* id 1, wireType 5 =*/13).fixed32(message.hash);
            if (message.duration != null && Object.hasOwnProperty.call(message, "duration"))
                writer.uint32(/* id 2, wireType 5 =*/21).float(message.duration);
            if (message.fromPlayer != null && Object.hasOwnProperty.call(message, "fromPlayer"))
                writer.uint32(/* id 3, wireType 0 =*/24).bool(message.fromPlayer);
            if (message.entIndex != null && Object.hasOwnProperty.call(message, "entIndex"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.entIndex);
            return writer;
        };
    
        /**
         * Encodes the specified CUserMessageCloseCaption message, length delimited. Does not implicitly {@link CUserMessageCloseCaption.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CUserMessageCloseCaption
         * @static
         * @param {ICUserMessageCloseCaption} message CUserMessageCloseCaption message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CUserMessageCloseCaption.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CUserMessageCloseCaption message from the specified reader or buffer.
         * @function decode
         * @memberof CUserMessageCloseCaption
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CUserMessageCloseCaption} CUserMessageCloseCaption
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CUserMessageCloseCaption.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CUserMessageCloseCaption();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.hash = reader.fixed32();
                        break;
                    }
                case 2: {
                        message.duration = reader.float();
                        break;
                    }
                case 3: {
                        message.fromPlayer = reader.bool();
                        break;
                    }
                case 4: {
                        message.entIndex = reader.int32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CUserMessageCloseCaption message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CUserMessageCloseCaption
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CUserMessageCloseCaption} CUserMessageCloseCaption
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CUserMessageCloseCaption.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CUserMessageCloseCaption message.
         * @function verify
         * @memberof CUserMessageCloseCaption
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CUserMessageCloseCaption.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.hash != null && message.hasOwnProperty("hash"))
                if (!$util.isInteger(message.hash))
                    return "hash: integer expected";
            if (message.duration != null && message.hasOwnProperty("duration"))
                if (typeof message.duration !== "number")
                    return "duration: number expected";
            if (message.fromPlayer != null && message.hasOwnProperty("fromPlayer"))
                if (typeof message.fromPlayer !== "boolean")
                    return "fromPlayer: boolean expected";
            if (message.entIndex != null && message.hasOwnProperty("entIndex"))
                if (!$util.isInteger(message.entIndex))
                    return "entIndex: integer expected";
            return null;
        };
    
        /**
         * Creates a CUserMessageCloseCaption message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CUserMessageCloseCaption
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CUserMessageCloseCaption} CUserMessageCloseCaption
         */
        CUserMessageCloseCaption.fromObject = function fromObject(object) {
            if (object instanceof $root.CUserMessageCloseCaption)
                return object;
            var message = new $root.CUserMessageCloseCaption();
            if (object.hash != null)
                message.hash = object.hash >>> 0;
            if (object.duration != null)
                message.duration = Number(object.duration);
            if (object.fromPlayer != null)
                message.fromPlayer = Boolean(object.fromPlayer);
            if (object.entIndex != null)
                message.entIndex = object.entIndex | 0;
            return message;
        };
    
        /**
         * Creates a plain object from a CUserMessageCloseCaption message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CUserMessageCloseCaption
         * @static
         * @param {CUserMessageCloseCaption} message CUserMessageCloseCaption
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CUserMessageCloseCaption.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.hash = 0;
                object.duration = 0;
                object.fromPlayer = false;
                object.entIndex = -1;
            }
            if (message.hash != null && message.hasOwnProperty("hash"))
                object.hash = message.hash;
            if (message.duration != null && message.hasOwnProperty("duration"))
                object.duration = options.json && !isFinite(message.duration) ? String(message.duration) : message.duration;
            if (message.fromPlayer != null && message.hasOwnProperty("fromPlayer"))
                object.fromPlayer = message.fromPlayer;
            if (message.entIndex != null && message.hasOwnProperty("entIndex"))
                object.entIndex = message.entIndex;
            return object;
        };
    
        /**
         * Converts this CUserMessageCloseCaption to JSON.
         * @function toJSON
         * @memberof CUserMessageCloseCaption
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CUserMessageCloseCaption.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * Gets the default type url for CUserMessageCloseCaption
         * @function getTypeUrl
         * @memberof CUserMessageCloseCaption
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        CUserMessageCloseCaption.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/CUserMessageCloseCaption";
        };
    
        return CUserMessageCloseCaption;
    })();
    
    $root.CUserMessageCloseCaptionDirect = (function() {
    
        /**
         * Properties of a CUserMessageCloseCaptionDirect.
         * @exports ICUserMessageCloseCaptionDirect
         * @interface ICUserMessageCloseCaptionDirect
         * @property {number|null} [hash] CUserMessageCloseCaptionDirect hash
         * @property {number|null} [duration] CUserMessageCloseCaptionDirect duration
         * @property {boolean|null} [fromPlayer] CUserMessageCloseCaptionDirect fromPlayer
         * @property {number|null} [entIndex] CUserMessageCloseCaptionDirect entIndex
         */
    
        /**
         * Constructs a new CUserMessageCloseCaptionDirect.
         * @exports CUserMessageCloseCaptionDirect
         * @classdesc Represents a CUserMessageCloseCaptionDirect.
         * @implements ICUserMessageCloseCaptionDirect
         * @constructor
         * @param {ICUserMessageCloseCaptionDirect=} [properties] Properties to set
         */
        function CUserMessageCloseCaptionDirect(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CUserMessageCloseCaptionDirect hash.
         * @member {number} hash
         * @memberof CUserMessageCloseCaptionDirect
         * @instance
         */
        CUserMessageCloseCaptionDirect.prototype.hash = 0;
    
        /**
         * CUserMessageCloseCaptionDirect duration.
         * @member {number} duration
         * @memberof CUserMessageCloseCaptionDirect
         * @instance
         */
        CUserMessageCloseCaptionDirect.prototype.duration = 0;
    
        /**
         * CUserMessageCloseCaptionDirect fromPlayer.
         * @member {boolean} fromPlayer
         * @memberof CUserMessageCloseCaptionDirect
         * @instance
         */
        CUserMessageCloseCaptionDirect.prototype.fromPlayer = false;
    
        /**
         * CUserMessageCloseCaptionDirect entIndex.
         * @member {number} entIndex
         * @memberof CUserMessageCloseCaptionDirect
         * @instance
         */
        CUserMessageCloseCaptionDirect.prototype.entIndex = -1;
    
        /**
         * Creates a new CUserMessageCloseCaptionDirect instance using the specified properties.
         * @function create
         * @memberof CUserMessageCloseCaptionDirect
         * @static
         * @param {ICUserMessageCloseCaptionDirect=} [properties] Properties to set
         * @returns {CUserMessageCloseCaptionDirect} CUserMessageCloseCaptionDirect instance
         */
        CUserMessageCloseCaptionDirect.create = function create(properties) {
            return new CUserMessageCloseCaptionDirect(properties);
        };
    
        /**
         * Encodes the specified CUserMessageCloseCaptionDirect message. Does not implicitly {@link CUserMessageCloseCaptionDirect.verify|verify} messages.
         * @function encode
         * @memberof CUserMessageCloseCaptionDirect
         * @static
         * @param {ICUserMessageCloseCaptionDirect} message CUserMessageCloseCaptionDirect message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CUserMessageCloseCaptionDirect.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.hash != null && Object.hasOwnProperty.call(message, "hash"))
                writer.uint32(/* id 1, wireType 5 =*/13).fixed32(message.hash);
            if (message.duration != null && Object.hasOwnProperty.call(message, "duration"))
                writer.uint32(/* id 2, wireType 5 =*/21).float(message.duration);
            if (message.fromPlayer != null && Object.hasOwnProperty.call(message, "fromPlayer"))
                writer.uint32(/* id 3, wireType 0 =*/24).bool(message.fromPlayer);
            if (message.entIndex != null && Object.hasOwnProperty.call(message, "entIndex"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.entIndex);
            return writer;
        };
    
        /**
         * Encodes the specified CUserMessageCloseCaptionDirect message, length delimited. Does not implicitly {@link CUserMessageCloseCaptionDirect.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CUserMessageCloseCaptionDirect
         * @static
         * @param {ICUserMessageCloseCaptionDirect} message CUserMessageCloseCaptionDirect message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CUserMessageCloseCaptionDirect.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CUserMessageCloseCaptionDirect message from the specified reader or buffer.
         * @function decode
         * @memberof CUserMessageCloseCaptionDirect
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CUserMessageCloseCaptionDirect} CUserMessageCloseCaptionDirect
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CUserMessageCloseCaptionDirect.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CUserMessageCloseCaptionDirect();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.hash = reader.fixed32();
                        break;
                    }
                case 2: {
                        message.duration = reader.float();
                        break;
                    }
                case 3: {
                        message.fromPlayer = reader.bool();
                        break;
                    }
                case 4: {
                        message.entIndex = reader.int32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CUserMessageCloseCaptionDirect message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CUserMessageCloseCaptionDirect
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CUserMessageCloseCaptionDirect} CUserMessageCloseCaptionDirect
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CUserMessageCloseCaptionDirect.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CUserMessageCloseCaptionDirect message.
         * @function verify
         * @memberof CUserMessageCloseCaptionDirect
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CUserMessageCloseCaptionDirect.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.hash != null && message.hasOwnProperty("hash"))
                if (!$util.isInteger(message.hash))
                    return "hash: integer expected";
            if (message.duration != null && message.hasOwnProperty("duration"))
                if (typeof message.duration !== "number")
                    return "duration: number expected";
            if (message.fromPlayer != null && message.hasOwnProperty("fromPlayer"))
                if (typeof message.fromPlayer !== "boolean")
                    return "fromPlayer: boolean expected";
            if (message.entIndex != null && message.hasOwnProperty("entIndex"))
                if (!$util.isInteger(message.entIndex))
                    return "entIndex: integer expected";
            return null;
        };
    
        /**
         * Creates a CUserMessageCloseCaptionDirect message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CUserMessageCloseCaptionDirect
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CUserMessageCloseCaptionDirect} CUserMessageCloseCaptionDirect
         */
        CUserMessageCloseCaptionDirect.fromObject = function fromObject(object) {
            if (object instanceof $root.CUserMessageCloseCaptionDirect)
                return object;
            var message = new $root.CUserMessageCloseCaptionDirect();
            if (object.hash != null)
                message.hash = object.hash >>> 0;
            if (object.duration != null)
                message.duration = Number(object.duration);
            if (object.fromPlayer != null)
                message.fromPlayer = Boolean(object.fromPlayer);
            if (object.entIndex != null)
                message.entIndex = object.entIndex | 0;
            return message;
        };
    
        /**
         * Creates a plain object from a CUserMessageCloseCaptionDirect message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CUserMessageCloseCaptionDirect
         * @static
         * @param {CUserMessageCloseCaptionDirect} message CUserMessageCloseCaptionDirect
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CUserMessageCloseCaptionDirect.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.hash = 0;
                object.duration = 0;
                object.fromPlayer = false;
                object.entIndex = -1;
            }
            if (message.hash != null && message.hasOwnProperty("hash"))
                object.hash = message.hash;
            if (message.duration != null && message.hasOwnProperty("duration"))
                object.duration = options.json && !isFinite(message.duration) ? String(message.duration) : message.duration;
            if (message.fromPlayer != null && message.hasOwnProperty("fromPlayer"))
                object.fromPlayer = message.fromPlayer;
            if (message.entIndex != null && message.hasOwnProperty("entIndex"))
                object.entIndex = message.entIndex;
            return object;
        };
    
        /**
         * Converts this CUserMessageCloseCaptionDirect to JSON.
         * @function toJSON
         * @memberof CUserMessageCloseCaptionDirect
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CUserMessageCloseCaptionDirect.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * Gets the default type url for CUserMessageCloseCaptionDirect
         * @function getTypeUrl
         * @memberof CUserMessageCloseCaptionDirect
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        CUserMessageCloseCaptionDirect.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/CUserMessageCloseCaptionDirect";
        };
    
        return CUserMessageCloseCaptionDirect;
    })();
    
    $root.CUserMessageCloseCaptionPlaceholder = (function() {
    
        /**
         * Properties of a CUserMessageCloseCaptionPlaceholder.
         * @exports ICUserMessageCloseCaptionPlaceholder
         * @interface ICUserMessageCloseCaptionPlaceholder
         * @property {string|null} [string] CUserMessageCloseCaptionPlaceholder string
         * @property {number|null} [duration] CUserMessageCloseCaptionPlaceholder duration
         * @property {boolean|null} [fromPlayer] CUserMessageCloseCaptionPlaceholder fromPlayer
         * @property {number|null} [entIndex] CUserMessageCloseCaptionPlaceholder entIndex
         */
    
        /**
         * Constructs a new CUserMessageCloseCaptionPlaceholder.
         * @exports CUserMessageCloseCaptionPlaceholder
         * @classdesc Represents a CUserMessageCloseCaptionPlaceholder.
         * @implements ICUserMessageCloseCaptionPlaceholder
         * @constructor
         * @param {ICUserMessageCloseCaptionPlaceholder=} [properties] Properties to set
         */
        function CUserMessageCloseCaptionPlaceholder(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CUserMessageCloseCaptionPlaceholder string.
         * @member {string} string
         * @memberof CUserMessageCloseCaptionPlaceholder
         * @instance
         */
        CUserMessageCloseCaptionPlaceholder.prototype.string = "";
    
        /**
         * CUserMessageCloseCaptionPlaceholder duration.
         * @member {number} duration
         * @memberof CUserMessageCloseCaptionPlaceholder
         * @instance
         */
        CUserMessageCloseCaptionPlaceholder.prototype.duration = 0;
    
        /**
         * CUserMessageCloseCaptionPlaceholder fromPlayer.
         * @member {boolean} fromPlayer
         * @memberof CUserMessageCloseCaptionPlaceholder
         * @instance
         */
        CUserMessageCloseCaptionPlaceholder.prototype.fromPlayer = false;
    
        /**
         * CUserMessageCloseCaptionPlaceholder entIndex.
         * @member {number} entIndex
         * @memberof CUserMessageCloseCaptionPlaceholder
         * @instance
         */
        CUserMessageCloseCaptionPlaceholder.prototype.entIndex = -1;
    
        /**
         * Creates a new CUserMessageCloseCaptionPlaceholder instance using the specified properties.
         * @function create
         * @memberof CUserMessageCloseCaptionPlaceholder
         * @static
         * @param {ICUserMessageCloseCaptionPlaceholder=} [properties] Properties to set
         * @returns {CUserMessageCloseCaptionPlaceholder} CUserMessageCloseCaptionPlaceholder instance
         */
        CUserMessageCloseCaptionPlaceholder.create = function create(properties) {
            return new CUserMessageCloseCaptionPlaceholder(properties);
        };
    
        /**
         * Encodes the specified CUserMessageCloseCaptionPlaceholder message. Does not implicitly {@link CUserMessageCloseCaptionPlaceholder.verify|verify} messages.
         * @function encode
         * @memberof CUserMessageCloseCaptionPlaceholder
         * @static
         * @param {ICUserMessageCloseCaptionPlaceholder} message CUserMessageCloseCaptionPlaceholder message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CUserMessageCloseCaptionPlaceholder.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.string != null && Object.hasOwnProperty.call(message, "string"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.string);
            if (message.duration != null && Object.hasOwnProperty.call(message, "duration"))
                writer.uint32(/* id 2, wireType 5 =*/21).float(message.duration);
            if (message.fromPlayer != null && Object.hasOwnProperty.call(message, "fromPlayer"))
                writer.uint32(/* id 3, wireType 0 =*/24).bool(message.fromPlayer);
            if (message.entIndex != null && Object.hasOwnProperty.call(message, "entIndex"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.entIndex);
            return writer;
        };
    
        /**
         * Encodes the specified CUserMessageCloseCaptionPlaceholder message, length delimited. Does not implicitly {@link CUserMessageCloseCaptionPlaceholder.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CUserMessageCloseCaptionPlaceholder
         * @static
         * @param {ICUserMessageCloseCaptionPlaceholder} message CUserMessageCloseCaptionPlaceholder message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CUserMessageCloseCaptionPlaceholder.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CUserMessageCloseCaptionPlaceholder message from the specified reader or buffer.
         * @function decode
         * @memberof CUserMessageCloseCaptionPlaceholder
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CUserMessageCloseCaptionPlaceholder} CUserMessageCloseCaptionPlaceholder
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CUserMessageCloseCaptionPlaceholder.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CUserMessageCloseCaptionPlaceholder();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.string = reader.string();
                        break;
                    }
                case 2: {
                        message.duration = reader.float();
                        break;
                    }
                case 3: {
                        message.fromPlayer = reader.bool();
                        break;
                    }
                case 4: {
                        message.entIndex = reader.int32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CUserMessageCloseCaptionPlaceholder message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CUserMessageCloseCaptionPlaceholder
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CUserMessageCloseCaptionPlaceholder} CUserMessageCloseCaptionPlaceholder
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CUserMessageCloseCaptionPlaceholder.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CUserMessageCloseCaptionPlaceholder message.
         * @function verify
         * @memberof CUserMessageCloseCaptionPlaceholder
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CUserMessageCloseCaptionPlaceholder.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.string != null && message.hasOwnProperty("string"))
                if (!$util.isString(message.string))
                    return "string: string expected";
            if (message.duration != null && message.hasOwnProperty("duration"))
                if (typeof message.duration !== "number")
                    return "duration: number expected";
            if (message.fromPlayer != null && message.hasOwnProperty("fromPlayer"))
                if (typeof message.fromPlayer !== "boolean")
                    return "fromPlayer: boolean expected";
            if (message.entIndex != null && message.hasOwnProperty("entIndex"))
                if (!$util.isInteger(message.entIndex))
                    return "entIndex: integer expected";
            return null;
        };
    
        /**
         * Creates a CUserMessageCloseCaptionPlaceholder message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CUserMessageCloseCaptionPlaceholder
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CUserMessageCloseCaptionPlaceholder} CUserMessageCloseCaptionPlaceholder
         */
        CUserMessageCloseCaptionPlaceholder.fromObject = function fromObject(object) {
            if (object instanceof $root.CUserMessageCloseCaptionPlaceholder)
                return object;
            var message = new $root.CUserMessageCloseCaptionPlaceholder();
            if (object.string != null)
                message.string = String(object.string);
            if (object.duration != null)
                message.duration = Number(object.duration);
            if (object.fromPlayer != null)
                message.fromPlayer = Boolean(object.fromPlayer);
            if (object.entIndex != null)
                message.entIndex = object.entIndex | 0;
            return message;
        };
    
        /**
         * Creates a plain object from a CUserMessageCloseCaptionPlaceholder message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CUserMessageCloseCaptionPlaceholder
         * @static
         * @param {CUserMessageCloseCaptionPlaceholder} message CUserMessageCloseCaptionPlaceholder
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CUserMessageCloseCaptionPlaceholder.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.string = "";
                object.duration = 0;
                object.fromPlayer = false;
                object.entIndex = -1;
            }
            if (message.string != null && message.hasOwnProperty("string"))
                object.string = message.string;
            if (message.duration != null && message.hasOwnProperty("duration"))
                object.duration = options.json && !isFinite(message.duration) ? String(message.duration) : message.duration;
            if (message.fromPlayer != null && message.hasOwnProperty("fromPlayer"))
                object.fromPlayer = message.fromPlayer;
            if (message.entIndex != null && message.hasOwnProperty("entIndex"))
                object.entIndex = message.entIndex;
            return object;
        };
    
        /**
         * Converts this CUserMessageCloseCaptionPlaceholder to JSON.
         * @function toJSON
         * @memberof CUserMessageCloseCaptionPlaceholder
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CUserMessageCloseCaptionPlaceholder.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * Gets the default type url for CUserMessageCloseCaptionPlaceholder
         * @function getTypeUrl
         * @memberof CUserMessageCloseCaptionPlaceholder
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        CUserMessageCloseCaptionPlaceholder.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/CUserMessageCloseCaptionPlaceholder";
        };
    
        return CUserMessageCloseCaptionPlaceholder;
    })();
    
    $root.CUserMessageCurrentTimescale = (function() {
    
        /**
         * Properties of a CUserMessageCurrentTimescale.
         * @exports ICUserMessageCurrentTimescale
         * @interface ICUserMessageCurrentTimescale
         * @property {number|null} [current] CUserMessageCurrentTimescale current
         */
    
        /**
         * Constructs a new CUserMessageCurrentTimescale.
         * @exports CUserMessageCurrentTimescale
         * @classdesc Represents a CUserMessageCurrentTimescale.
         * @implements ICUserMessageCurrentTimescale
         * @constructor
         * @param {ICUserMessageCurrentTimescale=} [properties] Properties to set
         */
        function CUserMessageCurrentTimescale(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CUserMessageCurrentTimescale current.
         * @member {number} current
         * @memberof CUserMessageCurrentTimescale
         * @instance
         */
        CUserMessageCurrentTimescale.prototype.current = 0;
    
        /**
         * Creates a new CUserMessageCurrentTimescale instance using the specified properties.
         * @function create
         * @memberof CUserMessageCurrentTimescale
         * @static
         * @param {ICUserMessageCurrentTimescale=} [properties] Properties to set
         * @returns {CUserMessageCurrentTimescale} CUserMessageCurrentTimescale instance
         */
        CUserMessageCurrentTimescale.create = function create(properties) {
            return new CUserMessageCurrentTimescale(properties);
        };
    
        /**
         * Encodes the specified CUserMessageCurrentTimescale message. Does not implicitly {@link CUserMessageCurrentTimescale.verify|verify} messages.
         * @function encode
         * @memberof CUserMessageCurrentTimescale
         * @static
         * @param {ICUserMessageCurrentTimescale} message CUserMessageCurrentTimescale message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CUserMessageCurrentTimescale.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.current != null && Object.hasOwnProperty.call(message, "current"))
                writer.uint32(/* id 1, wireType 5 =*/13).float(message.current);
            return writer;
        };
    
        /**
         * Encodes the specified CUserMessageCurrentTimescale message, length delimited. Does not implicitly {@link CUserMessageCurrentTimescale.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CUserMessageCurrentTimescale
         * @static
         * @param {ICUserMessageCurrentTimescale} message CUserMessageCurrentTimescale message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CUserMessageCurrentTimescale.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CUserMessageCurrentTimescale message from the specified reader or buffer.
         * @function decode
         * @memberof CUserMessageCurrentTimescale
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CUserMessageCurrentTimescale} CUserMessageCurrentTimescale
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CUserMessageCurrentTimescale.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CUserMessageCurrentTimescale();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.current = reader.float();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CUserMessageCurrentTimescale message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CUserMessageCurrentTimescale
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CUserMessageCurrentTimescale} CUserMessageCurrentTimescale
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CUserMessageCurrentTimescale.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CUserMessageCurrentTimescale message.
         * @function verify
         * @memberof CUserMessageCurrentTimescale
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CUserMessageCurrentTimescale.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.current != null && message.hasOwnProperty("current"))
                if (typeof message.current !== "number")
                    return "current: number expected";
            return null;
        };
    
        /**
         * Creates a CUserMessageCurrentTimescale message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CUserMessageCurrentTimescale
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CUserMessageCurrentTimescale} CUserMessageCurrentTimescale
         */
        CUserMessageCurrentTimescale.fromObject = function fromObject(object) {
            if (object instanceof $root.CUserMessageCurrentTimescale)
                return object;
            var message = new $root.CUserMessageCurrentTimescale();
            if (object.current != null)
                message.current = Number(object.current);
            return message;
        };
    
        /**
         * Creates a plain object from a CUserMessageCurrentTimescale message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CUserMessageCurrentTimescale
         * @static
         * @param {CUserMessageCurrentTimescale} message CUserMessageCurrentTimescale
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CUserMessageCurrentTimescale.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.current = 0;
            if (message.current != null && message.hasOwnProperty("current"))
                object.current = options.json && !isFinite(message.current) ? String(message.current) : message.current;
            return object;
        };
    
        /**
         * Converts this CUserMessageCurrentTimescale to JSON.
         * @function toJSON
         * @memberof CUserMessageCurrentTimescale
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CUserMessageCurrentTimescale.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * Gets the default type url for CUserMessageCurrentTimescale
         * @function getTypeUrl
         * @memberof CUserMessageCurrentTimescale
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        CUserMessageCurrentTimescale.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/CUserMessageCurrentTimescale";
        };
    
        return CUserMessageCurrentTimescale;
    })();
    
    $root.CUserMessageDesiredTimescale = (function() {
    
        /**
         * Properties of a CUserMessageDesiredTimescale.
         * @exports ICUserMessageDesiredTimescale
         * @interface ICUserMessageDesiredTimescale
         * @property {number|null} [desired] CUserMessageDesiredTimescale desired
         * @property {number|null} [acceleration] CUserMessageDesiredTimescale acceleration
         * @property {number|null} [minblendrate] CUserMessageDesiredTimescale minblendrate
         * @property {number|null} [blenddeltamultiplier] CUserMessageDesiredTimescale blenddeltamultiplier
         */
    
        /**
         * Constructs a new CUserMessageDesiredTimescale.
         * @exports CUserMessageDesiredTimescale
         * @classdesc Represents a CUserMessageDesiredTimescale.
         * @implements ICUserMessageDesiredTimescale
         * @constructor
         * @param {ICUserMessageDesiredTimescale=} [properties] Properties to set
         */
        function CUserMessageDesiredTimescale(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CUserMessageDesiredTimescale desired.
         * @member {number} desired
         * @memberof CUserMessageDesiredTimescale
         * @instance
         */
        CUserMessageDesiredTimescale.prototype.desired = 0;
    
        /**
         * CUserMessageDesiredTimescale acceleration.
         * @member {number} acceleration
         * @memberof CUserMessageDesiredTimescale
         * @instance
         */
        CUserMessageDesiredTimescale.prototype.acceleration = 0;
    
        /**
         * CUserMessageDesiredTimescale minblendrate.
         * @member {number} minblendrate
         * @memberof CUserMessageDesiredTimescale
         * @instance
         */
        CUserMessageDesiredTimescale.prototype.minblendrate = 0;
    
        /**
         * CUserMessageDesiredTimescale blenddeltamultiplier.
         * @member {number} blenddeltamultiplier
         * @memberof CUserMessageDesiredTimescale
         * @instance
         */
        CUserMessageDesiredTimescale.prototype.blenddeltamultiplier = 0;
    
        /**
         * Creates a new CUserMessageDesiredTimescale instance using the specified properties.
         * @function create
         * @memberof CUserMessageDesiredTimescale
         * @static
         * @param {ICUserMessageDesiredTimescale=} [properties] Properties to set
         * @returns {CUserMessageDesiredTimescale} CUserMessageDesiredTimescale instance
         */
        CUserMessageDesiredTimescale.create = function create(properties) {
            return new CUserMessageDesiredTimescale(properties);
        };
    
        /**
         * Encodes the specified CUserMessageDesiredTimescale message. Does not implicitly {@link CUserMessageDesiredTimescale.verify|verify} messages.
         * @function encode
         * @memberof CUserMessageDesiredTimescale
         * @static
         * @param {ICUserMessageDesiredTimescale} message CUserMessageDesiredTimescale message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CUserMessageDesiredTimescale.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.desired != null && Object.hasOwnProperty.call(message, "desired"))
                writer.uint32(/* id 1, wireType 5 =*/13).float(message.desired);
            if (message.acceleration != null && Object.hasOwnProperty.call(message, "acceleration"))
                writer.uint32(/* id 2, wireType 5 =*/21).float(message.acceleration);
            if (message.minblendrate != null && Object.hasOwnProperty.call(message, "minblendrate"))
                writer.uint32(/* id 3, wireType 5 =*/29).float(message.minblendrate);
            if (message.blenddeltamultiplier != null && Object.hasOwnProperty.call(message, "blenddeltamultiplier"))
                writer.uint32(/* id 4, wireType 5 =*/37).float(message.blenddeltamultiplier);
            return writer;
        };
    
        /**
         * Encodes the specified CUserMessageDesiredTimescale message, length delimited. Does not implicitly {@link CUserMessageDesiredTimescale.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CUserMessageDesiredTimescale
         * @static
         * @param {ICUserMessageDesiredTimescale} message CUserMessageDesiredTimescale message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CUserMessageDesiredTimescale.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CUserMessageDesiredTimescale message from the specified reader or buffer.
         * @function decode
         * @memberof CUserMessageDesiredTimescale
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CUserMessageDesiredTimescale} CUserMessageDesiredTimescale
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CUserMessageDesiredTimescale.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CUserMessageDesiredTimescale();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.desired = reader.float();
                        break;
                    }
                case 2: {
                        message.acceleration = reader.float();
                        break;
                    }
                case 3: {
                        message.minblendrate = reader.float();
                        break;
                    }
                case 4: {
                        message.blenddeltamultiplier = reader.float();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CUserMessageDesiredTimescale message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CUserMessageDesiredTimescale
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CUserMessageDesiredTimescale} CUserMessageDesiredTimescale
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CUserMessageDesiredTimescale.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CUserMessageDesiredTimescale message.
         * @function verify
         * @memberof CUserMessageDesiredTimescale
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CUserMessageDesiredTimescale.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.desired != null && message.hasOwnProperty("desired"))
                if (typeof message.desired !== "number")
                    return "desired: number expected";
            if (message.acceleration != null && message.hasOwnProperty("acceleration"))
                if (typeof message.acceleration !== "number")
                    return "acceleration: number expected";
            if (message.minblendrate != null && message.hasOwnProperty("minblendrate"))
                if (typeof message.minblendrate !== "number")
                    return "minblendrate: number expected";
            if (message.blenddeltamultiplier != null && message.hasOwnProperty("blenddeltamultiplier"))
                if (typeof message.blenddeltamultiplier !== "number")
                    return "blenddeltamultiplier: number expected";
            return null;
        };
    
        /**
         * Creates a CUserMessageDesiredTimescale message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CUserMessageDesiredTimescale
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CUserMessageDesiredTimescale} CUserMessageDesiredTimescale
         */
        CUserMessageDesiredTimescale.fromObject = function fromObject(object) {
            if (object instanceof $root.CUserMessageDesiredTimescale)
                return object;
            var message = new $root.CUserMessageDesiredTimescale();
            if (object.desired != null)
                message.desired = Number(object.desired);
            if (object.acceleration != null)
                message.acceleration = Number(object.acceleration);
            if (object.minblendrate != null)
                message.minblendrate = Number(object.minblendrate);
            if (object.blenddeltamultiplier != null)
                message.blenddeltamultiplier = Number(object.blenddeltamultiplier);
            return message;
        };
    
        /**
         * Creates a plain object from a CUserMessageDesiredTimescale message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CUserMessageDesiredTimescale
         * @static
         * @param {CUserMessageDesiredTimescale} message CUserMessageDesiredTimescale
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CUserMessageDesiredTimescale.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.desired = 0;
                object.acceleration = 0;
                object.minblendrate = 0;
                object.blenddeltamultiplier = 0;
            }
            if (message.desired != null && message.hasOwnProperty("desired"))
                object.desired = options.json && !isFinite(message.desired) ? String(message.desired) : message.desired;
            if (message.acceleration != null && message.hasOwnProperty("acceleration"))
                object.acceleration = options.json && !isFinite(message.acceleration) ? String(message.acceleration) : message.acceleration;
            if (message.minblendrate != null && message.hasOwnProperty("minblendrate"))
                object.minblendrate = options.json && !isFinite(message.minblendrate) ? String(message.minblendrate) : message.minblendrate;
            if (message.blenddeltamultiplier != null && message.hasOwnProperty("blenddeltamultiplier"))
                object.blenddeltamultiplier = options.json && !isFinite(message.blenddeltamultiplier) ? String(message.blenddeltamultiplier) : message.blenddeltamultiplier;
            return object;
        };
    
        /**
         * Converts this CUserMessageDesiredTimescale to JSON.
         * @function toJSON
         * @memberof CUserMessageDesiredTimescale
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CUserMessageDesiredTimescale.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * Gets the default type url for CUserMessageDesiredTimescale
         * @function getTypeUrl
         * @memberof CUserMessageDesiredTimescale
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        CUserMessageDesiredTimescale.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/CUserMessageDesiredTimescale";
        };
    
        return CUserMessageDesiredTimescale;
    })();
    
    $root.CUserMessageFade = (function() {
    
        /**
         * Properties of a CUserMessageFade.
         * @exports ICUserMessageFade
         * @interface ICUserMessageFade
         * @property {number|null} [duration] CUserMessageFade duration
         * @property {number|null} [holdTime] CUserMessageFade holdTime
         * @property {number|null} [flags] CUserMessageFade flags
         * @property {number|null} [color] CUserMessageFade color
         */
    
        /**
         * Constructs a new CUserMessageFade.
         * @exports CUserMessageFade
         * @classdesc Represents a CUserMessageFade.
         * @implements ICUserMessageFade
         * @constructor
         * @param {ICUserMessageFade=} [properties] Properties to set
         */
        function CUserMessageFade(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CUserMessageFade duration.
         * @member {number} duration
         * @memberof CUserMessageFade
         * @instance
         */
        CUserMessageFade.prototype.duration = 0;
    
        /**
         * CUserMessageFade holdTime.
         * @member {number} holdTime
         * @memberof CUserMessageFade
         * @instance
         */
        CUserMessageFade.prototype.holdTime = 0;
    
        /**
         * CUserMessageFade flags.
         * @member {number} flags
         * @memberof CUserMessageFade
         * @instance
         */
        CUserMessageFade.prototype.flags = 0;
    
        /**
         * CUserMessageFade color.
         * @member {number} color
         * @memberof CUserMessageFade
         * @instance
         */
        CUserMessageFade.prototype.color = 0;
    
        /**
         * Creates a new CUserMessageFade instance using the specified properties.
         * @function create
         * @memberof CUserMessageFade
         * @static
         * @param {ICUserMessageFade=} [properties] Properties to set
         * @returns {CUserMessageFade} CUserMessageFade instance
         */
        CUserMessageFade.create = function create(properties) {
            return new CUserMessageFade(properties);
        };
    
        /**
         * Encodes the specified CUserMessageFade message. Does not implicitly {@link CUserMessageFade.verify|verify} messages.
         * @function encode
         * @memberof CUserMessageFade
         * @static
         * @param {ICUserMessageFade} message CUserMessageFade message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CUserMessageFade.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.duration != null && Object.hasOwnProperty.call(message, "duration"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.duration);
            if (message.holdTime != null && Object.hasOwnProperty.call(message, "holdTime"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.holdTime);
            if (message.flags != null && Object.hasOwnProperty.call(message, "flags"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.flags);
            if (message.color != null && Object.hasOwnProperty.call(message, "color"))
                writer.uint32(/* id 4, wireType 5 =*/37).fixed32(message.color);
            return writer;
        };
    
        /**
         * Encodes the specified CUserMessageFade message, length delimited. Does not implicitly {@link CUserMessageFade.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CUserMessageFade
         * @static
         * @param {ICUserMessageFade} message CUserMessageFade message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CUserMessageFade.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CUserMessageFade message from the specified reader or buffer.
         * @function decode
         * @memberof CUserMessageFade
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CUserMessageFade} CUserMessageFade
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CUserMessageFade.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CUserMessageFade();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.duration = reader.uint32();
                        break;
                    }
                case 2: {
                        message.holdTime = reader.uint32();
                        break;
                    }
                case 3: {
                        message.flags = reader.uint32();
                        break;
                    }
                case 4: {
                        message.color = reader.fixed32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CUserMessageFade message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CUserMessageFade
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CUserMessageFade} CUserMessageFade
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CUserMessageFade.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CUserMessageFade message.
         * @function verify
         * @memberof CUserMessageFade
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CUserMessageFade.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.duration != null && message.hasOwnProperty("duration"))
                if (!$util.isInteger(message.duration))
                    return "duration: integer expected";
            if (message.holdTime != null && message.hasOwnProperty("holdTime"))
                if (!$util.isInteger(message.holdTime))
                    return "holdTime: integer expected";
            if (message.flags != null && message.hasOwnProperty("flags"))
                if (!$util.isInteger(message.flags))
                    return "flags: integer expected";
            if (message.color != null && message.hasOwnProperty("color"))
                if (!$util.isInteger(message.color))
                    return "color: integer expected";
            return null;
        };
    
        /**
         * Creates a CUserMessageFade message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CUserMessageFade
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CUserMessageFade} CUserMessageFade
         */
        CUserMessageFade.fromObject = function fromObject(object) {
            if (object instanceof $root.CUserMessageFade)
                return object;
            var message = new $root.CUserMessageFade();
            if (object.duration != null)
                message.duration = object.duration >>> 0;
            if (object.holdTime != null)
                message.holdTime = object.holdTime >>> 0;
            if (object.flags != null)
                message.flags = object.flags >>> 0;
            if (object.color != null)
                message.color = object.color >>> 0;
            return message;
        };
    
        /**
         * Creates a plain object from a CUserMessageFade message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CUserMessageFade
         * @static
         * @param {CUserMessageFade} message CUserMessageFade
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CUserMessageFade.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.duration = 0;
                object.holdTime = 0;
                object.flags = 0;
                object.color = 0;
            }
            if (message.duration != null && message.hasOwnProperty("duration"))
                object.duration = message.duration;
            if (message.holdTime != null && message.hasOwnProperty("holdTime"))
                object.holdTime = message.holdTime;
            if (message.flags != null && message.hasOwnProperty("flags"))
                object.flags = message.flags;
            if (message.color != null && message.hasOwnProperty("color"))
                object.color = message.color;
            return object;
        };
    
        /**
         * Converts this CUserMessageFade to JSON.
         * @function toJSON
         * @memberof CUserMessageFade
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CUserMessageFade.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * Gets the default type url for CUserMessageFade
         * @function getTypeUrl
         * @memberof CUserMessageFade
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        CUserMessageFade.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/CUserMessageFade";
        };
    
        return CUserMessageFade;
    })();
    
    $root.CUserMessageShake = (function() {
    
        /**
         * Properties of a CUserMessageShake.
         * @exports ICUserMessageShake
         * @interface ICUserMessageShake
         * @property {number|null} [command] CUserMessageShake command
         * @property {number|null} [amplitude] CUserMessageShake amplitude
         * @property {number|null} [frequency] CUserMessageShake frequency
         * @property {number|null} [duration] CUserMessageShake duration
         */
    
        /**
         * Constructs a new CUserMessageShake.
         * @exports CUserMessageShake
         * @classdesc Represents a CUserMessageShake.
         * @implements ICUserMessageShake
         * @constructor
         * @param {ICUserMessageShake=} [properties] Properties to set
         */
        function CUserMessageShake(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CUserMessageShake command.
         * @member {number} command
         * @memberof CUserMessageShake
         * @instance
         */
        CUserMessageShake.prototype.command = 0;
    
        /**
         * CUserMessageShake amplitude.
         * @member {number} amplitude
         * @memberof CUserMessageShake
         * @instance
         */
        CUserMessageShake.prototype.amplitude = 0;
    
        /**
         * CUserMessageShake frequency.
         * @member {number} frequency
         * @memberof CUserMessageShake
         * @instance
         */
        CUserMessageShake.prototype.frequency = 0;
    
        /**
         * CUserMessageShake duration.
         * @member {number} duration
         * @memberof CUserMessageShake
         * @instance
         */
        CUserMessageShake.prototype.duration = 0;
    
        /**
         * Creates a new CUserMessageShake instance using the specified properties.
         * @function create
         * @memberof CUserMessageShake
         * @static
         * @param {ICUserMessageShake=} [properties] Properties to set
         * @returns {CUserMessageShake} CUserMessageShake instance
         */
        CUserMessageShake.create = function create(properties) {
            return new CUserMessageShake(properties);
        };
    
        /**
         * Encodes the specified CUserMessageShake message. Does not implicitly {@link CUserMessageShake.verify|verify} messages.
         * @function encode
         * @memberof CUserMessageShake
         * @static
         * @param {ICUserMessageShake} message CUserMessageShake message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CUserMessageShake.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.command != null && Object.hasOwnProperty.call(message, "command"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.command);
            if (message.amplitude != null && Object.hasOwnProperty.call(message, "amplitude"))
                writer.uint32(/* id 2, wireType 5 =*/21).float(message.amplitude);
            if (message.frequency != null && Object.hasOwnProperty.call(message, "frequency"))
                writer.uint32(/* id 3, wireType 5 =*/29).float(message.frequency);
            if (message.duration != null && Object.hasOwnProperty.call(message, "duration"))
                writer.uint32(/* id 4, wireType 5 =*/37).float(message.duration);
            return writer;
        };
    
        /**
         * Encodes the specified CUserMessageShake message, length delimited. Does not implicitly {@link CUserMessageShake.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CUserMessageShake
         * @static
         * @param {ICUserMessageShake} message CUserMessageShake message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CUserMessageShake.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CUserMessageShake message from the specified reader or buffer.
         * @function decode
         * @memberof CUserMessageShake
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CUserMessageShake} CUserMessageShake
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CUserMessageShake.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CUserMessageShake();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.command = reader.uint32();
                        break;
                    }
                case 2: {
                        message.amplitude = reader.float();
                        break;
                    }
                case 3: {
                        message.frequency = reader.float();
                        break;
                    }
                case 4: {
                        message.duration = reader.float();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CUserMessageShake message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CUserMessageShake
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CUserMessageShake} CUserMessageShake
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CUserMessageShake.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CUserMessageShake message.
         * @function verify
         * @memberof CUserMessageShake
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CUserMessageShake.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.command != null && message.hasOwnProperty("command"))
                if (!$util.isInteger(message.command))
                    return "command: integer expected";
            if (message.amplitude != null && message.hasOwnProperty("amplitude"))
                if (typeof message.amplitude !== "number")
                    return "amplitude: number expected";
            if (message.frequency != null && message.hasOwnProperty("frequency"))
                if (typeof message.frequency !== "number")
                    return "frequency: number expected";
            if (message.duration != null && message.hasOwnProperty("duration"))
                if (typeof message.duration !== "number")
                    return "duration: number expected";
            return null;
        };
    
        /**
         * Creates a CUserMessageShake message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CUserMessageShake
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CUserMessageShake} CUserMessageShake
         */
        CUserMessageShake.fromObject = function fromObject(object) {
            if (object instanceof $root.CUserMessageShake)
                return object;
            var message = new $root.CUserMessageShake();
            if (object.command != null)
                message.command = object.command >>> 0;
            if (object.amplitude != null)
                message.amplitude = Number(object.amplitude);
            if (object.frequency != null)
                message.frequency = Number(object.frequency);
            if (object.duration != null)
                message.duration = Number(object.duration);
            return message;
        };
    
        /**
         * Creates a plain object from a CUserMessageShake message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CUserMessageShake
         * @static
         * @param {CUserMessageShake} message CUserMessageShake
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CUserMessageShake.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.command = 0;
                object.amplitude = 0;
                object.frequency = 0;
                object.duration = 0;
            }
            if (message.command != null && message.hasOwnProperty("command"))
                object.command = message.command;
            if (message.amplitude != null && message.hasOwnProperty("amplitude"))
                object.amplitude = options.json && !isFinite(message.amplitude) ? String(message.amplitude) : message.amplitude;
            if (message.frequency != null && message.hasOwnProperty("frequency"))
                object.frequency = options.json && !isFinite(message.frequency) ? String(message.frequency) : message.frequency;
            if (message.duration != null && message.hasOwnProperty("duration"))
                object.duration = options.json && !isFinite(message.duration) ? String(message.duration) : message.duration;
            return object;
        };
    
        /**
         * Converts this CUserMessageShake to JSON.
         * @function toJSON
         * @memberof CUserMessageShake
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CUserMessageShake.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * Gets the default type url for CUserMessageShake
         * @function getTypeUrl
         * @memberof CUserMessageShake
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        CUserMessageShake.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/CUserMessageShake";
        };
    
        return CUserMessageShake;
    })();
    
    $root.CUserMessageShakeDir = (function() {
    
        /**
         * Properties of a CUserMessageShakeDir.
         * @exports ICUserMessageShakeDir
         * @interface ICUserMessageShakeDir
         * @property {ICUserMessageShake|null} [shake] CUserMessageShakeDir shake
         * @property {ICMsgVector|null} [direction] CUserMessageShakeDir direction
         */
    
        /**
         * Constructs a new CUserMessageShakeDir.
         * @exports CUserMessageShakeDir
         * @classdesc Represents a CUserMessageShakeDir.
         * @implements ICUserMessageShakeDir
         * @constructor
         * @param {ICUserMessageShakeDir=} [properties] Properties to set
         */
        function CUserMessageShakeDir(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CUserMessageShakeDir shake.
         * @member {ICUserMessageShake|null|undefined} shake
         * @memberof CUserMessageShakeDir
         * @instance
         */
        CUserMessageShakeDir.prototype.shake = null;
    
        /**
         * CUserMessageShakeDir direction.
         * @member {ICMsgVector|null|undefined} direction
         * @memberof CUserMessageShakeDir
         * @instance
         */
        CUserMessageShakeDir.prototype.direction = null;
    
        /**
         * Creates a new CUserMessageShakeDir instance using the specified properties.
         * @function create
         * @memberof CUserMessageShakeDir
         * @static
         * @param {ICUserMessageShakeDir=} [properties] Properties to set
         * @returns {CUserMessageShakeDir} CUserMessageShakeDir instance
         */
        CUserMessageShakeDir.create = function create(properties) {
            return new CUserMessageShakeDir(properties);
        };
    
        /**
         * Encodes the specified CUserMessageShakeDir message. Does not implicitly {@link CUserMessageShakeDir.verify|verify} messages.
         * @function encode
         * @memberof CUserMessageShakeDir
         * @static
         * @param {ICUserMessageShakeDir} message CUserMessageShakeDir message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CUserMessageShakeDir.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.shake != null && Object.hasOwnProperty.call(message, "shake"))
                $root.CUserMessageShake.encode(message.shake, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.direction != null && Object.hasOwnProperty.call(message, "direction"))
                $root.CMsgVector.encode(message.direction, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };
    
        /**
         * Encodes the specified CUserMessageShakeDir message, length delimited. Does not implicitly {@link CUserMessageShakeDir.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CUserMessageShakeDir
         * @static
         * @param {ICUserMessageShakeDir} message CUserMessageShakeDir message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CUserMessageShakeDir.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CUserMessageShakeDir message from the specified reader or buffer.
         * @function decode
         * @memberof CUserMessageShakeDir
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CUserMessageShakeDir} CUserMessageShakeDir
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CUserMessageShakeDir.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CUserMessageShakeDir();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.shake = $root.CUserMessageShake.decode(reader, reader.uint32());
                        break;
                    }
                case 2: {
                        message.direction = $root.CMsgVector.decode(reader, reader.uint32());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CUserMessageShakeDir message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CUserMessageShakeDir
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CUserMessageShakeDir} CUserMessageShakeDir
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CUserMessageShakeDir.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CUserMessageShakeDir message.
         * @function verify
         * @memberof CUserMessageShakeDir
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CUserMessageShakeDir.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.shake != null && message.hasOwnProperty("shake")) {
                var error = $root.CUserMessageShake.verify(message.shake);
                if (error)
                    return "shake." + error;
            }
            if (message.direction != null && message.hasOwnProperty("direction")) {
                var error = $root.CMsgVector.verify(message.direction);
                if (error)
                    return "direction." + error;
            }
            return null;
        };
    
        /**
         * Creates a CUserMessageShakeDir message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CUserMessageShakeDir
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CUserMessageShakeDir} CUserMessageShakeDir
         */
        CUserMessageShakeDir.fromObject = function fromObject(object) {
            if (object instanceof $root.CUserMessageShakeDir)
                return object;
            var message = new $root.CUserMessageShakeDir();
            if (object.shake != null) {
                if (typeof object.shake !== "object")
                    throw TypeError(".CUserMessageShakeDir.shake: object expected");
                message.shake = $root.CUserMessageShake.fromObject(object.shake);
            }
            if (object.direction != null) {
                if (typeof object.direction !== "object")
                    throw TypeError(".CUserMessageShakeDir.direction: object expected");
                message.direction = $root.CMsgVector.fromObject(object.direction);
            }
            return message;
        };
    
        /**
         * Creates a plain object from a CUserMessageShakeDir message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CUserMessageShakeDir
         * @static
         * @param {CUserMessageShakeDir} message CUserMessageShakeDir
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CUserMessageShakeDir.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.shake = null;
                object.direction = null;
            }
            if (message.shake != null && message.hasOwnProperty("shake"))
                object.shake = $root.CUserMessageShake.toObject(message.shake, options);
            if (message.direction != null && message.hasOwnProperty("direction"))
                object.direction = $root.CMsgVector.toObject(message.direction, options);
            return object;
        };
    
        /**
         * Converts this CUserMessageShakeDir to JSON.
         * @function toJSON
         * @memberof CUserMessageShakeDir
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CUserMessageShakeDir.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * Gets the default type url for CUserMessageShakeDir
         * @function getTypeUrl
         * @memberof CUserMessageShakeDir
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        CUserMessageShakeDir.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/CUserMessageShakeDir";
        };
    
        return CUserMessageShakeDir;
    })();
    
    $root.CUserMessageScreenTilt = (function() {
    
        /**
         * Properties of a CUserMessageScreenTilt.
         * @exports ICUserMessageScreenTilt
         * @interface ICUserMessageScreenTilt
         * @property {number|null} [command] CUserMessageScreenTilt command
         * @property {boolean|null} [easeInOut] CUserMessageScreenTilt easeInOut
         * @property {ICMsgVector|null} [angle] CUserMessageScreenTilt angle
         * @property {number|null} [duration] CUserMessageScreenTilt duration
         * @property {number|null} [time] CUserMessageScreenTilt time
         */
    
        /**
         * Constructs a new CUserMessageScreenTilt.
         * @exports CUserMessageScreenTilt
         * @classdesc Represents a CUserMessageScreenTilt.
         * @implements ICUserMessageScreenTilt
         * @constructor
         * @param {ICUserMessageScreenTilt=} [properties] Properties to set
         */
        function CUserMessageScreenTilt(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CUserMessageScreenTilt command.
         * @member {number} command
         * @memberof CUserMessageScreenTilt
         * @instance
         */
        CUserMessageScreenTilt.prototype.command = 0;
    
        /**
         * CUserMessageScreenTilt easeInOut.
         * @member {boolean} easeInOut
         * @memberof CUserMessageScreenTilt
         * @instance
         */
        CUserMessageScreenTilt.prototype.easeInOut = false;
    
        /**
         * CUserMessageScreenTilt angle.
         * @member {ICMsgVector|null|undefined} angle
         * @memberof CUserMessageScreenTilt
         * @instance
         */
        CUserMessageScreenTilt.prototype.angle = null;
    
        /**
         * CUserMessageScreenTilt duration.
         * @member {number} duration
         * @memberof CUserMessageScreenTilt
         * @instance
         */
        CUserMessageScreenTilt.prototype.duration = 0;
    
        /**
         * CUserMessageScreenTilt time.
         * @member {number} time
         * @memberof CUserMessageScreenTilt
         * @instance
         */
        CUserMessageScreenTilt.prototype.time = 0;
    
        /**
         * Creates a new CUserMessageScreenTilt instance using the specified properties.
         * @function create
         * @memberof CUserMessageScreenTilt
         * @static
         * @param {ICUserMessageScreenTilt=} [properties] Properties to set
         * @returns {CUserMessageScreenTilt} CUserMessageScreenTilt instance
         */
        CUserMessageScreenTilt.create = function create(properties) {
            return new CUserMessageScreenTilt(properties);
        };
    
        /**
         * Encodes the specified CUserMessageScreenTilt message. Does not implicitly {@link CUserMessageScreenTilt.verify|verify} messages.
         * @function encode
         * @memberof CUserMessageScreenTilt
         * @static
         * @param {ICUserMessageScreenTilt} message CUserMessageScreenTilt message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CUserMessageScreenTilt.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.command != null && Object.hasOwnProperty.call(message, "command"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.command);
            if (message.easeInOut != null && Object.hasOwnProperty.call(message, "easeInOut"))
                writer.uint32(/* id 2, wireType 0 =*/16).bool(message.easeInOut);
            if (message.angle != null && Object.hasOwnProperty.call(message, "angle"))
                $root.CMsgVector.encode(message.angle, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.duration != null && Object.hasOwnProperty.call(message, "duration"))
                writer.uint32(/* id 4, wireType 5 =*/37).float(message.duration);
            if (message.time != null && Object.hasOwnProperty.call(message, "time"))
                writer.uint32(/* id 5, wireType 5 =*/45).float(message.time);
            return writer;
        };
    
        /**
         * Encodes the specified CUserMessageScreenTilt message, length delimited. Does not implicitly {@link CUserMessageScreenTilt.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CUserMessageScreenTilt
         * @static
         * @param {ICUserMessageScreenTilt} message CUserMessageScreenTilt message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CUserMessageScreenTilt.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CUserMessageScreenTilt message from the specified reader or buffer.
         * @function decode
         * @memberof CUserMessageScreenTilt
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CUserMessageScreenTilt} CUserMessageScreenTilt
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CUserMessageScreenTilt.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CUserMessageScreenTilt();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.command = reader.uint32();
                        break;
                    }
                case 2: {
                        message.easeInOut = reader.bool();
                        break;
                    }
                case 3: {
                        message.angle = $root.CMsgVector.decode(reader, reader.uint32());
                        break;
                    }
                case 4: {
                        message.duration = reader.float();
                        break;
                    }
                case 5: {
                        message.time = reader.float();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CUserMessageScreenTilt message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CUserMessageScreenTilt
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CUserMessageScreenTilt} CUserMessageScreenTilt
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CUserMessageScreenTilt.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CUserMessageScreenTilt message.
         * @function verify
         * @memberof CUserMessageScreenTilt
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CUserMessageScreenTilt.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.command != null && message.hasOwnProperty("command"))
                if (!$util.isInteger(message.command))
                    return "command: integer expected";
            if (message.easeInOut != null && message.hasOwnProperty("easeInOut"))
                if (typeof message.easeInOut !== "boolean")
                    return "easeInOut: boolean expected";
            if (message.angle != null && message.hasOwnProperty("angle")) {
                var error = $root.CMsgVector.verify(message.angle);
                if (error)
                    return "angle." + error;
            }
            if (message.duration != null && message.hasOwnProperty("duration"))
                if (typeof message.duration !== "number")
                    return "duration: number expected";
            if (message.time != null && message.hasOwnProperty("time"))
                if (typeof message.time !== "number")
                    return "time: number expected";
            return null;
        };
    
        /**
         * Creates a CUserMessageScreenTilt message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CUserMessageScreenTilt
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CUserMessageScreenTilt} CUserMessageScreenTilt
         */
        CUserMessageScreenTilt.fromObject = function fromObject(object) {
            if (object instanceof $root.CUserMessageScreenTilt)
                return object;
            var message = new $root.CUserMessageScreenTilt();
            if (object.command != null)
                message.command = object.command >>> 0;
            if (object.easeInOut != null)
                message.easeInOut = Boolean(object.easeInOut);
            if (object.angle != null) {
                if (typeof object.angle !== "object")
                    throw TypeError(".CUserMessageScreenTilt.angle: object expected");
                message.angle = $root.CMsgVector.fromObject(object.angle);
            }
            if (object.duration != null)
                message.duration = Number(object.duration);
            if (object.time != null)
                message.time = Number(object.time);
            return message;
        };
    
        /**
         * Creates a plain object from a CUserMessageScreenTilt message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CUserMessageScreenTilt
         * @static
         * @param {CUserMessageScreenTilt} message CUserMessageScreenTilt
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CUserMessageScreenTilt.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.command = 0;
                object.easeInOut = false;
                object.angle = null;
                object.duration = 0;
                object.time = 0;
            }
            if (message.command != null && message.hasOwnProperty("command"))
                object.command = message.command;
            if (message.easeInOut != null && message.hasOwnProperty("easeInOut"))
                object.easeInOut = message.easeInOut;
            if (message.angle != null && message.hasOwnProperty("angle"))
                object.angle = $root.CMsgVector.toObject(message.angle, options);
            if (message.duration != null && message.hasOwnProperty("duration"))
                object.duration = options.json && !isFinite(message.duration) ? String(message.duration) : message.duration;
            if (message.time != null && message.hasOwnProperty("time"))
                object.time = options.json && !isFinite(message.time) ? String(message.time) : message.time;
            return object;
        };
    
        /**
         * Converts this CUserMessageScreenTilt to JSON.
         * @function toJSON
         * @memberof CUserMessageScreenTilt
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CUserMessageScreenTilt.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * Gets the default type url for CUserMessageScreenTilt
         * @function getTypeUrl
         * @memberof CUserMessageScreenTilt
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        CUserMessageScreenTilt.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/CUserMessageScreenTilt";
        };
    
        return CUserMessageScreenTilt;
    })();
    
    $root.CUserMessageSayText = (function() {
    
        /**
         * Properties of a CUserMessageSayText.
         * @exports ICUserMessageSayText
         * @interface ICUserMessageSayText
         * @property {number|null} [playerindex] CUserMessageSayText playerindex
         * @property {string|null} [text] CUserMessageSayText text
         * @property {boolean|null} [chat] CUserMessageSayText chat
         */
    
        /**
         * Constructs a new CUserMessageSayText.
         * @exports CUserMessageSayText
         * @classdesc Represents a CUserMessageSayText.
         * @implements ICUserMessageSayText
         * @constructor
         * @param {ICUserMessageSayText=} [properties] Properties to set
         */
        function CUserMessageSayText(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CUserMessageSayText playerindex.
         * @member {number} playerindex
         * @memberof CUserMessageSayText
         * @instance
         */
        CUserMessageSayText.prototype.playerindex = -1;
    
        /**
         * CUserMessageSayText text.
         * @member {string} text
         * @memberof CUserMessageSayText
         * @instance
         */
        CUserMessageSayText.prototype.text = "";
    
        /**
         * CUserMessageSayText chat.
         * @member {boolean} chat
         * @memberof CUserMessageSayText
         * @instance
         */
        CUserMessageSayText.prototype.chat = false;
    
        /**
         * Creates a new CUserMessageSayText instance using the specified properties.
         * @function create
         * @memberof CUserMessageSayText
         * @static
         * @param {ICUserMessageSayText=} [properties] Properties to set
         * @returns {CUserMessageSayText} CUserMessageSayText instance
         */
        CUserMessageSayText.create = function create(properties) {
            return new CUserMessageSayText(properties);
        };
    
        /**
         * Encodes the specified CUserMessageSayText message. Does not implicitly {@link CUserMessageSayText.verify|verify} messages.
         * @function encode
         * @memberof CUserMessageSayText
         * @static
         * @param {ICUserMessageSayText} message CUserMessageSayText message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CUserMessageSayText.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.playerindex != null && Object.hasOwnProperty.call(message, "playerindex"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.playerindex);
            if (message.text != null && Object.hasOwnProperty.call(message, "text"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.text);
            if (message.chat != null && Object.hasOwnProperty.call(message, "chat"))
                writer.uint32(/* id 3, wireType 0 =*/24).bool(message.chat);
            return writer;
        };
    
        /**
         * Encodes the specified CUserMessageSayText message, length delimited. Does not implicitly {@link CUserMessageSayText.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CUserMessageSayText
         * @static
         * @param {ICUserMessageSayText} message CUserMessageSayText message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CUserMessageSayText.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CUserMessageSayText message from the specified reader or buffer.
         * @function decode
         * @memberof CUserMessageSayText
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CUserMessageSayText} CUserMessageSayText
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CUserMessageSayText.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CUserMessageSayText();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.playerindex = reader.int32();
                        break;
                    }
                case 2: {
                        message.text = reader.string();
                        break;
                    }
                case 3: {
                        message.chat = reader.bool();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CUserMessageSayText message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CUserMessageSayText
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CUserMessageSayText} CUserMessageSayText
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CUserMessageSayText.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CUserMessageSayText message.
         * @function verify
         * @memberof CUserMessageSayText
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CUserMessageSayText.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.playerindex != null && message.hasOwnProperty("playerindex"))
                if (!$util.isInteger(message.playerindex))
                    return "playerindex: integer expected";
            if (message.text != null && message.hasOwnProperty("text"))
                if (!$util.isString(message.text))
                    return "text: string expected";
            if (message.chat != null && message.hasOwnProperty("chat"))
                if (typeof message.chat !== "boolean")
                    return "chat: boolean expected";
            return null;
        };
    
        /**
         * Creates a CUserMessageSayText message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CUserMessageSayText
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CUserMessageSayText} CUserMessageSayText
         */
        CUserMessageSayText.fromObject = function fromObject(object) {
            if (object instanceof $root.CUserMessageSayText)
                return object;
            var message = new $root.CUserMessageSayText();
            if (object.playerindex != null)
                message.playerindex = object.playerindex | 0;
            if (object.text != null)
                message.text = String(object.text);
            if (object.chat != null)
                message.chat = Boolean(object.chat);
            return message;
        };
    
        /**
         * Creates a plain object from a CUserMessageSayText message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CUserMessageSayText
         * @static
         * @param {CUserMessageSayText} message CUserMessageSayText
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CUserMessageSayText.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.playerindex = -1;
                object.text = "";
                object.chat = false;
            }
            if (message.playerindex != null && message.hasOwnProperty("playerindex"))
                object.playerindex = message.playerindex;
            if (message.text != null && message.hasOwnProperty("text"))
                object.text = message.text;
            if (message.chat != null && message.hasOwnProperty("chat"))
                object.chat = message.chat;
            return object;
        };
    
        /**
         * Converts this CUserMessageSayText to JSON.
         * @function toJSON
         * @memberof CUserMessageSayText
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CUserMessageSayText.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * Gets the default type url for CUserMessageSayText
         * @function getTypeUrl
         * @memberof CUserMessageSayText
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        CUserMessageSayText.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/CUserMessageSayText";
        };
    
        return CUserMessageSayText;
    })();
    
    $root.CUserMessageSayText2 = (function() {
    
        /**
         * Properties of a CUserMessageSayText2.
         * @exports ICUserMessageSayText2
         * @interface ICUserMessageSayText2
         * @property {number|null} [entityindex] CUserMessageSayText2 entityindex
         * @property {boolean|null} [chat] CUserMessageSayText2 chat
         * @property {string|null} [messagename] CUserMessageSayText2 messagename
         * @property {string|null} [param1] CUserMessageSayText2 param1
         * @property {string|null} [param2] CUserMessageSayText2 param2
         * @property {string|null} [param3] CUserMessageSayText2 param3
         * @property {string|null} [param4] CUserMessageSayText2 param4
         */
    
        /**
         * Constructs a new CUserMessageSayText2.
         * @exports CUserMessageSayText2
         * @classdesc Represents a CUserMessageSayText2.
         * @implements ICUserMessageSayText2
         * @constructor
         * @param {ICUserMessageSayText2=} [properties] Properties to set
         */
        function CUserMessageSayText2(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CUserMessageSayText2 entityindex.
         * @member {number} entityindex
         * @memberof CUserMessageSayText2
         * @instance
         */
        CUserMessageSayText2.prototype.entityindex = -1;
    
        /**
         * CUserMessageSayText2 chat.
         * @member {boolean} chat
         * @memberof CUserMessageSayText2
         * @instance
         */
        CUserMessageSayText2.prototype.chat = false;
    
        /**
         * CUserMessageSayText2 messagename.
         * @member {string} messagename
         * @memberof CUserMessageSayText2
         * @instance
         */
        CUserMessageSayText2.prototype.messagename = "";
    
        /**
         * CUserMessageSayText2 param1.
         * @member {string} param1
         * @memberof CUserMessageSayText2
         * @instance
         */
        CUserMessageSayText2.prototype.param1 = "";
    
        /**
         * CUserMessageSayText2 param2.
         * @member {string} param2
         * @memberof CUserMessageSayText2
         * @instance
         */
        CUserMessageSayText2.prototype.param2 = "";
    
        /**
         * CUserMessageSayText2 param3.
         * @member {string} param3
         * @memberof CUserMessageSayText2
         * @instance
         */
        CUserMessageSayText2.prototype.param3 = "";
    
        /**
         * CUserMessageSayText2 param4.
         * @member {string} param4
         * @memberof CUserMessageSayText2
         * @instance
         */
        CUserMessageSayText2.prototype.param4 = "";
    
        /**
         * Creates a new CUserMessageSayText2 instance using the specified properties.
         * @function create
         * @memberof CUserMessageSayText2
         * @static
         * @param {ICUserMessageSayText2=} [properties] Properties to set
         * @returns {CUserMessageSayText2} CUserMessageSayText2 instance
         */
        CUserMessageSayText2.create = function create(properties) {
            return new CUserMessageSayText2(properties);
        };
    
        /**
         * Encodes the specified CUserMessageSayText2 message. Does not implicitly {@link CUserMessageSayText2.verify|verify} messages.
         * @function encode
         * @memberof CUserMessageSayText2
         * @static
         * @param {ICUserMessageSayText2} message CUserMessageSayText2 message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CUserMessageSayText2.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.entityindex != null && Object.hasOwnProperty.call(message, "entityindex"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.entityindex);
            if (message.chat != null && Object.hasOwnProperty.call(message, "chat"))
                writer.uint32(/* id 2, wireType 0 =*/16).bool(message.chat);
            if (message.messagename != null && Object.hasOwnProperty.call(message, "messagename"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.messagename);
            if (message.param1 != null && Object.hasOwnProperty.call(message, "param1"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.param1);
            if (message.param2 != null && Object.hasOwnProperty.call(message, "param2"))
                writer.uint32(/* id 5, wireType 2 =*/42).string(message.param2);
            if (message.param3 != null && Object.hasOwnProperty.call(message, "param3"))
                writer.uint32(/* id 6, wireType 2 =*/50).string(message.param3);
            if (message.param4 != null && Object.hasOwnProperty.call(message, "param4"))
                writer.uint32(/* id 7, wireType 2 =*/58).string(message.param4);
            return writer;
        };
    
        /**
         * Encodes the specified CUserMessageSayText2 message, length delimited. Does not implicitly {@link CUserMessageSayText2.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CUserMessageSayText2
         * @static
         * @param {ICUserMessageSayText2} message CUserMessageSayText2 message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CUserMessageSayText2.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CUserMessageSayText2 message from the specified reader or buffer.
         * @function decode
         * @memberof CUserMessageSayText2
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CUserMessageSayText2} CUserMessageSayText2
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CUserMessageSayText2.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CUserMessageSayText2();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.entityindex = reader.int32();
                        break;
                    }
                case 2: {
                        message.chat = reader.bool();
                        break;
                    }
                case 3: {
                        message.messagename = reader.string();
                        break;
                    }
                case 4: {
                        message.param1 = reader.string();
                        break;
                    }
                case 5: {
                        message.param2 = reader.string();
                        break;
                    }
                case 6: {
                        message.param3 = reader.string();
                        break;
                    }
                case 7: {
                        message.param4 = reader.string();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CUserMessageSayText2 message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CUserMessageSayText2
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CUserMessageSayText2} CUserMessageSayText2
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CUserMessageSayText2.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CUserMessageSayText2 message.
         * @function verify
         * @memberof CUserMessageSayText2
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CUserMessageSayText2.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.entityindex != null && message.hasOwnProperty("entityindex"))
                if (!$util.isInteger(message.entityindex))
                    return "entityindex: integer expected";
            if (message.chat != null && message.hasOwnProperty("chat"))
                if (typeof message.chat !== "boolean")
                    return "chat: boolean expected";
            if (message.messagename != null && message.hasOwnProperty("messagename"))
                if (!$util.isString(message.messagename))
                    return "messagename: string expected";
            if (message.param1 != null && message.hasOwnProperty("param1"))
                if (!$util.isString(message.param1))
                    return "param1: string expected";
            if (message.param2 != null && message.hasOwnProperty("param2"))
                if (!$util.isString(message.param2))
                    return "param2: string expected";
            if (message.param3 != null && message.hasOwnProperty("param3"))
                if (!$util.isString(message.param3))
                    return "param3: string expected";
            if (message.param4 != null && message.hasOwnProperty("param4"))
                if (!$util.isString(message.param4))
                    return "param4: string expected";
            return null;
        };
    
        /**
         * Creates a CUserMessageSayText2 message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CUserMessageSayText2
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CUserMessageSayText2} CUserMessageSayText2
         */
        CUserMessageSayText2.fromObject = function fromObject(object) {
            if (object instanceof $root.CUserMessageSayText2)
                return object;
            var message = new $root.CUserMessageSayText2();
            if (object.entityindex != null)
                message.entityindex = object.entityindex | 0;
            if (object.chat != null)
                message.chat = Boolean(object.chat);
            if (object.messagename != null)
                message.messagename = String(object.messagename);
            if (object.param1 != null)
                message.param1 = String(object.param1);
            if (object.param2 != null)
                message.param2 = String(object.param2);
            if (object.param3 != null)
                message.param3 = String(object.param3);
            if (object.param4 != null)
                message.param4 = String(object.param4);
            return message;
        };
    
        /**
         * Creates a plain object from a CUserMessageSayText2 message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CUserMessageSayText2
         * @static
         * @param {CUserMessageSayText2} message CUserMessageSayText2
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CUserMessageSayText2.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.entityindex = -1;
                object.chat = false;
                object.messagename = "";
                object.param1 = "";
                object.param2 = "";
                object.param3 = "";
                object.param4 = "";
            }
            if (message.entityindex != null && message.hasOwnProperty("entityindex"))
                object.entityindex = message.entityindex;
            if (message.chat != null && message.hasOwnProperty("chat"))
                object.chat = message.chat;
            if (message.messagename != null && message.hasOwnProperty("messagename"))
                object.messagename = message.messagename;
            if (message.param1 != null && message.hasOwnProperty("param1"))
                object.param1 = message.param1;
            if (message.param2 != null && message.hasOwnProperty("param2"))
                object.param2 = message.param2;
            if (message.param3 != null && message.hasOwnProperty("param3"))
                object.param3 = message.param3;
            if (message.param4 != null && message.hasOwnProperty("param4"))
                object.param4 = message.param4;
            return object;
        };
    
        /**
         * Converts this CUserMessageSayText2 to JSON.
         * @function toJSON
         * @memberof CUserMessageSayText2
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CUserMessageSayText2.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * Gets the default type url for CUserMessageSayText2
         * @function getTypeUrl
         * @memberof CUserMessageSayText2
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        CUserMessageSayText2.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/CUserMessageSayText2";
        };
    
        return CUserMessageSayText2;
    })();
    
    $root.CUserMessageHudMsg = (function() {
    
        /**
         * Properties of a CUserMessageHudMsg.
         * @exports ICUserMessageHudMsg
         * @interface ICUserMessageHudMsg
         * @property {number|null} [channel] CUserMessageHudMsg channel
         * @property {number|null} [x] CUserMessageHudMsg x
         * @property {number|null} [y] CUserMessageHudMsg y
         * @property {number|null} [color1] CUserMessageHudMsg color1
         * @property {number|null} [color2] CUserMessageHudMsg color2
         * @property {number|null} [effect] CUserMessageHudMsg effect
         * @property {string|null} [message] CUserMessageHudMsg message
         */
    
        /**
         * Constructs a new CUserMessageHudMsg.
         * @exports CUserMessageHudMsg
         * @classdesc Represents a CUserMessageHudMsg.
         * @implements ICUserMessageHudMsg
         * @constructor
         * @param {ICUserMessageHudMsg=} [properties] Properties to set
         */
        function CUserMessageHudMsg(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CUserMessageHudMsg channel.
         * @member {number} channel
         * @memberof CUserMessageHudMsg
         * @instance
         */
        CUserMessageHudMsg.prototype.channel = 0;
    
        /**
         * CUserMessageHudMsg x.
         * @member {number} x
         * @memberof CUserMessageHudMsg
         * @instance
         */
        CUserMessageHudMsg.prototype.x = 0;
    
        /**
         * CUserMessageHudMsg y.
         * @member {number} y
         * @memberof CUserMessageHudMsg
         * @instance
         */
        CUserMessageHudMsg.prototype.y = 0;
    
        /**
         * CUserMessageHudMsg color1.
         * @member {number} color1
         * @memberof CUserMessageHudMsg
         * @instance
         */
        CUserMessageHudMsg.prototype.color1 = 0;
    
        /**
         * CUserMessageHudMsg color2.
         * @member {number} color2
         * @memberof CUserMessageHudMsg
         * @instance
         */
        CUserMessageHudMsg.prototype.color2 = 0;
    
        /**
         * CUserMessageHudMsg effect.
         * @member {number} effect
         * @memberof CUserMessageHudMsg
         * @instance
         */
        CUserMessageHudMsg.prototype.effect = 0;
    
        /**
         * CUserMessageHudMsg message.
         * @member {string} message
         * @memberof CUserMessageHudMsg
         * @instance
         */
        CUserMessageHudMsg.prototype.message = "";
    
        /**
         * Creates a new CUserMessageHudMsg instance using the specified properties.
         * @function create
         * @memberof CUserMessageHudMsg
         * @static
         * @param {ICUserMessageHudMsg=} [properties] Properties to set
         * @returns {CUserMessageHudMsg} CUserMessageHudMsg instance
         */
        CUserMessageHudMsg.create = function create(properties) {
            return new CUserMessageHudMsg(properties);
        };
    
        /**
         * Encodes the specified CUserMessageHudMsg message. Does not implicitly {@link CUserMessageHudMsg.verify|verify} messages.
         * @function encode
         * @memberof CUserMessageHudMsg
         * @static
         * @param {ICUserMessageHudMsg} message CUserMessageHudMsg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CUserMessageHudMsg.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.channel != null && Object.hasOwnProperty.call(message, "channel"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.channel);
            if (message.x != null && Object.hasOwnProperty.call(message, "x"))
                writer.uint32(/* id 2, wireType 5 =*/21).float(message.x);
            if (message.y != null && Object.hasOwnProperty.call(message, "y"))
                writer.uint32(/* id 3, wireType 5 =*/29).float(message.y);
            if (message.color1 != null && Object.hasOwnProperty.call(message, "color1"))
                writer.uint32(/* id 4, wireType 5 =*/37).fixed32(message.color1);
            if (message.color2 != null && Object.hasOwnProperty.call(message, "color2"))
                writer.uint32(/* id 5, wireType 5 =*/45).fixed32(message.color2);
            if (message.effect != null && Object.hasOwnProperty.call(message, "effect"))
                writer.uint32(/* id 6, wireType 0 =*/48).uint32(message.effect);
            if (message.message != null && Object.hasOwnProperty.call(message, "message"))
                writer.uint32(/* id 11, wireType 2 =*/90).string(message.message);
            return writer;
        };
    
        /**
         * Encodes the specified CUserMessageHudMsg message, length delimited. Does not implicitly {@link CUserMessageHudMsg.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CUserMessageHudMsg
         * @static
         * @param {ICUserMessageHudMsg} message CUserMessageHudMsg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CUserMessageHudMsg.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CUserMessageHudMsg message from the specified reader or buffer.
         * @function decode
         * @memberof CUserMessageHudMsg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CUserMessageHudMsg} CUserMessageHudMsg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CUserMessageHudMsg.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CUserMessageHudMsg();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.channel = reader.uint32();
                        break;
                    }
                case 2: {
                        message.x = reader.float();
                        break;
                    }
                case 3: {
                        message.y = reader.float();
                        break;
                    }
                case 4: {
                        message.color1 = reader.fixed32();
                        break;
                    }
                case 5: {
                        message.color2 = reader.fixed32();
                        break;
                    }
                case 6: {
                        message.effect = reader.uint32();
                        break;
                    }
                case 11: {
                        message.message = reader.string();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CUserMessageHudMsg message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CUserMessageHudMsg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CUserMessageHudMsg} CUserMessageHudMsg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CUserMessageHudMsg.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CUserMessageHudMsg message.
         * @function verify
         * @memberof CUserMessageHudMsg
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CUserMessageHudMsg.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.channel != null && message.hasOwnProperty("channel"))
                if (!$util.isInteger(message.channel))
                    return "channel: integer expected";
            if (message.x != null && message.hasOwnProperty("x"))
                if (typeof message.x !== "number")
                    return "x: number expected";
            if (message.y != null && message.hasOwnProperty("y"))
                if (typeof message.y !== "number")
                    return "y: number expected";
            if (message.color1 != null && message.hasOwnProperty("color1"))
                if (!$util.isInteger(message.color1))
                    return "color1: integer expected";
            if (message.color2 != null && message.hasOwnProperty("color2"))
                if (!$util.isInteger(message.color2))
                    return "color2: integer expected";
            if (message.effect != null && message.hasOwnProperty("effect"))
                if (!$util.isInteger(message.effect))
                    return "effect: integer expected";
            if (message.message != null && message.hasOwnProperty("message"))
                if (!$util.isString(message.message))
                    return "message: string expected";
            return null;
        };
    
        /**
         * Creates a CUserMessageHudMsg message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CUserMessageHudMsg
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CUserMessageHudMsg} CUserMessageHudMsg
         */
        CUserMessageHudMsg.fromObject = function fromObject(object) {
            if (object instanceof $root.CUserMessageHudMsg)
                return object;
            var message = new $root.CUserMessageHudMsg();
            if (object.channel != null)
                message.channel = object.channel >>> 0;
            if (object.x != null)
                message.x = Number(object.x);
            if (object.y != null)
                message.y = Number(object.y);
            if (object.color1 != null)
                message.color1 = object.color1 >>> 0;
            if (object.color2 != null)
                message.color2 = object.color2 >>> 0;
            if (object.effect != null)
                message.effect = object.effect >>> 0;
            if (object.message != null)
                message.message = String(object.message);
            return message;
        };
    
        /**
         * Creates a plain object from a CUserMessageHudMsg message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CUserMessageHudMsg
         * @static
         * @param {CUserMessageHudMsg} message CUserMessageHudMsg
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CUserMessageHudMsg.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.channel = 0;
                object.x = 0;
                object.y = 0;
                object.color1 = 0;
                object.color2 = 0;
                object.effect = 0;
                object.message = "";
            }
            if (message.channel != null && message.hasOwnProperty("channel"))
                object.channel = message.channel;
            if (message.x != null && message.hasOwnProperty("x"))
                object.x = options.json && !isFinite(message.x) ? String(message.x) : message.x;
            if (message.y != null && message.hasOwnProperty("y"))
                object.y = options.json && !isFinite(message.y) ? String(message.y) : message.y;
            if (message.color1 != null && message.hasOwnProperty("color1"))
                object.color1 = message.color1;
            if (message.color2 != null && message.hasOwnProperty("color2"))
                object.color2 = message.color2;
            if (message.effect != null && message.hasOwnProperty("effect"))
                object.effect = message.effect;
            if (message.message != null && message.hasOwnProperty("message"))
                object.message = message.message;
            return object;
        };
    
        /**
         * Converts this CUserMessageHudMsg to JSON.
         * @function toJSON
         * @memberof CUserMessageHudMsg
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CUserMessageHudMsg.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * Gets the default type url for CUserMessageHudMsg
         * @function getTypeUrl
         * @memberof CUserMessageHudMsg
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        CUserMessageHudMsg.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/CUserMessageHudMsg";
        };
    
        return CUserMessageHudMsg;
    })();
    
    $root.CUserMessageHudText = (function() {
    
        /**
         * Properties of a CUserMessageHudText.
         * @exports ICUserMessageHudText
         * @interface ICUserMessageHudText
         * @property {string|null} [message] CUserMessageHudText message
         */
    
        /**
         * Constructs a new CUserMessageHudText.
         * @exports CUserMessageHudText
         * @classdesc Represents a CUserMessageHudText.
         * @implements ICUserMessageHudText
         * @constructor
         * @param {ICUserMessageHudText=} [properties] Properties to set
         */
        function CUserMessageHudText(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CUserMessageHudText message.
         * @member {string} message
         * @memberof CUserMessageHudText
         * @instance
         */
        CUserMessageHudText.prototype.message = "";
    
        /**
         * Creates a new CUserMessageHudText instance using the specified properties.
         * @function create
         * @memberof CUserMessageHudText
         * @static
         * @param {ICUserMessageHudText=} [properties] Properties to set
         * @returns {CUserMessageHudText} CUserMessageHudText instance
         */
        CUserMessageHudText.create = function create(properties) {
            return new CUserMessageHudText(properties);
        };
    
        /**
         * Encodes the specified CUserMessageHudText message. Does not implicitly {@link CUserMessageHudText.verify|verify} messages.
         * @function encode
         * @memberof CUserMessageHudText
         * @static
         * @param {ICUserMessageHudText} message CUserMessageHudText message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CUserMessageHudText.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.message != null && Object.hasOwnProperty.call(message, "message"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.message);
            return writer;
        };
    
        /**
         * Encodes the specified CUserMessageHudText message, length delimited. Does not implicitly {@link CUserMessageHudText.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CUserMessageHudText
         * @static
         * @param {ICUserMessageHudText} message CUserMessageHudText message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CUserMessageHudText.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CUserMessageHudText message from the specified reader or buffer.
         * @function decode
         * @memberof CUserMessageHudText
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CUserMessageHudText} CUserMessageHudText
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CUserMessageHudText.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CUserMessageHudText();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.message = reader.string();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CUserMessageHudText message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CUserMessageHudText
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CUserMessageHudText} CUserMessageHudText
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CUserMessageHudText.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CUserMessageHudText message.
         * @function verify
         * @memberof CUserMessageHudText
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CUserMessageHudText.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.message != null && message.hasOwnProperty("message"))
                if (!$util.isString(message.message))
                    return "message: string expected";
            return null;
        };
    
        /**
         * Creates a CUserMessageHudText message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CUserMessageHudText
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CUserMessageHudText} CUserMessageHudText
         */
        CUserMessageHudText.fromObject = function fromObject(object) {
            if (object instanceof $root.CUserMessageHudText)
                return object;
            var message = new $root.CUserMessageHudText();
            if (object.message != null)
                message.message = String(object.message);
            return message;
        };
    
        /**
         * Creates a plain object from a CUserMessageHudText message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CUserMessageHudText
         * @static
         * @param {CUserMessageHudText} message CUserMessageHudText
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CUserMessageHudText.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.message = "";
            if (message.message != null && message.hasOwnProperty("message"))
                object.message = message.message;
            return object;
        };
    
        /**
         * Converts this CUserMessageHudText to JSON.
         * @function toJSON
         * @memberof CUserMessageHudText
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CUserMessageHudText.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * Gets the default type url for CUserMessageHudText
         * @function getTypeUrl
         * @memberof CUserMessageHudText
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        CUserMessageHudText.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/CUserMessageHudText";
        };
    
        return CUserMessageHudText;
    })();
    
    $root.CUserMessageTextMsg = (function() {
    
        /**
         * Properties of a CUserMessageTextMsg.
         * @exports ICUserMessageTextMsg
         * @interface ICUserMessageTextMsg
         * @property {number|null} [dest] CUserMessageTextMsg dest
         * @property {Array.<string>|null} [param] CUserMessageTextMsg param
         */
    
        /**
         * Constructs a new CUserMessageTextMsg.
         * @exports CUserMessageTextMsg
         * @classdesc Represents a CUserMessageTextMsg.
         * @implements ICUserMessageTextMsg
         * @constructor
         * @param {ICUserMessageTextMsg=} [properties] Properties to set
         */
        function CUserMessageTextMsg(properties) {
            this.param = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CUserMessageTextMsg dest.
         * @member {number} dest
         * @memberof CUserMessageTextMsg
         * @instance
         */
        CUserMessageTextMsg.prototype.dest = 0;
    
        /**
         * CUserMessageTextMsg param.
         * @member {Array.<string>} param
         * @memberof CUserMessageTextMsg
         * @instance
         */
        CUserMessageTextMsg.prototype.param = $util.emptyArray;
    
        /**
         * Creates a new CUserMessageTextMsg instance using the specified properties.
         * @function create
         * @memberof CUserMessageTextMsg
         * @static
         * @param {ICUserMessageTextMsg=} [properties] Properties to set
         * @returns {CUserMessageTextMsg} CUserMessageTextMsg instance
         */
        CUserMessageTextMsg.create = function create(properties) {
            return new CUserMessageTextMsg(properties);
        };
    
        /**
         * Encodes the specified CUserMessageTextMsg message. Does not implicitly {@link CUserMessageTextMsg.verify|verify} messages.
         * @function encode
         * @memberof CUserMessageTextMsg
         * @static
         * @param {ICUserMessageTextMsg} message CUserMessageTextMsg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CUserMessageTextMsg.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.dest != null && Object.hasOwnProperty.call(message, "dest"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.dest);
            if (message.param != null && message.param.length)
                for (var i = 0; i < message.param.length; ++i)
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.param[i]);
            return writer;
        };
    
        /**
         * Encodes the specified CUserMessageTextMsg message, length delimited. Does not implicitly {@link CUserMessageTextMsg.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CUserMessageTextMsg
         * @static
         * @param {ICUserMessageTextMsg} message CUserMessageTextMsg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CUserMessageTextMsg.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CUserMessageTextMsg message from the specified reader or buffer.
         * @function decode
         * @memberof CUserMessageTextMsg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CUserMessageTextMsg} CUserMessageTextMsg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CUserMessageTextMsg.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CUserMessageTextMsg();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.dest = reader.uint32();
                        break;
                    }
                case 2: {
                        if (!(message.param && message.param.length))
                            message.param = [];
                        message.param.push(reader.string());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CUserMessageTextMsg message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CUserMessageTextMsg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CUserMessageTextMsg} CUserMessageTextMsg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CUserMessageTextMsg.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CUserMessageTextMsg message.
         * @function verify
         * @memberof CUserMessageTextMsg
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CUserMessageTextMsg.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.dest != null && message.hasOwnProperty("dest"))
                if (!$util.isInteger(message.dest))
                    return "dest: integer expected";
            if (message.param != null && message.hasOwnProperty("param")) {
                if (!Array.isArray(message.param))
                    return "param: array expected";
                for (var i = 0; i < message.param.length; ++i)
                    if (!$util.isString(message.param[i]))
                        return "param: string[] expected";
            }
            return null;
        };
    
        /**
         * Creates a CUserMessageTextMsg message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CUserMessageTextMsg
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CUserMessageTextMsg} CUserMessageTextMsg
         */
        CUserMessageTextMsg.fromObject = function fromObject(object) {
            if (object instanceof $root.CUserMessageTextMsg)
                return object;
            var message = new $root.CUserMessageTextMsg();
            if (object.dest != null)
                message.dest = object.dest >>> 0;
            if (object.param) {
                if (!Array.isArray(object.param))
                    throw TypeError(".CUserMessageTextMsg.param: array expected");
                message.param = [];
                for (var i = 0; i < object.param.length; ++i)
                    message.param[i] = String(object.param[i]);
            }
            return message;
        };
    
        /**
         * Creates a plain object from a CUserMessageTextMsg message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CUserMessageTextMsg
         * @static
         * @param {CUserMessageTextMsg} message CUserMessageTextMsg
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CUserMessageTextMsg.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.param = [];
            if (options.defaults)
                object.dest = 0;
            if (message.dest != null && message.hasOwnProperty("dest"))
                object.dest = message.dest;
            if (message.param && message.param.length) {
                object.param = [];
                for (var j = 0; j < message.param.length; ++j)
                    object.param[j] = message.param[j];
            }
            return object;
        };
    
        /**
         * Converts this CUserMessageTextMsg to JSON.
         * @function toJSON
         * @memberof CUserMessageTextMsg
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CUserMessageTextMsg.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * Gets the default type url for CUserMessageTextMsg
         * @function getTypeUrl
         * @memberof CUserMessageTextMsg
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        CUserMessageTextMsg.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/CUserMessageTextMsg";
        };
    
        return CUserMessageTextMsg;
    })();
    
    $root.CUserMessageGameTitle = (function() {
    
        /**
         * Properties of a CUserMessageGameTitle.
         * @exports ICUserMessageGameTitle
         * @interface ICUserMessageGameTitle
         */
    
        /**
         * Constructs a new CUserMessageGameTitle.
         * @exports CUserMessageGameTitle
         * @classdesc Represents a CUserMessageGameTitle.
         * @implements ICUserMessageGameTitle
         * @constructor
         * @param {ICUserMessageGameTitle=} [properties] Properties to set
         */
        function CUserMessageGameTitle(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * Creates a new CUserMessageGameTitle instance using the specified properties.
         * @function create
         * @memberof CUserMessageGameTitle
         * @static
         * @param {ICUserMessageGameTitle=} [properties] Properties to set
         * @returns {CUserMessageGameTitle} CUserMessageGameTitle instance
         */
        CUserMessageGameTitle.create = function create(properties) {
            return new CUserMessageGameTitle(properties);
        };
    
        /**
         * Encodes the specified CUserMessageGameTitle message. Does not implicitly {@link CUserMessageGameTitle.verify|verify} messages.
         * @function encode
         * @memberof CUserMessageGameTitle
         * @static
         * @param {ICUserMessageGameTitle} message CUserMessageGameTitle message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CUserMessageGameTitle.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };
    
        /**
         * Encodes the specified CUserMessageGameTitle message, length delimited. Does not implicitly {@link CUserMessageGameTitle.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CUserMessageGameTitle
         * @static
         * @param {ICUserMessageGameTitle} message CUserMessageGameTitle message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CUserMessageGameTitle.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CUserMessageGameTitle message from the specified reader or buffer.
         * @function decode
         * @memberof CUserMessageGameTitle
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CUserMessageGameTitle} CUserMessageGameTitle
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CUserMessageGameTitle.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CUserMessageGameTitle();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CUserMessageGameTitle message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CUserMessageGameTitle
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CUserMessageGameTitle} CUserMessageGameTitle
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CUserMessageGameTitle.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CUserMessageGameTitle message.
         * @function verify
         * @memberof CUserMessageGameTitle
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CUserMessageGameTitle.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };
    
        /**
         * Creates a CUserMessageGameTitle message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CUserMessageGameTitle
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CUserMessageGameTitle} CUserMessageGameTitle
         */
        CUserMessageGameTitle.fromObject = function fromObject(object) {
            if (object instanceof $root.CUserMessageGameTitle)
                return object;
            return new $root.CUserMessageGameTitle();
        };
    
        /**
         * Creates a plain object from a CUserMessageGameTitle message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CUserMessageGameTitle
         * @static
         * @param {CUserMessageGameTitle} message CUserMessageGameTitle
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CUserMessageGameTitle.toObject = function toObject() {
            return {};
        };
    
        /**
         * Converts this CUserMessageGameTitle to JSON.
         * @function toJSON
         * @memberof CUserMessageGameTitle
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CUserMessageGameTitle.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * Gets the default type url for CUserMessageGameTitle
         * @function getTypeUrl
         * @memberof CUserMessageGameTitle
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        CUserMessageGameTitle.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/CUserMessageGameTitle";
        };
    
        return CUserMessageGameTitle;
    })();
    
    $root.CUserMessageResetHUD = (function() {
    
        /**
         * Properties of a CUserMessageResetHUD.
         * @exports ICUserMessageResetHUD
         * @interface ICUserMessageResetHUD
         */
    
        /**
         * Constructs a new CUserMessageResetHUD.
         * @exports CUserMessageResetHUD
         * @classdesc Represents a CUserMessageResetHUD.
         * @implements ICUserMessageResetHUD
         * @constructor
         * @param {ICUserMessageResetHUD=} [properties] Properties to set
         */
        function CUserMessageResetHUD(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * Creates a new CUserMessageResetHUD instance using the specified properties.
         * @function create
         * @memberof CUserMessageResetHUD
         * @static
         * @param {ICUserMessageResetHUD=} [properties] Properties to set
         * @returns {CUserMessageResetHUD} CUserMessageResetHUD instance
         */
        CUserMessageResetHUD.create = function create(properties) {
            return new CUserMessageResetHUD(properties);
        };
    
        /**
         * Encodes the specified CUserMessageResetHUD message. Does not implicitly {@link CUserMessageResetHUD.verify|verify} messages.
         * @function encode
         * @memberof CUserMessageResetHUD
         * @static
         * @param {ICUserMessageResetHUD} message CUserMessageResetHUD message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CUserMessageResetHUD.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };
    
        /**
         * Encodes the specified CUserMessageResetHUD message, length delimited. Does not implicitly {@link CUserMessageResetHUD.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CUserMessageResetHUD
         * @static
         * @param {ICUserMessageResetHUD} message CUserMessageResetHUD message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CUserMessageResetHUD.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CUserMessageResetHUD message from the specified reader or buffer.
         * @function decode
         * @memberof CUserMessageResetHUD
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CUserMessageResetHUD} CUserMessageResetHUD
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CUserMessageResetHUD.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CUserMessageResetHUD();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CUserMessageResetHUD message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CUserMessageResetHUD
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CUserMessageResetHUD} CUserMessageResetHUD
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CUserMessageResetHUD.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CUserMessageResetHUD message.
         * @function verify
         * @memberof CUserMessageResetHUD
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CUserMessageResetHUD.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };
    
        /**
         * Creates a CUserMessageResetHUD message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CUserMessageResetHUD
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CUserMessageResetHUD} CUserMessageResetHUD
         */
        CUserMessageResetHUD.fromObject = function fromObject(object) {
            if (object instanceof $root.CUserMessageResetHUD)
                return object;
            return new $root.CUserMessageResetHUD();
        };
    
        /**
         * Creates a plain object from a CUserMessageResetHUD message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CUserMessageResetHUD
         * @static
         * @param {CUserMessageResetHUD} message CUserMessageResetHUD
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CUserMessageResetHUD.toObject = function toObject() {
            return {};
        };
    
        /**
         * Converts this CUserMessageResetHUD to JSON.
         * @function toJSON
         * @memberof CUserMessageResetHUD
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CUserMessageResetHUD.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * Gets the default type url for CUserMessageResetHUD
         * @function getTypeUrl
         * @memberof CUserMessageResetHUD
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        CUserMessageResetHUD.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/CUserMessageResetHUD";
        };
    
        return CUserMessageResetHUD;
    })();
    
    $root.CUserMessageSendAudio = (function() {
    
        /**
         * Properties of a CUserMessageSendAudio.
         * @exports ICUserMessageSendAudio
         * @interface ICUserMessageSendAudio
         * @property {string|null} [soundname] CUserMessageSendAudio soundname
         * @property {boolean|null} [stop] CUserMessageSendAudio stop
         */
    
        /**
         * Constructs a new CUserMessageSendAudio.
         * @exports CUserMessageSendAudio
         * @classdesc Represents a CUserMessageSendAudio.
         * @implements ICUserMessageSendAudio
         * @constructor
         * @param {ICUserMessageSendAudio=} [properties] Properties to set
         */
        function CUserMessageSendAudio(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CUserMessageSendAudio soundname.
         * @member {string} soundname
         * @memberof CUserMessageSendAudio
         * @instance
         */
        CUserMessageSendAudio.prototype.soundname = "";
    
        /**
         * CUserMessageSendAudio stop.
         * @member {boolean} stop
         * @memberof CUserMessageSendAudio
         * @instance
         */
        CUserMessageSendAudio.prototype.stop = false;
    
        /**
         * Creates a new CUserMessageSendAudio instance using the specified properties.
         * @function create
         * @memberof CUserMessageSendAudio
         * @static
         * @param {ICUserMessageSendAudio=} [properties] Properties to set
         * @returns {CUserMessageSendAudio} CUserMessageSendAudio instance
         */
        CUserMessageSendAudio.create = function create(properties) {
            return new CUserMessageSendAudio(properties);
        };
    
        /**
         * Encodes the specified CUserMessageSendAudio message. Does not implicitly {@link CUserMessageSendAudio.verify|verify} messages.
         * @function encode
         * @memberof CUserMessageSendAudio
         * @static
         * @param {ICUserMessageSendAudio} message CUserMessageSendAudio message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CUserMessageSendAudio.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.soundname != null && Object.hasOwnProperty.call(message, "soundname"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.soundname);
            if (message.stop != null && Object.hasOwnProperty.call(message, "stop"))
                writer.uint32(/* id 2, wireType 0 =*/16).bool(message.stop);
            return writer;
        };
    
        /**
         * Encodes the specified CUserMessageSendAudio message, length delimited. Does not implicitly {@link CUserMessageSendAudio.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CUserMessageSendAudio
         * @static
         * @param {ICUserMessageSendAudio} message CUserMessageSendAudio message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CUserMessageSendAudio.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CUserMessageSendAudio message from the specified reader or buffer.
         * @function decode
         * @memberof CUserMessageSendAudio
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CUserMessageSendAudio} CUserMessageSendAudio
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CUserMessageSendAudio.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CUserMessageSendAudio();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.soundname = reader.string();
                        break;
                    }
                case 2: {
                        message.stop = reader.bool();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CUserMessageSendAudio message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CUserMessageSendAudio
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CUserMessageSendAudio} CUserMessageSendAudio
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CUserMessageSendAudio.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CUserMessageSendAudio message.
         * @function verify
         * @memberof CUserMessageSendAudio
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CUserMessageSendAudio.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.soundname != null && message.hasOwnProperty("soundname"))
                if (!$util.isString(message.soundname))
                    return "soundname: string expected";
            if (message.stop != null && message.hasOwnProperty("stop"))
                if (typeof message.stop !== "boolean")
                    return "stop: boolean expected";
            return null;
        };
    
        /**
         * Creates a CUserMessageSendAudio message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CUserMessageSendAudio
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CUserMessageSendAudio} CUserMessageSendAudio
         */
        CUserMessageSendAudio.fromObject = function fromObject(object) {
            if (object instanceof $root.CUserMessageSendAudio)
                return object;
            var message = new $root.CUserMessageSendAudio();
            if (object.soundname != null)
                message.soundname = String(object.soundname);
            if (object.stop != null)
                message.stop = Boolean(object.stop);
            return message;
        };
    
        /**
         * Creates a plain object from a CUserMessageSendAudio message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CUserMessageSendAudio
         * @static
         * @param {CUserMessageSendAudio} message CUserMessageSendAudio
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CUserMessageSendAudio.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.soundname = "";
                object.stop = false;
            }
            if (message.soundname != null && message.hasOwnProperty("soundname"))
                object.soundname = message.soundname;
            if (message.stop != null && message.hasOwnProperty("stop"))
                object.stop = message.stop;
            return object;
        };
    
        /**
         * Converts this CUserMessageSendAudio to JSON.
         * @function toJSON
         * @memberof CUserMessageSendAudio
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CUserMessageSendAudio.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * Gets the default type url for CUserMessageSendAudio
         * @function getTypeUrl
         * @memberof CUserMessageSendAudio
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        CUserMessageSendAudio.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/CUserMessageSendAudio";
        };
    
        return CUserMessageSendAudio;
    })();
    
    $root.CUserMessageAudioParameter = (function() {
    
        /**
         * Properties of a CUserMessageAudioParameter.
         * @exports ICUserMessageAudioParameter
         * @interface ICUserMessageAudioParameter
         * @property {number|null} [parameterType] CUserMessageAudioParameter parameterType
         * @property {number|null} [nameHashCode] CUserMessageAudioParameter nameHashCode
         * @property {number|null} [value] CUserMessageAudioParameter value
         * @property {number|null} [intValue] CUserMessageAudioParameter intValue
         */
    
        /**
         * Constructs a new CUserMessageAudioParameter.
         * @exports CUserMessageAudioParameter
         * @classdesc Represents a CUserMessageAudioParameter.
         * @implements ICUserMessageAudioParameter
         * @constructor
         * @param {ICUserMessageAudioParameter=} [properties] Properties to set
         */
        function CUserMessageAudioParameter(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CUserMessageAudioParameter parameterType.
         * @member {number} parameterType
         * @memberof CUserMessageAudioParameter
         * @instance
         */
        CUserMessageAudioParameter.prototype.parameterType = 0;
    
        /**
         * CUserMessageAudioParameter nameHashCode.
         * @member {number} nameHashCode
         * @memberof CUserMessageAudioParameter
         * @instance
         */
        CUserMessageAudioParameter.prototype.nameHashCode = 0;
    
        /**
         * CUserMessageAudioParameter value.
         * @member {number} value
         * @memberof CUserMessageAudioParameter
         * @instance
         */
        CUserMessageAudioParameter.prototype.value = 0;
    
        /**
         * CUserMessageAudioParameter intValue.
         * @member {number} intValue
         * @memberof CUserMessageAudioParameter
         * @instance
         */
        CUserMessageAudioParameter.prototype.intValue = 0;
    
        /**
         * Creates a new CUserMessageAudioParameter instance using the specified properties.
         * @function create
         * @memberof CUserMessageAudioParameter
         * @static
         * @param {ICUserMessageAudioParameter=} [properties] Properties to set
         * @returns {CUserMessageAudioParameter} CUserMessageAudioParameter instance
         */
        CUserMessageAudioParameter.create = function create(properties) {
            return new CUserMessageAudioParameter(properties);
        };
    
        /**
         * Encodes the specified CUserMessageAudioParameter message. Does not implicitly {@link CUserMessageAudioParameter.verify|verify} messages.
         * @function encode
         * @memberof CUserMessageAudioParameter
         * @static
         * @param {ICUserMessageAudioParameter} message CUserMessageAudioParameter message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CUserMessageAudioParameter.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.parameterType != null && Object.hasOwnProperty.call(message, "parameterType"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.parameterType);
            if (message.nameHashCode != null && Object.hasOwnProperty.call(message, "nameHashCode"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.nameHashCode);
            if (message.value != null && Object.hasOwnProperty.call(message, "value"))
                writer.uint32(/* id 3, wireType 5 =*/29).float(message.value);
            if (message.intValue != null && Object.hasOwnProperty.call(message, "intValue"))
                writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.intValue);
            return writer;
        };
    
        /**
         * Encodes the specified CUserMessageAudioParameter message, length delimited. Does not implicitly {@link CUserMessageAudioParameter.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CUserMessageAudioParameter
         * @static
         * @param {ICUserMessageAudioParameter} message CUserMessageAudioParameter message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CUserMessageAudioParameter.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CUserMessageAudioParameter message from the specified reader or buffer.
         * @function decode
         * @memberof CUserMessageAudioParameter
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CUserMessageAudioParameter} CUserMessageAudioParameter
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CUserMessageAudioParameter.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CUserMessageAudioParameter();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.parameterType = reader.uint32();
                        break;
                    }
                case 2: {
                        message.nameHashCode = reader.uint32();
                        break;
                    }
                case 3: {
                        message.value = reader.float();
                        break;
                    }
                case 4: {
                        message.intValue = reader.uint32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CUserMessageAudioParameter message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CUserMessageAudioParameter
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CUserMessageAudioParameter} CUserMessageAudioParameter
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CUserMessageAudioParameter.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CUserMessageAudioParameter message.
         * @function verify
         * @memberof CUserMessageAudioParameter
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CUserMessageAudioParameter.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.parameterType != null && message.hasOwnProperty("parameterType"))
                if (!$util.isInteger(message.parameterType))
                    return "parameterType: integer expected";
            if (message.nameHashCode != null && message.hasOwnProperty("nameHashCode"))
                if (!$util.isInteger(message.nameHashCode))
                    return "nameHashCode: integer expected";
            if (message.value != null && message.hasOwnProperty("value"))
                if (typeof message.value !== "number")
                    return "value: number expected";
            if (message.intValue != null && message.hasOwnProperty("intValue"))
                if (!$util.isInteger(message.intValue))
                    return "intValue: integer expected";
            return null;
        };
    
        /**
         * Creates a CUserMessageAudioParameter message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CUserMessageAudioParameter
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CUserMessageAudioParameter} CUserMessageAudioParameter
         */
        CUserMessageAudioParameter.fromObject = function fromObject(object) {
            if (object instanceof $root.CUserMessageAudioParameter)
                return object;
            var message = new $root.CUserMessageAudioParameter();
            if (object.parameterType != null)
                message.parameterType = object.parameterType >>> 0;
            if (object.nameHashCode != null)
                message.nameHashCode = object.nameHashCode >>> 0;
            if (object.value != null)
                message.value = Number(object.value);
            if (object.intValue != null)
                message.intValue = object.intValue >>> 0;
            return message;
        };
    
        /**
         * Creates a plain object from a CUserMessageAudioParameter message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CUserMessageAudioParameter
         * @static
         * @param {CUserMessageAudioParameter} message CUserMessageAudioParameter
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CUserMessageAudioParameter.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.parameterType = 0;
                object.nameHashCode = 0;
                object.value = 0;
                object.intValue = 0;
            }
            if (message.parameterType != null && message.hasOwnProperty("parameterType"))
                object.parameterType = message.parameterType;
            if (message.nameHashCode != null && message.hasOwnProperty("nameHashCode"))
                object.nameHashCode = message.nameHashCode;
            if (message.value != null && message.hasOwnProperty("value"))
                object.value = options.json && !isFinite(message.value) ? String(message.value) : message.value;
            if (message.intValue != null && message.hasOwnProperty("intValue"))
                object.intValue = message.intValue;
            return object;
        };
    
        /**
         * Converts this CUserMessageAudioParameter to JSON.
         * @function toJSON
         * @memberof CUserMessageAudioParameter
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CUserMessageAudioParameter.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * Gets the default type url for CUserMessageAudioParameter
         * @function getTypeUrl
         * @memberof CUserMessageAudioParameter
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        CUserMessageAudioParameter.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/CUserMessageAudioParameter";
        };
    
        return CUserMessageAudioParameter;
    })();
    
    $root.CUserMessageVoiceMask = (function() {
    
        /**
         * Properties of a CUserMessageVoiceMask.
         * @exports ICUserMessageVoiceMask
         * @interface ICUserMessageVoiceMask
         * @property {Array.<number>|null} [gamerulesMasks] CUserMessageVoiceMask gamerulesMasks
         * @property {Array.<number>|null} [banMasks] CUserMessageVoiceMask banMasks
         * @property {boolean|null} [modEnable] CUserMessageVoiceMask modEnable
         */
    
        /**
         * Constructs a new CUserMessageVoiceMask.
         * @exports CUserMessageVoiceMask
         * @classdesc Represents a CUserMessageVoiceMask.
         * @implements ICUserMessageVoiceMask
         * @constructor
         * @param {ICUserMessageVoiceMask=} [properties] Properties to set
         */
        function CUserMessageVoiceMask(properties) {
            this.gamerulesMasks = [];
            this.banMasks = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CUserMessageVoiceMask gamerulesMasks.
         * @member {Array.<number>} gamerulesMasks
         * @memberof CUserMessageVoiceMask
         * @instance
         */
        CUserMessageVoiceMask.prototype.gamerulesMasks = $util.emptyArray;
    
        /**
         * CUserMessageVoiceMask banMasks.
         * @member {Array.<number>} banMasks
         * @memberof CUserMessageVoiceMask
         * @instance
         */
        CUserMessageVoiceMask.prototype.banMasks = $util.emptyArray;
    
        /**
         * CUserMessageVoiceMask modEnable.
         * @member {boolean} modEnable
         * @memberof CUserMessageVoiceMask
         * @instance
         */
        CUserMessageVoiceMask.prototype.modEnable = false;
    
        /**
         * Creates a new CUserMessageVoiceMask instance using the specified properties.
         * @function create
         * @memberof CUserMessageVoiceMask
         * @static
         * @param {ICUserMessageVoiceMask=} [properties] Properties to set
         * @returns {CUserMessageVoiceMask} CUserMessageVoiceMask instance
         */
        CUserMessageVoiceMask.create = function create(properties) {
            return new CUserMessageVoiceMask(properties);
        };
    
        /**
         * Encodes the specified CUserMessageVoiceMask message. Does not implicitly {@link CUserMessageVoiceMask.verify|verify} messages.
         * @function encode
         * @memberof CUserMessageVoiceMask
         * @static
         * @param {ICUserMessageVoiceMask} message CUserMessageVoiceMask message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CUserMessageVoiceMask.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.gamerulesMasks != null && message.gamerulesMasks.length)
                for (var i = 0; i < message.gamerulesMasks.length; ++i)
                    writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.gamerulesMasks[i]);
            if (message.banMasks != null && message.banMasks.length)
                for (var i = 0; i < message.banMasks.length; ++i)
                    writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.banMasks[i]);
            if (message.modEnable != null && Object.hasOwnProperty.call(message, "modEnable"))
                writer.uint32(/* id 3, wireType 0 =*/24).bool(message.modEnable);
            return writer;
        };
    
        /**
         * Encodes the specified CUserMessageVoiceMask message, length delimited. Does not implicitly {@link CUserMessageVoiceMask.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CUserMessageVoiceMask
         * @static
         * @param {ICUserMessageVoiceMask} message CUserMessageVoiceMask message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CUserMessageVoiceMask.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CUserMessageVoiceMask message from the specified reader or buffer.
         * @function decode
         * @memberof CUserMessageVoiceMask
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CUserMessageVoiceMask} CUserMessageVoiceMask
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CUserMessageVoiceMask.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CUserMessageVoiceMask();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        if (!(message.gamerulesMasks && message.gamerulesMasks.length))
                            message.gamerulesMasks = [];
                        if ((tag & 7) === 2) {
                            var end2 = reader.uint32() + reader.pos;
                            while (reader.pos < end2)
                                message.gamerulesMasks.push(reader.uint32());
                        } else
                            message.gamerulesMasks.push(reader.uint32());
                        break;
                    }
                case 2: {
                        if (!(message.banMasks && message.banMasks.length))
                            message.banMasks = [];
                        if ((tag & 7) === 2) {
                            var end2 = reader.uint32() + reader.pos;
                            while (reader.pos < end2)
                                message.banMasks.push(reader.uint32());
                        } else
                            message.banMasks.push(reader.uint32());
                        break;
                    }
                case 3: {
                        message.modEnable = reader.bool();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CUserMessageVoiceMask message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CUserMessageVoiceMask
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CUserMessageVoiceMask} CUserMessageVoiceMask
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CUserMessageVoiceMask.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CUserMessageVoiceMask message.
         * @function verify
         * @memberof CUserMessageVoiceMask
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CUserMessageVoiceMask.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.gamerulesMasks != null && message.hasOwnProperty("gamerulesMasks")) {
                if (!Array.isArray(message.gamerulesMasks))
                    return "gamerulesMasks: array expected";
                for (var i = 0; i < message.gamerulesMasks.length; ++i)
                    if (!$util.isInteger(message.gamerulesMasks[i]))
                        return "gamerulesMasks: integer[] expected";
            }
            if (message.banMasks != null && message.hasOwnProperty("banMasks")) {
                if (!Array.isArray(message.banMasks))
                    return "banMasks: array expected";
                for (var i = 0; i < message.banMasks.length; ++i)
                    if (!$util.isInteger(message.banMasks[i]))
                        return "banMasks: integer[] expected";
            }
            if (message.modEnable != null && message.hasOwnProperty("modEnable"))
                if (typeof message.modEnable !== "boolean")
                    return "modEnable: boolean expected";
            return null;
        };
    
        /**
         * Creates a CUserMessageVoiceMask message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CUserMessageVoiceMask
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CUserMessageVoiceMask} CUserMessageVoiceMask
         */
        CUserMessageVoiceMask.fromObject = function fromObject(object) {
            if (object instanceof $root.CUserMessageVoiceMask)
                return object;
            var message = new $root.CUserMessageVoiceMask();
            if (object.gamerulesMasks) {
                if (!Array.isArray(object.gamerulesMasks))
                    throw TypeError(".CUserMessageVoiceMask.gamerulesMasks: array expected");
                message.gamerulesMasks = [];
                for (var i = 0; i < object.gamerulesMasks.length; ++i)
                    message.gamerulesMasks[i] = object.gamerulesMasks[i] >>> 0;
            }
            if (object.banMasks) {
                if (!Array.isArray(object.banMasks))
                    throw TypeError(".CUserMessageVoiceMask.banMasks: array expected");
                message.banMasks = [];
                for (var i = 0; i < object.banMasks.length; ++i)
                    message.banMasks[i] = object.banMasks[i] >>> 0;
            }
            if (object.modEnable != null)
                message.modEnable = Boolean(object.modEnable);
            return message;
        };
    
        /**
         * Creates a plain object from a CUserMessageVoiceMask message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CUserMessageVoiceMask
         * @static
         * @param {CUserMessageVoiceMask} message CUserMessageVoiceMask
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CUserMessageVoiceMask.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults) {
                object.gamerulesMasks = [];
                object.banMasks = [];
            }
            if (options.defaults)
                object.modEnable = false;
            if (message.gamerulesMasks && message.gamerulesMasks.length) {
                object.gamerulesMasks = [];
                for (var j = 0; j < message.gamerulesMasks.length; ++j)
                    object.gamerulesMasks[j] = message.gamerulesMasks[j];
            }
            if (message.banMasks && message.banMasks.length) {
                object.banMasks = [];
                for (var j = 0; j < message.banMasks.length; ++j)
                    object.banMasks[j] = message.banMasks[j];
            }
            if (message.modEnable != null && message.hasOwnProperty("modEnable"))
                object.modEnable = message.modEnable;
            return object;
        };
    
        /**
         * Converts this CUserMessageVoiceMask to JSON.
         * @function toJSON
         * @memberof CUserMessageVoiceMask
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CUserMessageVoiceMask.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * Gets the default type url for CUserMessageVoiceMask
         * @function getTypeUrl
         * @memberof CUserMessageVoiceMask
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        CUserMessageVoiceMask.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/CUserMessageVoiceMask";
        };
    
        return CUserMessageVoiceMask;
    })();
    
    $root.CUserMessageRequestState = (function() {
    
        /**
         * Properties of a CUserMessageRequestState.
         * @exports ICUserMessageRequestState
         * @interface ICUserMessageRequestState
         */
    
        /**
         * Constructs a new CUserMessageRequestState.
         * @exports CUserMessageRequestState
         * @classdesc Represents a CUserMessageRequestState.
         * @implements ICUserMessageRequestState
         * @constructor
         * @param {ICUserMessageRequestState=} [properties] Properties to set
         */
        function CUserMessageRequestState(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * Creates a new CUserMessageRequestState instance using the specified properties.
         * @function create
         * @memberof CUserMessageRequestState
         * @static
         * @param {ICUserMessageRequestState=} [properties] Properties to set
         * @returns {CUserMessageRequestState} CUserMessageRequestState instance
         */
        CUserMessageRequestState.create = function create(properties) {
            return new CUserMessageRequestState(properties);
        };
    
        /**
         * Encodes the specified CUserMessageRequestState message. Does not implicitly {@link CUserMessageRequestState.verify|verify} messages.
         * @function encode
         * @memberof CUserMessageRequestState
         * @static
         * @param {ICUserMessageRequestState} message CUserMessageRequestState message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CUserMessageRequestState.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };
    
        /**
         * Encodes the specified CUserMessageRequestState message, length delimited. Does not implicitly {@link CUserMessageRequestState.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CUserMessageRequestState
         * @static
         * @param {ICUserMessageRequestState} message CUserMessageRequestState message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CUserMessageRequestState.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CUserMessageRequestState message from the specified reader or buffer.
         * @function decode
         * @memberof CUserMessageRequestState
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CUserMessageRequestState} CUserMessageRequestState
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CUserMessageRequestState.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CUserMessageRequestState();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CUserMessageRequestState message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CUserMessageRequestState
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CUserMessageRequestState} CUserMessageRequestState
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CUserMessageRequestState.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CUserMessageRequestState message.
         * @function verify
         * @memberof CUserMessageRequestState
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CUserMessageRequestState.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };
    
        /**
         * Creates a CUserMessageRequestState message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CUserMessageRequestState
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CUserMessageRequestState} CUserMessageRequestState
         */
        CUserMessageRequestState.fromObject = function fromObject(object) {
            if (object instanceof $root.CUserMessageRequestState)
                return object;
            return new $root.CUserMessageRequestState();
        };
    
        /**
         * Creates a plain object from a CUserMessageRequestState message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CUserMessageRequestState
         * @static
         * @param {CUserMessageRequestState} message CUserMessageRequestState
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CUserMessageRequestState.toObject = function toObject() {
            return {};
        };
    
        /**
         * Converts this CUserMessageRequestState to JSON.
         * @function toJSON
         * @memberof CUserMessageRequestState
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CUserMessageRequestState.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * Gets the default type url for CUserMessageRequestState
         * @function getTypeUrl
         * @memberof CUserMessageRequestState
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        CUserMessageRequestState.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/CUserMessageRequestState";
        };
    
        return CUserMessageRequestState;
    })();
    
    $root.CUserMessageRumble = (function() {
    
        /**
         * Properties of a CUserMessageRumble.
         * @exports ICUserMessageRumble
         * @interface ICUserMessageRumble
         * @property {number|null} [index] CUserMessageRumble index
         * @property {number|null} [data] CUserMessageRumble data
         * @property {number|null} [flags] CUserMessageRumble flags
         */
    
        /**
         * Constructs a new CUserMessageRumble.
         * @exports CUserMessageRumble
         * @classdesc Represents a CUserMessageRumble.
         * @implements ICUserMessageRumble
         * @constructor
         * @param {ICUserMessageRumble=} [properties] Properties to set
         */
        function CUserMessageRumble(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CUserMessageRumble index.
         * @member {number} index
         * @memberof CUserMessageRumble
         * @instance
         */
        CUserMessageRumble.prototype.index = 0;
    
        /**
         * CUserMessageRumble data.
         * @member {number} data
         * @memberof CUserMessageRumble
         * @instance
         */
        CUserMessageRumble.prototype.data = 0;
    
        /**
         * CUserMessageRumble flags.
         * @member {number} flags
         * @memberof CUserMessageRumble
         * @instance
         */
        CUserMessageRumble.prototype.flags = 0;
    
        /**
         * Creates a new CUserMessageRumble instance using the specified properties.
         * @function create
         * @memberof CUserMessageRumble
         * @static
         * @param {ICUserMessageRumble=} [properties] Properties to set
         * @returns {CUserMessageRumble} CUserMessageRumble instance
         */
        CUserMessageRumble.create = function create(properties) {
            return new CUserMessageRumble(properties);
        };
    
        /**
         * Encodes the specified CUserMessageRumble message. Does not implicitly {@link CUserMessageRumble.verify|verify} messages.
         * @function encode
         * @memberof CUserMessageRumble
         * @static
         * @param {ICUserMessageRumble} message CUserMessageRumble message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CUserMessageRumble.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.index != null && Object.hasOwnProperty.call(message, "index"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.index);
            if (message.data != null && Object.hasOwnProperty.call(message, "data"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.data);
            if (message.flags != null && Object.hasOwnProperty.call(message, "flags"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.flags);
            return writer;
        };
    
        /**
         * Encodes the specified CUserMessageRumble message, length delimited. Does not implicitly {@link CUserMessageRumble.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CUserMessageRumble
         * @static
         * @param {ICUserMessageRumble} message CUserMessageRumble message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CUserMessageRumble.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CUserMessageRumble message from the specified reader or buffer.
         * @function decode
         * @memberof CUserMessageRumble
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CUserMessageRumble} CUserMessageRumble
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CUserMessageRumble.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CUserMessageRumble();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.index = reader.int32();
                        break;
                    }
                case 2: {
                        message.data = reader.int32();
                        break;
                    }
                case 3: {
                        message.flags = reader.int32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CUserMessageRumble message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CUserMessageRumble
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CUserMessageRumble} CUserMessageRumble
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CUserMessageRumble.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CUserMessageRumble message.
         * @function verify
         * @memberof CUserMessageRumble
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CUserMessageRumble.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.index != null && message.hasOwnProperty("index"))
                if (!$util.isInteger(message.index))
                    return "index: integer expected";
            if (message.data != null && message.hasOwnProperty("data"))
                if (!$util.isInteger(message.data))
                    return "data: integer expected";
            if (message.flags != null && message.hasOwnProperty("flags"))
                if (!$util.isInteger(message.flags))
                    return "flags: integer expected";
            return null;
        };
    
        /**
         * Creates a CUserMessageRumble message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CUserMessageRumble
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CUserMessageRumble} CUserMessageRumble
         */
        CUserMessageRumble.fromObject = function fromObject(object) {
            if (object instanceof $root.CUserMessageRumble)
                return object;
            var message = new $root.CUserMessageRumble();
            if (object.index != null)
                message.index = object.index | 0;
            if (object.data != null)
                message.data = object.data | 0;
            if (object.flags != null)
                message.flags = object.flags | 0;
            return message;
        };
    
        /**
         * Creates a plain object from a CUserMessageRumble message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CUserMessageRumble
         * @static
         * @param {CUserMessageRumble} message CUserMessageRumble
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CUserMessageRumble.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.index = 0;
                object.data = 0;
                object.flags = 0;
            }
            if (message.index != null && message.hasOwnProperty("index"))
                object.index = message.index;
            if (message.data != null && message.hasOwnProperty("data"))
                object.data = message.data;
            if (message.flags != null && message.hasOwnProperty("flags"))
                object.flags = message.flags;
            return object;
        };
    
        /**
         * Converts this CUserMessageRumble to JSON.
         * @function toJSON
         * @memberof CUserMessageRumble
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CUserMessageRumble.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * Gets the default type url for CUserMessageRumble
         * @function getTypeUrl
         * @memberof CUserMessageRumble
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        CUserMessageRumble.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/CUserMessageRumble";
        };
    
        return CUserMessageRumble;
    })();
    
    $root.CUserMessageSayTextChannel = (function() {
    
        /**
         * Properties of a CUserMessageSayTextChannel.
         * @exports ICUserMessageSayTextChannel
         * @interface ICUserMessageSayTextChannel
         * @property {number|null} [player] CUserMessageSayTextChannel player
         * @property {number|null} [channel] CUserMessageSayTextChannel channel
         * @property {string|null} [text] CUserMessageSayTextChannel text
         */
    
        /**
         * Constructs a new CUserMessageSayTextChannel.
         * @exports CUserMessageSayTextChannel
         * @classdesc Represents a CUserMessageSayTextChannel.
         * @implements ICUserMessageSayTextChannel
         * @constructor
         * @param {ICUserMessageSayTextChannel=} [properties] Properties to set
         */
        function CUserMessageSayTextChannel(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CUserMessageSayTextChannel player.
         * @member {number} player
         * @memberof CUserMessageSayTextChannel
         * @instance
         */
        CUserMessageSayTextChannel.prototype.player = 0;
    
        /**
         * CUserMessageSayTextChannel channel.
         * @member {number} channel
         * @memberof CUserMessageSayTextChannel
         * @instance
         */
        CUserMessageSayTextChannel.prototype.channel = 0;
    
        /**
         * CUserMessageSayTextChannel text.
         * @member {string} text
         * @memberof CUserMessageSayTextChannel
         * @instance
         */
        CUserMessageSayTextChannel.prototype.text = "";
    
        /**
         * Creates a new CUserMessageSayTextChannel instance using the specified properties.
         * @function create
         * @memberof CUserMessageSayTextChannel
         * @static
         * @param {ICUserMessageSayTextChannel=} [properties] Properties to set
         * @returns {CUserMessageSayTextChannel} CUserMessageSayTextChannel instance
         */
        CUserMessageSayTextChannel.create = function create(properties) {
            return new CUserMessageSayTextChannel(properties);
        };
    
        /**
         * Encodes the specified CUserMessageSayTextChannel message. Does not implicitly {@link CUserMessageSayTextChannel.verify|verify} messages.
         * @function encode
         * @memberof CUserMessageSayTextChannel
         * @static
         * @param {ICUserMessageSayTextChannel} message CUserMessageSayTextChannel message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CUserMessageSayTextChannel.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.player != null && Object.hasOwnProperty.call(message, "player"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.player);
            if (message.channel != null && Object.hasOwnProperty.call(message, "channel"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.channel);
            if (message.text != null && Object.hasOwnProperty.call(message, "text"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.text);
            return writer;
        };
    
        /**
         * Encodes the specified CUserMessageSayTextChannel message, length delimited. Does not implicitly {@link CUserMessageSayTextChannel.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CUserMessageSayTextChannel
         * @static
         * @param {ICUserMessageSayTextChannel} message CUserMessageSayTextChannel message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CUserMessageSayTextChannel.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CUserMessageSayTextChannel message from the specified reader or buffer.
         * @function decode
         * @memberof CUserMessageSayTextChannel
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CUserMessageSayTextChannel} CUserMessageSayTextChannel
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CUserMessageSayTextChannel.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CUserMessageSayTextChannel();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.player = reader.int32();
                        break;
                    }
                case 2: {
                        message.channel = reader.int32();
                        break;
                    }
                case 3: {
                        message.text = reader.string();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CUserMessageSayTextChannel message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CUserMessageSayTextChannel
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CUserMessageSayTextChannel} CUserMessageSayTextChannel
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CUserMessageSayTextChannel.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CUserMessageSayTextChannel message.
         * @function verify
         * @memberof CUserMessageSayTextChannel
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CUserMessageSayTextChannel.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.player != null && message.hasOwnProperty("player"))
                if (!$util.isInteger(message.player))
                    return "player: integer expected";
            if (message.channel != null && message.hasOwnProperty("channel"))
                if (!$util.isInteger(message.channel))
                    return "channel: integer expected";
            if (message.text != null && message.hasOwnProperty("text"))
                if (!$util.isString(message.text))
                    return "text: string expected";
            return null;
        };
    
        /**
         * Creates a CUserMessageSayTextChannel message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CUserMessageSayTextChannel
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CUserMessageSayTextChannel} CUserMessageSayTextChannel
         */
        CUserMessageSayTextChannel.fromObject = function fromObject(object) {
            if (object instanceof $root.CUserMessageSayTextChannel)
                return object;
            var message = new $root.CUserMessageSayTextChannel();
            if (object.player != null)
                message.player = object.player | 0;
            if (object.channel != null)
                message.channel = object.channel | 0;
            if (object.text != null)
                message.text = String(object.text);
            return message;
        };
    
        /**
         * Creates a plain object from a CUserMessageSayTextChannel message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CUserMessageSayTextChannel
         * @static
         * @param {CUserMessageSayTextChannel} message CUserMessageSayTextChannel
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CUserMessageSayTextChannel.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.player = 0;
                object.channel = 0;
                object.text = "";
            }
            if (message.player != null && message.hasOwnProperty("player"))
                object.player = message.player;
            if (message.channel != null && message.hasOwnProperty("channel"))
                object.channel = message.channel;
            if (message.text != null && message.hasOwnProperty("text"))
                object.text = message.text;
            return object;
        };
    
        /**
         * Converts this CUserMessageSayTextChannel to JSON.
         * @function toJSON
         * @memberof CUserMessageSayTextChannel
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CUserMessageSayTextChannel.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * Gets the default type url for CUserMessageSayTextChannel
         * @function getTypeUrl
         * @memberof CUserMessageSayTextChannel
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        CUserMessageSayTextChannel.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/CUserMessageSayTextChannel";
        };
    
        return CUserMessageSayTextChannel;
    })();
    
    $root.CUserMessageColoredText = (function() {
    
        /**
         * Properties of a CUserMessageColoredText.
         * @exports ICUserMessageColoredText
         * @interface ICUserMessageColoredText
         * @property {number|null} [color] CUserMessageColoredText color
         * @property {string|null} [text] CUserMessageColoredText text
         * @property {boolean|null} [reset] CUserMessageColoredText reset
         * @property {number|null} [contextPlayerSlot] CUserMessageColoredText contextPlayerSlot
         * @property {number|null} [contextValue] CUserMessageColoredText contextValue
         * @property {number|null} [contextTeamId] CUserMessageColoredText contextTeamId
         */
    
        /**
         * Constructs a new CUserMessageColoredText.
         * @exports CUserMessageColoredText
         * @classdesc Represents a CUserMessageColoredText.
         * @implements ICUserMessageColoredText
         * @constructor
         * @param {ICUserMessageColoredText=} [properties] Properties to set
         */
        function CUserMessageColoredText(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CUserMessageColoredText color.
         * @member {number} color
         * @memberof CUserMessageColoredText
         * @instance
         */
        CUserMessageColoredText.prototype.color = 0;
    
        /**
         * CUserMessageColoredText text.
         * @member {string} text
         * @memberof CUserMessageColoredText
         * @instance
         */
        CUserMessageColoredText.prototype.text = "";
    
        /**
         * CUserMessageColoredText reset.
         * @member {boolean} reset
         * @memberof CUserMessageColoredText
         * @instance
         */
        CUserMessageColoredText.prototype.reset = false;
    
        /**
         * CUserMessageColoredText contextPlayerSlot.
         * @member {number} contextPlayerSlot
         * @memberof CUserMessageColoredText
         * @instance
         */
        CUserMessageColoredText.prototype.contextPlayerSlot = -1;
    
        /**
         * CUserMessageColoredText contextValue.
         * @member {number} contextValue
         * @memberof CUserMessageColoredText
         * @instance
         */
        CUserMessageColoredText.prototype.contextValue = 0;
    
        /**
         * CUserMessageColoredText contextTeamId.
         * @member {number} contextTeamId
         * @memberof CUserMessageColoredText
         * @instance
         */
        CUserMessageColoredText.prototype.contextTeamId = 0;
    
        /**
         * Creates a new CUserMessageColoredText instance using the specified properties.
         * @function create
         * @memberof CUserMessageColoredText
         * @static
         * @param {ICUserMessageColoredText=} [properties] Properties to set
         * @returns {CUserMessageColoredText} CUserMessageColoredText instance
         */
        CUserMessageColoredText.create = function create(properties) {
            return new CUserMessageColoredText(properties);
        };
    
        /**
         * Encodes the specified CUserMessageColoredText message. Does not implicitly {@link CUserMessageColoredText.verify|verify} messages.
         * @function encode
         * @memberof CUserMessageColoredText
         * @static
         * @param {ICUserMessageColoredText} message CUserMessageColoredText message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CUserMessageColoredText.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.color != null && Object.hasOwnProperty.call(message, "color"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.color);
            if (message.text != null && Object.hasOwnProperty.call(message, "text"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.text);
            if (message.reset != null && Object.hasOwnProperty.call(message, "reset"))
                writer.uint32(/* id 3, wireType 0 =*/24).bool(message.reset);
            if (message.contextPlayerSlot != null && Object.hasOwnProperty.call(message, "contextPlayerSlot"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.contextPlayerSlot);
            if (message.contextValue != null && Object.hasOwnProperty.call(message, "contextValue"))
                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.contextValue);
            if (message.contextTeamId != null && Object.hasOwnProperty.call(message, "contextTeamId"))
                writer.uint32(/* id 6, wireType 0 =*/48).int32(message.contextTeamId);
            return writer;
        };
    
        /**
         * Encodes the specified CUserMessageColoredText message, length delimited. Does not implicitly {@link CUserMessageColoredText.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CUserMessageColoredText
         * @static
         * @param {ICUserMessageColoredText} message CUserMessageColoredText message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CUserMessageColoredText.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CUserMessageColoredText message from the specified reader or buffer.
         * @function decode
         * @memberof CUserMessageColoredText
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CUserMessageColoredText} CUserMessageColoredText
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CUserMessageColoredText.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CUserMessageColoredText();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.color = reader.uint32();
                        break;
                    }
                case 2: {
                        message.text = reader.string();
                        break;
                    }
                case 3: {
                        message.reset = reader.bool();
                        break;
                    }
                case 4: {
                        message.contextPlayerSlot = reader.int32();
                        break;
                    }
                case 5: {
                        message.contextValue = reader.int32();
                        break;
                    }
                case 6: {
                        message.contextTeamId = reader.int32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CUserMessageColoredText message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CUserMessageColoredText
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CUserMessageColoredText} CUserMessageColoredText
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CUserMessageColoredText.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CUserMessageColoredText message.
         * @function verify
         * @memberof CUserMessageColoredText
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CUserMessageColoredText.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.color != null && message.hasOwnProperty("color"))
                if (!$util.isInteger(message.color))
                    return "color: integer expected";
            if (message.text != null && message.hasOwnProperty("text"))
                if (!$util.isString(message.text))
                    return "text: string expected";
            if (message.reset != null && message.hasOwnProperty("reset"))
                if (typeof message.reset !== "boolean")
                    return "reset: boolean expected";
            if (message.contextPlayerSlot != null && message.hasOwnProperty("contextPlayerSlot"))
                if (!$util.isInteger(message.contextPlayerSlot))
                    return "contextPlayerSlot: integer expected";
            if (message.contextValue != null && message.hasOwnProperty("contextValue"))
                if (!$util.isInteger(message.contextValue))
                    return "contextValue: integer expected";
            if (message.contextTeamId != null && message.hasOwnProperty("contextTeamId"))
                if (!$util.isInteger(message.contextTeamId))
                    return "contextTeamId: integer expected";
            return null;
        };
    
        /**
         * Creates a CUserMessageColoredText message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CUserMessageColoredText
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CUserMessageColoredText} CUserMessageColoredText
         */
        CUserMessageColoredText.fromObject = function fromObject(object) {
            if (object instanceof $root.CUserMessageColoredText)
                return object;
            var message = new $root.CUserMessageColoredText();
            if (object.color != null)
                message.color = object.color >>> 0;
            if (object.text != null)
                message.text = String(object.text);
            if (object.reset != null)
                message.reset = Boolean(object.reset);
            if (object.contextPlayerSlot != null)
                message.contextPlayerSlot = object.contextPlayerSlot | 0;
            if (object.contextValue != null)
                message.contextValue = object.contextValue | 0;
            if (object.contextTeamId != null)
                message.contextTeamId = object.contextTeamId | 0;
            return message;
        };
    
        /**
         * Creates a plain object from a CUserMessageColoredText message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CUserMessageColoredText
         * @static
         * @param {CUserMessageColoredText} message CUserMessageColoredText
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CUserMessageColoredText.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.color = 0;
                object.text = "";
                object.reset = false;
                object.contextPlayerSlot = -1;
                object.contextValue = 0;
                object.contextTeamId = 0;
            }
            if (message.color != null && message.hasOwnProperty("color"))
                object.color = message.color;
            if (message.text != null && message.hasOwnProperty("text"))
                object.text = message.text;
            if (message.reset != null && message.hasOwnProperty("reset"))
                object.reset = message.reset;
            if (message.contextPlayerSlot != null && message.hasOwnProperty("contextPlayerSlot"))
                object.contextPlayerSlot = message.contextPlayerSlot;
            if (message.contextValue != null && message.hasOwnProperty("contextValue"))
                object.contextValue = message.contextValue;
            if (message.contextTeamId != null && message.hasOwnProperty("contextTeamId"))
                object.contextTeamId = message.contextTeamId;
            return object;
        };
    
        /**
         * Converts this CUserMessageColoredText to JSON.
         * @function toJSON
         * @memberof CUserMessageColoredText
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CUserMessageColoredText.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * Gets the default type url for CUserMessageColoredText
         * @function getTypeUrl
         * @memberof CUserMessageColoredText
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        CUserMessageColoredText.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/CUserMessageColoredText";
        };
    
        return CUserMessageColoredText;
    })();
    
    $root.CUserMessageItemPickup = (function() {
    
        /**
         * Properties of a CUserMessageItemPickup.
         * @exports ICUserMessageItemPickup
         * @interface ICUserMessageItemPickup
         * @property {string|null} [itemname] CUserMessageItemPickup itemname
         */
    
        /**
         * Constructs a new CUserMessageItemPickup.
         * @exports CUserMessageItemPickup
         * @classdesc Represents a CUserMessageItemPickup.
         * @implements ICUserMessageItemPickup
         * @constructor
         * @param {ICUserMessageItemPickup=} [properties] Properties to set
         */
        function CUserMessageItemPickup(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CUserMessageItemPickup itemname.
         * @member {string} itemname
         * @memberof CUserMessageItemPickup
         * @instance
         */
        CUserMessageItemPickup.prototype.itemname = "";
    
        /**
         * Creates a new CUserMessageItemPickup instance using the specified properties.
         * @function create
         * @memberof CUserMessageItemPickup
         * @static
         * @param {ICUserMessageItemPickup=} [properties] Properties to set
         * @returns {CUserMessageItemPickup} CUserMessageItemPickup instance
         */
        CUserMessageItemPickup.create = function create(properties) {
            return new CUserMessageItemPickup(properties);
        };
    
        /**
         * Encodes the specified CUserMessageItemPickup message. Does not implicitly {@link CUserMessageItemPickup.verify|verify} messages.
         * @function encode
         * @memberof CUserMessageItemPickup
         * @static
         * @param {ICUserMessageItemPickup} message CUserMessageItemPickup message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CUserMessageItemPickup.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.itemname != null && Object.hasOwnProperty.call(message, "itemname"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.itemname);
            return writer;
        };
    
        /**
         * Encodes the specified CUserMessageItemPickup message, length delimited. Does not implicitly {@link CUserMessageItemPickup.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CUserMessageItemPickup
         * @static
         * @param {ICUserMessageItemPickup} message CUserMessageItemPickup message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CUserMessageItemPickup.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CUserMessageItemPickup message from the specified reader or buffer.
         * @function decode
         * @memberof CUserMessageItemPickup
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CUserMessageItemPickup} CUserMessageItemPickup
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CUserMessageItemPickup.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CUserMessageItemPickup();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.itemname = reader.string();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CUserMessageItemPickup message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CUserMessageItemPickup
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CUserMessageItemPickup} CUserMessageItemPickup
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CUserMessageItemPickup.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CUserMessageItemPickup message.
         * @function verify
         * @memberof CUserMessageItemPickup
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CUserMessageItemPickup.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.itemname != null && message.hasOwnProperty("itemname"))
                if (!$util.isString(message.itemname))
                    return "itemname: string expected";
            return null;
        };
    
        /**
         * Creates a CUserMessageItemPickup message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CUserMessageItemPickup
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CUserMessageItemPickup} CUserMessageItemPickup
         */
        CUserMessageItemPickup.fromObject = function fromObject(object) {
            if (object instanceof $root.CUserMessageItemPickup)
                return object;
            var message = new $root.CUserMessageItemPickup();
            if (object.itemname != null)
                message.itemname = String(object.itemname);
            return message;
        };
    
        /**
         * Creates a plain object from a CUserMessageItemPickup message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CUserMessageItemPickup
         * @static
         * @param {CUserMessageItemPickup} message CUserMessageItemPickup
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CUserMessageItemPickup.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.itemname = "";
            if (message.itemname != null && message.hasOwnProperty("itemname"))
                object.itemname = message.itemname;
            return object;
        };
    
        /**
         * Converts this CUserMessageItemPickup to JSON.
         * @function toJSON
         * @memberof CUserMessageItemPickup
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CUserMessageItemPickup.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * Gets the default type url for CUserMessageItemPickup
         * @function getTypeUrl
         * @memberof CUserMessageItemPickup
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        CUserMessageItemPickup.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/CUserMessageItemPickup";
        };
    
        return CUserMessageItemPickup;
    })();
    
    $root.CUserMessageAmmoDenied = (function() {
    
        /**
         * Properties of a CUserMessageAmmoDenied.
         * @exports ICUserMessageAmmoDenied
         * @interface ICUserMessageAmmoDenied
         * @property {number|null} [ammoId] CUserMessageAmmoDenied ammoId
         */
    
        /**
         * Constructs a new CUserMessageAmmoDenied.
         * @exports CUserMessageAmmoDenied
         * @classdesc Represents a CUserMessageAmmoDenied.
         * @implements ICUserMessageAmmoDenied
         * @constructor
         * @param {ICUserMessageAmmoDenied=} [properties] Properties to set
         */
        function CUserMessageAmmoDenied(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CUserMessageAmmoDenied ammoId.
         * @member {number} ammoId
         * @memberof CUserMessageAmmoDenied
         * @instance
         */
        CUserMessageAmmoDenied.prototype.ammoId = 0;
    
        /**
         * Creates a new CUserMessageAmmoDenied instance using the specified properties.
         * @function create
         * @memberof CUserMessageAmmoDenied
         * @static
         * @param {ICUserMessageAmmoDenied=} [properties] Properties to set
         * @returns {CUserMessageAmmoDenied} CUserMessageAmmoDenied instance
         */
        CUserMessageAmmoDenied.create = function create(properties) {
            return new CUserMessageAmmoDenied(properties);
        };
    
        /**
         * Encodes the specified CUserMessageAmmoDenied message. Does not implicitly {@link CUserMessageAmmoDenied.verify|verify} messages.
         * @function encode
         * @memberof CUserMessageAmmoDenied
         * @static
         * @param {ICUserMessageAmmoDenied} message CUserMessageAmmoDenied message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CUserMessageAmmoDenied.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.ammoId != null && Object.hasOwnProperty.call(message, "ammoId"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.ammoId);
            return writer;
        };
    
        /**
         * Encodes the specified CUserMessageAmmoDenied message, length delimited. Does not implicitly {@link CUserMessageAmmoDenied.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CUserMessageAmmoDenied
         * @static
         * @param {ICUserMessageAmmoDenied} message CUserMessageAmmoDenied message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CUserMessageAmmoDenied.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CUserMessageAmmoDenied message from the specified reader or buffer.
         * @function decode
         * @memberof CUserMessageAmmoDenied
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CUserMessageAmmoDenied} CUserMessageAmmoDenied
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CUserMessageAmmoDenied.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CUserMessageAmmoDenied();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.ammoId = reader.uint32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CUserMessageAmmoDenied message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CUserMessageAmmoDenied
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CUserMessageAmmoDenied} CUserMessageAmmoDenied
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CUserMessageAmmoDenied.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CUserMessageAmmoDenied message.
         * @function verify
         * @memberof CUserMessageAmmoDenied
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CUserMessageAmmoDenied.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.ammoId != null && message.hasOwnProperty("ammoId"))
                if (!$util.isInteger(message.ammoId))
                    return "ammoId: integer expected";
            return null;
        };
    
        /**
         * Creates a CUserMessageAmmoDenied message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CUserMessageAmmoDenied
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CUserMessageAmmoDenied} CUserMessageAmmoDenied
         */
        CUserMessageAmmoDenied.fromObject = function fromObject(object) {
            if (object instanceof $root.CUserMessageAmmoDenied)
                return object;
            var message = new $root.CUserMessageAmmoDenied();
            if (object.ammoId != null)
                message.ammoId = object.ammoId >>> 0;
            return message;
        };
    
        /**
         * Creates a plain object from a CUserMessageAmmoDenied message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CUserMessageAmmoDenied
         * @static
         * @param {CUserMessageAmmoDenied} message CUserMessageAmmoDenied
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CUserMessageAmmoDenied.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.ammoId = 0;
            if (message.ammoId != null && message.hasOwnProperty("ammoId"))
                object.ammoId = message.ammoId;
            return object;
        };
    
        /**
         * Converts this CUserMessageAmmoDenied to JSON.
         * @function toJSON
         * @memberof CUserMessageAmmoDenied
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CUserMessageAmmoDenied.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * Gets the default type url for CUserMessageAmmoDenied
         * @function getTypeUrl
         * @memberof CUserMessageAmmoDenied
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        CUserMessageAmmoDenied.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/CUserMessageAmmoDenied";
        };
    
        return CUserMessageAmmoDenied;
    })();
    
    $root.CUserMessageShowMenu = (function() {
    
        /**
         * Properties of a CUserMessageShowMenu.
         * @exports ICUserMessageShowMenu
         * @interface ICUserMessageShowMenu
         * @property {number|null} [validslots] CUserMessageShowMenu validslots
         * @property {number|null} [displaytime] CUserMessageShowMenu displaytime
         * @property {boolean|null} [needmore] CUserMessageShowMenu needmore
         * @property {string|null} [menustring] CUserMessageShowMenu menustring
         */
    
        /**
         * Constructs a new CUserMessageShowMenu.
         * @exports CUserMessageShowMenu
         * @classdesc Represents a CUserMessageShowMenu.
         * @implements ICUserMessageShowMenu
         * @constructor
         * @param {ICUserMessageShowMenu=} [properties] Properties to set
         */
        function CUserMessageShowMenu(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CUserMessageShowMenu validslots.
         * @member {number} validslots
         * @memberof CUserMessageShowMenu
         * @instance
         */
        CUserMessageShowMenu.prototype.validslots = 0;
    
        /**
         * CUserMessageShowMenu displaytime.
         * @member {number} displaytime
         * @memberof CUserMessageShowMenu
         * @instance
         */
        CUserMessageShowMenu.prototype.displaytime = 0;
    
        /**
         * CUserMessageShowMenu needmore.
         * @member {boolean} needmore
         * @memberof CUserMessageShowMenu
         * @instance
         */
        CUserMessageShowMenu.prototype.needmore = false;
    
        /**
         * CUserMessageShowMenu menustring.
         * @member {string} menustring
         * @memberof CUserMessageShowMenu
         * @instance
         */
        CUserMessageShowMenu.prototype.menustring = "";
    
        /**
         * Creates a new CUserMessageShowMenu instance using the specified properties.
         * @function create
         * @memberof CUserMessageShowMenu
         * @static
         * @param {ICUserMessageShowMenu=} [properties] Properties to set
         * @returns {CUserMessageShowMenu} CUserMessageShowMenu instance
         */
        CUserMessageShowMenu.create = function create(properties) {
            return new CUserMessageShowMenu(properties);
        };
    
        /**
         * Encodes the specified CUserMessageShowMenu message. Does not implicitly {@link CUserMessageShowMenu.verify|verify} messages.
         * @function encode
         * @memberof CUserMessageShowMenu
         * @static
         * @param {ICUserMessageShowMenu} message CUserMessageShowMenu message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CUserMessageShowMenu.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.validslots != null && Object.hasOwnProperty.call(message, "validslots"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.validslots);
            if (message.displaytime != null && Object.hasOwnProperty.call(message, "displaytime"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.displaytime);
            if (message.needmore != null && Object.hasOwnProperty.call(message, "needmore"))
                writer.uint32(/* id 3, wireType 0 =*/24).bool(message.needmore);
            if (message.menustring != null && Object.hasOwnProperty.call(message, "menustring"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.menustring);
            return writer;
        };
    
        /**
         * Encodes the specified CUserMessageShowMenu message, length delimited. Does not implicitly {@link CUserMessageShowMenu.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CUserMessageShowMenu
         * @static
         * @param {ICUserMessageShowMenu} message CUserMessageShowMenu message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CUserMessageShowMenu.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CUserMessageShowMenu message from the specified reader or buffer.
         * @function decode
         * @memberof CUserMessageShowMenu
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CUserMessageShowMenu} CUserMessageShowMenu
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CUserMessageShowMenu.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CUserMessageShowMenu();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.validslots = reader.uint32();
                        break;
                    }
                case 2: {
                        message.displaytime = reader.uint32();
                        break;
                    }
                case 3: {
                        message.needmore = reader.bool();
                        break;
                    }
                case 4: {
                        message.menustring = reader.string();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CUserMessageShowMenu message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CUserMessageShowMenu
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CUserMessageShowMenu} CUserMessageShowMenu
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CUserMessageShowMenu.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CUserMessageShowMenu message.
         * @function verify
         * @memberof CUserMessageShowMenu
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CUserMessageShowMenu.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.validslots != null && message.hasOwnProperty("validslots"))
                if (!$util.isInteger(message.validslots))
                    return "validslots: integer expected";
            if (message.displaytime != null && message.hasOwnProperty("displaytime"))
                if (!$util.isInteger(message.displaytime))
                    return "displaytime: integer expected";
            if (message.needmore != null && message.hasOwnProperty("needmore"))
                if (typeof message.needmore !== "boolean")
                    return "needmore: boolean expected";
            if (message.menustring != null && message.hasOwnProperty("menustring"))
                if (!$util.isString(message.menustring))
                    return "menustring: string expected";
            return null;
        };
    
        /**
         * Creates a CUserMessageShowMenu message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CUserMessageShowMenu
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CUserMessageShowMenu} CUserMessageShowMenu
         */
        CUserMessageShowMenu.fromObject = function fromObject(object) {
            if (object instanceof $root.CUserMessageShowMenu)
                return object;
            var message = new $root.CUserMessageShowMenu();
            if (object.validslots != null)
                message.validslots = object.validslots >>> 0;
            if (object.displaytime != null)
                message.displaytime = object.displaytime >>> 0;
            if (object.needmore != null)
                message.needmore = Boolean(object.needmore);
            if (object.menustring != null)
                message.menustring = String(object.menustring);
            return message;
        };
    
        /**
         * Creates a plain object from a CUserMessageShowMenu message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CUserMessageShowMenu
         * @static
         * @param {CUserMessageShowMenu} message CUserMessageShowMenu
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CUserMessageShowMenu.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.validslots = 0;
                object.displaytime = 0;
                object.needmore = false;
                object.menustring = "";
            }
            if (message.validslots != null && message.hasOwnProperty("validslots"))
                object.validslots = message.validslots;
            if (message.displaytime != null && message.hasOwnProperty("displaytime"))
                object.displaytime = message.displaytime;
            if (message.needmore != null && message.hasOwnProperty("needmore"))
                object.needmore = message.needmore;
            if (message.menustring != null && message.hasOwnProperty("menustring"))
                object.menustring = message.menustring;
            return object;
        };
    
        /**
         * Converts this CUserMessageShowMenu to JSON.
         * @function toJSON
         * @memberof CUserMessageShowMenu
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CUserMessageShowMenu.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * Gets the default type url for CUserMessageShowMenu
         * @function getTypeUrl
         * @memberof CUserMessageShowMenu
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        CUserMessageShowMenu.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/CUserMessageShowMenu";
        };
    
        return CUserMessageShowMenu;
    })();
    
    $root.CUserMessageCreditsMsg = (function() {
    
        /**
         * Properties of a CUserMessageCreditsMsg.
         * @exports ICUserMessageCreditsMsg
         * @interface ICUserMessageCreditsMsg
         * @property {eRollType|null} [rolltype] CUserMessageCreditsMsg rolltype
         * @property {number|null} [logoLength] CUserMessageCreditsMsg logoLength
         */
    
        /**
         * Constructs a new CUserMessageCreditsMsg.
         * @exports CUserMessageCreditsMsg
         * @classdesc Represents a CUserMessageCreditsMsg.
         * @implements ICUserMessageCreditsMsg
         * @constructor
         * @param {ICUserMessageCreditsMsg=} [properties] Properties to set
         */
        function CUserMessageCreditsMsg(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CUserMessageCreditsMsg rolltype.
         * @member {eRollType} rolltype
         * @memberof CUserMessageCreditsMsg
         * @instance
         */
        CUserMessageCreditsMsg.prototype.rolltype = -1;
    
        /**
         * CUserMessageCreditsMsg logoLength.
         * @member {number} logoLength
         * @memberof CUserMessageCreditsMsg
         * @instance
         */
        CUserMessageCreditsMsg.prototype.logoLength = 0;
    
        /**
         * Creates a new CUserMessageCreditsMsg instance using the specified properties.
         * @function create
         * @memberof CUserMessageCreditsMsg
         * @static
         * @param {ICUserMessageCreditsMsg=} [properties] Properties to set
         * @returns {CUserMessageCreditsMsg} CUserMessageCreditsMsg instance
         */
        CUserMessageCreditsMsg.create = function create(properties) {
            return new CUserMessageCreditsMsg(properties);
        };
    
        /**
         * Encodes the specified CUserMessageCreditsMsg message. Does not implicitly {@link CUserMessageCreditsMsg.verify|verify} messages.
         * @function encode
         * @memberof CUserMessageCreditsMsg
         * @static
         * @param {ICUserMessageCreditsMsg} message CUserMessageCreditsMsg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CUserMessageCreditsMsg.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.rolltype != null && Object.hasOwnProperty.call(message, "rolltype"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.rolltype);
            if (message.logoLength != null && Object.hasOwnProperty.call(message, "logoLength"))
                writer.uint32(/* id 2, wireType 5 =*/21).float(message.logoLength);
            return writer;
        };
    
        /**
         * Encodes the specified CUserMessageCreditsMsg message, length delimited. Does not implicitly {@link CUserMessageCreditsMsg.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CUserMessageCreditsMsg
         * @static
         * @param {ICUserMessageCreditsMsg} message CUserMessageCreditsMsg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CUserMessageCreditsMsg.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CUserMessageCreditsMsg message from the specified reader or buffer.
         * @function decode
         * @memberof CUserMessageCreditsMsg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CUserMessageCreditsMsg} CUserMessageCreditsMsg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CUserMessageCreditsMsg.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CUserMessageCreditsMsg();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.rolltype = reader.int32();
                        break;
                    }
                case 2: {
                        message.logoLength = reader.float();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CUserMessageCreditsMsg message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CUserMessageCreditsMsg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CUserMessageCreditsMsg} CUserMessageCreditsMsg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CUserMessageCreditsMsg.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CUserMessageCreditsMsg message.
         * @function verify
         * @memberof CUserMessageCreditsMsg
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CUserMessageCreditsMsg.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.rolltype != null && message.hasOwnProperty("rolltype"))
                switch (message.rolltype) {
                default:
                    return "rolltype: enum value expected";
                case -1:
                case 0:
                case 1:
                case 2:
                case 3:
                    break;
                }
            if (message.logoLength != null && message.hasOwnProperty("logoLength"))
                if (typeof message.logoLength !== "number")
                    return "logoLength: number expected";
            return null;
        };
    
        /**
         * Creates a CUserMessageCreditsMsg message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CUserMessageCreditsMsg
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CUserMessageCreditsMsg} CUserMessageCreditsMsg
         */
        CUserMessageCreditsMsg.fromObject = function fromObject(object) {
            if (object instanceof $root.CUserMessageCreditsMsg)
                return object;
            var message = new $root.CUserMessageCreditsMsg();
            switch (object.rolltype) {
            default:
                if (typeof object.rolltype === "number") {
                    message.rolltype = object.rolltype;
                    break;
                }
                break;
            case "ROLL_NONE":
            case -1:
                message.rolltype = -1;
                break;
            case "ROLL_STATS":
            case 0:
                message.rolltype = 0;
                break;
            case "ROLL_CREDITS":
            case 1:
                message.rolltype = 1;
                break;
            case "ROLL_LATE_JOIN_LOGO":
            case 2:
                message.rolltype = 2;
                break;
            case "ROLL_OUTTRO":
            case 3:
                message.rolltype = 3;
                break;
            }
            if (object.logoLength != null)
                message.logoLength = Number(object.logoLength);
            return message;
        };
    
        /**
         * Creates a plain object from a CUserMessageCreditsMsg message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CUserMessageCreditsMsg
         * @static
         * @param {CUserMessageCreditsMsg} message CUserMessageCreditsMsg
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CUserMessageCreditsMsg.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.rolltype = options.enums === String ? "ROLL_NONE" : -1;
                object.logoLength = 0;
            }
            if (message.rolltype != null && message.hasOwnProperty("rolltype"))
                object.rolltype = options.enums === String ? $root.eRollType[message.rolltype] === undefined ? message.rolltype : $root.eRollType[message.rolltype] : message.rolltype;
            if (message.logoLength != null && message.hasOwnProperty("logoLength"))
                object.logoLength = options.json && !isFinite(message.logoLength) ? String(message.logoLength) : message.logoLength;
            return object;
        };
    
        /**
         * Converts this CUserMessageCreditsMsg to JSON.
         * @function toJSON
         * @memberof CUserMessageCreditsMsg
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CUserMessageCreditsMsg.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * Gets the default type url for CUserMessageCreditsMsg
         * @function getTypeUrl
         * @memberof CUserMessageCreditsMsg
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        CUserMessageCreditsMsg.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/CUserMessageCreditsMsg";
        };
    
        return CUserMessageCreditsMsg;
    })();
    
    $root.CEntityMessagePlayJingle = (function() {
    
        /**
         * Properties of a CEntityMessagePlayJingle.
         * @exports ICEntityMessagePlayJingle
         * @interface ICEntityMessagePlayJingle
         * @property {ICEntityMsg|null} [entityMsg] CEntityMessagePlayJingle entityMsg
         */
    
        /**
         * Constructs a new CEntityMessagePlayJingle.
         * @exports CEntityMessagePlayJingle
         * @classdesc Represents a CEntityMessagePlayJingle.
         * @implements ICEntityMessagePlayJingle
         * @constructor
         * @param {ICEntityMessagePlayJingle=} [properties] Properties to set
         */
        function CEntityMessagePlayJingle(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CEntityMessagePlayJingle entityMsg.
         * @member {ICEntityMsg|null|undefined} entityMsg
         * @memberof CEntityMessagePlayJingle
         * @instance
         */
        CEntityMessagePlayJingle.prototype.entityMsg = null;
    
        /**
         * Creates a new CEntityMessagePlayJingle instance using the specified properties.
         * @function create
         * @memberof CEntityMessagePlayJingle
         * @static
         * @param {ICEntityMessagePlayJingle=} [properties] Properties to set
         * @returns {CEntityMessagePlayJingle} CEntityMessagePlayJingle instance
         */
        CEntityMessagePlayJingle.create = function create(properties) {
            return new CEntityMessagePlayJingle(properties);
        };
    
        /**
         * Encodes the specified CEntityMessagePlayJingle message. Does not implicitly {@link CEntityMessagePlayJingle.verify|verify} messages.
         * @function encode
         * @memberof CEntityMessagePlayJingle
         * @static
         * @param {ICEntityMessagePlayJingle} message CEntityMessagePlayJingle message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CEntityMessagePlayJingle.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.entityMsg != null && Object.hasOwnProperty.call(message, "entityMsg"))
                $root.CEntityMsg.encode(message.entityMsg, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };
    
        /**
         * Encodes the specified CEntityMessagePlayJingle message, length delimited. Does not implicitly {@link CEntityMessagePlayJingle.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CEntityMessagePlayJingle
         * @static
         * @param {ICEntityMessagePlayJingle} message CEntityMessagePlayJingle message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CEntityMessagePlayJingle.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CEntityMessagePlayJingle message from the specified reader or buffer.
         * @function decode
         * @memberof CEntityMessagePlayJingle
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CEntityMessagePlayJingle} CEntityMessagePlayJingle
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CEntityMessagePlayJingle.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CEntityMessagePlayJingle();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.entityMsg = $root.CEntityMsg.decode(reader, reader.uint32());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CEntityMessagePlayJingle message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CEntityMessagePlayJingle
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CEntityMessagePlayJingle} CEntityMessagePlayJingle
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CEntityMessagePlayJingle.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CEntityMessagePlayJingle message.
         * @function verify
         * @memberof CEntityMessagePlayJingle
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CEntityMessagePlayJingle.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.entityMsg != null && message.hasOwnProperty("entityMsg")) {
                var error = $root.CEntityMsg.verify(message.entityMsg);
                if (error)
                    return "entityMsg." + error;
            }
            return null;
        };
    
        /**
         * Creates a CEntityMessagePlayJingle message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CEntityMessagePlayJingle
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CEntityMessagePlayJingle} CEntityMessagePlayJingle
         */
        CEntityMessagePlayJingle.fromObject = function fromObject(object) {
            if (object instanceof $root.CEntityMessagePlayJingle)
                return object;
            var message = new $root.CEntityMessagePlayJingle();
            if (object.entityMsg != null) {
                if (typeof object.entityMsg !== "object")
                    throw TypeError(".CEntityMessagePlayJingle.entityMsg: object expected");
                message.entityMsg = $root.CEntityMsg.fromObject(object.entityMsg);
            }
            return message;
        };
    
        /**
         * Creates a plain object from a CEntityMessagePlayJingle message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CEntityMessagePlayJingle
         * @static
         * @param {CEntityMessagePlayJingle} message CEntityMessagePlayJingle
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CEntityMessagePlayJingle.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.entityMsg = null;
            if (message.entityMsg != null && message.hasOwnProperty("entityMsg"))
                object.entityMsg = $root.CEntityMsg.toObject(message.entityMsg, options);
            return object;
        };
    
        /**
         * Converts this CEntityMessagePlayJingle to JSON.
         * @function toJSON
         * @memberof CEntityMessagePlayJingle
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CEntityMessagePlayJingle.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * Gets the default type url for CEntityMessagePlayJingle
         * @function getTypeUrl
         * @memberof CEntityMessagePlayJingle
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        CEntityMessagePlayJingle.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/CEntityMessagePlayJingle";
        };
    
        return CEntityMessagePlayJingle;
    })();
    
    $root.CEntityMessageScreenOverlay = (function() {
    
        /**
         * Properties of a CEntityMessageScreenOverlay.
         * @exports ICEntityMessageScreenOverlay
         * @interface ICEntityMessageScreenOverlay
         * @property {boolean|null} [startEffect] CEntityMessageScreenOverlay startEffect
         * @property {ICEntityMsg|null} [entityMsg] CEntityMessageScreenOverlay entityMsg
         */
    
        /**
         * Constructs a new CEntityMessageScreenOverlay.
         * @exports CEntityMessageScreenOverlay
         * @classdesc Represents a CEntityMessageScreenOverlay.
         * @implements ICEntityMessageScreenOverlay
         * @constructor
         * @param {ICEntityMessageScreenOverlay=} [properties] Properties to set
         */
        function CEntityMessageScreenOverlay(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CEntityMessageScreenOverlay startEffect.
         * @member {boolean} startEffect
         * @memberof CEntityMessageScreenOverlay
         * @instance
         */
        CEntityMessageScreenOverlay.prototype.startEffect = false;
    
        /**
         * CEntityMessageScreenOverlay entityMsg.
         * @member {ICEntityMsg|null|undefined} entityMsg
         * @memberof CEntityMessageScreenOverlay
         * @instance
         */
        CEntityMessageScreenOverlay.prototype.entityMsg = null;
    
        /**
         * Creates a new CEntityMessageScreenOverlay instance using the specified properties.
         * @function create
         * @memberof CEntityMessageScreenOverlay
         * @static
         * @param {ICEntityMessageScreenOverlay=} [properties] Properties to set
         * @returns {CEntityMessageScreenOverlay} CEntityMessageScreenOverlay instance
         */
        CEntityMessageScreenOverlay.create = function create(properties) {
            return new CEntityMessageScreenOverlay(properties);
        };
    
        /**
         * Encodes the specified CEntityMessageScreenOverlay message. Does not implicitly {@link CEntityMessageScreenOverlay.verify|verify} messages.
         * @function encode
         * @memberof CEntityMessageScreenOverlay
         * @static
         * @param {ICEntityMessageScreenOverlay} message CEntityMessageScreenOverlay message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CEntityMessageScreenOverlay.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.startEffect != null && Object.hasOwnProperty.call(message, "startEffect"))
                writer.uint32(/* id 1, wireType 0 =*/8).bool(message.startEffect);
            if (message.entityMsg != null && Object.hasOwnProperty.call(message, "entityMsg"))
                $root.CEntityMsg.encode(message.entityMsg, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };
    
        /**
         * Encodes the specified CEntityMessageScreenOverlay message, length delimited. Does not implicitly {@link CEntityMessageScreenOverlay.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CEntityMessageScreenOverlay
         * @static
         * @param {ICEntityMessageScreenOverlay} message CEntityMessageScreenOverlay message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CEntityMessageScreenOverlay.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CEntityMessageScreenOverlay message from the specified reader or buffer.
         * @function decode
         * @memberof CEntityMessageScreenOverlay
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CEntityMessageScreenOverlay} CEntityMessageScreenOverlay
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CEntityMessageScreenOverlay.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CEntityMessageScreenOverlay();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.startEffect = reader.bool();
                        break;
                    }
                case 2: {
                        message.entityMsg = $root.CEntityMsg.decode(reader, reader.uint32());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CEntityMessageScreenOverlay message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CEntityMessageScreenOverlay
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CEntityMessageScreenOverlay} CEntityMessageScreenOverlay
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CEntityMessageScreenOverlay.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CEntityMessageScreenOverlay message.
         * @function verify
         * @memberof CEntityMessageScreenOverlay
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CEntityMessageScreenOverlay.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.startEffect != null && message.hasOwnProperty("startEffect"))
                if (typeof message.startEffect !== "boolean")
                    return "startEffect: boolean expected";
            if (message.entityMsg != null && message.hasOwnProperty("entityMsg")) {
                var error = $root.CEntityMsg.verify(message.entityMsg);
                if (error)
                    return "entityMsg." + error;
            }
            return null;
        };
    
        /**
         * Creates a CEntityMessageScreenOverlay message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CEntityMessageScreenOverlay
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CEntityMessageScreenOverlay} CEntityMessageScreenOverlay
         */
        CEntityMessageScreenOverlay.fromObject = function fromObject(object) {
            if (object instanceof $root.CEntityMessageScreenOverlay)
                return object;
            var message = new $root.CEntityMessageScreenOverlay();
            if (object.startEffect != null)
                message.startEffect = Boolean(object.startEffect);
            if (object.entityMsg != null) {
                if (typeof object.entityMsg !== "object")
                    throw TypeError(".CEntityMessageScreenOverlay.entityMsg: object expected");
                message.entityMsg = $root.CEntityMsg.fromObject(object.entityMsg);
            }
            return message;
        };
    
        /**
         * Creates a plain object from a CEntityMessageScreenOverlay message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CEntityMessageScreenOverlay
         * @static
         * @param {CEntityMessageScreenOverlay} message CEntityMessageScreenOverlay
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CEntityMessageScreenOverlay.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.startEffect = false;
                object.entityMsg = null;
            }
            if (message.startEffect != null && message.hasOwnProperty("startEffect"))
                object.startEffect = message.startEffect;
            if (message.entityMsg != null && message.hasOwnProperty("entityMsg"))
                object.entityMsg = $root.CEntityMsg.toObject(message.entityMsg, options);
            return object;
        };
    
        /**
         * Converts this CEntityMessageScreenOverlay to JSON.
         * @function toJSON
         * @memberof CEntityMessageScreenOverlay
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CEntityMessageScreenOverlay.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * Gets the default type url for CEntityMessageScreenOverlay
         * @function getTypeUrl
         * @memberof CEntityMessageScreenOverlay
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        CEntityMessageScreenOverlay.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/CEntityMessageScreenOverlay";
        };
    
        return CEntityMessageScreenOverlay;
    })();
    
    $root.CEntityMessageRemoveAllDecals = (function() {
    
        /**
         * Properties of a CEntityMessageRemoveAllDecals.
         * @exports ICEntityMessageRemoveAllDecals
         * @interface ICEntityMessageRemoveAllDecals
         * @property {boolean|null} [removeDecals] CEntityMessageRemoveAllDecals removeDecals
         * @property {ICEntityMsg|null} [entityMsg] CEntityMessageRemoveAllDecals entityMsg
         */
    
        /**
         * Constructs a new CEntityMessageRemoveAllDecals.
         * @exports CEntityMessageRemoveAllDecals
         * @classdesc Represents a CEntityMessageRemoveAllDecals.
         * @implements ICEntityMessageRemoveAllDecals
         * @constructor
         * @param {ICEntityMessageRemoveAllDecals=} [properties] Properties to set
         */
        function CEntityMessageRemoveAllDecals(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CEntityMessageRemoveAllDecals removeDecals.
         * @member {boolean} removeDecals
         * @memberof CEntityMessageRemoveAllDecals
         * @instance
         */
        CEntityMessageRemoveAllDecals.prototype.removeDecals = false;
    
        /**
         * CEntityMessageRemoveAllDecals entityMsg.
         * @member {ICEntityMsg|null|undefined} entityMsg
         * @memberof CEntityMessageRemoveAllDecals
         * @instance
         */
        CEntityMessageRemoveAllDecals.prototype.entityMsg = null;
    
        /**
         * Creates a new CEntityMessageRemoveAllDecals instance using the specified properties.
         * @function create
         * @memberof CEntityMessageRemoveAllDecals
         * @static
         * @param {ICEntityMessageRemoveAllDecals=} [properties] Properties to set
         * @returns {CEntityMessageRemoveAllDecals} CEntityMessageRemoveAllDecals instance
         */
        CEntityMessageRemoveAllDecals.create = function create(properties) {
            return new CEntityMessageRemoveAllDecals(properties);
        };
    
        /**
         * Encodes the specified CEntityMessageRemoveAllDecals message. Does not implicitly {@link CEntityMessageRemoveAllDecals.verify|verify} messages.
         * @function encode
         * @memberof CEntityMessageRemoveAllDecals
         * @static
         * @param {ICEntityMessageRemoveAllDecals} message CEntityMessageRemoveAllDecals message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CEntityMessageRemoveAllDecals.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.removeDecals != null && Object.hasOwnProperty.call(message, "removeDecals"))
                writer.uint32(/* id 1, wireType 0 =*/8).bool(message.removeDecals);
            if (message.entityMsg != null && Object.hasOwnProperty.call(message, "entityMsg"))
                $root.CEntityMsg.encode(message.entityMsg, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };
    
        /**
         * Encodes the specified CEntityMessageRemoveAllDecals message, length delimited. Does not implicitly {@link CEntityMessageRemoveAllDecals.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CEntityMessageRemoveAllDecals
         * @static
         * @param {ICEntityMessageRemoveAllDecals} message CEntityMessageRemoveAllDecals message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CEntityMessageRemoveAllDecals.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CEntityMessageRemoveAllDecals message from the specified reader or buffer.
         * @function decode
         * @memberof CEntityMessageRemoveAllDecals
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CEntityMessageRemoveAllDecals} CEntityMessageRemoveAllDecals
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CEntityMessageRemoveAllDecals.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CEntityMessageRemoveAllDecals();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.removeDecals = reader.bool();
                        break;
                    }
                case 2: {
                        message.entityMsg = $root.CEntityMsg.decode(reader, reader.uint32());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CEntityMessageRemoveAllDecals message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CEntityMessageRemoveAllDecals
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CEntityMessageRemoveAllDecals} CEntityMessageRemoveAllDecals
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CEntityMessageRemoveAllDecals.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CEntityMessageRemoveAllDecals message.
         * @function verify
         * @memberof CEntityMessageRemoveAllDecals
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CEntityMessageRemoveAllDecals.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.removeDecals != null && message.hasOwnProperty("removeDecals"))
                if (typeof message.removeDecals !== "boolean")
                    return "removeDecals: boolean expected";
            if (message.entityMsg != null && message.hasOwnProperty("entityMsg")) {
                var error = $root.CEntityMsg.verify(message.entityMsg);
                if (error)
                    return "entityMsg." + error;
            }
            return null;
        };
    
        /**
         * Creates a CEntityMessageRemoveAllDecals message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CEntityMessageRemoveAllDecals
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CEntityMessageRemoveAllDecals} CEntityMessageRemoveAllDecals
         */
        CEntityMessageRemoveAllDecals.fromObject = function fromObject(object) {
            if (object instanceof $root.CEntityMessageRemoveAllDecals)
                return object;
            var message = new $root.CEntityMessageRemoveAllDecals();
            if (object.removeDecals != null)
                message.removeDecals = Boolean(object.removeDecals);
            if (object.entityMsg != null) {
                if (typeof object.entityMsg !== "object")
                    throw TypeError(".CEntityMessageRemoveAllDecals.entityMsg: object expected");
                message.entityMsg = $root.CEntityMsg.fromObject(object.entityMsg);
            }
            return message;
        };
    
        /**
         * Creates a plain object from a CEntityMessageRemoveAllDecals message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CEntityMessageRemoveAllDecals
         * @static
         * @param {CEntityMessageRemoveAllDecals} message CEntityMessageRemoveAllDecals
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CEntityMessageRemoveAllDecals.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.removeDecals = false;
                object.entityMsg = null;
            }
            if (message.removeDecals != null && message.hasOwnProperty("removeDecals"))
                object.removeDecals = message.removeDecals;
            if (message.entityMsg != null && message.hasOwnProperty("entityMsg"))
                object.entityMsg = $root.CEntityMsg.toObject(message.entityMsg, options);
            return object;
        };
    
        /**
         * Converts this CEntityMessageRemoveAllDecals to JSON.
         * @function toJSON
         * @memberof CEntityMessageRemoveAllDecals
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CEntityMessageRemoveAllDecals.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * Gets the default type url for CEntityMessageRemoveAllDecals
         * @function getTypeUrl
         * @memberof CEntityMessageRemoveAllDecals
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        CEntityMessageRemoveAllDecals.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/CEntityMessageRemoveAllDecals";
        };
    
        return CEntityMessageRemoveAllDecals;
    })();
    
    $root.CEntityMessagePropagateForce = (function() {
    
        /**
         * Properties of a CEntityMessagePropagateForce.
         * @exports ICEntityMessagePropagateForce
         * @interface ICEntityMessagePropagateForce
         * @property {ICMsgVector|null} [impulse] CEntityMessagePropagateForce impulse
         * @property {ICEntityMsg|null} [entityMsg] CEntityMessagePropagateForce entityMsg
         */
    
        /**
         * Constructs a new CEntityMessagePropagateForce.
         * @exports CEntityMessagePropagateForce
         * @classdesc Represents a CEntityMessagePropagateForce.
         * @implements ICEntityMessagePropagateForce
         * @constructor
         * @param {ICEntityMessagePropagateForce=} [properties] Properties to set
         */
        function CEntityMessagePropagateForce(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CEntityMessagePropagateForce impulse.
         * @member {ICMsgVector|null|undefined} impulse
         * @memberof CEntityMessagePropagateForce
         * @instance
         */
        CEntityMessagePropagateForce.prototype.impulse = null;
    
        /**
         * CEntityMessagePropagateForce entityMsg.
         * @member {ICEntityMsg|null|undefined} entityMsg
         * @memberof CEntityMessagePropagateForce
         * @instance
         */
        CEntityMessagePropagateForce.prototype.entityMsg = null;
    
        /**
         * Creates a new CEntityMessagePropagateForce instance using the specified properties.
         * @function create
         * @memberof CEntityMessagePropagateForce
         * @static
         * @param {ICEntityMessagePropagateForce=} [properties] Properties to set
         * @returns {CEntityMessagePropagateForce} CEntityMessagePropagateForce instance
         */
        CEntityMessagePropagateForce.create = function create(properties) {
            return new CEntityMessagePropagateForce(properties);
        };
    
        /**
         * Encodes the specified CEntityMessagePropagateForce message. Does not implicitly {@link CEntityMessagePropagateForce.verify|verify} messages.
         * @function encode
         * @memberof CEntityMessagePropagateForce
         * @static
         * @param {ICEntityMessagePropagateForce} message CEntityMessagePropagateForce message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CEntityMessagePropagateForce.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.impulse != null && Object.hasOwnProperty.call(message, "impulse"))
                $root.CMsgVector.encode(message.impulse, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.entityMsg != null && Object.hasOwnProperty.call(message, "entityMsg"))
                $root.CEntityMsg.encode(message.entityMsg, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };
    
        /**
         * Encodes the specified CEntityMessagePropagateForce message, length delimited. Does not implicitly {@link CEntityMessagePropagateForce.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CEntityMessagePropagateForce
         * @static
         * @param {ICEntityMessagePropagateForce} message CEntityMessagePropagateForce message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CEntityMessagePropagateForce.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CEntityMessagePropagateForce message from the specified reader or buffer.
         * @function decode
         * @memberof CEntityMessagePropagateForce
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CEntityMessagePropagateForce} CEntityMessagePropagateForce
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CEntityMessagePropagateForce.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CEntityMessagePropagateForce();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.impulse = $root.CMsgVector.decode(reader, reader.uint32());
                        break;
                    }
                case 2: {
                        message.entityMsg = $root.CEntityMsg.decode(reader, reader.uint32());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CEntityMessagePropagateForce message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CEntityMessagePropagateForce
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CEntityMessagePropagateForce} CEntityMessagePropagateForce
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CEntityMessagePropagateForce.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CEntityMessagePropagateForce message.
         * @function verify
         * @memberof CEntityMessagePropagateForce
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CEntityMessagePropagateForce.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.impulse != null && message.hasOwnProperty("impulse")) {
                var error = $root.CMsgVector.verify(message.impulse);
                if (error)
                    return "impulse." + error;
            }
            if (message.entityMsg != null && message.hasOwnProperty("entityMsg")) {
                var error = $root.CEntityMsg.verify(message.entityMsg);
                if (error)
                    return "entityMsg." + error;
            }
            return null;
        };
    
        /**
         * Creates a CEntityMessagePropagateForce message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CEntityMessagePropagateForce
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CEntityMessagePropagateForce} CEntityMessagePropagateForce
         */
        CEntityMessagePropagateForce.fromObject = function fromObject(object) {
            if (object instanceof $root.CEntityMessagePropagateForce)
                return object;
            var message = new $root.CEntityMessagePropagateForce();
            if (object.impulse != null) {
                if (typeof object.impulse !== "object")
                    throw TypeError(".CEntityMessagePropagateForce.impulse: object expected");
                message.impulse = $root.CMsgVector.fromObject(object.impulse);
            }
            if (object.entityMsg != null) {
                if (typeof object.entityMsg !== "object")
                    throw TypeError(".CEntityMessagePropagateForce.entityMsg: object expected");
                message.entityMsg = $root.CEntityMsg.fromObject(object.entityMsg);
            }
            return message;
        };
    
        /**
         * Creates a plain object from a CEntityMessagePropagateForce message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CEntityMessagePropagateForce
         * @static
         * @param {CEntityMessagePropagateForce} message CEntityMessagePropagateForce
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CEntityMessagePropagateForce.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.impulse = null;
                object.entityMsg = null;
            }
            if (message.impulse != null && message.hasOwnProperty("impulse"))
                object.impulse = $root.CMsgVector.toObject(message.impulse, options);
            if (message.entityMsg != null && message.hasOwnProperty("entityMsg"))
                object.entityMsg = $root.CEntityMsg.toObject(message.entityMsg, options);
            return object;
        };
    
        /**
         * Converts this CEntityMessagePropagateForce to JSON.
         * @function toJSON
         * @memberof CEntityMessagePropagateForce
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CEntityMessagePropagateForce.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * Gets the default type url for CEntityMessagePropagateForce
         * @function getTypeUrl
         * @memberof CEntityMessagePropagateForce
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        CEntityMessagePropagateForce.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/CEntityMessagePropagateForce";
        };
    
        return CEntityMessagePropagateForce;
    })();
    
    $root.CEntityMessageDoSpark = (function() {
    
        /**
         * Properties of a CEntityMessageDoSpark.
         * @exports ICEntityMessageDoSpark
         * @interface ICEntityMessageDoSpark
         * @property {ICMsgVector|null} [origin] CEntityMessageDoSpark origin
         * @property {number|null} [entityindex] CEntityMessageDoSpark entityindex
         * @property {number|null} [radius] CEntityMessageDoSpark radius
         * @property {number|null} [color] CEntityMessageDoSpark color
         * @property {number|null} [beams] CEntityMessageDoSpark beams
         * @property {number|null} [thick] CEntityMessageDoSpark thick
         * @property {number|null} [duration] CEntityMessageDoSpark duration
         * @property {ICEntityMsg|null} [entityMsg] CEntityMessageDoSpark entityMsg
         */
    
        /**
         * Constructs a new CEntityMessageDoSpark.
         * @exports CEntityMessageDoSpark
         * @classdesc Represents a CEntityMessageDoSpark.
         * @implements ICEntityMessageDoSpark
         * @constructor
         * @param {ICEntityMessageDoSpark=} [properties] Properties to set
         */
        function CEntityMessageDoSpark(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CEntityMessageDoSpark origin.
         * @member {ICMsgVector|null|undefined} origin
         * @memberof CEntityMessageDoSpark
         * @instance
         */
        CEntityMessageDoSpark.prototype.origin = null;
    
        /**
         * CEntityMessageDoSpark entityindex.
         * @member {number} entityindex
         * @memberof CEntityMessageDoSpark
         * @instance
         */
        CEntityMessageDoSpark.prototype.entityindex = -1;
    
        /**
         * CEntityMessageDoSpark radius.
         * @member {number} radius
         * @memberof CEntityMessageDoSpark
         * @instance
         */
        CEntityMessageDoSpark.prototype.radius = 0;
    
        /**
         * CEntityMessageDoSpark color.
         * @member {number} color
         * @memberof CEntityMessageDoSpark
         * @instance
         */
        CEntityMessageDoSpark.prototype.color = 0;
    
        /**
         * CEntityMessageDoSpark beams.
         * @member {number} beams
         * @memberof CEntityMessageDoSpark
         * @instance
         */
        CEntityMessageDoSpark.prototype.beams = 0;
    
        /**
         * CEntityMessageDoSpark thick.
         * @member {number} thick
         * @memberof CEntityMessageDoSpark
         * @instance
         */
        CEntityMessageDoSpark.prototype.thick = 0;
    
        /**
         * CEntityMessageDoSpark duration.
         * @member {number} duration
         * @memberof CEntityMessageDoSpark
         * @instance
         */
        CEntityMessageDoSpark.prototype.duration = 0;
    
        /**
         * CEntityMessageDoSpark entityMsg.
         * @member {ICEntityMsg|null|undefined} entityMsg
         * @memberof CEntityMessageDoSpark
         * @instance
         */
        CEntityMessageDoSpark.prototype.entityMsg = null;
    
        /**
         * Creates a new CEntityMessageDoSpark instance using the specified properties.
         * @function create
         * @memberof CEntityMessageDoSpark
         * @static
         * @param {ICEntityMessageDoSpark=} [properties] Properties to set
         * @returns {CEntityMessageDoSpark} CEntityMessageDoSpark instance
         */
        CEntityMessageDoSpark.create = function create(properties) {
            return new CEntityMessageDoSpark(properties);
        };
    
        /**
         * Encodes the specified CEntityMessageDoSpark message. Does not implicitly {@link CEntityMessageDoSpark.verify|verify} messages.
         * @function encode
         * @memberof CEntityMessageDoSpark
         * @static
         * @param {ICEntityMessageDoSpark} message CEntityMessageDoSpark message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CEntityMessageDoSpark.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.origin != null && Object.hasOwnProperty.call(message, "origin"))
                $root.CMsgVector.encode(message.origin, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.entityindex != null && Object.hasOwnProperty.call(message, "entityindex"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.entityindex);
            if (message.radius != null && Object.hasOwnProperty.call(message, "radius"))
                writer.uint32(/* id 3, wireType 5 =*/29).float(message.radius);
            if (message.color != null && Object.hasOwnProperty.call(message, "color"))
                writer.uint32(/* id 4, wireType 5 =*/37).fixed32(message.color);
            if (message.beams != null && Object.hasOwnProperty.call(message, "beams"))
                writer.uint32(/* id 5, wireType 0 =*/40).uint32(message.beams);
            if (message.thick != null && Object.hasOwnProperty.call(message, "thick"))
                writer.uint32(/* id 6, wireType 5 =*/53).float(message.thick);
            if (message.duration != null && Object.hasOwnProperty.call(message, "duration"))
                writer.uint32(/* id 7, wireType 5 =*/61).float(message.duration);
            if (message.entityMsg != null && Object.hasOwnProperty.call(message, "entityMsg"))
                $root.CEntityMsg.encode(message.entityMsg, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
            return writer;
        };
    
        /**
         * Encodes the specified CEntityMessageDoSpark message, length delimited. Does not implicitly {@link CEntityMessageDoSpark.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CEntityMessageDoSpark
         * @static
         * @param {ICEntityMessageDoSpark} message CEntityMessageDoSpark message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CEntityMessageDoSpark.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CEntityMessageDoSpark message from the specified reader or buffer.
         * @function decode
         * @memberof CEntityMessageDoSpark
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CEntityMessageDoSpark} CEntityMessageDoSpark
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CEntityMessageDoSpark.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CEntityMessageDoSpark();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.origin = $root.CMsgVector.decode(reader, reader.uint32());
                        break;
                    }
                case 2: {
                        message.entityindex = reader.int32();
                        break;
                    }
                case 3: {
                        message.radius = reader.float();
                        break;
                    }
                case 4: {
                        message.color = reader.fixed32();
                        break;
                    }
                case 5: {
                        message.beams = reader.uint32();
                        break;
                    }
                case 6: {
                        message.thick = reader.float();
                        break;
                    }
                case 7: {
                        message.duration = reader.float();
                        break;
                    }
                case 8: {
                        message.entityMsg = $root.CEntityMsg.decode(reader, reader.uint32());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CEntityMessageDoSpark message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CEntityMessageDoSpark
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CEntityMessageDoSpark} CEntityMessageDoSpark
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CEntityMessageDoSpark.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CEntityMessageDoSpark message.
         * @function verify
         * @memberof CEntityMessageDoSpark
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CEntityMessageDoSpark.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.origin != null && message.hasOwnProperty("origin")) {
                var error = $root.CMsgVector.verify(message.origin);
                if (error)
                    return "origin." + error;
            }
            if (message.entityindex != null && message.hasOwnProperty("entityindex"))
                if (!$util.isInteger(message.entityindex))
                    return "entityindex: integer expected";
            if (message.radius != null && message.hasOwnProperty("radius"))
                if (typeof message.radius !== "number")
                    return "radius: number expected";
            if (message.color != null && message.hasOwnProperty("color"))
                if (!$util.isInteger(message.color))
                    return "color: integer expected";
            if (message.beams != null && message.hasOwnProperty("beams"))
                if (!$util.isInteger(message.beams))
                    return "beams: integer expected";
            if (message.thick != null && message.hasOwnProperty("thick"))
                if (typeof message.thick !== "number")
                    return "thick: number expected";
            if (message.duration != null && message.hasOwnProperty("duration"))
                if (typeof message.duration !== "number")
                    return "duration: number expected";
            if (message.entityMsg != null && message.hasOwnProperty("entityMsg")) {
                var error = $root.CEntityMsg.verify(message.entityMsg);
                if (error)
                    return "entityMsg." + error;
            }
            return null;
        };
    
        /**
         * Creates a CEntityMessageDoSpark message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CEntityMessageDoSpark
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CEntityMessageDoSpark} CEntityMessageDoSpark
         */
        CEntityMessageDoSpark.fromObject = function fromObject(object) {
            if (object instanceof $root.CEntityMessageDoSpark)
                return object;
            var message = new $root.CEntityMessageDoSpark();
            if (object.origin != null) {
                if (typeof object.origin !== "object")
                    throw TypeError(".CEntityMessageDoSpark.origin: object expected");
                message.origin = $root.CMsgVector.fromObject(object.origin);
            }
            if (object.entityindex != null)
                message.entityindex = object.entityindex | 0;
            if (object.radius != null)
                message.radius = Number(object.radius);
            if (object.color != null)
                message.color = object.color >>> 0;
            if (object.beams != null)
                message.beams = object.beams >>> 0;
            if (object.thick != null)
                message.thick = Number(object.thick);
            if (object.duration != null)
                message.duration = Number(object.duration);
            if (object.entityMsg != null) {
                if (typeof object.entityMsg !== "object")
                    throw TypeError(".CEntityMessageDoSpark.entityMsg: object expected");
                message.entityMsg = $root.CEntityMsg.fromObject(object.entityMsg);
            }
            return message;
        };
    
        /**
         * Creates a plain object from a CEntityMessageDoSpark message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CEntityMessageDoSpark
         * @static
         * @param {CEntityMessageDoSpark} message CEntityMessageDoSpark
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CEntityMessageDoSpark.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.origin = null;
                object.entityindex = -1;
                object.radius = 0;
                object.color = 0;
                object.beams = 0;
                object.thick = 0;
                object.duration = 0;
                object.entityMsg = null;
            }
            if (message.origin != null && message.hasOwnProperty("origin"))
                object.origin = $root.CMsgVector.toObject(message.origin, options);
            if (message.entityindex != null && message.hasOwnProperty("entityindex"))
                object.entityindex = message.entityindex;
            if (message.radius != null && message.hasOwnProperty("radius"))
                object.radius = options.json && !isFinite(message.radius) ? String(message.radius) : message.radius;
            if (message.color != null && message.hasOwnProperty("color"))
                object.color = message.color;
            if (message.beams != null && message.hasOwnProperty("beams"))
                object.beams = message.beams;
            if (message.thick != null && message.hasOwnProperty("thick"))
                object.thick = options.json && !isFinite(message.thick) ? String(message.thick) : message.thick;
            if (message.duration != null && message.hasOwnProperty("duration"))
                object.duration = options.json && !isFinite(message.duration) ? String(message.duration) : message.duration;
            if (message.entityMsg != null && message.hasOwnProperty("entityMsg"))
                object.entityMsg = $root.CEntityMsg.toObject(message.entityMsg, options);
            return object;
        };
    
        /**
         * Converts this CEntityMessageDoSpark to JSON.
         * @function toJSON
         * @memberof CEntityMessageDoSpark
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CEntityMessageDoSpark.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * Gets the default type url for CEntityMessageDoSpark
         * @function getTypeUrl
         * @memberof CEntityMessageDoSpark
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        CEntityMessageDoSpark.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/CEntityMessageDoSpark";
        };
    
        return CEntityMessageDoSpark;
    })();
    
    $root.CEntityMessageFixAngle = (function() {
    
        /**
         * Properties of a CEntityMessageFixAngle.
         * @exports ICEntityMessageFixAngle
         * @interface ICEntityMessageFixAngle
         * @property {boolean|null} [relative] CEntityMessageFixAngle relative
         * @property {ICMsgQAngle|null} [angle] CEntityMessageFixAngle angle
         * @property {ICEntityMsg|null} [entityMsg] CEntityMessageFixAngle entityMsg
         */
    
        /**
         * Constructs a new CEntityMessageFixAngle.
         * @exports CEntityMessageFixAngle
         * @classdesc Represents a CEntityMessageFixAngle.
         * @implements ICEntityMessageFixAngle
         * @constructor
         * @param {ICEntityMessageFixAngle=} [properties] Properties to set
         */
        function CEntityMessageFixAngle(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CEntityMessageFixAngle relative.
         * @member {boolean} relative
         * @memberof CEntityMessageFixAngle
         * @instance
         */
        CEntityMessageFixAngle.prototype.relative = false;
    
        /**
         * CEntityMessageFixAngle angle.
         * @member {ICMsgQAngle|null|undefined} angle
         * @memberof CEntityMessageFixAngle
         * @instance
         */
        CEntityMessageFixAngle.prototype.angle = null;
    
        /**
         * CEntityMessageFixAngle entityMsg.
         * @member {ICEntityMsg|null|undefined} entityMsg
         * @memberof CEntityMessageFixAngle
         * @instance
         */
        CEntityMessageFixAngle.prototype.entityMsg = null;
    
        /**
         * Creates a new CEntityMessageFixAngle instance using the specified properties.
         * @function create
         * @memberof CEntityMessageFixAngle
         * @static
         * @param {ICEntityMessageFixAngle=} [properties] Properties to set
         * @returns {CEntityMessageFixAngle} CEntityMessageFixAngle instance
         */
        CEntityMessageFixAngle.create = function create(properties) {
            return new CEntityMessageFixAngle(properties);
        };
    
        /**
         * Encodes the specified CEntityMessageFixAngle message. Does not implicitly {@link CEntityMessageFixAngle.verify|verify} messages.
         * @function encode
         * @memberof CEntityMessageFixAngle
         * @static
         * @param {ICEntityMessageFixAngle} message CEntityMessageFixAngle message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CEntityMessageFixAngle.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.relative != null && Object.hasOwnProperty.call(message, "relative"))
                writer.uint32(/* id 1, wireType 0 =*/8).bool(message.relative);
            if (message.angle != null && Object.hasOwnProperty.call(message, "angle"))
                $root.CMsgQAngle.encode(message.angle, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.entityMsg != null && Object.hasOwnProperty.call(message, "entityMsg"))
                $root.CEntityMsg.encode(message.entityMsg, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            return writer;
        };
    
        /**
         * Encodes the specified CEntityMessageFixAngle message, length delimited. Does not implicitly {@link CEntityMessageFixAngle.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CEntityMessageFixAngle
         * @static
         * @param {ICEntityMessageFixAngle} message CEntityMessageFixAngle message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CEntityMessageFixAngle.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CEntityMessageFixAngle message from the specified reader or buffer.
         * @function decode
         * @memberof CEntityMessageFixAngle
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CEntityMessageFixAngle} CEntityMessageFixAngle
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CEntityMessageFixAngle.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CEntityMessageFixAngle();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.relative = reader.bool();
                        break;
                    }
                case 2: {
                        message.angle = $root.CMsgQAngle.decode(reader, reader.uint32());
                        break;
                    }
                case 3: {
                        message.entityMsg = $root.CEntityMsg.decode(reader, reader.uint32());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CEntityMessageFixAngle message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CEntityMessageFixAngle
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CEntityMessageFixAngle} CEntityMessageFixAngle
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CEntityMessageFixAngle.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CEntityMessageFixAngle message.
         * @function verify
         * @memberof CEntityMessageFixAngle
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CEntityMessageFixAngle.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.relative != null && message.hasOwnProperty("relative"))
                if (typeof message.relative !== "boolean")
                    return "relative: boolean expected";
            if (message.angle != null && message.hasOwnProperty("angle")) {
                var error = $root.CMsgQAngle.verify(message.angle);
                if (error)
                    return "angle." + error;
            }
            if (message.entityMsg != null && message.hasOwnProperty("entityMsg")) {
                var error = $root.CEntityMsg.verify(message.entityMsg);
                if (error)
                    return "entityMsg." + error;
            }
            return null;
        };
    
        /**
         * Creates a CEntityMessageFixAngle message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CEntityMessageFixAngle
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CEntityMessageFixAngle} CEntityMessageFixAngle
         */
        CEntityMessageFixAngle.fromObject = function fromObject(object) {
            if (object instanceof $root.CEntityMessageFixAngle)
                return object;
            var message = new $root.CEntityMessageFixAngle();
            if (object.relative != null)
                message.relative = Boolean(object.relative);
            if (object.angle != null) {
                if (typeof object.angle !== "object")
                    throw TypeError(".CEntityMessageFixAngle.angle: object expected");
                message.angle = $root.CMsgQAngle.fromObject(object.angle);
            }
            if (object.entityMsg != null) {
                if (typeof object.entityMsg !== "object")
                    throw TypeError(".CEntityMessageFixAngle.entityMsg: object expected");
                message.entityMsg = $root.CEntityMsg.fromObject(object.entityMsg);
            }
            return message;
        };
    
        /**
         * Creates a plain object from a CEntityMessageFixAngle message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CEntityMessageFixAngle
         * @static
         * @param {CEntityMessageFixAngle} message CEntityMessageFixAngle
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CEntityMessageFixAngle.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.relative = false;
                object.angle = null;
                object.entityMsg = null;
            }
            if (message.relative != null && message.hasOwnProperty("relative"))
                object.relative = message.relative;
            if (message.angle != null && message.hasOwnProperty("angle"))
                object.angle = $root.CMsgQAngle.toObject(message.angle, options);
            if (message.entityMsg != null && message.hasOwnProperty("entityMsg"))
                object.entityMsg = $root.CEntityMsg.toObject(message.entityMsg, options);
            return object;
        };
    
        /**
         * Converts this CEntityMessageFixAngle to JSON.
         * @function toJSON
         * @memberof CEntityMessageFixAngle
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CEntityMessageFixAngle.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * Gets the default type url for CEntityMessageFixAngle
         * @function getTypeUrl
         * @memberof CEntityMessageFixAngle
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        CEntityMessageFixAngle.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/CEntityMessageFixAngle";
        };
    
        return CEntityMessageFixAngle;
    })();
    
    $root.CUserMessageCameraTransition = (function() {
    
        /**
         * Properties of a CUserMessageCameraTransition.
         * @exports ICUserMessageCameraTransition
         * @interface ICUserMessageCameraTransition
         * @property {number|null} [cameraType] CUserMessageCameraTransition cameraType
         * @property {number|null} [duration] CUserMessageCameraTransition duration
         * @property {CUserMessageCameraTransition.ITransition_DataDriven|null} [paramsDataDriven] CUserMessageCameraTransition paramsDataDriven
         */
    
        /**
         * Constructs a new CUserMessageCameraTransition.
         * @exports CUserMessageCameraTransition
         * @classdesc Represents a CUserMessageCameraTransition.
         * @implements ICUserMessageCameraTransition
         * @constructor
         * @param {ICUserMessageCameraTransition=} [properties] Properties to set
         */
        function CUserMessageCameraTransition(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CUserMessageCameraTransition cameraType.
         * @member {number} cameraType
         * @memberof CUserMessageCameraTransition
         * @instance
         */
        CUserMessageCameraTransition.prototype.cameraType = 0;
    
        /**
         * CUserMessageCameraTransition duration.
         * @member {number} duration
         * @memberof CUserMessageCameraTransition
         * @instance
         */
        CUserMessageCameraTransition.prototype.duration = 0;
    
        /**
         * CUserMessageCameraTransition paramsDataDriven.
         * @member {CUserMessageCameraTransition.ITransition_DataDriven|null|undefined} paramsDataDriven
         * @memberof CUserMessageCameraTransition
         * @instance
         */
        CUserMessageCameraTransition.prototype.paramsDataDriven = null;
    
        /**
         * Creates a new CUserMessageCameraTransition instance using the specified properties.
         * @function create
         * @memberof CUserMessageCameraTransition
         * @static
         * @param {ICUserMessageCameraTransition=} [properties] Properties to set
         * @returns {CUserMessageCameraTransition} CUserMessageCameraTransition instance
         */
        CUserMessageCameraTransition.create = function create(properties) {
            return new CUserMessageCameraTransition(properties);
        };
    
        /**
         * Encodes the specified CUserMessageCameraTransition message. Does not implicitly {@link CUserMessageCameraTransition.verify|verify} messages.
         * @function encode
         * @memberof CUserMessageCameraTransition
         * @static
         * @param {ICUserMessageCameraTransition} message CUserMessageCameraTransition message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CUserMessageCameraTransition.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.cameraType != null && Object.hasOwnProperty.call(message, "cameraType"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.cameraType);
            if (message.duration != null && Object.hasOwnProperty.call(message, "duration"))
                writer.uint32(/* id 2, wireType 5 =*/21).float(message.duration);
            if (message.paramsDataDriven != null && Object.hasOwnProperty.call(message, "paramsDataDriven"))
                $root.CUserMessageCameraTransition.Transition_DataDriven.encode(message.paramsDataDriven, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            return writer;
        };
    
        /**
         * Encodes the specified CUserMessageCameraTransition message, length delimited. Does not implicitly {@link CUserMessageCameraTransition.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CUserMessageCameraTransition
         * @static
         * @param {ICUserMessageCameraTransition} message CUserMessageCameraTransition message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CUserMessageCameraTransition.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CUserMessageCameraTransition message from the specified reader or buffer.
         * @function decode
         * @memberof CUserMessageCameraTransition
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CUserMessageCameraTransition} CUserMessageCameraTransition
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CUserMessageCameraTransition.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CUserMessageCameraTransition();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.cameraType = reader.uint32();
                        break;
                    }
                case 2: {
                        message.duration = reader.float();
                        break;
                    }
                case 3: {
                        message.paramsDataDriven = $root.CUserMessageCameraTransition.Transition_DataDriven.decode(reader, reader.uint32());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CUserMessageCameraTransition message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CUserMessageCameraTransition
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CUserMessageCameraTransition} CUserMessageCameraTransition
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CUserMessageCameraTransition.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CUserMessageCameraTransition message.
         * @function verify
         * @memberof CUserMessageCameraTransition
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CUserMessageCameraTransition.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.cameraType != null && message.hasOwnProperty("cameraType"))
                if (!$util.isInteger(message.cameraType))
                    return "cameraType: integer expected";
            if (message.duration != null && message.hasOwnProperty("duration"))
                if (typeof message.duration !== "number")
                    return "duration: number expected";
            if (message.paramsDataDriven != null && message.hasOwnProperty("paramsDataDriven")) {
                var error = $root.CUserMessageCameraTransition.Transition_DataDriven.verify(message.paramsDataDriven);
                if (error)
                    return "paramsDataDriven." + error;
            }
            return null;
        };
    
        /**
         * Creates a CUserMessageCameraTransition message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CUserMessageCameraTransition
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CUserMessageCameraTransition} CUserMessageCameraTransition
         */
        CUserMessageCameraTransition.fromObject = function fromObject(object) {
            if (object instanceof $root.CUserMessageCameraTransition)
                return object;
            var message = new $root.CUserMessageCameraTransition();
            if (object.cameraType != null)
                message.cameraType = object.cameraType >>> 0;
            if (object.duration != null)
                message.duration = Number(object.duration);
            if (object.paramsDataDriven != null) {
                if (typeof object.paramsDataDriven !== "object")
                    throw TypeError(".CUserMessageCameraTransition.paramsDataDriven: object expected");
                message.paramsDataDriven = $root.CUserMessageCameraTransition.Transition_DataDriven.fromObject(object.paramsDataDriven);
            }
            return message;
        };
    
        /**
         * Creates a plain object from a CUserMessageCameraTransition message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CUserMessageCameraTransition
         * @static
         * @param {CUserMessageCameraTransition} message CUserMessageCameraTransition
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CUserMessageCameraTransition.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.cameraType = 0;
                object.duration = 0;
                object.paramsDataDriven = null;
            }
            if (message.cameraType != null && message.hasOwnProperty("cameraType"))
                object.cameraType = message.cameraType;
            if (message.duration != null && message.hasOwnProperty("duration"))
                object.duration = options.json && !isFinite(message.duration) ? String(message.duration) : message.duration;
            if (message.paramsDataDriven != null && message.hasOwnProperty("paramsDataDriven"))
                object.paramsDataDriven = $root.CUserMessageCameraTransition.Transition_DataDriven.toObject(message.paramsDataDriven, options);
            return object;
        };
    
        /**
         * Converts this CUserMessageCameraTransition to JSON.
         * @function toJSON
         * @memberof CUserMessageCameraTransition
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CUserMessageCameraTransition.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * Gets the default type url for CUserMessageCameraTransition
         * @function getTypeUrl
         * @memberof CUserMessageCameraTransition
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        CUserMessageCameraTransition.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/CUserMessageCameraTransition";
        };
    
        CUserMessageCameraTransition.Transition_DataDriven = (function() {
    
            /**
             * Properties of a Transition_DataDriven.
             * @memberof CUserMessageCameraTransition
             * @interface ITransition_DataDriven
             * @property {string|null} [filename] Transition_DataDriven filename
             * @property {number|null} [attachEntIndex] Transition_DataDriven attachEntIndex
             * @property {number|null} [duration] Transition_DataDriven duration
             */
    
            /**
             * Constructs a new Transition_DataDriven.
             * @memberof CUserMessageCameraTransition
             * @classdesc Represents a Transition_DataDriven.
             * @implements ITransition_DataDriven
             * @constructor
             * @param {CUserMessageCameraTransition.ITransition_DataDriven=} [properties] Properties to set
             */
            function Transition_DataDriven(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * Transition_DataDriven filename.
             * @member {string} filename
             * @memberof CUserMessageCameraTransition.Transition_DataDriven
             * @instance
             */
            Transition_DataDriven.prototype.filename = "";
    
            /**
             * Transition_DataDriven attachEntIndex.
             * @member {number} attachEntIndex
             * @memberof CUserMessageCameraTransition.Transition_DataDriven
             * @instance
             */
            Transition_DataDriven.prototype.attachEntIndex = -1;
    
            /**
             * Transition_DataDriven duration.
             * @member {number} duration
             * @memberof CUserMessageCameraTransition.Transition_DataDriven
             * @instance
             */
            Transition_DataDriven.prototype.duration = 0;
    
            /**
             * Creates a new Transition_DataDriven instance using the specified properties.
             * @function create
             * @memberof CUserMessageCameraTransition.Transition_DataDriven
             * @static
             * @param {CUserMessageCameraTransition.ITransition_DataDriven=} [properties] Properties to set
             * @returns {CUserMessageCameraTransition.Transition_DataDriven} Transition_DataDriven instance
             */
            Transition_DataDriven.create = function create(properties) {
                return new Transition_DataDriven(properties);
            };
    
            /**
             * Encodes the specified Transition_DataDriven message. Does not implicitly {@link CUserMessageCameraTransition.Transition_DataDriven.verify|verify} messages.
             * @function encode
             * @memberof CUserMessageCameraTransition.Transition_DataDriven
             * @static
             * @param {CUserMessageCameraTransition.ITransition_DataDriven} message Transition_DataDriven message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Transition_DataDriven.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.filename != null && Object.hasOwnProperty.call(message, "filename"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.filename);
                if (message.attachEntIndex != null && Object.hasOwnProperty.call(message, "attachEntIndex"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.attachEntIndex);
                if (message.duration != null && Object.hasOwnProperty.call(message, "duration"))
                    writer.uint32(/* id 3, wireType 5 =*/29).float(message.duration);
                return writer;
            };
    
            /**
             * Encodes the specified Transition_DataDriven message, length delimited. Does not implicitly {@link CUserMessageCameraTransition.Transition_DataDriven.verify|verify} messages.
             * @function encodeDelimited
             * @memberof CUserMessageCameraTransition.Transition_DataDriven
             * @static
             * @param {CUserMessageCameraTransition.ITransition_DataDriven} message Transition_DataDriven message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Transition_DataDriven.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a Transition_DataDriven message from the specified reader or buffer.
             * @function decode
             * @memberof CUserMessageCameraTransition.Transition_DataDriven
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {CUserMessageCameraTransition.Transition_DataDriven} Transition_DataDriven
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Transition_DataDriven.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CUserMessageCameraTransition.Transition_DataDriven();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.filename = reader.string();
                            break;
                        }
                    case 2: {
                            message.attachEntIndex = reader.int32();
                            break;
                        }
                    case 3: {
                            message.duration = reader.float();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a Transition_DataDriven message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof CUserMessageCameraTransition.Transition_DataDriven
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {CUserMessageCameraTransition.Transition_DataDriven} Transition_DataDriven
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Transition_DataDriven.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a Transition_DataDriven message.
             * @function verify
             * @memberof CUserMessageCameraTransition.Transition_DataDriven
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Transition_DataDriven.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.filename != null && message.hasOwnProperty("filename"))
                    if (!$util.isString(message.filename))
                        return "filename: string expected";
                if (message.attachEntIndex != null && message.hasOwnProperty("attachEntIndex"))
                    if (!$util.isInteger(message.attachEntIndex))
                        return "attachEntIndex: integer expected";
                if (message.duration != null && message.hasOwnProperty("duration"))
                    if (typeof message.duration !== "number")
                        return "duration: number expected";
                return null;
            };
    
            /**
             * Creates a Transition_DataDriven message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof CUserMessageCameraTransition.Transition_DataDriven
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {CUserMessageCameraTransition.Transition_DataDriven} Transition_DataDriven
             */
            Transition_DataDriven.fromObject = function fromObject(object) {
                if (object instanceof $root.CUserMessageCameraTransition.Transition_DataDriven)
                    return object;
                var message = new $root.CUserMessageCameraTransition.Transition_DataDriven();
                if (object.filename != null)
                    message.filename = String(object.filename);
                if (object.attachEntIndex != null)
                    message.attachEntIndex = object.attachEntIndex | 0;
                if (object.duration != null)
                    message.duration = Number(object.duration);
                return message;
            };
    
            /**
             * Creates a plain object from a Transition_DataDriven message. Also converts values to other types if specified.
             * @function toObject
             * @memberof CUserMessageCameraTransition.Transition_DataDriven
             * @static
             * @param {CUserMessageCameraTransition.Transition_DataDriven} message Transition_DataDriven
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Transition_DataDriven.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.filename = "";
                    object.attachEntIndex = -1;
                    object.duration = 0;
                }
                if (message.filename != null && message.hasOwnProperty("filename"))
                    object.filename = message.filename;
                if (message.attachEntIndex != null && message.hasOwnProperty("attachEntIndex"))
                    object.attachEntIndex = message.attachEntIndex;
                if (message.duration != null && message.hasOwnProperty("duration"))
                    object.duration = options.json && !isFinite(message.duration) ? String(message.duration) : message.duration;
                return object;
            };
    
            /**
             * Converts this Transition_DataDriven to JSON.
             * @function toJSON
             * @memberof CUserMessageCameraTransition.Transition_DataDriven
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Transition_DataDriven.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            /**
             * Gets the default type url for Transition_DataDriven
             * @function getTypeUrl
             * @memberof CUserMessageCameraTransition.Transition_DataDriven
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            Transition_DataDriven.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/CUserMessageCameraTransition.Transition_DataDriven";
            };
    
            return Transition_DataDriven;
        })();
    
        return CUserMessageCameraTransition;
    })();
    
    $root.CUserMsg_ParticleManager = (function() {
    
        /**
         * Properties of a CUserMsg_ParticleManager.
         * @exports ICUserMsg_ParticleManager
         * @interface ICUserMsg_ParticleManager
         * @property {PARTICLE_MESSAGE} type CUserMsg_ParticleManager type
         * @property {number} index CUserMsg_ParticleManager index
         * @property {CUserMsg_ParticleManager.IReleaseParticleIndex|null} [releaseParticleIndex] CUserMsg_ParticleManager releaseParticleIndex
         * @property {CUserMsg_ParticleManager.ICreateParticle|null} [createParticle] CUserMsg_ParticleManager createParticle
         * @property {CUserMsg_ParticleManager.IDestroyParticle|null} [destroyParticle] CUserMsg_ParticleManager destroyParticle
         * @property {CUserMsg_ParticleManager.IDestroyParticleInvolving|null} [destroyParticleInvolving] CUserMsg_ParticleManager destroyParticleInvolving
         * @property {CUserMsg_ParticleManager.IUpdateParticle_OBSOLETE|null} [updateParticle] CUserMsg_ParticleManager updateParticle
         * @property {CUserMsg_ParticleManager.IUpdateParticleFwd_OBSOLETE|null} [updateParticleFwd] CUserMsg_ParticleManager updateParticleFwd
         * @property {CUserMsg_ParticleManager.IUpdateParticleOrient_OBSOLETE|null} [updateParticleOrient] CUserMsg_ParticleManager updateParticleOrient
         * @property {CUserMsg_ParticleManager.IUpdateParticleFallback|null} [updateParticleFallback] CUserMsg_ParticleManager updateParticleFallback
         * @property {CUserMsg_ParticleManager.IUpdateParticleOffset|null} [updateParticleOffset] CUserMsg_ParticleManager updateParticleOffset
         * @property {CUserMsg_ParticleManager.IUpdateParticleEnt|null} [updateParticleEnt] CUserMsg_ParticleManager updateParticleEnt
         * @property {CUserMsg_ParticleManager.IUpdateParticleShouldDraw|null} [updateParticleShouldDraw] CUserMsg_ParticleManager updateParticleShouldDraw
         * @property {CUserMsg_ParticleManager.IUpdateParticleSetFrozen|null} [updateParticleSetFrozen] CUserMsg_ParticleManager updateParticleSetFrozen
         * @property {CUserMsg_ParticleManager.IChangeControlPointAttachment|null} [changeControlPointAttachment] CUserMsg_ParticleManager changeControlPointAttachment
         * @property {CUserMsg_ParticleManager.IUpdateEntityPosition|null} [updateEntityPosition] CUserMsg_ParticleManager updateEntityPosition
         * @property {CUserMsg_ParticleManager.ISetParticleFoWProperties|null} [setParticleFowProperties] CUserMsg_ParticleManager setParticleFowProperties
         * @property {CUserMsg_ParticleManager.ISetParticleText|null} [setParticleText] CUserMsg_ParticleManager setParticleText
         * @property {CUserMsg_ParticleManager.ISetParticleShouldCheckFoW|null} [setParticleShouldCheckFow] CUserMsg_ParticleManager setParticleShouldCheckFow
         * @property {CUserMsg_ParticleManager.ISetControlPointModel|null} [setControlPointModel] CUserMsg_ParticleManager setControlPointModel
         * @property {CUserMsg_ParticleManager.ISetControlPointSnapshot|null} [setControlPointSnapshot] CUserMsg_ParticleManager setControlPointSnapshot
         * @property {CUserMsg_ParticleManager.ISetTextureAttribute|null} [setTextureAttribute] CUserMsg_ParticleManager setTextureAttribute
         * @property {CUserMsg_ParticleManager.ISetSceneObjectGenericFlag|null} [setSceneObjectGenericFlag] CUserMsg_ParticleManager setSceneObjectGenericFlag
         * @property {CUserMsg_ParticleManager.ISetSceneObjectTintAndDesat|null} [setSceneObjectTintAndDesat] CUserMsg_ParticleManager setSceneObjectTintAndDesat
         * @property {CUserMsg_ParticleManager.IDestroyParticleNamed|null} [destroyParticleNamed] CUserMsg_ParticleManager destroyParticleNamed
         * @property {CUserMsg_ParticleManager.IParticleSkipToTime|null} [particleSkipToTime] CUserMsg_ParticleManager particleSkipToTime
         * @property {CUserMsg_ParticleManager.IParticleCanFreeze|null} [particleCanFreeze] CUserMsg_ParticleManager particleCanFreeze
         * @property {CUserMsg_ParticleManager.ISetParticleNamedValueContext|null} [setNamedValueContext] CUserMsg_ParticleManager setNamedValueContext
         * @property {CUserMsg_ParticleManager.IUpdateParticleTransform|null} [updateParticleTransform] CUserMsg_ParticleManager updateParticleTransform
         * @property {CUserMsg_ParticleManager.IParticleFreezeTransitionOverride|null} [particleFreezeTransitionOverride] CUserMsg_ParticleManager particleFreezeTransitionOverride
         * @property {CUserMsg_ParticleManager.IFreezeParticleInvolving|null} [freezeParticleInvolving] CUserMsg_ParticleManager freezeParticleInvolving
         */
    
        /**
         * Constructs a new CUserMsg_ParticleManager.
         * @exports CUserMsg_ParticleManager
         * @classdesc Represents a CUserMsg_ParticleManager.
         * @implements ICUserMsg_ParticleManager
         * @constructor
         * @param {ICUserMsg_ParticleManager=} [properties] Properties to set
         */
        function CUserMsg_ParticleManager(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CUserMsg_ParticleManager type.
         * @member {PARTICLE_MESSAGE} type
         * @memberof CUserMsg_ParticleManager
         * @instance
         */
        CUserMsg_ParticleManager.prototype.type = 0;
    
        /**
         * CUserMsg_ParticleManager index.
         * @member {number} index
         * @memberof CUserMsg_ParticleManager
         * @instance
         */
        CUserMsg_ParticleManager.prototype.index = 0;
    
        /**
         * CUserMsg_ParticleManager releaseParticleIndex.
         * @member {CUserMsg_ParticleManager.IReleaseParticleIndex|null|undefined} releaseParticleIndex
         * @memberof CUserMsg_ParticleManager
         * @instance
         */
        CUserMsg_ParticleManager.prototype.releaseParticleIndex = null;
    
        /**
         * CUserMsg_ParticleManager createParticle.
         * @member {CUserMsg_ParticleManager.ICreateParticle|null|undefined} createParticle
         * @memberof CUserMsg_ParticleManager
         * @instance
         */
        CUserMsg_ParticleManager.prototype.createParticle = null;
    
        /**
         * CUserMsg_ParticleManager destroyParticle.
         * @member {CUserMsg_ParticleManager.IDestroyParticle|null|undefined} destroyParticle
         * @memberof CUserMsg_ParticleManager
         * @instance
         */
        CUserMsg_ParticleManager.prototype.destroyParticle = null;
    
        /**
         * CUserMsg_ParticleManager destroyParticleInvolving.
         * @member {CUserMsg_ParticleManager.IDestroyParticleInvolving|null|undefined} destroyParticleInvolving
         * @memberof CUserMsg_ParticleManager
         * @instance
         */
        CUserMsg_ParticleManager.prototype.destroyParticleInvolving = null;
    
        /**
         * CUserMsg_ParticleManager updateParticle.
         * @member {CUserMsg_ParticleManager.IUpdateParticle_OBSOLETE|null|undefined} updateParticle
         * @memberof CUserMsg_ParticleManager
         * @instance
         */
        CUserMsg_ParticleManager.prototype.updateParticle = null;
    
        /**
         * CUserMsg_ParticleManager updateParticleFwd.
         * @member {CUserMsg_ParticleManager.IUpdateParticleFwd_OBSOLETE|null|undefined} updateParticleFwd
         * @memberof CUserMsg_ParticleManager
         * @instance
         */
        CUserMsg_ParticleManager.prototype.updateParticleFwd = null;
    
        /**
         * CUserMsg_ParticleManager updateParticleOrient.
         * @member {CUserMsg_ParticleManager.IUpdateParticleOrient_OBSOLETE|null|undefined} updateParticleOrient
         * @memberof CUserMsg_ParticleManager
         * @instance
         */
        CUserMsg_ParticleManager.prototype.updateParticleOrient = null;
    
        /**
         * CUserMsg_ParticleManager updateParticleFallback.
         * @member {CUserMsg_ParticleManager.IUpdateParticleFallback|null|undefined} updateParticleFallback
         * @memberof CUserMsg_ParticleManager
         * @instance
         */
        CUserMsg_ParticleManager.prototype.updateParticleFallback = null;
    
        /**
         * CUserMsg_ParticleManager updateParticleOffset.
         * @member {CUserMsg_ParticleManager.IUpdateParticleOffset|null|undefined} updateParticleOffset
         * @memberof CUserMsg_ParticleManager
         * @instance
         */
        CUserMsg_ParticleManager.prototype.updateParticleOffset = null;
    
        /**
         * CUserMsg_ParticleManager updateParticleEnt.
         * @member {CUserMsg_ParticleManager.IUpdateParticleEnt|null|undefined} updateParticleEnt
         * @memberof CUserMsg_ParticleManager
         * @instance
         */
        CUserMsg_ParticleManager.prototype.updateParticleEnt = null;
    
        /**
         * CUserMsg_ParticleManager updateParticleShouldDraw.
         * @member {CUserMsg_ParticleManager.IUpdateParticleShouldDraw|null|undefined} updateParticleShouldDraw
         * @memberof CUserMsg_ParticleManager
         * @instance
         */
        CUserMsg_ParticleManager.prototype.updateParticleShouldDraw = null;
    
        /**
         * CUserMsg_ParticleManager updateParticleSetFrozen.
         * @member {CUserMsg_ParticleManager.IUpdateParticleSetFrozen|null|undefined} updateParticleSetFrozen
         * @memberof CUserMsg_ParticleManager
         * @instance
         */
        CUserMsg_ParticleManager.prototype.updateParticleSetFrozen = null;
    
        /**
         * CUserMsg_ParticleManager changeControlPointAttachment.
         * @member {CUserMsg_ParticleManager.IChangeControlPointAttachment|null|undefined} changeControlPointAttachment
         * @memberof CUserMsg_ParticleManager
         * @instance
         */
        CUserMsg_ParticleManager.prototype.changeControlPointAttachment = null;
    
        /**
         * CUserMsg_ParticleManager updateEntityPosition.
         * @member {CUserMsg_ParticleManager.IUpdateEntityPosition|null|undefined} updateEntityPosition
         * @memberof CUserMsg_ParticleManager
         * @instance
         */
        CUserMsg_ParticleManager.prototype.updateEntityPosition = null;
    
        /**
         * CUserMsg_ParticleManager setParticleFowProperties.
         * @member {CUserMsg_ParticleManager.ISetParticleFoWProperties|null|undefined} setParticleFowProperties
         * @memberof CUserMsg_ParticleManager
         * @instance
         */
        CUserMsg_ParticleManager.prototype.setParticleFowProperties = null;
    
        /**
         * CUserMsg_ParticleManager setParticleText.
         * @member {CUserMsg_ParticleManager.ISetParticleText|null|undefined} setParticleText
         * @memberof CUserMsg_ParticleManager
         * @instance
         */
        CUserMsg_ParticleManager.prototype.setParticleText = null;
    
        /**
         * CUserMsg_ParticleManager setParticleShouldCheckFow.
         * @member {CUserMsg_ParticleManager.ISetParticleShouldCheckFoW|null|undefined} setParticleShouldCheckFow
         * @memberof CUserMsg_ParticleManager
         * @instance
         */
        CUserMsg_ParticleManager.prototype.setParticleShouldCheckFow = null;
    
        /**
         * CUserMsg_ParticleManager setControlPointModel.
         * @member {CUserMsg_ParticleManager.ISetControlPointModel|null|undefined} setControlPointModel
         * @memberof CUserMsg_ParticleManager
         * @instance
         */
        CUserMsg_ParticleManager.prototype.setControlPointModel = null;
    
        /**
         * CUserMsg_ParticleManager setControlPointSnapshot.
         * @member {CUserMsg_ParticleManager.ISetControlPointSnapshot|null|undefined} setControlPointSnapshot
         * @memberof CUserMsg_ParticleManager
         * @instance
         */
        CUserMsg_ParticleManager.prototype.setControlPointSnapshot = null;
    
        /**
         * CUserMsg_ParticleManager setTextureAttribute.
         * @member {CUserMsg_ParticleManager.ISetTextureAttribute|null|undefined} setTextureAttribute
         * @memberof CUserMsg_ParticleManager
         * @instance
         */
        CUserMsg_ParticleManager.prototype.setTextureAttribute = null;
    
        /**
         * CUserMsg_ParticleManager setSceneObjectGenericFlag.
         * @member {CUserMsg_ParticleManager.ISetSceneObjectGenericFlag|null|undefined} setSceneObjectGenericFlag
         * @memberof CUserMsg_ParticleManager
         * @instance
         */
        CUserMsg_ParticleManager.prototype.setSceneObjectGenericFlag = null;
    
        /**
         * CUserMsg_ParticleManager setSceneObjectTintAndDesat.
         * @member {CUserMsg_ParticleManager.ISetSceneObjectTintAndDesat|null|undefined} setSceneObjectTintAndDesat
         * @memberof CUserMsg_ParticleManager
         * @instance
         */
        CUserMsg_ParticleManager.prototype.setSceneObjectTintAndDesat = null;
    
        /**
         * CUserMsg_ParticleManager destroyParticleNamed.
         * @member {CUserMsg_ParticleManager.IDestroyParticleNamed|null|undefined} destroyParticleNamed
         * @memberof CUserMsg_ParticleManager
         * @instance
         */
        CUserMsg_ParticleManager.prototype.destroyParticleNamed = null;
    
        /**
         * CUserMsg_ParticleManager particleSkipToTime.
         * @member {CUserMsg_ParticleManager.IParticleSkipToTime|null|undefined} particleSkipToTime
         * @memberof CUserMsg_ParticleManager
         * @instance
         */
        CUserMsg_ParticleManager.prototype.particleSkipToTime = null;
    
        /**
         * CUserMsg_ParticleManager particleCanFreeze.
         * @member {CUserMsg_ParticleManager.IParticleCanFreeze|null|undefined} particleCanFreeze
         * @memberof CUserMsg_ParticleManager
         * @instance
         */
        CUserMsg_ParticleManager.prototype.particleCanFreeze = null;
    
        /**
         * CUserMsg_ParticleManager setNamedValueContext.
         * @member {CUserMsg_ParticleManager.ISetParticleNamedValueContext|null|undefined} setNamedValueContext
         * @memberof CUserMsg_ParticleManager
         * @instance
         */
        CUserMsg_ParticleManager.prototype.setNamedValueContext = null;
    
        /**
         * CUserMsg_ParticleManager updateParticleTransform.
         * @member {CUserMsg_ParticleManager.IUpdateParticleTransform|null|undefined} updateParticleTransform
         * @memberof CUserMsg_ParticleManager
         * @instance
         */
        CUserMsg_ParticleManager.prototype.updateParticleTransform = null;
    
        /**
         * CUserMsg_ParticleManager particleFreezeTransitionOverride.
         * @member {CUserMsg_ParticleManager.IParticleFreezeTransitionOverride|null|undefined} particleFreezeTransitionOverride
         * @memberof CUserMsg_ParticleManager
         * @instance
         */
        CUserMsg_ParticleManager.prototype.particleFreezeTransitionOverride = null;
    
        /**
         * CUserMsg_ParticleManager freezeParticleInvolving.
         * @member {CUserMsg_ParticleManager.IFreezeParticleInvolving|null|undefined} freezeParticleInvolving
         * @memberof CUserMsg_ParticleManager
         * @instance
         */
        CUserMsg_ParticleManager.prototype.freezeParticleInvolving = null;
    
        /**
         * Creates a new CUserMsg_ParticleManager instance using the specified properties.
         * @function create
         * @memberof CUserMsg_ParticleManager
         * @static
         * @param {ICUserMsg_ParticleManager=} [properties] Properties to set
         * @returns {CUserMsg_ParticleManager} CUserMsg_ParticleManager instance
         */
        CUserMsg_ParticleManager.create = function create(properties) {
            return new CUserMsg_ParticleManager(properties);
        };
    
        /**
         * Encodes the specified CUserMsg_ParticleManager message. Does not implicitly {@link CUserMsg_ParticleManager.verify|verify} messages.
         * @function encode
         * @memberof CUserMsg_ParticleManager
         * @static
         * @param {ICUserMsg_ParticleManager} message CUserMsg_ParticleManager message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CUserMsg_ParticleManager.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
            writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.index);
            if (message.releaseParticleIndex != null && Object.hasOwnProperty.call(message, "releaseParticleIndex"))
                $root.CUserMsg_ParticleManager.ReleaseParticleIndex.encode(message.releaseParticleIndex, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.createParticle != null && Object.hasOwnProperty.call(message, "createParticle"))
                $root.CUserMsg_ParticleManager.CreateParticle.encode(message.createParticle, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            if (message.destroyParticle != null && Object.hasOwnProperty.call(message, "destroyParticle"))
                $root.CUserMsg_ParticleManager.DestroyParticle.encode(message.destroyParticle, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            if (message.destroyParticleInvolving != null && Object.hasOwnProperty.call(message, "destroyParticleInvolving"))
                $root.CUserMsg_ParticleManager.DestroyParticleInvolving.encode(message.destroyParticleInvolving, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
            if (message.updateParticle != null && Object.hasOwnProperty.call(message, "updateParticle"))
                $root.CUserMsg_ParticleManager.UpdateParticle_OBSOLETE.encode(message.updateParticle, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
            if (message.updateParticleFwd != null && Object.hasOwnProperty.call(message, "updateParticleFwd"))
                $root.CUserMsg_ParticleManager.UpdateParticleFwd_OBSOLETE.encode(message.updateParticleFwd, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
            if (message.updateParticleOrient != null && Object.hasOwnProperty.call(message, "updateParticleOrient"))
                $root.CUserMsg_ParticleManager.UpdateParticleOrient_OBSOLETE.encode(message.updateParticleOrient, writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
            if (message.updateParticleFallback != null && Object.hasOwnProperty.call(message, "updateParticleFallback"))
                $root.CUserMsg_ParticleManager.UpdateParticleFallback.encode(message.updateParticleFallback, writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();
            if (message.updateParticleOffset != null && Object.hasOwnProperty.call(message, "updateParticleOffset"))
                $root.CUserMsg_ParticleManager.UpdateParticleOffset.encode(message.updateParticleOffset, writer.uint32(/* id 11, wireType 2 =*/90).fork()).ldelim();
            if (message.updateParticleEnt != null && Object.hasOwnProperty.call(message, "updateParticleEnt"))
                $root.CUserMsg_ParticleManager.UpdateParticleEnt.encode(message.updateParticleEnt, writer.uint32(/* id 12, wireType 2 =*/98).fork()).ldelim();
            if (message.updateParticleShouldDraw != null && Object.hasOwnProperty.call(message, "updateParticleShouldDraw"))
                $root.CUserMsg_ParticleManager.UpdateParticleShouldDraw.encode(message.updateParticleShouldDraw, writer.uint32(/* id 14, wireType 2 =*/114).fork()).ldelim();
            if (message.updateParticleSetFrozen != null && Object.hasOwnProperty.call(message, "updateParticleSetFrozen"))
                $root.CUserMsg_ParticleManager.UpdateParticleSetFrozen.encode(message.updateParticleSetFrozen, writer.uint32(/* id 15, wireType 2 =*/122).fork()).ldelim();
            if (message.changeControlPointAttachment != null && Object.hasOwnProperty.call(message, "changeControlPointAttachment"))
                $root.CUserMsg_ParticleManager.ChangeControlPointAttachment.encode(message.changeControlPointAttachment, writer.uint32(/* id 16, wireType 2 =*/130).fork()).ldelim();
            if (message.updateEntityPosition != null && Object.hasOwnProperty.call(message, "updateEntityPosition"))
                $root.CUserMsg_ParticleManager.UpdateEntityPosition.encode(message.updateEntityPosition, writer.uint32(/* id 17, wireType 2 =*/138).fork()).ldelim();
            if (message.setParticleFowProperties != null && Object.hasOwnProperty.call(message, "setParticleFowProperties"))
                $root.CUserMsg_ParticleManager.SetParticleFoWProperties.encode(message.setParticleFowProperties, writer.uint32(/* id 18, wireType 2 =*/146).fork()).ldelim();
            if (message.setParticleText != null && Object.hasOwnProperty.call(message, "setParticleText"))
                $root.CUserMsg_ParticleManager.SetParticleText.encode(message.setParticleText, writer.uint32(/* id 19, wireType 2 =*/154).fork()).ldelim();
            if (message.setParticleShouldCheckFow != null && Object.hasOwnProperty.call(message, "setParticleShouldCheckFow"))
                $root.CUserMsg_ParticleManager.SetParticleShouldCheckFoW.encode(message.setParticleShouldCheckFow, writer.uint32(/* id 20, wireType 2 =*/162).fork()).ldelim();
            if (message.setControlPointModel != null && Object.hasOwnProperty.call(message, "setControlPointModel"))
                $root.CUserMsg_ParticleManager.SetControlPointModel.encode(message.setControlPointModel, writer.uint32(/* id 21, wireType 2 =*/170).fork()).ldelim();
            if (message.setControlPointSnapshot != null && Object.hasOwnProperty.call(message, "setControlPointSnapshot"))
                $root.CUserMsg_ParticleManager.SetControlPointSnapshot.encode(message.setControlPointSnapshot, writer.uint32(/* id 22, wireType 2 =*/178).fork()).ldelim();
            if (message.setTextureAttribute != null && Object.hasOwnProperty.call(message, "setTextureAttribute"))
                $root.CUserMsg_ParticleManager.SetTextureAttribute.encode(message.setTextureAttribute, writer.uint32(/* id 23, wireType 2 =*/186).fork()).ldelim();
            if (message.setSceneObjectGenericFlag != null && Object.hasOwnProperty.call(message, "setSceneObjectGenericFlag"))
                $root.CUserMsg_ParticleManager.SetSceneObjectGenericFlag.encode(message.setSceneObjectGenericFlag, writer.uint32(/* id 24, wireType 2 =*/194).fork()).ldelim();
            if (message.setSceneObjectTintAndDesat != null && Object.hasOwnProperty.call(message, "setSceneObjectTintAndDesat"))
                $root.CUserMsg_ParticleManager.SetSceneObjectTintAndDesat.encode(message.setSceneObjectTintAndDesat, writer.uint32(/* id 25, wireType 2 =*/202).fork()).ldelim();
            if (message.destroyParticleNamed != null && Object.hasOwnProperty.call(message, "destroyParticleNamed"))
                $root.CUserMsg_ParticleManager.DestroyParticleNamed.encode(message.destroyParticleNamed, writer.uint32(/* id 26, wireType 2 =*/210).fork()).ldelim();
            if (message.particleSkipToTime != null && Object.hasOwnProperty.call(message, "particleSkipToTime"))
                $root.CUserMsg_ParticleManager.ParticleSkipToTime.encode(message.particleSkipToTime, writer.uint32(/* id 27, wireType 2 =*/218).fork()).ldelim();
            if (message.particleCanFreeze != null && Object.hasOwnProperty.call(message, "particleCanFreeze"))
                $root.CUserMsg_ParticleManager.ParticleCanFreeze.encode(message.particleCanFreeze, writer.uint32(/* id 28, wireType 2 =*/226).fork()).ldelim();
            if (message.setNamedValueContext != null && Object.hasOwnProperty.call(message, "setNamedValueContext"))
                $root.CUserMsg_ParticleManager.SetParticleNamedValueContext.encode(message.setNamedValueContext, writer.uint32(/* id 29, wireType 2 =*/234).fork()).ldelim();
            if (message.updateParticleTransform != null && Object.hasOwnProperty.call(message, "updateParticleTransform"))
                $root.CUserMsg_ParticleManager.UpdateParticleTransform.encode(message.updateParticleTransform, writer.uint32(/* id 30, wireType 2 =*/242).fork()).ldelim();
            if (message.particleFreezeTransitionOverride != null && Object.hasOwnProperty.call(message, "particleFreezeTransitionOverride"))
                $root.CUserMsg_ParticleManager.ParticleFreezeTransitionOverride.encode(message.particleFreezeTransitionOverride, writer.uint32(/* id 31, wireType 2 =*/250).fork()).ldelim();
            if (message.freezeParticleInvolving != null && Object.hasOwnProperty.call(message, "freezeParticleInvolving"))
                $root.CUserMsg_ParticleManager.FreezeParticleInvolving.encode(message.freezeParticleInvolving, writer.uint32(/* id 32, wireType 2 =*/258).fork()).ldelim();
            return writer;
        };
    
        /**
         * Encodes the specified CUserMsg_ParticleManager message, length delimited. Does not implicitly {@link CUserMsg_ParticleManager.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CUserMsg_ParticleManager
         * @static
         * @param {ICUserMsg_ParticleManager} message CUserMsg_ParticleManager message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CUserMsg_ParticleManager.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CUserMsg_ParticleManager message from the specified reader or buffer.
         * @function decode
         * @memberof CUserMsg_ParticleManager
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CUserMsg_ParticleManager} CUserMsg_ParticleManager
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CUserMsg_ParticleManager.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CUserMsg_ParticleManager();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.type = reader.int32();
                        break;
                    }
                case 2: {
                        message.index = reader.uint32();
                        break;
                    }
                case 3: {
                        message.releaseParticleIndex = $root.CUserMsg_ParticleManager.ReleaseParticleIndex.decode(reader, reader.uint32());
                        break;
                    }
                case 4: {
                        message.createParticle = $root.CUserMsg_ParticleManager.CreateParticle.decode(reader, reader.uint32());
                        break;
                    }
                case 5: {
                        message.destroyParticle = $root.CUserMsg_ParticleManager.DestroyParticle.decode(reader, reader.uint32());
                        break;
                    }
                case 6: {
                        message.destroyParticleInvolving = $root.CUserMsg_ParticleManager.DestroyParticleInvolving.decode(reader, reader.uint32());
                        break;
                    }
                case 7: {
                        message.updateParticle = $root.CUserMsg_ParticleManager.UpdateParticle_OBSOLETE.decode(reader, reader.uint32());
                        break;
                    }
                case 8: {
                        message.updateParticleFwd = $root.CUserMsg_ParticleManager.UpdateParticleFwd_OBSOLETE.decode(reader, reader.uint32());
                        break;
                    }
                case 9: {
                        message.updateParticleOrient = $root.CUserMsg_ParticleManager.UpdateParticleOrient_OBSOLETE.decode(reader, reader.uint32());
                        break;
                    }
                case 10: {
                        message.updateParticleFallback = $root.CUserMsg_ParticleManager.UpdateParticleFallback.decode(reader, reader.uint32());
                        break;
                    }
                case 11: {
                        message.updateParticleOffset = $root.CUserMsg_ParticleManager.UpdateParticleOffset.decode(reader, reader.uint32());
                        break;
                    }
                case 12: {
                        message.updateParticleEnt = $root.CUserMsg_ParticleManager.UpdateParticleEnt.decode(reader, reader.uint32());
                        break;
                    }
                case 14: {
                        message.updateParticleShouldDraw = $root.CUserMsg_ParticleManager.UpdateParticleShouldDraw.decode(reader, reader.uint32());
                        break;
                    }
                case 15: {
                        message.updateParticleSetFrozen = $root.CUserMsg_ParticleManager.UpdateParticleSetFrozen.decode(reader, reader.uint32());
                        break;
                    }
                case 16: {
                        message.changeControlPointAttachment = $root.CUserMsg_ParticleManager.ChangeControlPointAttachment.decode(reader, reader.uint32());
                        break;
                    }
                case 17: {
                        message.updateEntityPosition = $root.CUserMsg_ParticleManager.UpdateEntityPosition.decode(reader, reader.uint32());
                        break;
                    }
                case 18: {
                        message.setParticleFowProperties = $root.CUserMsg_ParticleManager.SetParticleFoWProperties.decode(reader, reader.uint32());
                        break;
                    }
                case 19: {
                        message.setParticleText = $root.CUserMsg_ParticleManager.SetParticleText.decode(reader, reader.uint32());
                        break;
                    }
                case 20: {
                        message.setParticleShouldCheckFow = $root.CUserMsg_ParticleManager.SetParticleShouldCheckFoW.decode(reader, reader.uint32());
                        break;
                    }
                case 21: {
                        message.setControlPointModel = $root.CUserMsg_ParticleManager.SetControlPointModel.decode(reader, reader.uint32());
                        break;
                    }
                case 22: {
                        message.setControlPointSnapshot = $root.CUserMsg_ParticleManager.SetControlPointSnapshot.decode(reader, reader.uint32());
                        break;
                    }
                case 23: {
                        message.setTextureAttribute = $root.CUserMsg_ParticleManager.SetTextureAttribute.decode(reader, reader.uint32());
                        break;
                    }
                case 24: {
                        message.setSceneObjectGenericFlag = $root.CUserMsg_ParticleManager.SetSceneObjectGenericFlag.decode(reader, reader.uint32());
                        break;
                    }
                case 25: {
                        message.setSceneObjectTintAndDesat = $root.CUserMsg_ParticleManager.SetSceneObjectTintAndDesat.decode(reader, reader.uint32());
                        break;
                    }
                case 26: {
                        message.destroyParticleNamed = $root.CUserMsg_ParticleManager.DestroyParticleNamed.decode(reader, reader.uint32());
                        break;
                    }
                case 27: {
                        message.particleSkipToTime = $root.CUserMsg_ParticleManager.ParticleSkipToTime.decode(reader, reader.uint32());
                        break;
                    }
                case 28: {
                        message.particleCanFreeze = $root.CUserMsg_ParticleManager.ParticleCanFreeze.decode(reader, reader.uint32());
                        break;
                    }
                case 29: {
                        message.setNamedValueContext = $root.CUserMsg_ParticleManager.SetParticleNamedValueContext.decode(reader, reader.uint32());
                        break;
                    }
                case 30: {
                        message.updateParticleTransform = $root.CUserMsg_ParticleManager.UpdateParticleTransform.decode(reader, reader.uint32());
                        break;
                    }
                case 31: {
                        message.particleFreezeTransitionOverride = $root.CUserMsg_ParticleManager.ParticleFreezeTransitionOverride.decode(reader, reader.uint32());
                        break;
                    }
                case 32: {
                        message.freezeParticleInvolving = $root.CUserMsg_ParticleManager.FreezeParticleInvolving.decode(reader, reader.uint32());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("type"))
                throw $util.ProtocolError("missing required 'type'", { instance: message });
            if (!message.hasOwnProperty("index"))
                throw $util.ProtocolError("missing required 'index'", { instance: message });
            return message;
        };
    
        /**
         * Decodes a CUserMsg_ParticleManager message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CUserMsg_ParticleManager
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CUserMsg_ParticleManager} CUserMsg_ParticleManager
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CUserMsg_ParticleManager.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CUserMsg_ParticleManager message.
         * @function verify
         * @memberof CUserMsg_ParticleManager
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CUserMsg_ParticleManager.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            switch (message.type) {
            default:
                return "type: enum value expected";
            case 0:
            case 1:
            case 2:
            case 3:
            case 4:
            case 5:
            case 6:
            case 7:
            case 8:
            case 9:
            case 10:
            case 11:
            case 12:
            case 13:
            case 14:
            case 15:
            case 16:
            case 17:
            case 18:
            case 19:
            case 20:
            case 21:
            case 22:
            case 23:
            case 24:
            case 25:
            case 26:
            case 27:
            case 28:
            case 29:
                break;
            }
            if (!$util.isInteger(message.index))
                return "index: integer expected";
            if (message.releaseParticleIndex != null && message.hasOwnProperty("releaseParticleIndex")) {
                var error = $root.CUserMsg_ParticleManager.ReleaseParticleIndex.verify(message.releaseParticleIndex);
                if (error)
                    return "releaseParticleIndex." + error;
            }
            if (message.createParticle != null && message.hasOwnProperty("createParticle")) {
                var error = $root.CUserMsg_ParticleManager.CreateParticle.verify(message.createParticle);
                if (error)
                    return "createParticle." + error;
            }
            if (message.destroyParticle != null && message.hasOwnProperty("destroyParticle")) {
                var error = $root.CUserMsg_ParticleManager.DestroyParticle.verify(message.destroyParticle);
                if (error)
                    return "destroyParticle." + error;
            }
            if (message.destroyParticleInvolving != null && message.hasOwnProperty("destroyParticleInvolving")) {
                var error = $root.CUserMsg_ParticleManager.DestroyParticleInvolving.verify(message.destroyParticleInvolving);
                if (error)
                    return "destroyParticleInvolving." + error;
            }
            if (message.updateParticle != null && message.hasOwnProperty("updateParticle")) {
                var error = $root.CUserMsg_ParticleManager.UpdateParticle_OBSOLETE.verify(message.updateParticle);
                if (error)
                    return "updateParticle." + error;
            }
            if (message.updateParticleFwd != null && message.hasOwnProperty("updateParticleFwd")) {
                var error = $root.CUserMsg_ParticleManager.UpdateParticleFwd_OBSOLETE.verify(message.updateParticleFwd);
                if (error)
                    return "updateParticleFwd." + error;
            }
            if (message.updateParticleOrient != null && message.hasOwnProperty("updateParticleOrient")) {
                var error = $root.CUserMsg_ParticleManager.UpdateParticleOrient_OBSOLETE.verify(message.updateParticleOrient);
                if (error)
                    return "updateParticleOrient." + error;
            }
            if (message.updateParticleFallback != null && message.hasOwnProperty("updateParticleFallback")) {
                var error = $root.CUserMsg_ParticleManager.UpdateParticleFallback.verify(message.updateParticleFallback);
                if (error)
                    return "updateParticleFallback." + error;
            }
            if (message.updateParticleOffset != null && message.hasOwnProperty("updateParticleOffset")) {
                var error = $root.CUserMsg_ParticleManager.UpdateParticleOffset.verify(message.updateParticleOffset);
                if (error)
                    return "updateParticleOffset." + error;
            }
            if (message.updateParticleEnt != null && message.hasOwnProperty("updateParticleEnt")) {
                var error = $root.CUserMsg_ParticleManager.UpdateParticleEnt.verify(message.updateParticleEnt);
                if (error)
                    return "updateParticleEnt." + error;
            }
            if (message.updateParticleShouldDraw != null && message.hasOwnProperty("updateParticleShouldDraw")) {
                var error = $root.CUserMsg_ParticleManager.UpdateParticleShouldDraw.verify(message.updateParticleShouldDraw);
                if (error)
                    return "updateParticleShouldDraw." + error;
            }
            if (message.updateParticleSetFrozen != null && message.hasOwnProperty("updateParticleSetFrozen")) {
                var error = $root.CUserMsg_ParticleManager.UpdateParticleSetFrozen.verify(message.updateParticleSetFrozen);
                if (error)
                    return "updateParticleSetFrozen." + error;
            }
            if (message.changeControlPointAttachment != null && message.hasOwnProperty("changeControlPointAttachment")) {
                var error = $root.CUserMsg_ParticleManager.ChangeControlPointAttachment.verify(message.changeControlPointAttachment);
                if (error)
                    return "changeControlPointAttachment." + error;
            }
            if (message.updateEntityPosition != null && message.hasOwnProperty("updateEntityPosition")) {
                var error = $root.CUserMsg_ParticleManager.UpdateEntityPosition.verify(message.updateEntityPosition);
                if (error)
                    return "updateEntityPosition." + error;
            }
            if (message.setParticleFowProperties != null && message.hasOwnProperty("setParticleFowProperties")) {
                var error = $root.CUserMsg_ParticleManager.SetParticleFoWProperties.verify(message.setParticleFowProperties);
                if (error)
                    return "setParticleFowProperties." + error;
            }
            if (message.setParticleText != null && message.hasOwnProperty("setParticleText")) {
                var error = $root.CUserMsg_ParticleManager.SetParticleText.verify(message.setParticleText);
                if (error)
                    return "setParticleText." + error;
            }
            if (message.setParticleShouldCheckFow != null && message.hasOwnProperty("setParticleShouldCheckFow")) {
                var error = $root.CUserMsg_ParticleManager.SetParticleShouldCheckFoW.verify(message.setParticleShouldCheckFow);
                if (error)
                    return "setParticleShouldCheckFow." + error;
            }
            if (message.setControlPointModel != null && message.hasOwnProperty("setControlPointModel")) {
                var error = $root.CUserMsg_ParticleManager.SetControlPointModel.verify(message.setControlPointModel);
                if (error)
                    return "setControlPointModel." + error;
            }
            if (message.setControlPointSnapshot != null && message.hasOwnProperty("setControlPointSnapshot")) {
                var error = $root.CUserMsg_ParticleManager.SetControlPointSnapshot.verify(message.setControlPointSnapshot);
                if (error)
                    return "setControlPointSnapshot." + error;
            }
            if (message.setTextureAttribute != null && message.hasOwnProperty("setTextureAttribute")) {
                var error = $root.CUserMsg_ParticleManager.SetTextureAttribute.verify(message.setTextureAttribute);
                if (error)
                    return "setTextureAttribute." + error;
            }
            if (message.setSceneObjectGenericFlag != null && message.hasOwnProperty("setSceneObjectGenericFlag")) {
                var error = $root.CUserMsg_ParticleManager.SetSceneObjectGenericFlag.verify(message.setSceneObjectGenericFlag);
                if (error)
                    return "setSceneObjectGenericFlag." + error;
            }
            if (message.setSceneObjectTintAndDesat != null && message.hasOwnProperty("setSceneObjectTintAndDesat")) {
                var error = $root.CUserMsg_ParticleManager.SetSceneObjectTintAndDesat.verify(message.setSceneObjectTintAndDesat);
                if (error)
                    return "setSceneObjectTintAndDesat." + error;
            }
            if (message.destroyParticleNamed != null && message.hasOwnProperty("destroyParticleNamed")) {
                var error = $root.CUserMsg_ParticleManager.DestroyParticleNamed.verify(message.destroyParticleNamed);
                if (error)
                    return "destroyParticleNamed." + error;
            }
            if (message.particleSkipToTime != null && message.hasOwnProperty("particleSkipToTime")) {
                var error = $root.CUserMsg_ParticleManager.ParticleSkipToTime.verify(message.particleSkipToTime);
                if (error)
                    return "particleSkipToTime." + error;
            }
            if (message.particleCanFreeze != null && message.hasOwnProperty("particleCanFreeze")) {
                var error = $root.CUserMsg_ParticleManager.ParticleCanFreeze.verify(message.particleCanFreeze);
                if (error)
                    return "particleCanFreeze." + error;
            }
            if (message.setNamedValueContext != null && message.hasOwnProperty("setNamedValueContext")) {
                var error = $root.CUserMsg_ParticleManager.SetParticleNamedValueContext.verify(message.setNamedValueContext);
                if (error)
                    return "setNamedValueContext." + error;
            }
            if (message.updateParticleTransform != null && message.hasOwnProperty("updateParticleTransform")) {
                var error = $root.CUserMsg_ParticleManager.UpdateParticleTransform.verify(message.updateParticleTransform);
                if (error)
                    return "updateParticleTransform." + error;
            }
            if (message.particleFreezeTransitionOverride != null && message.hasOwnProperty("particleFreezeTransitionOverride")) {
                var error = $root.CUserMsg_ParticleManager.ParticleFreezeTransitionOverride.verify(message.particleFreezeTransitionOverride);
                if (error)
                    return "particleFreezeTransitionOverride." + error;
            }
            if (message.freezeParticleInvolving != null && message.hasOwnProperty("freezeParticleInvolving")) {
                var error = $root.CUserMsg_ParticleManager.FreezeParticleInvolving.verify(message.freezeParticleInvolving);
                if (error)
                    return "freezeParticleInvolving." + error;
            }
            return null;
        };
    
        /**
         * Creates a CUserMsg_ParticleManager message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CUserMsg_ParticleManager
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CUserMsg_ParticleManager} CUserMsg_ParticleManager
         */
        CUserMsg_ParticleManager.fromObject = function fromObject(object) {
            if (object instanceof $root.CUserMsg_ParticleManager)
                return object;
            var message = new $root.CUserMsg_ParticleManager();
            switch (object.type) {
            default:
                if (typeof object.type === "number") {
                    message.type = object.type;
                    break;
                }
                break;
            case "GAME_PARTICLE_MANAGER_EVENT_CREATE":
            case 0:
                message.type = 0;
                break;
            case "GAME_PARTICLE_MANAGER_EVENT_UPDATE":
            case 1:
                message.type = 1;
                break;
            case "GAME_PARTICLE_MANAGER_EVENT_UPDATE_FORWARD":
            case 2:
                message.type = 2;
                break;
            case "GAME_PARTICLE_MANAGER_EVENT_UPDATE_ORIENTATION":
            case 3:
                message.type = 3;
                break;
            case "GAME_PARTICLE_MANAGER_EVENT_UPDATE_FALLBACK":
            case 4:
                message.type = 4;
                break;
            case "GAME_PARTICLE_MANAGER_EVENT_UPDATE_ENT":
            case 5:
                message.type = 5;
                break;
            case "GAME_PARTICLE_MANAGER_EVENT_UPDATE_OFFSET":
            case 6:
                message.type = 6;
                break;
            case "GAME_PARTICLE_MANAGER_EVENT_DESTROY":
            case 7:
                message.type = 7;
                break;
            case "GAME_PARTICLE_MANAGER_EVENT_DESTROY_INVOLVING":
            case 8:
                message.type = 8;
                break;
            case "GAME_PARTICLE_MANAGER_EVENT_RELEASE":
            case 9:
                message.type = 9;
                break;
            case "GAME_PARTICLE_MANAGER_EVENT_LATENCY":
            case 10:
                message.type = 10;
                break;
            case "GAME_PARTICLE_MANAGER_EVENT_SHOULD_DRAW":
            case 11:
                message.type = 11;
                break;
            case "GAME_PARTICLE_MANAGER_EVENT_FROZEN":
            case 12:
                message.type = 12;
                break;
            case "GAME_PARTICLE_MANAGER_EVENT_CHANGE_CONTROL_POINT_ATTACHMENT":
            case 13:
                message.type = 13;
                break;
            case "GAME_PARTICLE_MANAGER_EVENT_UPDATE_ENTITY_POSITION":
            case 14:
                message.type = 14;
                break;
            case "GAME_PARTICLE_MANAGER_EVENT_SET_FOW_PROPERTIES":
            case 15:
                message.type = 15;
                break;
            case "GAME_PARTICLE_MANAGER_EVENT_SET_TEXT":
            case 16:
                message.type = 16;
                break;
            case "GAME_PARTICLE_MANAGER_EVENT_SET_SHOULD_CHECK_FOW":
            case 17:
                message.type = 17;
                break;
            case "GAME_PARTICLE_MANAGER_EVENT_SET_CONTROL_POINT_MODEL":
            case 18:
                message.type = 18;
                break;
            case "GAME_PARTICLE_MANAGER_EVENT_SET_CONTROL_POINT_SNAPSHOT":
            case 19:
                message.type = 19;
                break;
            case "GAME_PARTICLE_MANAGER_EVENT_SET_TEXTURE_ATTRIBUTE":
            case 20:
                message.type = 20;
                break;
            case "GAME_PARTICLE_MANAGER_EVENT_SET_SCENE_OBJECT_GENERIC_FLAG":
            case 21:
                message.type = 21;
                break;
            case "GAME_PARTICLE_MANAGER_EVENT_SET_SCENE_OBJECT_TINT_AND_DESAT":
            case 22:
                message.type = 22;
                break;
            case "GAME_PARTICLE_MANAGER_EVENT_DESTROY_NAMED":
            case 23:
                message.type = 23;
                break;
            case "GAME_PARTICLE_MANAGER_EVENT_SKIP_TO_TIME":
            case 24:
                message.type = 24;
                break;
            case "GAME_PARTICLE_MANAGER_EVENT_CAN_FREEZE":
            case 25:
                message.type = 25;
                break;
            case "GAME_PARTICLE_MANAGER_EVENT_SET_NAMED_VALUE_CONTEXT":
            case 26:
                message.type = 26;
                break;
            case "GAME_PARTICLE_MANAGER_EVENT_UPDATE_TRANSFORM":
            case 27:
                message.type = 27;
                break;
            case "GAME_PARTICLE_MANAGER_EVENT_FREEZE_TRANSITION_OVERRIDE":
            case 28:
                message.type = 28;
                break;
            case "GAME_PARTICLE_MANAGER_EVENT_FREEZE_INVOLVING":
            case 29:
                message.type = 29;
                break;
            }
            if (object.index != null)
                message.index = object.index >>> 0;
            if (object.releaseParticleIndex != null) {
                if (typeof object.releaseParticleIndex !== "object")
                    throw TypeError(".CUserMsg_ParticleManager.releaseParticleIndex: object expected");
                message.releaseParticleIndex = $root.CUserMsg_ParticleManager.ReleaseParticleIndex.fromObject(object.releaseParticleIndex);
            }
            if (object.createParticle != null) {
                if (typeof object.createParticle !== "object")
                    throw TypeError(".CUserMsg_ParticleManager.createParticle: object expected");
                message.createParticle = $root.CUserMsg_ParticleManager.CreateParticle.fromObject(object.createParticle);
            }
            if (object.destroyParticle != null) {
                if (typeof object.destroyParticle !== "object")
                    throw TypeError(".CUserMsg_ParticleManager.destroyParticle: object expected");
                message.destroyParticle = $root.CUserMsg_ParticleManager.DestroyParticle.fromObject(object.destroyParticle);
            }
            if (object.destroyParticleInvolving != null) {
                if (typeof object.destroyParticleInvolving !== "object")
                    throw TypeError(".CUserMsg_ParticleManager.destroyParticleInvolving: object expected");
                message.destroyParticleInvolving = $root.CUserMsg_ParticleManager.DestroyParticleInvolving.fromObject(object.destroyParticleInvolving);
            }
            if (object.updateParticle != null) {
                if (typeof object.updateParticle !== "object")
                    throw TypeError(".CUserMsg_ParticleManager.updateParticle: object expected");
                message.updateParticle = $root.CUserMsg_ParticleManager.UpdateParticle_OBSOLETE.fromObject(object.updateParticle);
            }
            if (object.updateParticleFwd != null) {
                if (typeof object.updateParticleFwd !== "object")
                    throw TypeError(".CUserMsg_ParticleManager.updateParticleFwd: object expected");
                message.updateParticleFwd = $root.CUserMsg_ParticleManager.UpdateParticleFwd_OBSOLETE.fromObject(object.updateParticleFwd);
            }
            if (object.updateParticleOrient != null) {
                if (typeof object.updateParticleOrient !== "object")
                    throw TypeError(".CUserMsg_ParticleManager.updateParticleOrient: object expected");
                message.updateParticleOrient = $root.CUserMsg_ParticleManager.UpdateParticleOrient_OBSOLETE.fromObject(object.updateParticleOrient);
            }
            if (object.updateParticleFallback != null) {
                if (typeof object.updateParticleFallback !== "object")
                    throw TypeError(".CUserMsg_ParticleManager.updateParticleFallback: object expected");
                message.updateParticleFallback = $root.CUserMsg_ParticleManager.UpdateParticleFallback.fromObject(object.updateParticleFallback);
            }
            if (object.updateParticleOffset != null) {
                if (typeof object.updateParticleOffset !== "object")
                    throw TypeError(".CUserMsg_ParticleManager.updateParticleOffset: object expected");
                message.updateParticleOffset = $root.CUserMsg_ParticleManager.UpdateParticleOffset.fromObject(object.updateParticleOffset);
            }
            if (object.updateParticleEnt != null) {
                if (typeof object.updateParticleEnt !== "object")
                    throw TypeError(".CUserMsg_ParticleManager.updateParticleEnt: object expected");
                message.updateParticleEnt = $root.CUserMsg_ParticleManager.UpdateParticleEnt.fromObject(object.updateParticleEnt);
            }
            if (object.updateParticleShouldDraw != null) {
                if (typeof object.updateParticleShouldDraw !== "object")
                    throw TypeError(".CUserMsg_ParticleManager.updateParticleShouldDraw: object expected");
                message.updateParticleShouldDraw = $root.CUserMsg_ParticleManager.UpdateParticleShouldDraw.fromObject(object.updateParticleShouldDraw);
            }
            if (object.updateParticleSetFrozen != null) {
                if (typeof object.updateParticleSetFrozen !== "object")
                    throw TypeError(".CUserMsg_ParticleManager.updateParticleSetFrozen: object expected");
                message.updateParticleSetFrozen = $root.CUserMsg_ParticleManager.UpdateParticleSetFrozen.fromObject(object.updateParticleSetFrozen);
            }
            if (object.changeControlPointAttachment != null) {
                if (typeof object.changeControlPointAttachment !== "object")
                    throw TypeError(".CUserMsg_ParticleManager.changeControlPointAttachment: object expected");
                message.changeControlPointAttachment = $root.CUserMsg_ParticleManager.ChangeControlPointAttachment.fromObject(object.changeControlPointAttachment);
            }
            if (object.updateEntityPosition != null) {
                if (typeof object.updateEntityPosition !== "object")
                    throw TypeError(".CUserMsg_ParticleManager.updateEntityPosition: object expected");
                message.updateEntityPosition = $root.CUserMsg_ParticleManager.UpdateEntityPosition.fromObject(object.updateEntityPosition);
            }
            if (object.setParticleFowProperties != null) {
                if (typeof object.setParticleFowProperties !== "object")
                    throw TypeError(".CUserMsg_ParticleManager.setParticleFowProperties: object expected");
                message.setParticleFowProperties = $root.CUserMsg_ParticleManager.SetParticleFoWProperties.fromObject(object.setParticleFowProperties);
            }
            if (object.setParticleText != null) {
                if (typeof object.setParticleText !== "object")
                    throw TypeError(".CUserMsg_ParticleManager.setParticleText: object expected");
                message.setParticleText = $root.CUserMsg_ParticleManager.SetParticleText.fromObject(object.setParticleText);
            }
            if (object.setParticleShouldCheckFow != null) {
                if (typeof object.setParticleShouldCheckFow !== "object")
                    throw TypeError(".CUserMsg_ParticleManager.setParticleShouldCheckFow: object expected");
                message.setParticleShouldCheckFow = $root.CUserMsg_ParticleManager.SetParticleShouldCheckFoW.fromObject(object.setParticleShouldCheckFow);
            }
            if (object.setControlPointModel != null) {
                if (typeof object.setControlPointModel !== "object")
                    throw TypeError(".CUserMsg_ParticleManager.setControlPointModel: object expected");
                message.setControlPointModel = $root.CUserMsg_ParticleManager.SetControlPointModel.fromObject(object.setControlPointModel);
            }
            if (object.setControlPointSnapshot != null) {
                if (typeof object.setControlPointSnapshot !== "object")
                    throw TypeError(".CUserMsg_ParticleManager.setControlPointSnapshot: object expected");
                message.setControlPointSnapshot = $root.CUserMsg_ParticleManager.SetControlPointSnapshot.fromObject(object.setControlPointSnapshot);
            }
            if (object.setTextureAttribute != null) {
                if (typeof object.setTextureAttribute !== "object")
                    throw TypeError(".CUserMsg_ParticleManager.setTextureAttribute: object expected");
                message.setTextureAttribute = $root.CUserMsg_ParticleManager.SetTextureAttribute.fromObject(object.setTextureAttribute);
            }
            if (object.setSceneObjectGenericFlag != null) {
                if (typeof object.setSceneObjectGenericFlag !== "object")
                    throw TypeError(".CUserMsg_ParticleManager.setSceneObjectGenericFlag: object expected");
                message.setSceneObjectGenericFlag = $root.CUserMsg_ParticleManager.SetSceneObjectGenericFlag.fromObject(object.setSceneObjectGenericFlag);
            }
            if (object.setSceneObjectTintAndDesat != null) {
                if (typeof object.setSceneObjectTintAndDesat !== "object")
                    throw TypeError(".CUserMsg_ParticleManager.setSceneObjectTintAndDesat: object expected");
                message.setSceneObjectTintAndDesat = $root.CUserMsg_ParticleManager.SetSceneObjectTintAndDesat.fromObject(object.setSceneObjectTintAndDesat);
            }
            if (object.destroyParticleNamed != null) {
                if (typeof object.destroyParticleNamed !== "object")
                    throw TypeError(".CUserMsg_ParticleManager.destroyParticleNamed: object expected");
                message.destroyParticleNamed = $root.CUserMsg_ParticleManager.DestroyParticleNamed.fromObject(object.destroyParticleNamed);
            }
            if (object.particleSkipToTime != null) {
                if (typeof object.particleSkipToTime !== "object")
                    throw TypeError(".CUserMsg_ParticleManager.particleSkipToTime: object expected");
                message.particleSkipToTime = $root.CUserMsg_ParticleManager.ParticleSkipToTime.fromObject(object.particleSkipToTime);
            }
            if (object.particleCanFreeze != null) {
                if (typeof object.particleCanFreeze !== "object")
                    throw TypeError(".CUserMsg_ParticleManager.particleCanFreeze: object expected");
                message.particleCanFreeze = $root.CUserMsg_ParticleManager.ParticleCanFreeze.fromObject(object.particleCanFreeze);
            }
            if (object.setNamedValueContext != null) {
                if (typeof object.setNamedValueContext !== "object")
                    throw TypeError(".CUserMsg_ParticleManager.setNamedValueContext: object expected");
                message.setNamedValueContext = $root.CUserMsg_ParticleManager.SetParticleNamedValueContext.fromObject(object.setNamedValueContext);
            }
            if (object.updateParticleTransform != null) {
                if (typeof object.updateParticleTransform !== "object")
                    throw TypeError(".CUserMsg_ParticleManager.updateParticleTransform: object expected");
                message.updateParticleTransform = $root.CUserMsg_ParticleManager.UpdateParticleTransform.fromObject(object.updateParticleTransform);
            }
            if (object.particleFreezeTransitionOverride != null) {
                if (typeof object.particleFreezeTransitionOverride !== "object")
                    throw TypeError(".CUserMsg_ParticleManager.particleFreezeTransitionOverride: object expected");
                message.particleFreezeTransitionOverride = $root.CUserMsg_ParticleManager.ParticleFreezeTransitionOverride.fromObject(object.particleFreezeTransitionOverride);
            }
            if (object.freezeParticleInvolving != null) {
                if (typeof object.freezeParticleInvolving !== "object")
                    throw TypeError(".CUserMsg_ParticleManager.freezeParticleInvolving: object expected");
                message.freezeParticleInvolving = $root.CUserMsg_ParticleManager.FreezeParticleInvolving.fromObject(object.freezeParticleInvolving);
            }
            return message;
        };
    
        /**
         * Creates a plain object from a CUserMsg_ParticleManager message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CUserMsg_ParticleManager
         * @static
         * @param {CUserMsg_ParticleManager} message CUserMsg_ParticleManager
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CUserMsg_ParticleManager.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.type = options.enums === String ? "GAME_PARTICLE_MANAGER_EVENT_CREATE" : 0;
                object.index = 0;
                object.releaseParticleIndex = null;
                object.createParticle = null;
                object.destroyParticle = null;
                object.destroyParticleInvolving = null;
                object.updateParticle = null;
                object.updateParticleFwd = null;
                object.updateParticleOrient = null;
                object.updateParticleFallback = null;
                object.updateParticleOffset = null;
                object.updateParticleEnt = null;
                object.updateParticleShouldDraw = null;
                object.updateParticleSetFrozen = null;
                object.changeControlPointAttachment = null;
                object.updateEntityPosition = null;
                object.setParticleFowProperties = null;
                object.setParticleText = null;
                object.setParticleShouldCheckFow = null;
                object.setControlPointModel = null;
                object.setControlPointSnapshot = null;
                object.setTextureAttribute = null;
                object.setSceneObjectGenericFlag = null;
                object.setSceneObjectTintAndDesat = null;
                object.destroyParticleNamed = null;
                object.particleSkipToTime = null;
                object.particleCanFreeze = null;
                object.setNamedValueContext = null;
                object.updateParticleTransform = null;
                object.particleFreezeTransitionOverride = null;
                object.freezeParticleInvolving = null;
            }
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = options.enums === String ? $root.PARTICLE_MESSAGE[message.type] === undefined ? message.type : $root.PARTICLE_MESSAGE[message.type] : message.type;
            if (message.index != null && message.hasOwnProperty("index"))
                object.index = message.index;
            if (message.releaseParticleIndex != null && message.hasOwnProperty("releaseParticleIndex"))
                object.releaseParticleIndex = $root.CUserMsg_ParticleManager.ReleaseParticleIndex.toObject(message.releaseParticleIndex, options);
            if (message.createParticle != null && message.hasOwnProperty("createParticle"))
                object.createParticle = $root.CUserMsg_ParticleManager.CreateParticle.toObject(message.createParticle, options);
            if (message.destroyParticle != null && message.hasOwnProperty("destroyParticle"))
                object.destroyParticle = $root.CUserMsg_ParticleManager.DestroyParticle.toObject(message.destroyParticle, options);
            if (message.destroyParticleInvolving != null && message.hasOwnProperty("destroyParticleInvolving"))
                object.destroyParticleInvolving = $root.CUserMsg_ParticleManager.DestroyParticleInvolving.toObject(message.destroyParticleInvolving, options);
            if (message.updateParticle != null && message.hasOwnProperty("updateParticle"))
                object.updateParticle = $root.CUserMsg_ParticleManager.UpdateParticle_OBSOLETE.toObject(message.updateParticle, options);
            if (message.updateParticleFwd != null && message.hasOwnProperty("updateParticleFwd"))
                object.updateParticleFwd = $root.CUserMsg_ParticleManager.UpdateParticleFwd_OBSOLETE.toObject(message.updateParticleFwd, options);
            if (message.updateParticleOrient != null && message.hasOwnProperty("updateParticleOrient"))
                object.updateParticleOrient = $root.CUserMsg_ParticleManager.UpdateParticleOrient_OBSOLETE.toObject(message.updateParticleOrient, options);
            if (message.updateParticleFallback != null && message.hasOwnProperty("updateParticleFallback"))
                object.updateParticleFallback = $root.CUserMsg_ParticleManager.UpdateParticleFallback.toObject(message.updateParticleFallback, options);
            if (message.updateParticleOffset != null && message.hasOwnProperty("updateParticleOffset"))
                object.updateParticleOffset = $root.CUserMsg_ParticleManager.UpdateParticleOffset.toObject(message.updateParticleOffset, options);
            if (message.updateParticleEnt != null && message.hasOwnProperty("updateParticleEnt"))
                object.updateParticleEnt = $root.CUserMsg_ParticleManager.UpdateParticleEnt.toObject(message.updateParticleEnt, options);
            if (message.updateParticleShouldDraw != null && message.hasOwnProperty("updateParticleShouldDraw"))
                object.updateParticleShouldDraw = $root.CUserMsg_ParticleManager.UpdateParticleShouldDraw.toObject(message.updateParticleShouldDraw, options);
            if (message.updateParticleSetFrozen != null && message.hasOwnProperty("updateParticleSetFrozen"))
                object.updateParticleSetFrozen = $root.CUserMsg_ParticleManager.UpdateParticleSetFrozen.toObject(message.updateParticleSetFrozen, options);
            if (message.changeControlPointAttachment != null && message.hasOwnProperty("changeControlPointAttachment"))
                object.changeControlPointAttachment = $root.CUserMsg_ParticleManager.ChangeControlPointAttachment.toObject(message.changeControlPointAttachment, options);
            if (message.updateEntityPosition != null && message.hasOwnProperty("updateEntityPosition"))
                object.updateEntityPosition = $root.CUserMsg_ParticleManager.UpdateEntityPosition.toObject(message.updateEntityPosition, options);
            if (message.setParticleFowProperties != null && message.hasOwnProperty("setParticleFowProperties"))
                object.setParticleFowProperties = $root.CUserMsg_ParticleManager.SetParticleFoWProperties.toObject(message.setParticleFowProperties, options);
            if (message.setParticleText != null && message.hasOwnProperty("setParticleText"))
                object.setParticleText = $root.CUserMsg_ParticleManager.SetParticleText.toObject(message.setParticleText, options);
            if (message.setParticleShouldCheckFow != null && message.hasOwnProperty("setParticleShouldCheckFow"))
                object.setParticleShouldCheckFow = $root.CUserMsg_ParticleManager.SetParticleShouldCheckFoW.toObject(message.setParticleShouldCheckFow, options);
            if (message.setControlPointModel != null && message.hasOwnProperty("setControlPointModel"))
                object.setControlPointModel = $root.CUserMsg_ParticleManager.SetControlPointModel.toObject(message.setControlPointModel, options);
            if (message.setControlPointSnapshot != null && message.hasOwnProperty("setControlPointSnapshot"))
                object.setControlPointSnapshot = $root.CUserMsg_ParticleManager.SetControlPointSnapshot.toObject(message.setControlPointSnapshot, options);
            if (message.setTextureAttribute != null && message.hasOwnProperty("setTextureAttribute"))
                object.setTextureAttribute = $root.CUserMsg_ParticleManager.SetTextureAttribute.toObject(message.setTextureAttribute, options);
            if (message.setSceneObjectGenericFlag != null && message.hasOwnProperty("setSceneObjectGenericFlag"))
                object.setSceneObjectGenericFlag = $root.CUserMsg_ParticleManager.SetSceneObjectGenericFlag.toObject(message.setSceneObjectGenericFlag, options);
            if (message.setSceneObjectTintAndDesat != null && message.hasOwnProperty("setSceneObjectTintAndDesat"))
                object.setSceneObjectTintAndDesat = $root.CUserMsg_ParticleManager.SetSceneObjectTintAndDesat.toObject(message.setSceneObjectTintAndDesat, options);
            if (message.destroyParticleNamed != null && message.hasOwnProperty("destroyParticleNamed"))
                object.destroyParticleNamed = $root.CUserMsg_ParticleManager.DestroyParticleNamed.toObject(message.destroyParticleNamed, options);
            if (message.particleSkipToTime != null && message.hasOwnProperty("particleSkipToTime"))
                object.particleSkipToTime = $root.CUserMsg_ParticleManager.ParticleSkipToTime.toObject(message.particleSkipToTime, options);
            if (message.particleCanFreeze != null && message.hasOwnProperty("particleCanFreeze"))
                object.particleCanFreeze = $root.CUserMsg_ParticleManager.ParticleCanFreeze.toObject(message.particleCanFreeze, options);
            if (message.setNamedValueContext != null && message.hasOwnProperty("setNamedValueContext"))
                object.setNamedValueContext = $root.CUserMsg_ParticleManager.SetParticleNamedValueContext.toObject(message.setNamedValueContext, options);
            if (message.updateParticleTransform != null && message.hasOwnProperty("updateParticleTransform"))
                object.updateParticleTransform = $root.CUserMsg_ParticleManager.UpdateParticleTransform.toObject(message.updateParticleTransform, options);
            if (message.particleFreezeTransitionOverride != null && message.hasOwnProperty("particleFreezeTransitionOverride"))
                object.particleFreezeTransitionOverride = $root.CUserMsg_ParticleManager.ParticleFreezeTransitionOverride.toObject(message.particleFreezeTransitionOverride, options);
            if (message.freezeParticleInvolving != null && message.hasOwnProperty("freezeParticleInvolving"))
                object.freezeParticleInvolving = $root.CUserMsg_ParticleManager.FreezeParticleInvolving.toObject(message.freezeParticleInvolving, options);
            return object;
        };
    
        /**
         * Converts this CUserMsg_ParticleManager to JSON.
         * @function toJSON
         * @memberof CUserMsg_ParticleManager
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CUserMsg_ParticleManager.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * Gets the default type url for CUserMsg_ParticleManager
         * @function getTypeUrl
         * @memberof CUserMsg_ParticleManager
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        CUserMsg_ParticleManager.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/CUserMsg_ParticleManager";
        };
    
        CUserMsg_ParticleManager.ReleaseParticleIndex = (function() {
    
            /**
             * Properties of a ReleaseParticleIndex.
             * @memberof CUserMsg_ParticleManager
             * @interface IReleaseParticleIndex
             */
    
            /**
             * Constructs a new ReleaseParticleIndex.
             * @memberof CUserMsg_ParticleManager
             * @classdesc Represents a ReleaseParticleIndex.
             * @implements IReleaseParticleIndex
             * @constructor
             * @param {CUserMsg_ParticleManager.IReleaseParticleIndex=} [properties] Properties to set
             */
            function ReleaseParticleIndex(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * Creates a new ReleaseParticleIndex instance using the specified properties.
             * @function create
             * @memberof CUserMsg_ParticleManager.ReleaseParticleIndex
             * @static
             * @param {CUserMsg_ParticleManager.IReleaseParticleIndex=} [properties] Properties to set
             * @returns {CUserMsg_ParticleManager.ReleaseParticleIndex} ReleaseParticleIndex instance
             */
            ReleaseParticleIndex.create = function create(properties) {
                return new ReleaseParticleIndex(properties);
            };
    
            /**
             * Encodes the specified ReleaseParticleIndex message. Does not implicitly {@link CUserMsg_ParticleManager.ReleaseParticleIndex.verify|verify} messages.
             * @function encode
             * @memberof CUserMsg_ParticleManager.ReleaseParticleIndex
             * @static
             * @param {CUserMsg_ParticleManager.IReleaseParticleIndex} message ReleaseParticleIndex message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ReleaseParticleIndex.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };
    
            /**
             * Encodes the specified ReleaseParticleIndex message, length delimited. Does not implicitly {@link CUserMsg_ParticleManager.ReleaseParticleIndex.verify|verify} messages.
             * @function encodeDelimited
             * @memberof CUserMsg_ParticleManager.ReleaseParticleIndex
             * @static
             * @param {CUserMsg_ParticleManager.IReleaseParticleIndex} message ReleaseParticleIndex message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ReleaseParticleIndex.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a ReleaseParticleIndex message from the specified reader or buffer.
             * @function decode
             * @memberof CUserMsg_ParticleManager.ReleaseParticleIndex
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {CUserMsg_ParticleManager.ReleaseParticleIndex} ReleaseParticleIndex
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ReleaseParticleIndex.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CUserMsg_ParticleManager.ReleaseParticleIndex();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a ReleaseParticleIndex message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof CUserMsg_ParticleManager.ReleaseParticleIndex
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {CUserMsg_ParticleManager.ReleaseParticleIndex} ReleaseParticleIndex
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ReleaseParticleIndex.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a ReleaseParticleIndex message.
             * @function verify
             * @memberof CUserMsg_ParticleManager.ReleaseParticleIndex
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ReleaseParticleIndex.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };
    
            /**
             * Creates a ReleaseParticleIndex message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof CUserMsg_ParticleManager.ReleaseParticleIndex
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {CUserMsg_ParticleManager.ReleaseParticleIndex} ReleaseParticleIndex
             */
            ReleaseParticleIndex.fromObject = function fromObject(object) {
                if (object instanceof $root.CUserMsg_ParticleManager.ReleaseParticleIndex)
                    return object;
                return new $root.CUserMsg_ParticleManager.ReleaseParticleIndex();
            };
    
            /**
             * Creates a plain object from a ReleaseParticleIndex message. Also converts values to other types if specified.
             * @function toObject
             * @memberof CUserMsg_ParticleManager.ReleaseParticleIndex
             * @static
             * @param {CUserMsg_ParticleManager.ReleaseParticleIndex} message ReleaseParticleIndex
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ReleaseParticleIndex.toObject = function toObject() {
                return {};
            };
    
            /**
             * Converts this ReleaseParticleIndex to JSON.
             * @function toJSON
             * @memberof CUserMsg_ParticleManager.ReleaseParticleIndex
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ReleaseParticleIndex.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            /**
             * Gets the default type url for ReleaseParticleIndex
             * @function getTypeUrl
             * @memberof CUserMsg_ParticleManager.ReleaseParticleIndex
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            ReleaseParticleIndex.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/CUserMsg_ParticleManager.ReleaseParticleIndex";
            };
    
            return ReleaseParticleIndex;
        })();
    
        CUserMsg_ParticleManager.CreateParticle = (function() {
    
            /**
             * Properties of a CreateParticle.
             * @memberof CUserMsg_ParticleManager
             * @interface ICreateParticle
             * @property {number|Long|null} [particleNameIndex] CreateParticle particleNameIndex
             * @property {number|null} [attachType] CreateParticle attachType
             * @property {number|null} [entityHandle] CreateParticle entityHandle
             * @property {number|null} [entityHandleForModifiers] CreateParticle entityHandleForModifiers
             * @property {boolean|null} [applyVoiceBanRules] CreateParticle applyVoiceBanRules
             * @property {number|null} [teamBehavior] CreateParticle teamBehavior
             * @property {string|null} [controlPointConfiguration] CreateParticle controlPointConfiguration
             */
    
            /**
             * Constructs a new CreateParticle.
             * @memberof CUserMsg_ParticleManager
             * @classdesc Represents a CreateParticle.
             * @implements ICreateParticle
             * @constructor
             * @param {CUserMsg_ParticleManager.ICreateParticle=} [properties] Properties to set
             */
            function CreateParticle(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * CreateParticle particleNameIndex.
             * @member {number|Long} particleNameIndex
             * @memberof CUserMsg_ParticleManager.CreateParticle
             * @instance
             */
            CreateParticle.prototype.particleNameIndex = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
            /**
             * CreateParticle attachType.
             * @member {number} attachType
             * @memberof CUserMsg_ParticleManager.CreateParticle
             * @instance
             */
            CreateParticle.prototype.attachType = 0;
    
            /**
             * CreateParticle entityHandle.
             * @member {number} entityHandle
             * @memberof CUserMsg_ParticleManager.CreateParticle
             * @instance
             */
            CreateParticle.prototype.entityHandle = 16777215;
    
            /**
             * CreateParticle entityHandleForModifiers.
             * @member {number} entityHandleForModifiers
             * @memberof CUserMsg_ParticleManager.CreateParticle
             * @instance
             */
            CreateParticle.prototype.entityHandleForModifiers = 16777215;
    
            /**
             * CreateParticle applyVoiceBanRules.
             * @member {boolean} applyVoiceBanRules
             * @memberof CUserMsg_ParticleManager.CreateParticle
             * @instance
             */
            CreateParticle.prototype.applyVoiceBanRules = false;
    
            /**
             * CreateParticle teamBehavior.
             * @member {number} teamBehavior
             * @memberof CUserMsg_ParticleManager.CreateParticle
             * @instance
             */
            CreateParticle.prototype.teamBehavior = 0;
    
            /**
             * CreateParticle controlPointConfiguration.
             * @member {string} controlPointConfiguration
             * @memberof CUserMsg_ParticleManager.CreateParticle
             * @instance
             */
            CreateParticle.prototype.controlPointConfiguration = "";
    
            /**
             * Creates a new CreateParticle instance using the specified properties.
             * @function create
             * @memberof CUserMsg_ParticleManager.CreateParticle
             * @static
             * @param {CUserMsg_ParticleManager.ICreateParticle=} [properties] Properties to set
             * @returns {CUserMsg_ParticleManager.CreateParticle} CreateParticle instance
             */
            CreateParticle.create = function create(properties) {
                return new CreateParticle(properties);
            };
    
            /**
             * Encodes the specified CreateParticle message. Does not implicitly {@link CUserMsg_ParticleManager.CreateParticle.verify|verify} messages.
             * @function encode
             * @memberof CUserMsg_ParticleManager.CreateParticle
             * @static
             * @param {CUserMsg_ParticleManager.ICreateParticle} message CreateParticle message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CreateParticle.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.particleNameIndex != null && Object.hasOwnProperty.call(message, "particleNameIndex"))
                    writer.uint32(/* id 1, wireType 1 =*/9).fixed64(message.particleNameIndex);
                if (message.attachType != null && Object.hasOwnProperty.call(message, "attachType"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.attachType);
                if (message.entityHandle != null && Object.hasOwnProperty.call(message, "entityHandle"))
                    writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.entityHandle);
                if (message.entityHandleForModifiers != null && Object.hasOwnProperty.call(message, "entityHandleForModifiers"))
                    writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.entityHandleForModifiers);
                if (message.applyVoiceBanRules != null && Object.hasOwnProperty.call(message, "applyVoiceBanRules"))
                    writer.uint32(/* id 5, wireType 0 =*/40).bool(message.applyVoiceBanRules);
                if (message.teamBehavior != null && Object.hasOwnProperty.call(message, "teamBehavior"))
                    writer.uint32(/* id 6, wireType 0 =*/48).int32(message.teamBehavior);
                if (message.controlPointConfiguration != null && Object.hasOwnProperty.call(message, "controlPointConfiguration"))
                    writer.uint32(/* id 7, wireType 2 =*/58).string(message.controlPointConfiguration);
                return writer;
            };
    
            /**
             * Encodes the specified CreateParticle message, length delimited. Does not implicitly {@link CUserMsg_ParticleManager.CreateParticle.verify|verify} messages.
             * @function encodeDelimited
             * @memberof CUserMsg_ParticleManager.CreateParticle
             * @static
             * @param {CUserMsg_ParticleManager.ICreateParticle} message CreateParticle message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CreateParticle.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a CreateParticle message from the specified reader or buffer.
             * @function decode
             * @memberof CUserMsg_ParticleManager.CreateParticle
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {CUserMsg_ParticleManager.CreateParticle} CreateParticle
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CreateParticle.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CUserMsg_ParticleManager.CreateParticle();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.particleNameIndex = reader.fixed64();
                            break;
                        }
                    case 2: {
                            message.attachType = reader.int32();
                            break;
                        }
                    case 3: {
                            message.entityHandle = reader.uint32();
                            break;
                        }
                    case 4: {
                            message.entityHandleForModifiers = reader.uint32();
                            break;
                        }
                    case 5: {
                            message.applyVoiceBanRules = reader.bool();
                            break;
                        }
                    case 6: {
                            message.teamBehavior = reader.int32();
                            break;
                        }
                    case 7: {
                            message.controlPointConfiguration = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a CreateParticle message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof CUserMsg_ParticleManager.CreateParticle
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {CUserMsg_ParticleManager.CreateParticle} CreateParticle
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CreateParticle.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a CreateParticle message.
             * @function verify
             * @memberof CUserMsg_ParticleManager.CreateParticle
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            CreateParticle.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.particleNameIndex != null && message.hasOwnProperty("particleNameIndex"))
                    if (!$util.isInteger(message.particleNameIndex) && !(message.particleNameIndex && $util.isInteger(message.particleNameIndex.low) && $util.isInteger(message.particleNameIndex.high)))
                        return "particleNameIndex: integer|Long expected";
                if (message.attachType != null && message.hasOwnProperty("attachType"))
                    if (!$util.isInteger(message.attachType))
                        return "attachType: integer expected";
                if (message.entityHandle != null && message.hasOwnProperty("entityHandle"))
                    if (!$util.isInteger(message.entityHandle))
                        return "entityHandle: integer expected";
                if (message.entityHandleForModifiers != null && message.hasOwnProperty("entityHandleForModifiers"))
                    if (!$util.isInteger(message.entityHandleForModifiers))
                        return "entityHandleForModifiers: integer expected";
                if (message.applyVoiceBanRules != null && message.hasOwnProperty("applyVoiceBanRules"))
                    if (typeof message.applyVoiceBanRules !== "boolean")
                        return "applyVoiceBanRules: boolean expected";
                if (message.teamBehavior != null && message.hasOwnProperty("teamBehavior"))
                    if (!$util.isInteger(message.teamBehavior))
                        return "teamBehavior: integer expected";
                if (message.controlPointConfiguration != null && message.hasOwnProperty("controlPointConfiguration"))
                    if (!$util.isString(message.controlPointConfiguration))
                        return "controlPointConfiguration: string expected";
                return null;
            };
    
            /**
             * Creates a CreateParticle message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof CUserMsg_ParticleManager.CreateParticle
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {CUserMsg_ParticleManager.CreateParticle} CreateParticle
             */
            CreateParticle.fromObject = function fromObject(object) {
                if (object instanceof $root.CUserMsg_ParticleManager.CreateParticle)
                    return object;
                var message = new $root.CUserMsg_ParticleManager.CreateParticle();
                if (object.particleNameIndex != null)
                    if ($util.Long)
                        (message.particleNameIndex = $util.Long.fromValue(object.particleNameIndex)).unsigned = false;
                    else if (typeof object.particleNameIndex === "string")
                        message.particleNameIndex = parseInt(object.particleNameIndex, 10);
                    else if (typeof object.particleNameIndex === "number")
                        message.particleNameIndex = object.particleNameIndex;
                    else if (typeof object.particleNameIndex === "object")
                        message.particleNameIndex = new $util.LongBits(object.particleNameIndex.low >>> 0, object.particleNameIndex.high >>> 0).toNumber();
                if (object.attachType != null)
                    message.attachType = object.attachType | 0;
                if (object.entityHandle != null)
                    message.entityHandle = object.entityHandle >>> 0;
                if (object.entityHandleForModifiers != null)
                    message.entityHandleForModifiers = object.entityHandleForModifiers >>> 0;
                if (object.applyVoiceBanRules != null)
                    message.applyVoiceBanRules = Boolean(object.applyVoiceBanRules);
                if (object.teamBehavior != null)
                    message.teamBehavior = object.teamBehavior | 0;
                if (object.controlPointConfiguration != null)
                    message.controlPointConfiguration = String(object.controlPointConfiguration);
                return message;
            };
    
            /**
             * Creates a plain object from a CreateParticle message. Also converts values to other types if specified.
             * @function toObject
             * @memberof CUserMsg_ParticleManager.CreateParticle
             * @static
             * @param {CUserMsg_ParticleManager.CreateParticle} message CreateParticle
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            CreateParticle.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.particleNameIndex = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.particleNameIndex = options.longs === String ? "0" : 0;
                    object.attachType = 0;
                    object.entityHandle = 16777215;
                    object.entityHandleForModifiers = 16777215;
                    object.applyVoiceBanRules = false;
                    object.teamBehavior = 0;
                    object.controlPointConfiguration = "";
                }
                if (message.particleNameIndex != null && message.hasOwnProperty("particleNameIndex"))
                    if (typeof message.particleNameIndex === "number")
                        object.particleNameIndex = options.longs === String ? String(message.particleNameIndex) : message.particleNameIndex;
                    else
                        object.particleNameIndex = options.longs === String ? $util.Long.prototype.toString.call(message.particleNameIndex) : options.longs === Number ? new $util.LongBits(message.particleNameIndex.low >>> 0, message.particleNameIndex.high >>> 0).toNumber() : message.particleNameIndex;
                if (message.attachType != null && message.hasOwnProperty("attachType"))
                    object.attachType = message.attachType;
                if (message.entityHandle != null && message.hasOwnProperty("entityHandle"))
                    object.entityHandle = message.entityHandle;
                if (message.entityHandleForModifiers != null && message.hasOwnProperty("entityHandleForModifiers"))
                    object.entityHandleForModifiers = message.entityHandleForModifiers;
                if (message.applyVoiceBanRules != null && message.hasOwnProperty("applyVoiceBanRules"))
                    object.applyVoiceBanRules = message.applyVoiceBanRules;
                if (message.teamBehavior != null && message.hasOwnProperty("teamBehavior"))
                    object.teamBehavior = message.teamBehavior;
                if (message.controlPointConfiguration != null && message.hasOwnProperty("controlPointConfiguration"))
                    object.controlPointConfiguration = message.controlPointConfiguration;
                return object;
            };
    
            /**
             * Converts this CreateParticle to JSON.
             * @function toJSON
             * @memberof CUserMsg_ParticleManager.CreateParticle
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            CreateParticle.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            /**
             * Gets the default type url for CreateParticle
             * @function getTypeUrl
             * @memberof CUserMsg_ParticleManager.CreateParticle
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            CreateParticle.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/CUserMsg_ParticleManager.CreateParticle";
            };
    
            return CreateParticle;
        })();
    
        CUserMsg_ParticleManager.DestroyParticle = (function() {
    
            /**
             * Properties of a DestroyParticle.
             * @memberof CUserMsg_ParticleManager
             * @interface IDestroyParticle
             * @property {boolean|null} [destroyImmediately] DestroyParticle destroyImmediately
             */
    
            /**
             * Constructs a new DestroyParticle.
             * @memberof CUserMsg_ParticleManager
             * @classdesc Represents a DestroyParticle.
             * @implements IDestroyParticle
             * @constructor
             * @param {CUserMsg_ParticleManager.IDestroyParticle=} [properties] Properties to set
             */
            function DestroyParticle(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * DestroyParticle destroyImmediately.
             * @member {boolean} destroyImmediately
             * @memberof CUserMsg_ParticleManager.DestroyParticle
             * @instance
             */
            DestroyParticle.prototype.destroyImmediately = false;
    
            /**
             * Creates a new DestroyParticle instance using the specified properties.
             * @function create
             * @memberof CUserMsg_ParticleManager.DestroyParticle
             * @static
             * @param {CUserMsg_ParticleManager.IDestroyParticle=} [properties] Properties to set
             * @returns {CUserMsg_ParticleManager.DestroyParticle} DestroyParticle instance
             */
            DestroyParticle.create = function create(properties) {
                return new DestroyParticle(properties);
            };
    
            /**
             * Encodes the specified DestroyParticle message. Does not implicitly {@link CUserMsg_ParticleManager.DestroyParticle.verify|verify} messages.
             * @function encode
             * @memberof CUserMsg_ParticleManager.DestroyParticle
             * @static
             * @param {CUserMsg_ParticleManager.IDestroyParticle} message DestroyParticle message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DestroyParticle.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.destroyImmediately != null && Object.hasOwnProperty.call(message, "destroyImmediately"))
                    writer.uint32(/* id 1, wireType 0 =*/8).bool(message.destroyImmediately);
                return writer;
            };
    
            /**
             * Encodes the specified DestroyParticle message, length delimited. Does not implicitly {@link CUserMsg_ParticleManager.DestroyParticle.verify|verify} messages.
             * @function encodeDelimited
             * @memberof CUserMsg_ParticleManager.DestroyParticle
             * @static
             * @param {CUserMsg_ParticleManager.IDestroyParticle} message DestroyParticle message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DestroyParticle.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a DestroyParticle message from the specified reader or buffer.
             * @function decode
             * @memberof CUserMsg_ParticleManager.DestroyParticle
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {CUserMsg_ParticleManager.DestroyParticle} DestroyParticle
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DestroyParticle.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CUserMsg_ParticleManager.DestroyParticle();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.destroyImmediately = reader.bool();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a DestroyParticle message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof CUserMsg_ParticleManager.DestroyParticle
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {CUserMsg_ParticleManager.DestroyParticle} DestroyParticle
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DestroyParticle.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a DestroyParticle message.
             * @function verify
             * @memberof CUserMsg_ParticleManager.DestroyParticle
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            DestroyParticle.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.destroyImmediately != null && message.hasOwnProperty("destroyImmediately"))
                    if (typeof message.destroyImmediately !== "boolean")
                        return "destroyImmediately: boolean expected";
                return null;
            };
    
            /**
             * Creates a DestroyParticle message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof CUserMsg_ParticleManager.DestroyParticle
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {CUserMsg_ParticleManager.DestroyParticle} DestroyParticle
             */
            DestroyParticle.fromObject = function fromObject(object) {
                if (object instanceof $root.CUserMsg_ParticleManager.DestroyParticle)
                    return object;
                var message = new $root.CUserMsg_ParticleManager.DestroyParticle();
                if (object.destroyImmediately != null)
                    message.destroyImmediately = Boolean(object.destroyImmediately);
                return message;
            };
    
            /**
             * Creates a plain object from a DestroyParticle message. Also converts values to other types if specified.
             * @function toObject
             * @memberof CUserMsg_ParticleManager.DestroyParticle
             * @static
             * @param {CUserMsg_ParticleManager.DestroyParticle} message DestroyParticle
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            DestroyParticle.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.destroyImmediately = false;
                if (message.destroyImmediately != null && message.hasOwnProperty("destroyImmediately"))
                    object.destroyImmediately = message.destroyImmediately;
                return object;
            };
    
            /**
             * Converts this DestroyParticle to JSON.
             * @function toJSON
             * @memberof CUserMsg_ParticleManager.DestroyParticle
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            DestroyParticle.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            /**
             * Gets the default type url for DestroyParticle
             * @function getTypeUrl
             * @memberof CUserMsg_ParticleManager.DestroyParticle
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            DestroyParticle.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/CUserMsg_ParticleManager.DestroyParticle";
            };
    
            return DestroyParticle;
        })();
    
        CUserMsg_ParticleManager.DestroyParticleInvolving = (function() {
    
            /**
             * Properties of a DestroyParticleInvolving.
             * @memberof CUserMsg_ParticleManager
             * @interface IDestroyParticleInvolving
             * @property {boolean|null} [destroyImmediately] DestroyParticleInvolving destroyImmediately
             * @property {number|null} [entityHandle] DestroyParticleInvolving entityHandle
             */
    
            /**
             * Constructs a new DestroyParticleInvolving.
             * @memberof CUserMsg_ParticleManager
             * @classdesc Represents a DestroyParticleInvolving.
             * @implements IDestroyParticleInvolving
             * @constructor
             * @param {CUserMsg_ParticleManager.IDestroyParticleInvolving=} [properties] Properties to set
             */
            function DestroyParticleInvolving(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * DestroyParticleInvolving destroyImmediately.
             * @member {boolean} destroyImmediately
             * @memberof CUserMsg_ParticleManager.DestroyParticleInvolving
             * @instance
             */
            DestroyParticleInvolving.prototype.destroyImmediately = false;
    
            /**
             * DestroyParticleInvolving entityHandle.
             * @member {number} entityHandle
             * @memberof CUserMsg_ParticleManager.DestroyParticleInvolving
             * @instance
             */
            DestroyParticleInvolving.prototype.entityHandle = 16777215;
    
            /**
             * Creates a new DestroyParticleInvolving instance using the specified properties.
             * @function create
             * @memberof CUserMsg_ParticleManager.DestroyParticleInvolving
             * @static
             * @param {CUserMsg_ParticleManager.IDestroyParticleInvolving=} [properties] Properties to set
             * @returns {CUserMsg_ParticleManager.DestroyParticleInvolving} DestroyParticleInvolving instance
             */
            DestroyParticleInvolving.create = function create(properties) {
                return new DestroyParticleInvolving(properties);
            };
    
            /**
             * Encodes the specified DestroyParticleInvolving message. Does not implicitly {@link CUserMsg_ParticleManager.DestroyParticleInvolving.verify|verify} messages.
             * @function encode
             * @memberof CUserMsg_ParticleManager.DestroyParticleInvolving
             * @static
             * @param {CUserMsg_ParticleManager.IDestroyParticleInvolving} message DestroyParticleInvolving message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DestroyParticleInvolving.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.destroyImmediately != null && Object.hasOwnProperty.call(message, "destroyImmediately"))
                    writer.uint32(/* id 1, wireType 0 =*/8).bool(message.destroyImmediately);
                if (message.entityHandle != null && Object.hasOwnProperty.call(message, "entityHandle"))
                    writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.entityHandle);
                return writer;
            };
    
            /**
             * Encodes the specified DestroyParticleInvolving message, length delimited. Does not implicitly {@link CUserMsg_ParticleManager.DestroyParticleInvolving.verify|verify} messages.
             * @function encodeDelimited
             * @memberof CUserMsg_ParticleManager.DestroyParticleInvolving
             * @static
             * @param {CUserMsg_ParticleManager.IDestroyParticleInvolving} message DestroyParticleInvolving message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DestroyParticleInvolving.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a DestroyParticleInvolving message from the specified reader or buffer.
             * @function decode
             * @memberof CUserMsg_ParticleManager.DestroyParticleInvolving
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {CUserMsg_ParticleManager.DestroyParticleInvolving} DestroyParticleInvolving
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DestroyParticleInvolving.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CUserMsg_ParticleManager.DestroyParticleInvolving();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.destroyImmediately = reader.bool();
                            break;
                        }
                    case 3: {
                            message.entityHandle = reader.uint32();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a DestroyParticleInvolving message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof CUserMsg_ParticleManager.DestroyParticleInvolving
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {CUserMsg_ParticleManager.DestroyParticleInvolving} DestroyParticleInvolving
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DestroyParticleInvolving.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a DestroyParticleInvolving message.
             * @function verify
             * @memberof CUserMsg_ParticleManager.DestroyParticleInvolving
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            DestroyParticleInvolving.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.destroyImmediately != null && message.hasOwnProperty("destroyImmediately"))
                    if (typeof message.destroyImmediately !== "boolean")
                        return "destroyImmediately: boolean expected";
                if (message.entityHandle != null && message.hasOwnProperty("entityHandle"))
                    if (!$util.isInteger(message.entityHandle))
                        return "entityHandle: integer expected";
                return null;
            };
    
            /**
             * Creates a DestroyParticleInvolving message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof CUserMsg_ParticleManager.DestroyParticleInvolving
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {CUserMsg_ParticleManager.DestroyParticleInvolving} DestroyParticleInvolving
             */
            DestroyParticleInvolving.fromObject = function fromObject(object) {
                if (object instanceof $root.CUserMsg_ParticleManager.DestroyParticleInvolving)
                    return object;
                var message = new $root.CUserMsg_ParticleManager.DestroyParticleInvolving();
                if (object.destroyImmediately != null)
                    message.destroyImmediately = Boolean(object.destroyImmediately);
                if (object.entityHandle != null)
                    message.entityHandle = object.entityHandle >>> 0;
                return message;
            };
    
            /**
             * Creates a plain object from a DestroyParticleInvolving message. Also converts values to other types if specified.
             * @function toObject
             * @memberof CUserMsg_ParticleManager.DestroyParticleInvolving
             * @static
             * @param {CUserMsg_ParticleManager.DestroyParticleInvolving} message DestroyParticleInvolving
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            DestroyParticleInvolving.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.destroyImmediately = false;
                    object.entityHandle = 16777215;
                }
                if (message.destroyImmediately != null && message.hasOwnProperty("destroyImmediately"))
                    object.destroyImmediately = message.destroyImmediately;
                if (message.entityHandle != null && message.hasOwnProperty("entityHandle"))
                    object.entityHandle = message.entityHandle;
                return object;
            };
    
            /**
             * Converts this DestroyParticleInvolving to JSON.
             * @function toJSON
             * @memberof CUserMsg_ParticleManager.DestroyParticleInvolving
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            DestroyParticleInvolving.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            /**
             * Gets the default type url for DestroyParticleInvolving
             * @function getTypeUrl
             * @memberof CUserMsg_ParticleManager.DestroyParticleInvolving
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            DestroyParticleInvolving.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/CUserMsg_ParticleManager.DestroyParticleInvolving";
            };
    
            return DestroyParticleInvolving;
        })();
    
        CUserMsg_ParticleManager.DestroyParticleNamed = (function() {
    
            /**
             * Properties of a DestroyParticleNamed.
             * @memberof CUserMsg_ParticleManager
             * @interface IDestroyParticleNamed
             * @property {number|Long|null} [particleNameIndex] DestroyParticleNamed particleNameIndex
             * @property {number|null} [entityHandle] DestroyParticleNamed entityHandle
             * @property {boolean|null} [destroyImmediately] DestroyParticleNamed destroyImmediately
             * @property {boolean|null} [playEndcap] DestroyParticleNamed playEndcap
             */
    
            /**
             * Constructs a new DestroyParticleNamed.
             * @memberof CUserMsg_ParticleManager
             * @classdesc Represents a DestroyParticleNamed.
             * @implements IDestroyParticleNamed
             * @constructor
             * @param {CUserMsg_ParticleManager.IDestroyParticleNamed=} [properties] Properties to set
             */
            function DestroyParticleNamed(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * DestroyParticleNamed particleNameIndex.
             * @member {number|Long} particleNameIndex
             * @memberof CUserMsg_ParticleManager.DestroyParticleNamed
             * @instance
             */
            DestroyParticleNamed.prototype.particleNameIndex = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
            /**
             * DestroyParticleNamed entityHandle.
             * @member {number} entityHandle
             * @memberof CUserMsg_ParticleManager.DestroyParticleNamed
             * @instance
             */
            DestroyParticleNamed.prototype.entityHandle = 16777215;
    
            /**
             * DestroyParticleNamed destroyImmediately.
             * @member {boolean} destroyImmediately
             * @memberof CUserMsg_ParticleManager.DestroyParticleNamed
             * @instance
             */
            DestroyParticleNamed.prototype.destroyImmediately = false;
    
            /**
             * DestroyParticleNamed playEndcap.
             * @member {boolean} playEndcap
             * @memberof CUserMsg_ParticleManager.DestroyParticleNamed
             * @instance
             */
            DestroyParticleNamed.prototype.playEndcap = false;
    
            /**
             * Creates a new DestroyParticleNamed instance using the specified properties.
             * @function create
             * @memberof CUserMsg_ParticleManager.DestroyParticleNamed
             * @static
             * @param {CUserMsg_ParticleManager.IDestroyParticleNamed=} [properties] Properties to set
             * @returns {CUserMsg_ParticleManager.DestroyParticleNamed} DestroyParticleNamed instance
             */
            DestroyParticleNamed.create = function create(properties) {
                return new DestroyParticleNamed(properties);
            };
    
            /**
             * Encodes the specified DestroyParticleNamed message. Does not implicitly {@link CUserMsg_ParticleManager.DestroyParticleNamed.verify|verify} messages.
             * @function encode
             * @memberof CUserMsg_ParticleManager.DestroyParticleNamed
             * @static
             * @param {CUserMsg_ParticleManager.IDestroyParticleNamed} message DestroyParticleNamed message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DestroyParticleNamed.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.particleNameIndex != null && Object.hasOwnProperty.call(message, "particleNameIndex"))
                    writer.uint32(/* id 1, wireType 1 =*/9).fixed64(message.particleNameIndex);
                if (message.entityHandle != null && Object.hasOwnProperty.call(message, "entityHandle"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.entityHandle);
                if (message.destroyImmediately != null && Object.hasOwnProperty.call(message, "destroyImmediately"))
                    writer.uint32(/* id 3, wireType 0 =*/24).bool(message.destroyImmediately);
                if (message.playEndcap != null && Object.hasOwnProperty.call(message, "playEndcap"))
                    writer.uint32(/* id 4, wireType 0 =*/32).bool(message.playEndcap);
                return writer;
            };
    
            /**
             * Encodes the specified DestroyParticleNamed message, length delimited. Does not implicitly {@link CUserMsg_ParticleManager.DestroyParticleNamed.verify|verify} messages.
             * @function encodeDelimited
             * @memberof CUserMsg_ParticleManager.DestroyParticleNamed
             * @static
             * @param {CUserMsg_ParticleManager.IDestroyParticleNamed} message DestroyParticleNamed message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DestroyParticleNamed.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a DestroyParticleNamed message from the specified reader or buffer.
             * @function decode
             * @memberof CUserMsg_ParticleManager.DestroyParticleNamed
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {CUserMsg_ParticleManager.DestroyParticleNamed} DestroyParticleNamed
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DestroyParticleNamed.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CUserMsg_ParticleManager.DestroyParticleNamed();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.particleNameIndex = reader.fixed64();
                            break;
                        }
                    case 2: {
                            message.entityHandle = reader.uint32();
                            break;
                        }
                    case 3: {
                            message.destroyImmediately = reader.bool();
                            break;
                        }
                    case 4: {
                            message.playEndcap = reader.bool();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a DestroyParticleNamed message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof CUserMsg_ParticleManager.DestroyParticleNamed
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {CUserMsg_ParticleManager.DestroyParticleNamed} DestroyParticleNamed
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DestroyParticleNamed.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a DestroyParticleNamed message.
             * @function verify
             * @memberof CUserMsg_ParticleManager.DestroyParticleNamed
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            DestroyParticleNamed.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.particleNameIndex != null && message.hasOwnProperty("particleNameIndex"))
                    if (!$util.isInteger(message.particleNameIndex) && !(message.particleNameIndex && $util.isInteger(message.particleNameIndex.low) && $util.isInteger(message.particleNameIndex.high)))
                        return "particleNameIndex: integer|Long expected";
                if (message.entityHandle != null && message.hasOwnProperty("entityHandle"))
                    if (!$util.isInteger(message.entityHandle))
                        return "entityHandle: integer expected";
                if (message.destroyImmediately != null && message.hasOwnProperty("destroyImmediately"))
                    if (typeof message.destroyImmediately !== "boolean")
                        return "destroyImmediately: boolean expected";
                if (message.playEndcap != null && message.hasOwnProperty("playEndcap"))
                    if (typeof message.playEndcap !== "boolean")
                        return "playEndcap: boolean expected";
                return null;
            };
    
            /**
             * Creates a DestroyParticleNamed message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof CUserMsg_ParticleManager.DestroyParticleNamed
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {CUserMsg_ParticleManager.DestroyParticleNamed} DestroyParticleNamed
             */
            DestroyParticleNamed.fromObject = function fromObject(object) {
                if (object instanceof $root.CUserMsg_ParticleManager.DestroyParticleNamed)
                    return object;
                var message = new $root.CUserMsg_ParticleManager.DestroyParticleNamed();
                if (object.particleNameIndex != null)
                    if ($util.Long)
                        (message.particleNameIndex = $util.Long.fromValue(object.particleNameIndex)).unsigned = false;
                    else if (typeof object.particleNameIndex === "string")
                        message.particleNameIndex = parseInt(object.particleNameIndex, 10);
                    else if (typeof object.particleNameIndex === "number")
                        message.particleNameIndex = object.particleNameIndex;
                    else if (typeof object.particleNameIndex === "object")
                        message.particleNameIndex = new $util.LongBits(object.particleNameIndex.low >>> 0, object.particleNameIndex.high >>> 0).toNumber();
                if (object.entityHandle != null)
                    message.entityHandle = object.entityHandle >>> 0;
                if (object.destroyImmediately != null)
                    message.destroyImmediately = Boolean(object.destroyImmediately);
                if (object.playEndcap != null)
                    message.playEndcap = Boolean(object.playEndcap);
                return message;
            };
    
            /**
             * Creates a plain object from a DestroyParticleNamed message. Also converts values to other types if specified.
             * @function toObject
             * @memberof CUserMsg_ParticleManager.DestroyParticleNamed
             * @static
             * @param {CUserMsg_ParticleManager.DestroyParticleNamed} message DestroyParticleNamed
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            DestroyParticleNamed.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.particleNameIndex = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.particleNameIndex = options.longs === String ? "0" : 0;
                    object.entityHandle = 16777215;
                    object.destroyImmediately = false;
                    object.playEndcap = false;
                }
                if (message.particleNameIndex != null && message.hasOwnProperty("particleNameIndex"))
                    if (typeof message.particleNameIndex === "number")
                        object.particleNameIndex = options.longs === String ? String(message.particleNameIndex) : message.particleNameIndex;
                    else
                        object.particleNameIndex = options.longs === String ? $util.Long.prototype.toString.call(message.particleNameIndex) : options.longs === Number ? new $util.LongBits(message.particleNameIndex.low >>> 0, message.particleNameIndex.high >>> 0).toNumber() : message.particleNameIndex;
                if (message.entityHandle != null && message.hasOwnProperty("entityHandle"))
                    object.entityHandle = message.entityHandle;
                if (message.destroyImmediately != null && message.hasOwnProperty("destroyImmediately"))
                    object.destroyImmediately = message.destroyImmediately;
                if (message.playEndcap != null && message.hasOwnProperty("playEndcap"))
                    object.playEndcap = message.playEndcap;
                return object;
            };
    
            /**
             * Converts this DestroyParticleNamed to JSON.
             * @function toJSON
             * @memberof CUserMsg_ParticleManager.DestroyParticleNamed
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            DestroyParticleNamed.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            /**
             * Gets the default type url for DestroyParticleNamed
             * @function getTypeUrl
             * @memberof CUserMsg_ParticleManager.DestroyParticleNamed
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            DestroyParticleNamed.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/CUserMsg_ParticleManager.DestroyParticleNamed";
            };
    
            return DestroyParticleNamed;
        })();
    
        CUserMsg_ParticleManager.UpdateParticle_OBSOLETE = (function() {
    
            /**
             * Properties of an UpdateParticle_OBSOLETE.
             * @memberof CUserMsg_ParticleManager
             * @interface IUpdateParticle_OBSOLETE
             * @property {number|null} [controlPoint] UpdateParticle_OBSOLETE controlPoint
             * @property {ICMsgVector|null} [position] UpdateParticle_OBSOLETE position
             */
    
            /**
             * Constructs a new UpdateParticle_OBSOLETE.
             * @memberof CUserMsg_ParticleManager
             * @classdesc Represents an UpdateParticle_OBSOLETE.
             * @implements IUpdateParticle_OBSOLETE
             * @constructor
             * @param {CUserMsg_ParticleManager.IUpdateParticle_OBSOLETE=} [properties] Properties to set
             */
            function UpdateParticle_OBSOLETE(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * UpdateParticle_OBSOLETE controlPoint.
             * @member {number} controlPoint
             * @memberof CUserMsg_ParticleManager.UpdateParticle_OBSOLETE
             * @instance
             */
            UpdateParticle_OBSOLETE.prototype.controlPoint = 0;
    
            /**
             * UpdateParticle_OBSOLETE position.
             * @member {ICMsgVector|null|undefined} position
             * @memberof CUserMsg_ParticleManager.UpdateParticle_OBSOLETE
             * @instance
             */
            UpdateParticle_OBSOLETE.prototype.position = null;
    
            /**
             * Creates a new UpdateParticle_OBSOLETE instance using the specified properties.
             * @function create
             * @memberof CUserMsg_ParticleManager.UpdateParticle_OBSOLETE
             * @static
             * @param {CUserMsg_ParticleManager.IUpdateParticle_OBSOLETE=} [properties] Properties to set
             * @returns {CUserMsg_ParticleManager.UpdateParticle_OBSOLETE} UpdateParticle_OBSOLETE instance
             */
            UpdateParticle_OBSOLETE.create = function create(properties) {
                return new UpdateParticle_OBSOLETE(properties);
            };
    
            /**
             * Encodes the specified UpdateParticle_OBSOLETE message. Does not implicitly {@link CUserMsg_ParticleManager.UpdateParticle_OBSOLETE.verify|verify} messages.
             * @function encode
             * @memberof CUserMsg_ParticleManager.UpdateParticle_OBSOLETE
             * @static
             * @param {CUserMsg_ParticleManager.IUpdateParticle_OBSOLETE} message UpdateParticle_OBSOLETE message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            UpdateParticle_OBSOLETE.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.controlPoint != null && Object.hasOwnProperty.call(message, "controlPoint"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.controlPoint);
                if (message.position != null && Object.hasOwnProperty.call(message, "position"))
                    $root.CMsgVector.encode(message.position, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };
    
            /**
             * Encodes the specified UpdateParticle_OBSOLETE message, length delimited. Does not implicitly {@link CUserMsg_ParticleManager.UpdateParticle_OBSOLETE.verify|verify} messages.
             * @function encodeDelimited
             * @memberof CUserMsg_ParticleManager.UpdateParticle_OBSOLETE
             * @static
             * @param {CUserMsg_ParticleManager.IUpdateParticle_OBSOLETE} message UpdateParticle_OBSOLETE message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            UpdateParticle_OBSOLETE.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes an UpdateParticle_OBSOLETE message from the specified reader or buffer.
             * @function decode
             * @memberof CUserMsg_ParticleManager.UpdateParticle_OBSOLETE
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {CUserMsg_ParticleManager.UpdateParticle_OBSOLETE} UpdateParticle_OBSOLETE
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            UpdateParticle_OBSOLETE.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CUserMsg_ParticleManager.UpdateParticle_OBSOLETE();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.controlPoint = reader.int32();
                            break;
                        }
                    case 2: {
                            message.position = $root.CMsgVector.decode(reader, reader.uint32());
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes an UpdateParticle_OBSOLETE message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof CUserMsg_ParticleManager.UpdateParticle_OBSOLETE
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {CUserMsg_ParticleManager.UpdateParticle_OBSOLETE} UpdateParticle_OBSOLETE
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            UpdateParticle_OBSOLETE.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies an UpdateParticle_OBSOLETE message.
             * @function verify
             * @memberof CUserMsg_ParticleManager.UpdateParticle_OBSOLETE
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            UpdateParticle_OBSOLETE.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.controlPoint != null && message.hasOwnProperty("controlPoint"))
                    if (!$util.isInteger(message.controlPoint))
                        return "controlPoint: integer expected";
                if (message.position != null && message.hasOwnProperty("position")) {
                    var error = $root.CMsgVector.verify(message.position);
                    if (error)
                        return "position." + error;
                }
                return null;
            };
    
            /**
             * Creates an UpdateParticle_OBSOLETE message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof CUserMsg_ParticleManager.UpdateParticle_OBSOLETE
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {CUserMsg_ParticleManager.UpdateParticle_OBSOLETE} UpdateParticle_OBSOLETE
             */
            UpdateParticle_OBSOLETE.fromObject = function fromObject(object) {
                if (object instanceof $root.CUserMsg_ParticleManager.UpdateParticle_OBSOLETE)
                    return object;
                var message = new $root.CUserMsg_ParticleManager.UpdateParticle_OBSOLETE();
                if (object.controlPoint != null)
                    message.controlPoint = object.controlPoint | 0;
                if (object.position != null) {
                    if (typeof object.position !== "object")
                        throw TypeError(".CUserMsg_ParticleManager.UpdateParticle_OBSOLETE.position: object expected");
                    message.position = $root.CMsgVector.fromObject(object.position);
                }
                return message;
            };
    
            /**
             * Creates a plain object from an UpdateParticle_OBSOLETE message. Also converts values to other types if specified.
             * @function toObject
             * @memberof CUserMsg_ParticleManager.UpdateParticle_OBSOLETE
             * @static
             * @param {CUserMsg_ParticleManager.UpdateParticle_OBSOLETE} message UpdateParticle_OBSOLETE
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            UpdateParticle_OBSOLETE.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.controlPoint = 0;
                    object.position = null;
                }
                if (message.controlPoint != null && message.hasOwnProperty("controlPoint"))
                    object.controlPoint = message.controlPoint;
                if (message.position != null && message.hasOwnProperty("position"))
                    object.position = $root.CMsgVector.toObject(message.position, options);
                return object;
            };
    
            /**
             * Converts this UpdateParticle_OBSOLETE to JSON.
             * @function toJSON
             * @memberof CUserMsg_ParticleManager.UpdateParticle_OBSOLETE
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            UpdateParticle_OBSOLETE.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            /**
             * Gets the default type url for UpdateParticle_OBSOLETE
             * @function getTypeUrl
             * @memberof CUserMsg_ParticleManager.UpdateParticle_OBSOLETE
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            UpdateParticle_OBSOLETE.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/CUserMsg_ParticleManager.UpdateParticle_OBSOLETE";
            };
    
            return UpdateParticle_OBSOLETE;
        })();
    
        CUserMsg_ParticleManager.UpdateParticleFwd_OBSOLETE = (function() {
    
            /**
             * Properties of an UpdateParticleFwd_OBSOLETE.
             * @memberof CUserMsg_ParticleManager
             * @interface IUpdateParticleFwd_OBSOLETE
             * @property {number|null} [controlPoint] UpdateParticleFwd_OBSOLETE controlPoint
             * @property {ICMsgVector|null} [forward] UpdateParticleFwd_OBSOLETE forward
             */
    
            /**
             * Constructs a new UpdateParticleFwd_OBSOLETE.
             * @memberof CUserMsg_ParticleManager
             * @classdesc Represents an UpdateParticleFwd_OBSOLETE.
             * @implements IUpdateParticleFwd_OBSOLETE
             * @constructor
             * @param {CUserMsg_ParticleManager.IUpdateParticleFwd_OBSOLETE=} [properties] Properties to set
             */
            function UpdateParticleFwd_OBSOLETE(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * UpdateParticleFwd_OBSOLETE controlPoint.
             * @member {number} controlPoint
             * @memberof CUserMsg_ParticleManager.UpdateParticleFwd_OBSOLETE
             * @instance
             */
            UpdateParticleFwd_OBSOLETE.prototype.controlPoint = 0;
    
            /**
             * UpdateParticleFwd_OBSOLETE forward.
             * @member {ICMsgVector|null|undefined} forward
             * @memberof CUserMsg_ParticleManager.UpdateParticleFwd_OBSOLETE
             * @instance
             */
            UpdateParticleFwd_OBSOLETE.prototype.forward = null;
    
            /**
             * Creates a new UpdateParticleFwd_OBSOLETE instance using the specified properties.
             * @function create
             * @memberof CUserMsg_ParticleManager.UpdateParticleFwd_OBSOLETE
             * @static
             * @param {CUserMsg_ParticleManager.IUpdateParticleFwd_OBSOLETE=} [properties] Properties to set
             * @returns {CUserMsg_ParticleManager.UpdateParticleFwd_OBSOLETE} UpdateParticleFwd_OBSOLETE instance
             */
            UpdateParticleFwd_OBSOLETE.create = function create(properties) {
                return new UpdateParticleFwd_OBSOLETE(properties);
            };
    
            /**
             * Encodes the specified UpdateParticleFwd_OBSOLETE message. Does not implicitly {@link CUserMsg_ParticleManager.UpdateParticleFwd_OBSOLETE.verify|verify} messages.
             * @function encode
             * @memberof CUserMsg_ParticleManager.UpdateParticleFwd_OBSOLETE
             * @static
             * @param {CUserMsg_ParticleManager.IUpdateParticleFwd_OBSOLETE} message UpdateParticleFwd_OBSOLETE message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            UpdateParticleFwd_OBSOLETE.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.controlPoint != null && Object.hasOwnProperty.call(message, "controlPoint"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.controlPoint);
                if (message.forward != null && Object.hasOwnProperty.call(message, "forward"))
                    $root.CMsgVector.encode(message.forward, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };
    
            /**
             * Encodes the specified UpdateParticleFwd_OBSOLETE message, length delimited. Does not implicitly {@link CUserMsg_ParticleManager.UpdateParticleFwd_OBSOLETE.verify|verify} messages.
             * @function encodeDelimited
             * @memberof CUserMsg_ParticleManager.UpdateParticleFwd_OBSOLETE
             * @static
             * @param {CUserMsg_ParticleManager.IUpdateParticleFwd_OBSOLETE} message UpdateParticleFwd_OBSOLETE message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            UpdateParticleFwd_OBSOLETE.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes an UpdateParticleFwd_OBSOLETE message from the specified reader or buffer.
             * @function decode
             * @memberof CUserMsg_ParticleManager.UpdateParticleFwd_OBSOLETE
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {CUserMsg_ParticleManager.UpdateParticleFwd_OBSOLETE} UpdateParticleFwd_OBSOLETE
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            UpdateParticleFwd_OBSOLETE.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CUserMsg_ParticleManager.UpdateParticleFwd_OBSOLETE();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.controlPoint = reader.int32();
                            break;
                        }
                    case 2: {
                            message.forward = $root.CMsgVector.decode(reader, reader.uint32());
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes an UpdateParticleFwd_OBSOLETE message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof CUserMsg_ParticleManager.UpdateParticleFwd_OBSOLETE
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {CUserMsg_ParticleManager.UpdateParticleFwd_OBSOLETE} UpdateParticleFwd_OBSOLETE
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            UpdateParticleFwd_OBSOLETE.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies an UpdateParticleFwd_OBSOLETE message.
             * @function verify
             * @memberof CUserMsg_ParticleManager.UpdateParticleFwd_OBSOLETE
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            UpdateParticleFwd_OBSOLETE.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.controlPoint != null && message.hasOwnProperty("controlPoint"))
                    if (!$util.isInteger(message.controlPoint))
                        return "controlPoint: integer expected";
                if (message.forward != null && message.hasOwnProperty("forward")) {
                    var error = $root.CMsgVector.verify(message.forward);
                    if (error)
                        return "forward." + error;
                }
                return null;
            };
    
            /**
             * Creates an UpdateParticleFwd_OBSOLETE message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof CUserMsg_ParticleManager.UpdateParticleFwd_OBSOLETE
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {CUserMsg_ParticleManager.UpdateParticleFwd_OBSOLETE} UpdateParticleFwd_OBSOLETE
             */
            UpdateParticleFwd_OBSOLETE.fromObject = function fromObject(object) {
                if (object instanceof $root.CUserMsg_ParticleManager.UpdateParticleFwd_OBSOLETE)
                    return object;
                var message = new $root.CUserMsg_ParticleManager.UpdateParticleFwd_OBSOLETE();
                if (object.controlPoint != null)
                    message.controlPoint = object.controlPoint | 0;
                if (object.forward != null) {
                    if (typeof object.forward !== "object")
                        throw TypeError(".CUserMsg_ParticleManager.UpdateParticleFwd_OBSOLETE.forward: object expected");
                    message.forward = $root.CMsgVector.fromObject(object.forward);
                }
                return message;
            };
    
            /**
             * Creates a plain object from an UpdateParticleFwd_OBSOLETE message. Also converts values to other types if specified.
             * @function toObject
             * @memberof CUserMsg_ParticleManager.UpdateParticleFwd_OBSOLETE
             * @static
             * @param {CUserMsg_ParticleManager.UpdateParticleFwd_OBSOLETE} message UpdateParticleFwd_OBSOLETE
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            UpdateParticleFwd_OBSOLETE.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.controlPoint = 0;
                    object.forward = null;
                }
                if (message.controlPoint != null && message.hasOwnProperty("controlPoint"))
                    object.controlPoint = message.controlPoint;
                if (message.forward != null && message.hasOwnProperty("forward"))
                    object.forward = $root.CMsgVector.toObject(message.forward, options);
                return object;
            };
    
            /**
             * Converts this UpdateParticleFwd_OBSOLETE to JSON.
             * @function toJSON
             * @memberof CUserMsg_ParticleManager.UpdateParticleFwd_OBSOLETE
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            UpdateParticleFwd_OBSOLETE.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            /**
             * Gets the default type url for UpdateParticleFwd_OBSOLETE
             * @function getTypeUrl
             * @memberof CUserMsg_ParticleManager.UpdateParticleFwd_OBSOLETE
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            UpdateParticleFwd_OBSOLETE.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/CUserMsg_ParticleManager.UpdateParticleFwd_OBSOLETE";
            };
    
            return UpdateParticleFwd_OBSOLETE;
        })();
    
        CUserMsg_ParticleManager.UpdateParticleOrient_OBSOLETE = (function() {
    
            /**
             * Properties of an UpdateParticleOrient_OBSOLETE.
             * @memberof CUserMsg_ParticleManager
             * @interface IUpdateParticleOrient_OBSOLETE
             * @property {number|null} [controlPoint] UpdateParticleOrient_OBSOLETE controlPoint
             * @property {ICMsgVector|null} [forward] UpdateParticleOrient_OBSOLETE forward
             * @property {ICMsgVector|null} [deprecatedRight] UpdateParticleOrient_OBSOLETE deprecatedRight
             * @property {ICMsgVector|null} [up] UpdateParticleOrient_OBSOLETE up
             * @property {ICMsgVector|null} [left] UpdateParticleOrient_OBSOLETE left
             */
    
            /**
             * Constructs a new UpdateParticleOrient_OBSOLETE.
             * @memberof CUserMsg_ParticleManager
             * @classdesc Represents an UpdateParticleOrient_OBSOLETE.
             * @implements IUpdateParticleOrient_OBSOLETE
             * @constructor
             * @param {CUserMsg_ParticleManager.IUpdateParticleOrient_OBSOLETE=} [properties] Properties to set
             */
            function UpdateParticleOrient_OBSOLETE(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * UpdateParticleOrient_OBSOLETE controlPoint.
             * @member {number} controlPoint
             * @memberof CUserMsg_ParticleManager.UpdateParticleOrient_OBSOLETE
             * @instance
             */
            UpdateParticleOrient_OBSOLETE.prototype.controlPoint = 0;
    
            /**
             * UpdateParticleOrient_OBSOLETE forward.
             * @member {ICMsgVector|null|undefined} forward
             * @memberof CUserMsg_ParticleManager.UpdateParticleOrient_OBSOLETE
             * @instance
             */
            UpdateParticleOrient_OBSOLETE.prototype.forward = null;
    
            /**
             * UpdateParticleOrient_OBSOLETE deprecatedRight.
             * @member {ICMsgVector|null|undefined} deprecatedRight
             * @memberof CUserMsg_ParticleManager.UpdateParticleOrient_OBSOLETE
             * @instance
             */
            UpdateParticleOrient_OBSOLETE.prototype.deprecatedRight = null;
    
            /**
             * UpdateParticleOrient_OBSOLETE up.
             * @member {ICMsgVector|null|undefined} up
             * @memberof CUserMsg_ParticleManager.UpdateParticleOrient_OBSOLETE
             * @instance
             */
            UpdateParticleOrient_OBSOLETE.prototype.up = null;
    
            /**
             * UpdateParticleOrient_OBSOLETE left.
             * @member {ICMsgVector|null|undefined} left
             * @memberof CUserMsg_ParticleManager.UpdateParticleOrient_OBSOLETE
             * @instance
             */
            UpdateParticleOrient_OBSOLETE.prototype.left = null;
    
            /**
             * Creates a new UpdateParticleOrient_OBSOLETE instance using the specified properties.
             * @function create
             * @memberof CUserMsg_ParticleManager.UpdateParticleOrient_OBSOLETE
             * @static
             * @param {CUserMsg_ParticleManager.IUpdateParticleOrient_OBSOLETE=} [properties] Properties to set
             * @returns {CUserMsg_ParticleManager.UpdateParticleOrient_OBSOLETE} UpdateParticleOrient_OBSOLETE instance
             */
            UpdateParticleOrient_OBSOLETE.create = function create(properties) {
                return new UpdateParticleOrient_OBSOLETE(properties);
            };
    
            /**
             * Encodes the specified UpdateParticleOrient_OBSOLETE message. Does not implicitly {@link CUserMsg_ParticleManager.UpdateParticleOrient_OBSOLETE.verify|verify} messages.
             * @function encode
             * @memberof CUserMsg_ParticleManager.UpdateParticleOrient_OBSOLETE
             * @static
             * @param {CUserMsg_ParticleManager.IUpdateParticleOrient_OBSOLETE} message UpdateParticleOrient_OBSOLETE message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            UpdateParticleOrient_OBSOLETE.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.controlPoint != null && Object.hasOwnProperty.call(message, "controlPoint"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.controlPoint);
                if (message.forward != null && Object.hasOwnProperty.call(message, "forward"))
                    $root.CMsgVector.encode(message.forward, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.deprecatedRight != null && Object.hasOwnProperty.call(message, "deprecatedRight"))
                    $root.CMsgVector.encode(message.deprecatedRight, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.up != null && Object.hasOwnProperty.call(message, "up"))
                    $root.CMsgVector.encode(message.up, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                if (message.left != null && Object.hasOwnProperty.call(message, "left"))
                    $root.CMsgVector.encode(message.left, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                return writer;
            };
    
            /**
             * Encodes the specified UpdateParticleOrient_OBSOLETE message, length delimited. Does not implicitly {@link CUserMsg_ParticleManager.UpdateParticleOrient_OBSOLETE.verify|verify} messages.
             * @function encodeDelimited
             * @memberof CUserMsg_ParticleManager.UpdateParticleOrient_OBSOLETE
             * @static
             * @param {CUserMsg_ParticleManager.IUpdateParticleOrient_OBSOLETE} message UpdateParticleOrient_OBSOLETE message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            UpdateParticleOrient_OBSOLETE.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes an UpdateParticleOrient_OBSOLETE message from the specified reader or buffer.
             * @function decode
             * @memberof CUserMsg_ParticleManager.UpdateParticleOrient_OBSOLETE
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {CUserMsg_ParticleManager.UpdateParticleOrient_OBSOLETE} UpdateParticleOrient_OBSOLETE
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            UpdateParticleOrient_OBSOLETE.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CUserMsg_ParticleManager.UpdateParticleOrient_OBSOLETE();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.controlPoint = reader.int32();
                            break;
                        }
                    case 2: {
                            message.forward = $root.CMsgVector.decode(reader, reader.uint32());
                            break;
                        }
                    case 3: {
                            message.deprecatedRight = $root.CMsgVector.decode(reader, reader.uint32());
                            break;
                        }
                    case 4: {
                            message.up = $root.CMsgVector.decode(reader, reader.uint32());
                            break;
                        }
                    case 5: {
                            message.left = $root.CMsgVector.decode(reader, reader.uint32());
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes an UpdateParticleOrient_OBSOLETE message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof CUserMsg_ParticleManager.UpdateParticleOrient_OBSOLETE
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {CUserMsg_ParticleManager.UpdateParticleOrient_OBSOLETE} UpdateParticleOrient_OBSOLETE
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            UpdateParticleOrient_OBSOLETE.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies an UpdateParticleOrient_OBSOLETE message.
             * @function verify
             * @memberof CUserMsg_ParticleManager.UpdateParticleOrient_OBSOLETE
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            UpdateParticleOrient_OBSOLETE.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.controlPoint != null && message.hasOwnProperty("controlPoint"))
                    if (!$util.isInteger(message.controlPoint))
                        return "controlPoint: integer expected";
                if (message.forward != null && message.hasOwnProperty("forward")) {
                    var error = $root.CMsgVector.verify(message.forward);
                    if (error)
                        return "forward." + error;
                }
                if (message.deprecatedRight != null && message.hasOwnProperty("deprecatedRight")) {
                    var error = $root.CMsgVector.verify(message.deprecatedRight);
                    if (error)
                        return "deprecatedRight." + error;
                }
                if (message.up != null && message.hasOwnProperty("up")) {
                    var error = $root.CMsgVector.verify(message.up);
                    if (error)
                        return "up." + error;
                }
                if (message.left != null && message.hasOwnProperty("left")) {
                    var error = $root.CMsgVector.verify(message.left);
                    if (error)
                        return "left." + error;
                }
                return null;
            };
    
            /**
             * Creates an UpdateParticleOrient_OBSOLETE message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof CUserMsg_ParticleManager.UpdateParticleOrient_OBSOLETE
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {CUserMsg_ParticleManager.UpdateParticleOrient_OBSOLETE} UpdateParticleOrient_OBSOLETE
             */
            UpdateParticleOrient_OBSOLETE.fromObject = function fromObject(object) {
                if (object instanceof $root.CUserMsg_ParticleManager.UpdateParticleOrient_OBSOLETE)
                    return object;
                var message = new $root.CUserMsg_ParticleManager.UpdateParticleOrient_OBSOLETE();
                if (object.controlPoint != null)
                    message.controlPoint = object.controlPoint | 0;
                if (object.forward != null) {
                    if (typeof object.forward !== "object")
                        throw TypeError(".CUserMsg_ParticleManager.UpdateParticleOrient_OBSOLETE.forward: object expected");
                    message.forward = $root.CMsgVector.fromObject(object.forward);
                }
                if (object.deprecatedRight != null) {
                    if (typeof object.deprecatedRight !== "object")
                        throw TypeError(".CUserMsg_ParticleManager.UpdateParticleOrient_OBSOLETE.deprecatedRight: object expected");
                    message.deprecatedRight = $root.CMsgVector.fromObject(object.deprecatedRight);
                }
                if (object.up != null) {
                    if (typeof object.up !== "object")
                        throw TypeError(".CUserMsg_ParticleManager.UpdateParticleOrient_OBSOLETE.up: object expected");
                    message.up = $root.CMsgVector.fromObject(object.up);
                }
                if (object.left != null) {
                    if (typeof object.left !== "object")
                        throw TypeError(".CUserMsg_ParticleManager.UpdateParticleOrient_OBSOLETE.left: object expected");
                    message.left = $root.CMsgVector.fromObject(object.left);
                }
                return message;
            };
    
            /**
             * Creates a plain object from an UpdateParticleOrient_OBSOLETE message. Also converts values to other types if specified.
             * @function toObject
             * @memberof CUserMsg_ParticleManager.UpdateParticleOrient_OBSOLETE
             * @static
             * @param {CUserMsg_ParticleManager.UpdateParticleOrient_OBSOLETE} message UpdateParticleOrient_OBSOLETE
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            UpdateParticleOrient_OBSOLETE.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.controlPoint = 0;
                    object.forward = null;
                    object.deprecatedRight = null;
                    object.up = null;
                    object.left = null;
                }
                if (message.controlPoint != null && message.hasOwnProperty("controlPoint"))
                    object.controlPoint = message.controlPoint;
                if (message.forward != null && message.hasOwnProperty("forward"))
                    object.forward = $root.CMsgVector.toObject(message.forward, options);
                if (message.deprecatedRight != null && message.hasOwnProperty("deprecatedRight"))
                    object.deprecatedRight = $root.CMsgVector.toObject(message.deprecatedRight, options);
                if (message.up != null && message.hasOwnProperty("up"))
                    object.up = $root.CMsgVector.toObject(message.up, options);
                if (message.left != null && message.hasOwnProperty("left"))
                    object.left = $root.CMsgVector.toObject(message.left, options);
                return object;
            };
    
            /**
             * Converts this UpdateParticleOrient_OBSOLETE to JSON.
             * @function toJSON
             * @memberof CUserMsg_ParticleManager.UpdateParticleOrient_OBSOLETE
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            UpdateParticleOrient_OBSOLETE.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            /**
             * Gets the default type url for UpdateParticleOrient_OBSOLETE
             * @function getTypeUrl
             * @memberof CUserMsg_ParticleManager.UpdateParticleOrient_OBSOLETE
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            UpdateParticleOrient_OBSOLETE.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/CUserMsg_ParticleManager.UpdateParticleOrient_OBSOLETE";
            };
    
            return UpdateParticleOrient_OBSOLETE;
        })();
    
        CUserMsg_ParticleManager.UpdateParticleTransform = (function() {
    
            /**
             * Properties of an UpdateParticleTransform.
             * @memberof CUserMsg_ParticleManager
             * @interface IUpdateParticleTransform
             * @property {number|null} [controlPoint] UpdateParticleTransform controlPoint
             * @property {ICMsgVector|null} [position] UpdateParticleTransform position
             * @property {ICMsgQuaternion|null} [orientation] UpdateParticleTransform orientation
             * @property {number|null} [interpolationInterval] UpdateParticleTransform interpolationInterval
             */
    
            /**
             * Constructs a new UpdateParticleTransform.
             * @memberof CUserMsg_ParticleManager
             * @classdesc Represents an UpdateParticleTransform.
             * @implements IUpdateParticleTransform
             * @constructor
             * @param {CUserMsg_ParticleManager.IUpdateParticleTransform=} [properties] Properties to set
             */
            function UpdateParticleTransform(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * UpdateParticleTransform controlPoint.
             * @member {number} controlPoint
             * @memberof CUserMsg_ParticleManager.UpdateParticleTransform
             * @instance
             */
            UpdateParticleTransform.prototype.controlPoint = 0;
    
            /**
             * UpdateParticleTransform position.
             * @member {ICMsgVector|null|undefined} position
             * @memberof CUserMsg_ParticleManager.UpdateParticleTransform
             * @instance
             */
            UpdateParticleTransform.prototype.position = null;
    
            /**
             * UpdateParticleTransform orientation.
             * @member {ICMsgQuaternion|null|undefined} orientation
             * @memberof CUserMsg_ParticleManager.UpdateParticleTransform
             * @instance
             */
            UpdateParticleTransform.prototype.orientation = null;
    
            /**
             * UpdateParticleTransform interpolationInterval.
             * @member {number} interpolationInterval
             * @memberof CUserMsg_ParticleManager.UpdateParticleTransform
             * @instance
             */
            UpdateParticleTransform.prototype.interpolationInterval = 0;
    
            /**
             * Creates a new UpdateParticleTransform instance using the specified properties.
             * @function create
             * @memberof CUserMsg_ParticleManager.UpdateParticleTransform
             * @static
             * @param {CUserMsg_ParticleManager.IUpdateParticleTransform=} [properties] Properties to set
             * @returns {CUserMsg_ParticleManager.UpdateParticleTransform} UpdateParticleTransform instance
             */
            UpdateParticleTransform.create = function create(properties) {
                return new UpdateParticleTransform(properties);
            };
    
            /**
             * Encodes the specified UpdateParticleTransform message. Does not implicitly {@link CUserMsg_ParticleManager.UpdateParticleTransform.verify|verify} messages.
             * @function encode
             * @memberof CUserMsg_ParticleManager.UpdateParticleTransform
             * @static
             * @param {CUserMsg_ParticleManager.IUpdateParticleTransform} message UpdateParticleTransform message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            UpdateParticleTransform.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.controlPoint != null && Object.hasOwnProperty.call(message, "controlPoint"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.controlPoint);
                if (message.position != null && Object.hasOwnProperty.call(message, "position"))
                    $root.CMsgVector.encode(message.position, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.orientation != null && Object.hasOwnProperty.call(message, "orientation"))
                    $root.CMsgQuaternion.encode(message.orientation, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.interpolationInterval != null && Object.hasOwnProperty.call(message, "interpolationInterval"))
                    writer.uint32(/* id 4, wireType 5 =*/37).float(message.interpolationInterval);
                return writer;
            };
    
            /**
             * Encodes the specified UpdateParticleTransform message, length delimited. Does not implicitly {@link CUserMsg_ParticleManager.UpdateParticleTransform.verify|verify} messages.
             * @function encodeDelimited
             * @memberof CUserMsg_ParticleManager.UpdateParticleTransform
             * @static
             * @param {CUserMsg_ParticleManager.IUpdateParticleTransform} message UpdateParticleTransform message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            UpdateParticleTransform.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes an UpdateParticleTransform message from the specified reader or buffer.
             * @function decode
             * @memberof CUserMsg_ParticleManager.UpdateParticleTransform
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {CUserMsg_ParticleManager.UpdateParticleTransform} UpdateParticleTransform
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            UpdateParticleTransform.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CUserMsg_ParticleManager.UpdateParticleTransform();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.controlPoint = reader.int32();
                            break;
                        }
                    case 2: {
                            message.position = $root.CMsgVector.decode(reader, reader.uint32());
                            break;
                        }
                    case 3: {
                            message.orientation = $root.CMsgQuaternion.decode(reader, reader.uint32());
                            break;
                        }
                    case 4: {
                            message.interpolationInterval = reader.float();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes an UpdateParticleTransform message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof CUserMsg_ParticleManager.UpdateParticleTransform
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {CUserMsg_ParticleManager.UpdateParticleTransform} UpdateParticleTransform
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            UpdateParticleTransform.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies an UpdateParticleTransform message.
             * @function verify
             * @memberof CUserMsg_ParticleManager.UpdateParticleTransform
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            UpdateParticleTransform.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.controlPoint != null && message.hasOwnProperty("controlPoint"))
                    if (!$util.isInteger(message.controlPoint))
                        return "controlPoint: integer expected";
                if (message.position != null && message.hasOwnProperty("position")) {
                    var error = $root.CMsgVector.verify(message.position);
                    if (error)
                        return "position." + error;
                }
                if (message.orientation != null && message.hasOwnProperty("orientation")) {
                    var error = $root.CMsgQuaternion.verify(message.orientation);
                    if (error)
                        return "orientation." + error;
                }
                if (message.interpolationInterval != null && message.hasOwnProperty("interpolationInterval"))
                    if (typeof message.interpolationInterval !== "number")
                        return "interpolationInterval: number expected";
                return null;
            };
    
            /**
             * Creates an UpdateParticleTransform message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof CUserMsg_ParticleManager.UpdateParticleTransform
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {CUserMsg_ParticleManager.UpdateParticleTransform} UpdateParticleTransform
             */
            UpdateParticleTransform.fromObject = function fromObject(object) {
                if (object instanceof $root.CUserMsg_ParticleManager.UpdateParticleTransform)
                    return object;
                var message = new $root.CUserMsg_ParticleManager.UpdateParticleTransform();
                if (object.controlPoint != null)
                    message.controlPoint = object.controlPoint | 0;
                if (object.position != null) {
                    if (typeof object.position !== "object")
                        throw TypeError(".CUserMsg_ParticleManager.UpdateParticleTransform.position: object expected");
                    message.position = $root.CMsgVector.fromObject(object.position);
                }
                if (object.orientation != null) {
                    if (typeof object.orientation !== "object")
                        throw TypeError(".CUserMsg_ParticleManager.UpdateParticleTransform.orientation: object expected");
                    message.orientation = $root.CMsgQuaternion.fromObject(object.orientation);
                }
                if (object.interpolationInterval != null)
                    message.interpolationInterval = Number(object.interpolationInterval);
                return message;
            };
    
            /**
             * Creates a plain object from an UpdateParticleTransform message. Also converts values to other types if specified.
             * @function toObject
             * @memberof CUserMsg_ParticleManager.UpdateParticleTransform
             * @static
             * @param {CUserMsg_ParticleManager.UpdateParticleTransform} message UpdateParticleTransform
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            UpdateParticleTransform.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.controlPoint = 0;
                    object.position = null;
                    object.orientation = null;
                    object.interpolationInterval = 0;
                }
                if (message.controlPoint != null && message.hasOwnProperty("controlPoint"))
                    object.controlPoint = message.controlPoint;
                if (message.position != null && message.hasOwnProperty("position"))
                    object.position = $root.CMsgVector.toObject(message.position, options);
                if (message.orientation != null && message.hasOwnProperty("orientation"))
                    object.orientation = $root.CMsgQuaternion.toObject(message.orientation, options);
                if (message.interpolationInterval != null && message.hasOwnProperty("interpolationInterval"))
                    object.interpolationInterval = options.json && !isFinite(message.interpolationInterval) ? String(message.interpolationInterval) : message.interpolationInterval;
                return object;
            };
    
            /**
             * Converts this UpdateParticleTransform to JSON.
             * @function toJSON
             * @memberof CUserMsg_ParticleManager.UpdateParticleTransform
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            UpdateParticleTransform.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            /**
             * Gets the default type url for UpdateParticleTransform
             * @function getTypeUrl
             * @memberof CUserMsg_ParticleManager.UpdateParticleTransform
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            UpdateParticleTransform.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/CUserMsg_ParticleManager.UpdateParticleTransform";
            };
    
            return UpdateParticleTransform;
        })();
    
        CUserMsg_ParticleManager.UpdateParticleFallback = (function() {
    
            /**
             * Properties of an UpdateParticleFallback.
             * @memberof CUserMsg_ParticleManager
             * @interface IUpdateParticleFallback
             * @property {number|null} [controlPoint] UpdateParticleFallback controlPoint
             * @property {ICMsgVector|null} [position] UpdateParticleFallback position
             */
    
            /**
             * Constructs a new UpdateParticleFallback.
             * @memberof CUserMsg_ParticleManager
             * @classdesc Represents an UpdateParticleFallback.
             * @implements IUpdateParticleFallback
             * @constructor
             * @param {CUserMsg_ParticleManager.IUpdateParticleFallback=} [properties] Properties to set
             */
            function UpdateParticleFallback(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * UpdateParticleFallback controlPoint.
             * @member {number} controlPoint
             * @memberof CUserMsg_ParticleManager.UpdateParticleFallback
             * @instance
             */
            UpdateParticleFallback.prototype.controlPoint = 0;
    
            /**
             * UpdateParticleFallback position.
             * @member {ICMsgVector|null|undefined} position
             * @memberof CUserMsg_ParticleManager.UpdateParticleFallback
             * @instance
             */
            UpdateParticleFallback.prototype.position = null;
    
            /**
             * Creates a new UpdateParticleFallback instance using the specified properties.
             * @function create
             * @memberof CUserMsg_ParticleManager.UpdateParticleFallback
             * @static
             * @param {CUserMsg_ParticleManager.IUpdateParticleFallback=} [properties] Properties to set
             * @returns {CUserMsg_ParticleManager.UpdateParticleFallback} UpdateParticleFallback instance
             */
            UpdateParticleFallback.create = function create(properties) {
                return new UpdateParticleFallback(properties);
            };
    
            /**
             * Encodes the specified UpdateParticleFallback message. Does not implicitly {@link CUserMsg_ParticleManager.UpdateParticleFallback.verify|verify} messages.
             * @function encode
             * @memberof CUserMsg_ParticleManager.UpdateParticleFallback
             * @static
             * @param {CUserMsg_ParticleManager.IUpdateParticleFallback} message UpdateParticleFallback message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            UpdateParticleFallback.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.controlPoint != null && Object.hasOwnProperty.call(message, "controlPoint"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.controlPoint);
                if (message.position != null && Object.hasOwnProperty.call(message, "position"))
                    $root.CMsgVector.encode(message.position, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };
    
            /**
             * Encodes the specified UpdateParticleFallback message, length delimited. Does not implicitly {@link CUserMsg_ParticleManager.UpdateParticleFallback.verify|verify} messages.
             * @function encodeDelimited
             * @memberof CUserMsg_ParticleManager.UpdateParticleFallback
             * @static
             * @param {CUserMsg_ParticleManager.IUpdateParticleFallback} message UpdateParticleFallback message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            UpdateParticleFallback.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes an UpdateParticleFallback message from the specified reader or buffer.
             * @function decode
             * @memberof CUserMsg_ParticleManager.UpdateParticleFallback
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {CUserMsg_ParticleManager.UpdateParticleFallback} UpdateParticleFallback
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            UpdateParticleFallback.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CUserMsg_ParticleManager.UpdateParticleFallback();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.controlPoint = reader.int32();
                            break;
                        }
                    case 2: {
                            message.position = $root.CMsgVector.decode(reader, reader.uint32());
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes an UpdateParticleFallback message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof CUserMsg_ParticleManager.UpdateParticleFallback
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {CUserMsg_ParticleManager.UpdateParticleFallback} UpdateParticleFallback
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            UpdateParticleFallback.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies an UpdateParticleFallback message.
             * @function verify
             * @memberof CUserMsg_ParticleManager.UpdateParticleFallback
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            UpdateParticleFallback.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.controlPoint != null && message.hasOwnProperty("controlPoint"))
                    if (!$util.isInteger(message.controlPoint))
                        return "controlPoint: integer expected";
                if (message.position != null && message.hasOwnProperty("position")) {
                    var error = $root.CMsgVector.verify(message.position);
                    if (error)
                        return "position." + error;
                }
                return null;
            };
    
            /**
             * Creates an UpdateParticleFallback message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof CUserMsg_ParticleManager.UpdateParticleFallback
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {CUserMsg_ParticleManager.UpdateParticleFallback} UpdateParticleFallback
             */
            UpdateParticleFallback.fromObject = function fromObject(object) {
                if (object instanceof $root.CUserMsg_ParticleManager.UpdateParticleFallback)
                    return object;
                var message = new $root.CUserMsg_ParticleManager.UpdateParticleFallback();
                if (object.controlPoint != null)
                    message.controlPoint = object.controlPoint | 0;
                if (object.position != null) {
                    if (typeof object.position !== "object")
                        throw TypeError(".CUserMsg_ParticleManager.UpdateParticleFallback.position: object expected");
                    message.position = $root.CMsgVector.fromObject(object.position);
                }
                return message;
            };
    
            /**
             * Creates a plain object from an UpdateParticleFallback message. Also converts values to other types if specified.
             * @function toObject
             * @memberof CUserMsg_ParticleManager.UpdateParticleFallback
             * @static
             * @param {CUserMsg_ParticleManager.UpdateParticleFallback} message UpdateParticleFallback
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            UpdateParticleFallback.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.controlPoint = 0;
                    object.position = null;
                }
                if (message.controlPoint != null && message.hasOwnProperty("controlPoint"))
                    object.controlPoint = message.controlPoint;
                if (message.position != null && message.hasOwnProperty("position"))
                    object.position = $root.CMsgVector.toObject(message.position, options);
                return object;
            };
    
            /**
             * Converts this UpdateParticleFallback to JSON.
             * @function toJSON
             * @memberof CUserMsg_ParticleManager.UpdateParticleFallback
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            UpdateParticleFallback.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            /**
             * Gets the default type url for UpdateParticleFallback
             * @function getTypeUrl
             * @memberof CUserMsg_ParticleManager.UpdateParticleFallback
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            UpdateParticleFallback.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/CUserMsg_ParticleManager.UpdateParticleFallback";
            };
    
            return UpdateParticleFallback;
        })();
    
        CUserMsg_ParticleManager.UpdateParticleOffset = (function() {
    
            /**
             * Properties of an UpdateParticleOffset.
             * @memberof CUserMsg_ParticleManager
             * @interface IUpdateParticleOffset
             * @property {number|null} [controlPoint] UpdateParticleOffset controlPoint
             * @property {ICMsgVector|null} [originOffset] UpdateParticleOffset originOffset
             * @property {ICMsgQAngle|null} [angleOffset] UpdateParticleOffset angleOffset
             */
    
            /**
             * Constructs a new UpdateParticleOffset.
             * @memberof CUserMsg_ParticleManager
             * @classdesc Represents an UpdateParticleOffset.
             * @implements IUpdateParticleOffset
             * @constructor
             * @param {CUserMsg_ParticleManager.IUpdateParticleOffset=} [properties] Properties to set
             */
            function UpdateParticleOffset(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * UpdateParticleOffset controlPoint.
             * @member {number} controlPoint
             * @memberof CUserMsg_ParticleManager.UpdateParticleOffset
             * @instance
             */
            UpdateParticleOffset.prototype.controlPoint = 0;
    
            /**
             * UpdateParticleOffset originOffset.
             * @member {ICMsgVector|null|undefined} originOffset
             * @memberof CUserMsg_ParticleManager.UpdateParticleOffset
             * @instance
             */
            UpdateParticleOffset.prototype.originOffset = null;
    
            /**
             * UpdateParticleOffset angleOffset.
             * @member {ICMsgQAngle|null|undefined} angleOffset
             * @memberof CUserMsg_ParticleManager.UpdateParticleOffset
             * @instance
             */
            UpdateParticleOffset.prototype.angleOffset = null;
    
            /**
             * Creates a new UpdateParticleOffset instance using the specified properties.
             * @function create
             * @memberof CUserMsg_ParticleManager.UpdateParticleOffset
             * @static
             * @param {CUserMsg_ParticleManager.IUpdateParticleOffset=} [properties] Properties to set
             * @returns {CUserMsg_ParticleManager.UpdateParticleOffset} UpdateParticleOffset instance
             */
            UpdateParticleOffset.create = function create(properties) {
                return new UpdateParticleOffset(properties);
            };
    
            /**
             * Encodes the specified UpdateParticleOffset message. Does not implicitly {@link CUserMsg_ParticleManager.UpdateParticleOffset.verify|verify} messages.
             * @function encode
             * @memberof CUserMsg_ParticleManager.UpdateParticleOffset
             * @static
             * @param {CUserMsg_ParticleManager.IUpdateParticleOffset} message UpdateParticleOffset message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            UpdateParticleOffset.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.controlPoint != null && Object.hasOwnProperty.call(message, "controlPoint"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.controlPoint);
                if (message.originOffset != null && Object.hasOwnProperty.call(message, "originOffset"))
                    $root.CMsgVector.encode(message.originOffset, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.angleOffset != null && Object.hasOwnProperty.call(message, "angleOffset"))
                    $root.CMsgQAngle.encode(message.angleOffset, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                return writer;
            };
    
            /**
             * Encodes the specified UpdateParticleOffset message, length delimited. Does not implicitly {@link CUserMsg_ParticleManager.UpdateParticleOffset.verify|verify} messages.
             * @function encodeDelimited
             * @memberof CUserMsg_ParticleManager.UpdateParticleOffset
             * @static
             * @param {CUserMsg_ParticleManager.IUpdateParticleOffset} message UpdateParticleOffset message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            UpdateParticleOffset.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes an UpdateParticleOffset message from the specified reader or buffer.
             * @function decode
             * @memberof CUserMsg_ParticleManager.UpdateParticleOffset
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {CUserMsg_ParticleManager.UpdateParticleOffset} UpdateParticleOffset
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            UpdateParticleOffset.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CUserMsg_ParticleManager.UpdateParticleOffset();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.controlPoint = reader.int32();
                            break;
                        }
                    case 2: {
                            message.originOffset = $root.CMsgVector.decode(reader, reader.uint32());
                            break;
                        }
                    case 3: {
                            message.angleOffset = $root.CMsgQAngle.decode(reader, reader.uint32());
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes an UpdateParticleOffset message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof CUserMsg_ParticleManager.UpdateParticleOffset
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {CUserMsg_ParticleManager.UpdateParticleOffset} UpdateParticleOffset
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            UpdateParticleOffset.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies an UpdateParticleOffset message.
             * @function verify
             * @memberof CUserMsg_ParticleManager.UpdateParticleOffset
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            UpdateParticleOffset.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.controlPoint != null && message.hasOwnProperty("controlPoint"))
                    if (!$util.isInteger(message.controlPoint))
                        return "controlPoint: integer expected";
                if (message.originOffset != null && message.hasOwnProperty("originOffset")) {
                    var error = $root.CMsgVector.verify(message.originOffset);
                    if (error)
                        return "originOffset." + error;
                }
                if (message.angleOffset != null && message.hasOwnProperty("angleOffset")) {
                    var error = $root.CMsgQAngle.verify(message.angleOffset);
                    if (error)
                        return "angleOffset." + error;
                }
                return null;
            };
    
            /**
             * Creates an UpdateParticleOffset message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof CUserMsg_ParticleManager.UpdateParticleOffset
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {CUserMsg_ParticleManager.UpdateParticleOffset} UpdateParticleOffset
             */
            UpdateParticleOffset.fromObject = function fromObject(object) {
                if (object instanceof $root.CUserMsg_ParticleManager.UpdateParticleOffset)
                    return object;
                var message = new $root.CUserMsg_ParticleManager.UpdateParticleOffset();
                if (object.controlPoint != null)
                    message.controlPoint = object.controlPoint | 0;
                if (object.originOffset != null) {
                    if (typeof object.originOffset !== "object")
                        throw TypeError(".CUserMsg_ParticleManager.UpdateParticleOffset.originOffset: object expected");
                    message.originOffset = $root.CMsgVector.fromObject(object.originOffset);
                }
                if (object.angleOffset != null) {
                    if (typeof object.angleOffset !== "object")
                        throw TypeError(".CUserMsg_ParticleManager.UpdateParticleOffset.angleOffset: object expected");
                    message.angleOffset = $root.CMsgQAngle.fromObject(object.angleOffset);
                }
                return message;
            };
    
            /**
             * Creates a plain object from an UpdateParticleOffset message. Also converts values to other types if specified.
             * @function toObject
             * @memberof CUserMsg_ParticleManager.UpdateParticleOffset
             * @static
             * @param {CUserMsg_ParticleManager.UpdateParticleOffset} message UpdateParticleOffset
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            UpdateParticleOffset.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.controlPoint = 0;
                    object.originOffset = null;
                    object.angleOffset = null;
                }
                if (message.controlPoint != null && message.hasOwnProperty("controlPoint"))
                    object.controlPoint = message.controlPoint;
                if (message.originOffset != null && message.hasOwnProperty("originOffset"))
                    object.originOffset = $root.CMsgVector.toObject(message.originOffset, options);
                if (message.angleOffset != null && message.hasOwnProperty("angleOffset"))
                    object.angleOffset = $root.CMsgQAngle.toObject(message.angleOffset, options);
                return object;
            };
    
            /**
             * Converts this UpdateParticleOffset to JSON.
             * @function toJSON
             * @memberof CUserMsg_ParticleManager.UpdateParticleOffset
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            UpdateParticleOffset.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            /**
             * Gets the default type url for UpdateParticleOffset
             * @function getTypeUrl
             * @memberof CUserMsg_ParticleManager.UpdateParticleOffset
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            UpdateParticleOffset.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/CUserMsg_ParticleManager.UpdateParticleOffset";
            };
    
            return UpdateParticleOffset;
        })();
    
        CUserMsg_ParticleManager.UpdateParticleEnt = (function() {
    
            /**
             * Properties of an UpdateParticleEnt.
             * @memberof CUserMsg_ParticleManager
             * @interface IUpdateParticleEnt
             * @property {number|null} [controlPoint] UpdateParticleEnt controlPoint
             * @property {number|null} [entityHandle] UpdateParticleEnt entityHandle
             * @property {number|null} [attachType] UpdateParticleEnt attachType
             * @property {number|null} [attachment] UpdateParticleEnt attachment
             * @property {ICMsgVector|null} [fallbackPosition] UpdateParticleEnt fallbackPosition
             * @property {boolean|null} [includeWearables] UpdateParticleEnt includeWearables
             * @property {ICMsgVector|null} [offsetPosition] UpdateParticleEnt offsetPosition
             * @property {ICMsgQAngle|null} [offsetAngles] UpdateParticleEnt offsetAngles
             */
    
            /**
             * Constructs a new UpdateParticleEnt.
             * @memberof CUserMsg_ParticleManager
             * @classdesc Represents an UpdateParticleEnt.
             * @implements IUpdateParticleEnt
             * @constructor
             * @param {CUserMsg_ParticleManager.IUpdateParticleEnt=} [properties] Properties to set
             */
            function UpdateParticleEnt(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * UpdateParticleEnt controlPoint.
             * @member {number} controlPoint
             * @memberof CUserMsg_ParticleManager.UpdateParticleEnt
             * @instance
             */
            UpdateParticleEnt.prototype.controlPoint = 0;
    
            /**
             * UpdateParticleEnt entityHandle.
             * @member {number} entityHandle
             * @memberof CUserMsg_ParticleManager.UpdateParticleEnt
             * @instance
             */
            UpdateParticleEnt.prototype.entityHandle = 16777215;
    
            /**
             * UpdateParticleEnt attachType.
             * @member {number} attachType
             * @memberof CUserMsg_ParticleManager.UpdateParticleEnt
             * @instance
             */
            UpdateParticleEnt.prototype.attachType = 0;
    
            /**
             * UpdateParticleEnt attachment.
             * @member {number} attachment
             * @memberof CUserMsg_ParticleManager.UpdateParticleEnt
             * @instance
             */
            UpdateParticleEnt.prototype.attachment = 0;
    
            /**
             * UpdateParticleEnt fallbackPosition.
             * @member {ICMsgVector|null|undefined} fallbackPosition
             * @memberof CUserMsg_ParticleManager.UpdateParticleEnt
             * @instance
             */
            UpdateParticleEnt.prototype.fallbackPosition = null;
    
            /**
             * UpdateParticleEnt includeWearables.
             * @member {boolean} includeWearables
             * @memberof CUserMsg_ParticleManager.UpdateParticleEnt
             * @instance
             */
            UpdateParticleEnt.prototype.includeWearables = false;
    
            /**
             * UpdateParticleEnt offsetPosition.
             * @member {ICMsgVector|null|undefined} offsetPosition
             * @memberof CUserMsg_ParticleManager.UpdateParticleEnt
             * @instance
             */
            UpdateParticleEnt.prototype.offsetPosition = null;
    
            /**
             * UpdateParticleEnt offsetAngles.
             * @member {ICMsgQAngle|null|undefined} offsetAngles
             * @memberof CUserMsg_ParticleManager.UpdateParticleEnt
             * @instance
             */
            UpdateParticleEnt.prototype.offsetAngles = null;
    
            /**
             * Creates a new UpdateParticleEnt instance using the specified properties.
             * @function create
             * @memberof CUserMsg_ParticleManager.UpdateParticleEnt
             * @static
             * @param {CUserMsg_ParticleManager.IUpdateParticleEnt=} [properties] Properties to set
             * @returns {CUserMsg_ParticleManager.UpdateParticleEnt} UpdateParticleEnt instance
             */
            UpdateParticleEnt.create = function create(properties) {
                return new UpdateParticleEnt(properties);
            };
    
            /**
             * Encodes the specified UpdateParticleEnt message. Does not implicitly {@link CUserMsg_ParticleManager.UpdateParticleEnt.verify|verify} messages.
             * @function encode
             * @memberof CUserMsg_ParticleManager.UpdateParticleEnt
             * @static
             * @param {CUserMsg_ParticleManager.IUpdateParticleEnt} message UpdateParticleEnt message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            UpdateParticleEnt.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.controlPoint != null && Object.hasOwnProperty.call(message, "controlPoint"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.controlPoint);
                if (message.entityHandle != null && Object.hasOwnProperty.call(message, "entityHandle"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.entityHandle);
                if (message.attachType != null && Object.hasOwnProperty.call(message, "attachType"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int32(message.attachType);
                if (message.attachment != null && Object.hasOwnProperty.call(message, "attachment"))
                    writer.uint32(/* id 4, wireType 0 =*/32).int32(message.attachment);
                if (message.fallbackPosition != null && Object.hasOwnProperty.call(message, "fallbackPosition"))
                    $root.CMsgVector.encode(message.fallbackPosition, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                if (message.includeWearables != null && Object.hasOwnProperty.call(message, "includeWearables"))
                    writer.uint32(/* id 6, wireType 0 =*/48).bool(message.includeWearables);
                if (message.offsetPosition != null && Object.hasOwnProperty.call(message, "offsetPosition"))
                    $root.CMsgVector.encode(message.offsetPosition, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
                if (message.offsetAngles != null && Object.hasOwnProperty.call(message, "offsetAngles"))
                    $root.CMsgQAngle.encode(message.offsetAngles, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
                return writer;
            };
    
            /**
             * Encodes the specified UpdateParticleEnt message, length delimited. Does not implicitly {@link CUserMsg_ParticleManager.UpdateParticleEnt.verify|verify} messages.
             * @function encodeDelimited
             * @memberof CUserMsg_ParticleManager.UpdateParticleEnt
             * @static
             * @param {CUserMsg_ParticleManager.IUpdateParticleEnt} message UpdateParticleEnt message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            UpdateParticleEnt.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes an UpdateParticleEnt message from the specified reader or buffer.
             * @function decode
             * @memberof CUserMsg_ParticleManager.UpdateParticleEnt
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {CUserMsg_ParticleManager.UpdateParticleEnt} UpdateParticleEnt
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            UpdateParticleEnt.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CUserMsg_ParticleManager.UpdateParticleEnt();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.controlPoint = reader.int32();
                            break;
                        }
                    case 2: {
                            message.entityHandle = reader.uint32();
                            break;
                        }
                    case 3: {
                            message.attachType = reader.int32();
                            break;
                        }
                    case 4: {
                            message.attachment = reader.int32();
                            break;
                        }
                    case 5: {
                            message.fallbackPosition = $root.CMsgVector.decode(reader, reader.uint32());
                            break;
                        }
                    case 6: {
                            message.includeWearables = reader.bool();
                            break;
                        }
                    case 7: {
                            message.offsetPosition = $root.CMsgVector.decode(reader, reader.uint32());
                            break;
                        }
                    case 8: {
                            message.offsetAngles = $root.CMsgQAngle.decode(reader, reader.uint32());
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes an UpdateParticleEnt message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof CUserMsg_ParticleManager.UpdateParticleEnt
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {CUserMsg_ParticleManager.UpdateParticleEnt} UpdateParticleEnt
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            UpdateParticleEnt.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies an UpdateParticleEnt message.
             * @function verify
             * @memberof CUserMsg_ParticleManager.UpdateParticleEnt
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            UpdateParticleEnt.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.controlPoint != null && message.hasOwnProperty("controlPoint"))
                    if (!$util.isInteger(message.controlPoint))
                        return "controlPoint: integer expected";
                if (message.entityHandle != null && message.hasOwnProperty("entityHandle"))
                    if (!$util.isInteger(message.entityHandle))
                        return "entityHandle: integer expected";
                if (message.attachType != null && message.hasOwnProperty("attachType"))
                    if (!$util.isInteger(message.attachType))
                        return "attachType: integer expected";
                if (message.attachment != null && message.hasOwnProperty("attachment"))
                    if (!$util.isInteger(message.attachment))
                        return "attachment: integer expected";
                if (message.fallbackPosition != null && message.hasOwnProperty("fallbackPosition")) {
                    var error = $root.CMsgVector.verify(message.fallbackPosition);
                    if (error)
                        return "fallbackPosition." + error;
                }
                if (message.includeWearables != null && message.hasOwnProperty("includeWearables"))
                    if (typeof message.includeWearables !== "boolean")
                        return "includeWearables: boolean expected";
                if (message.offsetPosition != null && message.hasOwnProperty("offsetPosition")) {
                    var error = $root.CMsgVector.verify(message.offsetPosition);
                    if (error)
                        return "offsetPosition." + error;
                }
                if (message.offsetAngles != null && message.hasOwnProperty("offsetAngles")) {
                    var error = $root.CMsgQAngle.verify(message.offsetAngles);
                    if (error)
                        return "offsetAngles." + error;
                }
                return null;
            };
    
            /**
             * Creates an UpdateParticleEnt message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof CUserMsg_ParticleManager.UpdateParticleEnt
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {CUserMsg_ParticleManager.UpdateParticleEnt} UpdateParticleEnt
             */
            UpdateParticleEnt.fromObject = function fromObject(object) {
                if (object instanceof $root.CUserMsg_ParticleManager.UpdateParticleEnt)
                    return object;
                var message = new $root.CUserMsg_ParticleManager.UpdateParticleEnt();
                if (object.controlPoint != null)
                    message.controlPoint = object.controlPoint | 0;
                if (object.entityHandle != null)
                    message.entityHandle = object.entityHandle >>> 0;
                if (object.attachType != null)
                    message.attachType = object.attachType | 0;
                if (object.attachment != null)
                    message.attachment = object.attachment | 0;
                if (object.fallbackPosition != null) {
                    if (typeof object.fallbackPosition !== "object")
                        throw TypeError(".CUserMsg_ParticleManager.UpdateParticleEnt.fallbackPosition: object expected");
                    message.fallbackPosition = $root.CMsgVector.fromObject(object.fallbackPosition);
                }
                if (object.includeWearables != null)
                    message.includeWearables = Boolean(object.includeWearables);
                if (object.offsetPosition != null) {
                    if (typeof object.offsetPosition !== "object")
                        throw TypeError(".CUserMsg_ParticleManager.UpdateParticleEnt.offsetPosition: object expected");
                    message.offsetPosition = $root.CMsgVector.fromObject(object.offsetPosition);
                }
                if (object.offsetAngles != null) {
                    if (typeof object.offsetAngles !== "object")
                        throw TypeError(".CUserMsg_ParticleManager.UpdateParticleEnt.offsetAngles: object expected");
                    message.offsetAngles = $root.CMsgQAngle.fromObject(object.offsetAngles);
                }
                return message;
            };
    
            /**
             * Creates a plain object from an UpdateParticleEnt message. Also converts values to other types if specified.
             * @function toObject
             * @memberof CUserMsg_ParticleManager.UpdateParticleEnt
             * @static
             * @param {CUserMsg_ParticleManager.UpdateParticleEnt} message UpdateParticleEnt
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            UpdateParticleEnt.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.controlPoint = 0;
                    object.entityHandle = 16777215;
                    object.attachType = 0;
                    object.attachment = 0;
                    object.fallbackPosition = null;
                    object.includeWearables = false;
                    object.offsetPosition = null;
                    object.offsetAngles = null;
                }
                if (message.controlPoint != null && message.hasOwnProperty("controlPoint"))
                    object.controlPoint = message.controlPoint;
                if (message.entityHandle != null && message.hasOwnProperty("entityHandle"))
                    object.entityHandle = message.entityHandle;
                if (message.attachType != null && message.hasOwnProperty("attachType"))
                    object.attachType = message.attachType;
                if (message.attachment != null && message.hasOwnProperty("attachment"))
                    object.attachment = message.attachment;
                if (message.fallbackPosition != null && message.hasOwnProperty("fallbackPosition"))
                    object.fallbackPosition = $root.CMsgVector.toObject(message.fallbackPosition, options);
                if (message.includeWearables != null && message.hasOwnProperty("includeWearables"))
                    object.includeWearables = message.includeWearables;
                if (message.offsetPosition != null && message.hasOwnProperty("offsetPosition"))
                    object.offsetPosition = $root.CMsgVector.toObject(message.offsetPosition, options);
                if (message.offsetAngles != null && message.hasOwnProperty("offsetAngles"))
                    object.offsetAngles = $root.CMsgQAngle.toObject(message.offsetAngles, options);
                return object;
            };
    
            /**
             * Converts this UpdateParticleEnt to JSON.
             * @function toJSON
             * @memberof CUserMsg_ParticleManager.UpdateParticleEnt
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            UpdateParticleEnt.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            /**
             * Gets the default type url for UpdateParticleEnt
             * @function getTypeUrl
             * @memberof CUserMsg_ParticleManager.UpdateParticleEnt
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            UpdateParticleEnt.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/CUserMsg_ParticleManager.UpdateParticleEnt";
            };
    
            return UpdateParticleEnt;
        })();
    
        CUserMsg_ParticleManager.UpdateParticleSetFrozen = (function() {
    
            /**
             * Properties of an UpdateParticleSetFrozen.
             * @memberof CUserMsg_ParticleManager
             * @interface IUpdateParticleSetFrozen
             * @property {boolean|null} [setFrozen] UpdateParticleSetFrozen setFrozen
             * @property {number|null} [transitionDuration] UpdateParticleSetFrozen transitionDuration
             */
    
            /**
             * Constructs a new UpdateParticleSetFrozen.
             * @memberof CUserMsg_ParticleManager
             * @classdesc Represents an UpdateParticleSetFrozen.
             * @implements IUpdateParticleSetFrozen
             * @constructor
             * @param {CUserMsg_ParticleManager.IUpdateParticleSetFrozen=} [properties] Properties to set
             */
            function UpdateParticleSetFrozen(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * UpdateParticleSetFrozen setFrozen.
             * @member {boolean} setFrozen
             * @memberof CUserMsg_ParticleManager.UpdateParticleSetFrozen
             * @instance
             */
            UpdateParticleSetFrozen.prototype.setFrozen = false;
    
            /**
             * UpdateParticleSetFrozen transitionDuration.
             * @member {number} transitionDuration
             * @memberof CUserMsg_ParticleManager.UpdateParticleSetFrozen
             * @instance
             */
            UpdateParticleSetFrozen.prototype.transitionDuration = 0;
    
            /**
             * Creates a new UpdateParticleSetFrozen instance using the specified properties.
             * @function create
             * @memberof CUserMsg_ParticleManager.UpdateParticleSetFrozen
             * @static
             * @param {CUserMsg_ParticleManager.IUpdateParticleSetFrozen=} [properties] Properties to set
             * @returns {CUserMsg_ParticleManager.UpdateParticleSetFrozen} UpdateParticleSetFrozen instance
             */
            UpdateParticleSetFrozen.create = function create(properties) {
                return new UpdateParticleSetFrozen(properties);
            };
    
            /**
             * Encodes the specified UpdateParticleSetFrozen message. Does not implicitly {@link CUserMsg_ParticleManager.UpdateParticleSetFrozen.verify|verify} messages.
             * @function encode
             * @memberof CUserMsg_ParticleManager.UpdateParticleSetFrozen
             * @static
             * @param {CUserMsg_ParticleManager.IUpdateParticleSetFrozen} message UpdateParticleSetFrozen message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            UpdateParticleSetFrozen.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.setFrozen != null && Object.hasOwnProperty.call(message, "setFrozen"))
                    writer.uint32(/* id 1, wireType 0 =*/8).bool(message.setFrozen);
                if (message.transitionDuration != null && Object.hasOwnProperty.call(message, "transitionDuration"))
                    writer.uint32(/* id 2, wireType 5 =*/21).float(message.transitionDuration);
                return writer;
            };
    
            /**
             * Encodes the specified UpdateParticleSetFrozen message, length delimited. Does not implicitly {@link CUserMsg_ParticleManager.UpdateParticleSetFrozen.verify|verify} messages.
             * @function encodeDelimited
             * @memberof CUserMsg_ParticleManager.UpdateParticleSetFrozen
             * @static
             * @param {CUserMsg_ParticleManager.IUpdateParticleSetFrozen} message UpdateParticleSetFrozen message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            UpdateParticleSetFrozen.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes an UpdateParticleSetFrozen message from the specified reader or buffer.
             * @function decode
             * @memberof CUserMsg_ParticleManager.UpdateParticleSetFrozen
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {CUserMsg_ParticleManager.UpdateParticleSetFrozen} UpdateParticleSetFrozen
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            UpdateParticleSetFrozen.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CUserMsg_ParticleManager.UpdateParticleSetFrozen();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.setFrozen = reader.bool();
                            break;
                        }
                    case 2: {
                            message.transitionDuration = reader.float();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes an UpdateParticleSetFrozen message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof CUserMsg_ParticleManager.UpdateParticleSetFrozen
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {CUserMsg_ParticleManager.UpdateParticleSetFrozen} UpdateParticleSetFrozen
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            UpdateParticleSetFrozen.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies an UpdateParticleSetFrozen message.
             * @function verify
             * @memberof CUserMsg_ParticleManager.UpdateParticleSetFrozen
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            UpdateParticleSetFrozen.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.setFrozen != null && message.hasOwnProperty("setFrozen"))
                    if (typeof message.setFrozen !== "boolean")
                        return "setFrozen: boolean expected";
                if (message.transitionDuration != null && message.hasOwnProperty("transitionDuration"))
                    if (typeof message.transitionDuration !== "number")
                        return "transitionDuration: number expected";
                return null;
            };
    
            /**
             * Creates an UpdateParticleSetFrozen message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof CUserMsg_ParticleManager.UpdateParticleSetFrozen
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {CUserMsg_ParticleManager.UpdateParticleSetFrozen} UpdateParticleSetFrozen
             */
            UpdateParticleSetFrozen.fromObject = function fromObject(object) {
                if (object instanceof $root.CUserMsg_ParticleManager.UpdateParticleSetFrozen)
                    return object;
                var message = new $root.CUserMsg_ParticleManager.UpdateParticleSetFrozen();
                if (object.setFrozen != null)
                    message.setFrozen = Boolean(object.setFrozen);
                if (object.transitionDuration != null)
                    message.transitionDuration = Number(object.transitionDuration);
                return message;
            };
    
            /**
             * Creates a plain object from an UpdateParticleSetFrozen message. Also converts values to other types if specified.
             * @function toObject
             * @memberof CUserMsg_ParticleManager.UpdateParticleSetFrozen
             * @static
             * @param {CUserMsg_ParticleManager.UpdateParticleSetFrozen} message UpdateParticleSetFrozen
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            UpdateParticleSetFrozen.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.setFrozen = false;
                    object.transitionDuration = 0;
                }
                if (message.setFrozen != null && message.hasOwnProperty("setFrozen"))
                    object.setFrozen = message.setFrozen;
                if (message.transitionDuration != null && message.hasOwnProperty("transitionDuration"))
                    object.transitionDuration = options.json && !isFinite(message.transitionDuration) ? String(message.transitionDuration) : message.transitionDuration;
                return object;
            };
    
            /**
             * Converts this UpdateParticleSetFrozen to JSON.
             * @function toJSON
             * @memberof CUserMsg_ParticleManager.UpdateParticleSetFrozen
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            UpdateParticleSetFrozen.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            /**
             * Gets the default type url for UpdateParticleSetFrozen
             * @function getTypeUrl
             * @memberof CUserMsg_ParticleManager.UpdateParticleSetFrozen
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            UpdateParticleSetFrozen.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/CUserMsg_ParticleManager.UpdateParticleSetFrozen";
            };
    
            return UpdateParticleSetFrozen;
        })();
    
        CUserMsg_ParticleManager.UpdateParticleShouldDraw = (function() {
    
            /**
             * Properties of an UpdateParticleShouldDraw.
             * @memberof CUserMsg_ParticleManager
             * @interface IUpdateParticleShouldDraw
             * @property {boolean|null} [shouldDraw] UpdateParticleShouldDraw shouldDraw
             */
    
            /**
             * Constructs a new UpdateParticleShouldDraw.
             * @memberof CUserMsg_ParticleManager
             * @classdesc Represents an UpdateParticleShouldDraw.
             * @implements IUpdateParticleShouldDraw
             * @constructor
             * @param {CUserMsg_ParticleManager.IUpdateParticleShouldDraw=} [properties] Properties to set
             */
            function UpdateParticleShouldDraw(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * UpdateParticleShouldDraw shouldDraw.
             * @member {boolean} shouldDraw
             * @memberof CUserMsg_ParticleManager.UpdateParticleShouldDraw
             * @instance
             */
            UpdateParticleShouldDraw.prototype.shouldDraw = false;
    
            /**
             * Creates a new UpdateParticleShouldDraw instance using the specified properties.
             * @function create
             * @memberof CUserMsg_ParticleManager.UpdateParticleShouldDraw
             * @static
             * @param {CUserMsg_ParticleManager.IUpdateParticleShouldDraw=} [properties] Properties to set
             * @returns {CUserMsg_ParticleManager.UpdateParticleShouldDraw} UpdateParticleShouldDraw instance
             */
            UpdateParticleShouldDraw.create = function create(properties) {
                return new UpdateParticleShouldDraw(properties);
            };
    
            /**
             * Encodes the specified UpdateParticleShouldDraw message. Does not implicitly {@link CUserMsg_ParticleManager.UpdateParticleShouldDraw.verify|verify} messages.
             * @function encode
             * @memberof CUserMsg_ParticleManager.UpdateParticleShouldDraw
             * @static
             * @param {CUserMsg_ParticleManager.IUpdateParticleShouldDraw} message UpdateParticleShouldDraw message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            UpdateParticleShouldDraw.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.shouldDraw != null && Object.hasOwnProperty.call(message, "shouldDraw"))
                    writer.uint32(/* id 1, wireType 0 =*/8).bool(message.shouldDraw);
                return writer;
            };
    
            /**
             * Encodes the specified UpdateParticleShouldDraw message, length delimited. Does not implicitly {@link CUserMsg_ParticleManager.UpdateParticleShouldDraw.verify|verify} messages.
             * @function encodeDelimited
             * @memberof CUserMsg_ParticleManager.UpdateParticleShouldDraw
             * @static
             * @param {CUserMsg_ParticleManager.IUpdateParticleShouldDraw} message UpdateParticleShouldDraw message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            UpdateParticleShouldDraw.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes an UpdateParticleShouldDraw message from the specified reader or buffer.
             * @function decode
             * @memberof CUserMsg_ParticleManager.UpdateParticleShouldDraw
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {CUserMsg_ParticleManager.UpdateParticleShouldDraw} UpdateParticleShouldDraw
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            UpdateParticleShouldDraw.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CUserMsg_ParticleManager.UpdateParticleShouldDraw();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.shouldDraw = reader.bool();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes an UpdateParticleShouldDraw message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof CUserMsg_ParticleManager.UpdateParticleShouldDraw
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {CUserMsg_ParticleManager.UpdateParticleShouldDraw} UpdateParticleShouldDraw
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            UpdateParticleShouldDraw.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies an UpdateParticleShouldDraw message.
             * @function verify
             * @memberof CUserMsg_ParticleManager.UpdateParticleShouldDraw
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            UpdateParticleShouldDraw.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.shouldDraw != null && message.hasOwnProperty("shouldDraw"))
                    if (typeof message.shouldDraw !== "boolean")
                        return "shouldDraw: boolean expected";
                return null;
            };
    
            /**
             * Creates an UpdateParticleShouldDraw message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof CUserMsg_ParticleManager.UpdateParticleShouldDraw
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {CUserMsg_ParticleManager.UpdateParticleShouldDraw} UpdateParticleShouldDraw
             */
            UpdateParticleShouldDraw.fromObject = function fromObject(object) {
                if (object instanceof $root.CUserMsg_ParticleManager.UpdateParticleShouldDraw)
                    return object;
                var message = new $root.CUserMsg_ParticleManager.UpdateParticleShouldDraw();
                if (object.shouldDraw != null)
                    message.shouldDraw = Boolean(object.shouldDraw);
                return message;
            };
    
            /**
             * Creates a plain object from an UpdateParticleShouldDraw message. Also converts values to other types if specified.
             * @function toObject
             * @memberof CUserMsg_ParticleManager.UpdateParticleShouldDraw
             * @static
             * @param {CUserMsg_ParticleManager.UpdateParticleShouldDraw} message UpdateParticleShouldDraw
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            UpdateParticleShouldDraw.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.shouldDraw = false;
                if (message.shouldDraw != null && message.hasOwnProperty("shouldDraw"))
                    object.shouldDraw = message.shouldDraw;
                return object;
            };
    
            /**
             * Converts this UpdateParticleShouldDraw to JSON.
             * @function toJSON
             * @memberof CUserMsg_ParticleManager.UpdateParticleShouldDraw
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            UpdateParticleShouldDraw.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            /**
             * Gets the default type url for UpdateParticleShouldDraw
             * @function getTypeUrl
             * @memberof CUserMsg_ParticleManager.UpdateParticleShouldDraw
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            UpdateParticleShouldDraw.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/CUserMsg_ParticleManager.UpdateParticleShouldDraw";
            };
    
            return UpdateParticleShouldDraw;
        })();
    
        CUserMsg_ParticleManager.ChangeControlPointAttachment = (function() {
    
            /**
             * Properties of a ChangeControlPointAttachment.
             * @memberof CUserMsg_ParticleManager
             * @interface IChangeControlPointAttachment
             * @property {number|null} [attachmentOld] ChangeControlPointAttachment attachmentOld
             * @property {number|null} [attachmentNew] ChangeControlPointAttachment attachmentNew
             * @property {number|null} [entityHandle] ChangeControlPointAttachment entityHandle
             */
    
            /**
             * Constructs a new ChangeControlPointAttachment.
             * @memberof CUserMsg_ParticleManager
             * @classdesc Represents a ChangeControlPointAttachment.
             * @implements IChangeControlPointAttachment
             * @constructor
             * @param {CUserMsg_ParticleManager.IChangeControlPointAttachment=} [properties] Properties to set
             */
            function ChangeControlPointAttachment(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * ChangeControlPointAttachment attachmentOld.
             * @member {number} attachmentOld
             * @memberof CUserMsg_ParticleManager.ChangeControlPointAttachment
             * @instance
             */
            ChangeControlPointAttachment.prototype.attachmentOld = 0;
    
            /**
             * ChangeControlPointAttachment attachmentNew.
             * @member {number} attachmentNew
             * @memberof CUserMsg_ParticleManager.ChangeControlPointAttachment
             * @instance
             */
            ChangeControlPointAttachment.prototype.attachmentNew = 0;
    
            /**
             * ChangeControlPointAttachment entityHandle.
             * @member {number} entityHandle
             * @memberof CUserMsg_ParticleManager.ChangeControlPointAttachment
             * @instance
             */
            ChangeControlPointAttachment.prototype.entityHandle = 16777215;
    
            /**
             * Creates a new ChangeControlPointAttachment instance using the specified properties.
             * @function create
             * @memberof CUserMsg_ParticleManager.ChangeControlPointAttachment
             * @static
             * @param {CUserMsg_ParticleManager.IChangeControlPointAttachment=} [properties] Properties to set
             * @returns {CUserMsg_ParticleManager.ChangeControlPointAttachment} ChangeControlPointAttachment instance
             */
            ChangeControlPointAttachment.create = function create(properties) {
                return new ChangeControlPointAttachment(properties);
            };
    
            /**
             * Encodes the specified ChangeControlPointAttachment message. Does not implicitly {@link CUserMsg_ParticleManager.ChangeControlPointAttachment.verify|verify} messages.
             * @function encode
             * @memberof CUserMsg_ParticleManager.ChangeControlPointAttachment
             * @static
             * @param {CUserMsg_ParticleManager.IChangeControlPointAttachment} message ChangeControlPointAttachment message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ChangeControlPointAttachment.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.attachmentOld != null && Object.hasOwnProperty.call(message, "attachmentOld"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.attachmentOld);
                if (message.attachmentNew != null && Object.hasOwnProperty.call(message, "attachmentNew"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.attachmentNew);
                if (message.entityHandle != null && Object.hasOwnProperty.call(message, "entityHandle"))
                    writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.entityHandle);
                return writer;
            };
    
            /**
             * Encodes the specified ChangeControlPointAttachment message, length delimited. Does not implicitly {@link CUserMsg_ParticleManager.ChangeControlPointAttachment.verify|verify} messages.
             * @function encodeDelimited
             * @memberof CUserMsg_ParticleManager.ChangeControlPointAttachment
             * @static
             * @param {CUserMsg_ParticleManager.IChangeControlPointAttachment} message ChangeControlPointAttachment message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ChangeControlPointAttachment.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a ChangeControlPointAttachment message from the specified reader or buffer.
             * @function decode
             * @memberof CUserMsg_ParticleManager.ChangeControlPointAttachment
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {CUserMsg_ParticleManager.ChangeControlPointAttachment} ChangeControlPointAttachment
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ChangeControlPointAttachment.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CUserMsg_ParticleManager.ChangeControlPointAttachment();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.attachmentOld = reader.int32();
                            break;
                        }
                    case 2: {
                            message.attachmentNew = reader.int32();
                            break;
                        }
                    case 3: {
                            message.entityHandle = reader.uint32();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a ChangeControlPointAttachment message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof CUserMsg_ParticleManager.ChangeControlPointAttachment
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {CUserMsg_ParticleManager.ChangeControlPointAttachment} ChangeControlPointAttachment
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ChangeControlPointAttachment.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a ChangeControlPointAttachment message.
             * @function verify
             * @memberof CUserMsg_ParticleManager.ChangeControlPointAttachment
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ChangeControlPointAttachment.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.attachmentOld != null && message.hasOwnProperty("attachmentOld"))
                    if (!$util.isInteger(message.attachmentOld))
                        return "attachmentOld: integer expected";
                if (message.attachmentNew != null && message.hasOwnProperty("attachmentNew"))
                    if (!$util.isInteger(message.attachmentNew))
                        return "attachmentNew: integer expected";
                if (message.entityHandle != null && message.hasOwnProperty("entityHandle"))
                    if (!$util.isInteger(message.entityHandle))
                        return "entityHandle: integer expected";
                return null;
            };
    
            /**
             * Creates a ChangeControlPointAttachment message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof CUserMsg_ParticleManager.ChangeControlPointAttachment
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {CUserMsg_ParticleManager.ChangeControlPointAttachment} ChangeControlPointAttachment
             */
            ChangeControlPointAttachment.fromObject = function fromObject(object) {
                if (object instanceof $root.CUserMsg_ParticleManager.ChangeControlPointAttachment)
                    return object;
                var message = new $root.CUserMsg_ParticleManager.ChangeControlPointAttachment();
                if (object.attachmentOld != null)
                    message.attachmentOld = object.attachmentOld | 0;
                if (object.attachmentNew != null)
                    message.attachmentNew = object.attachmentNew | 0;
                if (object.entityHandle != null)
                    message.entityHandle = object.entityHandle >>> 0;
                return message;
            };
    
            /**
             * Creates a plain object from a ChangeControlPointAttachment message. Also converts values to other types if specified.
             * @function toObject
             * @memberof CUserMsg_ParticleManager.ChangeControlPointAttachment
             * @static
             * @param {CUserMsg_ParticleManager.ChangeControlPointAttachment} message ChangeControlPointAttachment
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ChangeControlPointAttachment.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.attachmentOld = 0;
                    object.attachmentNew = 0;
                    object.entityHandle = 16777215;
                }
                if (message.attachmentOld != null && message.hasOwnProperty("attachmentOld"))
                    object.attachmentOld = message.attachmentOld;
                if (message.attachmentNew != null && message.hasOwnProperty("attachmentNew"))
                    object.attachmentNew = message.attachmentNew;
                if (message.entityHandle != null && message.hasOwnProperty("entityHandle"))
                    object.entityHandle = message.entityHandle;
                return object;
            };
    
            /**
             * Converts this ChangeControlPointAttachment to JSON.
             * @function toJSON
             * @memberof CUserMsg_ParticleManager.ChangeControlPointAttachment
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ChangeControlPointAttachment.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            /**
             * Gets the default type url for ChangeControlPointAttachment
             * @function getTypeUrl
             * @memberof CUserMsg_ParticleManager.ChangeControlPointAttachment
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            ChangeControlPointAttachment.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/CUserMsg_ParticleManager.ChangeControlPointAttachment";
            };
    
            return ChangeControlPointAttachment;
        })();
    
        CUserMsg_ParticleManager.UpdateEntityPosition = (function() {
    
            /**
             * Properties of an UpdateEntityPosition.
             * @memberof CUserMsg_ParticleManager
             * @interface IUpdateEntityPosition
             * @property {number|null} [entityHandle] UpdateEntityPosition entityHandle
             * @property {ICMsgVector|null} [position] UpdateEntityPosition position
             */
    
            /**
             * Constructs a new UpdateEntityPosition.
             * @memberof CUserMsg_ParticleManager
             * @classdesc Represents an UpdateEntityPosition.
             * @implements IUpdateEntityPosition
             * @constructor
             * @param {CUserMsg_ParticleManager.IUpdateEntityPosition=} [properties] Properties to set
             */
            function UpdateEntityPosition(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * UpdateEntityPosition entityHandle.
             * @member {number} entityHandle
             * @memberof CUserMsg_ParticleManager.UpdateEntityPosition
             * @instance
             */
            UpdateEntityPosition.prototype.entityHandle = 16777215;
    
            /**
             * UpdateEntityPosition position.
             * @member {ICMsgVector|null|undefined} position
             * @memberof CUserMsg_ParticleManager.UpdateEntityPosition
             * @instance
             */
            UpdateEntityPosition.prototype.position = null;
    
            /**
             * Creates a new UpdateEntityPosition instance using the specified properties.
             * @function create
             * @memberof CUserMsg_ParticleManager.UpdateEntityPosition
             * @static
             * @param {CUserMsg_ParticleManager.IUpdateEntityPosition=} [properties] Properties to set
             * @returns {CUserMsg_ParticleManager.UpdateEntityPosition} UpdateEntityPosition instance
             */
            UpdateEntityPosition.create = function create(properties) {
                return new UpdateEntityPosition(properties);
            };
    
            /**
             * Encodes the specified UpdateEntityPosition message. Does not implicitly {@link CUserMsg_ParticleManager.UpdateEntityPosition.verify|verify} messages.
             * @function encode
             * @memberof CUserMsg_ParticleManager.UpdateEntityPosition
             * @static
             * @param {CUserMsg_ParticleManager.IUpdateEntityPosition} message UpdateEntityPosition message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            UpdateEntityPosition.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.entityHandle != null && Object.hasOwnProperty.call(message, "entityHandle"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.entityHandle);
                if (message.position != null && Object.hasOwnProperty.call(message, "position"))
                    $root.CMsgVector.encode(message.position, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };
    
            /**
             * Encodes the specified UpdateEntityPosition message, length delimited. Does not implicitly {@link CUserMsg_ParticleManager.UpdateEntityPosition.verify|verify} messages.
             * @function encodeDelimited
             * @memberof CUserMsg_ParticleManager.UpdateEntityPosition
             * @static
             * @param {CUserMsg_ParticleManager.IUpdateEntityPosition} message UpdateEntityPosition message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            UpdateEntityPosition.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes an UpdateEntityPosition message from the specified reader or buffer.
             * @function decode
             * @memberof CUserMsg_ParticleManager.UpdateEntityPosition
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {CUserMsg_ParticleManager.UpdateEntityPosition} UpdateEntityPosition
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            UpdateEntityPosition.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CUserMsg_ParticleManager.UpdateEntityPosition();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.entityHandle = reader.uint32();
                            break;
                        }
                    case 2: {
                            message.position = $root.CMsgVector.decode(reader, reader.uint32());
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes an UpdateEntityPosition message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof CUserMsg_ParticleManager.UpdateEntityPosition
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {CUserMsg_ParticleManager.UpdateEntityPosition} UpdateEntityPosition
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            UpdateEntityPosition.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies an UpdateEntityPosition message.
             * @function verify
             * @memberof CUserMsg_ParticleManager.UpdateEntityPosition
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            UpdateEntityPosition.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.entityHandle != null && message.hasOwnProperty("entityHandle"))
                    if (!$util.isInteger(message.entityHandle))
                        return "entityHandle: integer expected";
                if (message.position != null && message.hasOwnProperty("position")) {
                    var error = $root.CMsgVector.verify(message.position);
                    if (error)
                        return "position." + error;
                }
                return null;
            };
    
            /**
             * Creates an UpdateEntityPosition message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof CUserMsg_ParticleManager.UpdateEntityPosition
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {CUserMsg_ParticleManager.UpdateEntityPosition} UpdateEntityPosition
             */
            UpdateEntityPosition.fromObject = function fromObject(object) {
                if (object instanceof $root.CUserMsg_ParticleManager.UpdateEntityPosition)
                    return object;
                var message = new $root.CUserMsg_ParticleManager.UpdateEntityPosition();
                if (object.entityHandle != null)
                    message.entityHandle = object.entityHandle >>> 0;
                if (object.position != null) {
                    if (typeof object.position !== "object")
                        throw TypeError(".CUserMsg_ParticleManager.UpdateEntityPosition.position: object expected");
                    message.position = $root.CMsgVector.fromObject(object.position);
                }
                return message;
            };
    
            /**
             * Creates a plain object from an UpdateEntityPosition message. Also converts values to other types if specified.
             * @function toObject
             * @memberof CUserMsg_ParticleManager.UpdateEntityPosition
             * @static
             * @param {CUserMsg_ParticleManager.UpdateEntityPosition} message UpdateEntityPosition
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            UpdateEntityPosition.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.entityHandle = 16777215;
                    object.position = null;
                }
                if (message.entityHandle != null && message.hasOwnProperty("entityHandle"))
                    object.entityHandle = message.entityHandle;
                if (message.position != null && message.hasOwnProperty("position"))
                    object.position = $root.CMsgVector.toObject(message.position, options);
                return object;
            };
    
            /**
             * Converts this UpdateEntityPosition to JSON.
             * @function toJSON
             * @memberof CUserMsg_ParticleManager.UpdateEntityPosition
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            UpdateEntityPosition.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            /**
             * Gets the default type url for UpdateEntityPosition
             * @function getTypeUrl
             * @memberof CUserMsg_ParticleManager.UpdateEntityPosition
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            UpdateEntityPosition.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/CUserMsg_ParticleManager.UpdateEntityPosition";
            };
    
            return UpdateEntityPosition;
        })();
    
        CUserMsg_ParticleManager.SetParticleFoWProperties = (function() {
    
            /**
             * Properties of a SetParticleFoWProperties.
             * @memberof CUserMsg_ParticleManager
             * @interface ISetParticleFoWProperties
             * @property {number|null} [fowControlPoint] SetParticleFoWProperties fowControlPoint
             * @property {number|null} [fowControlPoint2] SetParticleFoWProperties fowControlPoint2
             * @property {number|null} [fowRadius] SetParticleFoWProperties fowRadius
             */
    
            /**
             * Constructs a new SetParticleFoWProperties.
             * @memberof CUserMsg_ParticleManager
             * @classdesc Represents a SetParticleFoWProperties.
             * @implements ISetParticleFoWProperties
             * @constructor
             * @param {CUserMsg_ParticleManager.ISetParticleFoWProperties=} [properties] Properties to set
             */
            function SetParticleFoWProperties(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * SetParticleFoWProperties fowControlPoint.
             * @member {number} fowControlPoint
             * @memberof CUserMsg_ParticleManager.SetParticleFoWProperties
             * @instance
             */
            SetParticleFoWProperties.prototype.fowControlPoint = 0;
    
            /**
             * SetParticleFoWProperties fowControlPoint2.
             * @member {number} fowControlPoint2
             * @memberof CUserMsg_ParticleManager.SetParticleFoWProperties
             * @instance
             */
            SetParticleFoWProperties.prototype.fowControlPoint2 = 0;
    
            /**
             * SetParticleFoWProperties fowRadius.
             * @member {number} fowRadius
             * @memberof CUserMsg_ParticleManager.SetParticleFoWProperties
             * @instance
             */
            SetParticleFoWProperties.prototype.fowRadius = 0;
    
            /**
             * Creates a new SetParticleFoWProperties instance using the specified properties.
             * @function create
             * @memberof CUserMsg_ParticleManager.SetParticleFoWProperties
             * @static
             * @param {CUserMsg_ParticleManager.ISetParticleFoWProperties=} [properties] Properties to set
             * @returns {CUserMsg_ParticleManager.SetParticleFoWProperties} SetParticleFoWProperties instance
             */
            SetParticleFoWProperties.create = function create(properties) {
                return new SetParticleFoWProperties(properties);
            };
    
            /**
             * Encodes the specified SetParticleFoWProperties message. Does not implicitly {@link CUserMsg_ParticleManager.SetParticleFoWProperties.verify|verify} messages.
             * @function encode
             * @memberof CUserMsg_ParticleManager.SetParticleFoWProperties
             * @static
             * @param {CUserMsg_ParticleManager.ISetParticleFoWProperties} message SetParticleFoWProperties message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SetParticleFoWProperties.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.fowControlPoint != null && Object.hasOwnProperty.call(message, "fowControlPoint"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.fowControlPoint);
                if (message.fowControlPoint2 != null && Object.hasOwnProperty.call(message, "fowControlPoint2"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.fowControlPoint2);
                if (message.fowRadius != null && Object.hasOwnProperty.call(message, "fowRadius"))
                    writer.uint32(/* id 3, wireType 5 =*/29).float(message.fowRadius);
                return writer;
            };
    
            /**
             * Encodes the specified SetParticleFoWProperties message, length delimited. Does not implicitly {@link CUserMsg_ParticleManager.SetParticleFoWProperties.verify|verify} messages.
             * @function encodeDelimited
             * @memberof CUserMsg_ParticleManager.SetParticleFoWProperties
             * @static
             * @param {CUserMsg_ParticleManager.ISetParticleFoWProperties} message SetParticleFoWProperties message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SetParticleFoWProperties.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a SetParticleFoWProperties message from the specified reader or buffer.
             * @function decode
             * @memberof CUserMsg_ParticleManager.SetParticleFoWProperties
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {CUserMsg_ParticleManager.SetParticleFoWProperties} SetParticleFoWProperties
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SetParticleFoWProperties.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CUserMsg_ParticleManager.SetParticleFoWProperties();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.fowControlPoint = reader.int32();
                            break;
                        }
                    case 2: {
                            message.fowControlPoint2 = reader.int32();
                            break;
                        }
                    case 3: {
                            message.fowRadius = reader.float();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a SetParticleFoWProperties message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof CUserMsg_ParticleManager.SetParticleFoWProperties
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {CUserMsg_ParticleManager.SetParticleFoWProperties} SetParticleFoWProperties
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SetParticleFoWProperties.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a SetParticleFoWProperties message.
             * @function verify
             * @memberof CUserMsg_ParticleManager.SetParticleFoWProperties
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SetParticleFoWProperties.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.fowControlPoint != null && message.hasOwnProperty("fowControlPoint"))
                    if (!$util.isInteger(message.fowControlPoint))
                        return "fowControlPoint: integer expected";
                if (message.fowControlPoint2 != null && message.hasOwnProperty("fowControlPoint2"))
                    if (!$util.isInteger(message.fowControlPoint2))
                        return "fowControlPoint2: integer expected";
                if (message.fowRadius != null && message.hasOwnProperty("fowRadius"))
                    if (typeof message.fowRadius !== "number")
                        return "fowRadius: number expected";
                return null;
            };
    
            /**
             * Creates a SetParticleFoWProperties message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof CUserMsg_ParticleManager.SetParticleFoWProperties
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {CUserMsg_ParticleManager.SetParticleFoWProperties} SetParticleFoWProperties
             */
            SetParticleFoWProperties.fromObject = function fromObject(object) {
                if (object instanceof $root.CUserMsg_ParticleManager.SetParticleFoWProperties)
                    return object;
                var message = new $root.CUserMsg_ParticleManager.SetParticleFoWProperties();
                if (object.fowControlPoint != null)
                    message.fowControlPoint = object.fowControlPoint | 0;
                if (object.fowControlPoint2 != null)
                    message.fowControlPoint2 = object.fowControlPoint2 | 0;
                if (object.fowRadius != null)
                    message.fowRadius = Number(object.fowRadius);
                return message;
            };
    
            /**
             * Creates a plain object from a SetParticleFoWProperties message. Also converts values to other types if specified.
             * @function toObject
             * @memberof CUserMsg_ParticleManager.SetParticleFoWProperties
             * @static
             * @param {CUserMsg_ParticleManager.SetParticleFoWProperties} message SetParticleFoWProperties
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SetParticleFoWProperties.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.fowControlPoint = 0;
                    object.fowControlPoint2 = 0;
                    object.fowRadius = 0;
                }
                if (message.fowControlPoint != null && message.hasOwnProperty("fowControlPoint"))
                    object.fowControlPoint = message.fowControlPoint;
                if (message.fowControlPoint2 != null && message.hasOwnProperty("fowControlPoint2"))
                    object.fowControlPoint2 = message.fowControlPoint2;
                if (message.fowRadius != null && message.hasOwnProperty("fowRadius"))
                    object.fowRadius = options.json && !isFinite(message.fowRadius) ? String(message.fowRadius) : message.fowRadius;
                return object;
            };
    
            /**
             * Converts this SetParticleFoWProperties to JSON.
             * @function toJSON
             * @memberof CUserMsg_ParticleManager.SetParticleFoWProperties
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            SetParticleFoWProperties.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            /**
             * Gets the default type url for SetParticleFoWProperties
             * @function getTypeUrl
             * @memberof CUserMsg_ParticleManager.SetParticleFoWProperties
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            SetParticleFoWProperties.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/CUserMsg_ParticleManager.SetParticleFoWProperties";
            };
    
            return SetParticleFoWProperties;
        })();
    
        CUserMsg_ParticleManager.SetParticleShouldCheckFoW = (function() {
    
            /**
             * Properties of a SetParticleShouldCheckFoW.
             * @memberof CUserMsg_ParticleManager
             * @interface ISetParticleShouldCheckFoW
             * @property {boolean|null} [checkFow] SetParticleShouldCheckFoW checkFow
             */
    
            /**
             * Constructs a new SetParticleShouldCheckFoW.
             * @memberof CUserMsg_ParticleManager
             * @classdesc Represents a SetParticleShouldCheckFoW.
             * @implements ISetParticleShouldCheckFoW
             * @constructor
             * @param {CUserMsg_ParticleManager.ISetParticleShouldCheckFoW=} [properties] Properties to set
             */
            function SetParticleShouldCheckFoW(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * SetParticleShouldCheckFoW checkFow.
             * @member {boolean} checkFow
             * @memberof CUserMsg_ParticleManager.SetParticleShouldCheckFoW
             * @instance
             */
            SetParticleShouldCheckFoW.prototype.checkFow = false;
    
            /**
             * Creates a new SetParticleShouldCheckFoW instance using the specified properties.
             * @function create
             * @memberof CUserMsg_ParticleManager.SetParticleShouldCheckFoW
             * @static
             * @param {CUserMsg_ParticleManager.ISetParticleShouldCheckFoW=} [properties] Properties to set
             * @returns {CUserMsg_ParticleManager.SetParticleShouldCheckFoW} SetParticleShouldCheckFoW instance
             */
            SetParticleShouldCheckFoW.create = function create(properties) {
                return new SetParticleShouldCheckFoW(properties);
            };
    
            /**
             * Encodes the specified SetParticleShouldCheckFoW message. Does not implicitly {@link CUserMsg_ParticleManager.SetParticleShouldCheckFoW.verify|verify} messages.
             * @function encode
             * @memberof CUserMsg_ParticleManager.SetParticleShouldCheckFoW
             * @static
             * @param {CUserMsg_ParticleManager.ISetParticleShouldCheckFoW} message SetParticleShouldCheckFoW message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SetParticleShouldCheckFoW.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.checkFow != null && Object.hasOwnProperty.call(message, "checkFow"))
                    writer.uint32(/* id 1, wireType 0 =*/8).bool(message.checkFow);
                return writer;
            };
    
            /**
             * Encodes the specified SetParticleShouldCheckFoW message, length delimited. Does not implicitly {@link CUserMsg_ParticleManager.SetParticleShouldCheckFoW.verify|verify} messages.
             * @function encodeDelimited
             * @memberof CUserMsg_ParticleManager.SetParticleShouldCheckFoW
             * @static
             * @param {CUserMsg_ParticleManager.ISetParticleShouldCheckFoW} message SetParticleShouldCheckFoW message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SetParticleShouldCheckFoW.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a SetParticleShouldCheckFoW message from the specified reader or buffer.
             * @function decode
             * @memberof CUserMsg_ParticleManager.SetParticleShouldCheckFoW
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {CUserMsg_ParticleManager.SetParticleShouldCheckFoW} SetParticleShouldCheckFoW
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SetParticleShouldCheckFoW.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CUserMsg_ParticleManager.SetParticleShouldCheckFoW();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.checkFow = reader.bool();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a SetParticleShouldCheckFoW message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof CUserMsg_ParticleManager.SetParticleShouldCheckFoW
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {CUserMsg_ParticleManager.SetParticleShouldCheckFoW} SetParticleShouldCheckFoW
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SetParticleShouldCheckFoW.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a SetParticleShouldCheckFoW message.
             * @function verify
             * @memberof CUserMsg_ParticleManager.SetParticleShouldCheckFoW
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SetParticleShouldCheckFoW.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.checkFow != null && message.hasOwnProperty("checkFow"))
                    if (typeof message.checkFow !== "boolean")
                        return "checkFow: boolean expected";
                return null;
            };
    
            /**
             * Creates a SetParticleShouldCheckFoW message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof CUserMsg_ParticleManager.SetParticleShouldCheckFoW
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {CUserMsg_ParticleManager.SetParticleShouldCheckFoW} SetParticleShouldCheckFoW
             */
            SetParticleShouldCheckFoW.fromObject = function fromObject(object) {
                if (object instanceof $root.CUserMsg_ParticleManager.SetParticleShouldCheckFoW)
                    return object;
                var message = new $root.CUserMsg_ParticleManager.SetParticleShouldCheckFoW();
                if (object.checkFow != null)
                    message.checkFow = Boolean(object.checkFow);
                return message;
            };
    
            /**
             * Creates a plain object from a SetParticleShouldCheckFoW message. Also converts values to other types if specified.
             * @function toObject
             * @memberof CUserMsg_ParticleManager.SetParticleShouldCheckFoW
             * @static
             * @param {CUserMsg_ParticleManager.SetParticleShouldCheckFoW} message SetParticleShouldCheckFoW
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SetParticleShouldCheckFoW.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.checkFow = false;
                if (message.checkFow != null && message.hasOwnProperty("checkFow"))
                    object.checkFow = message.checkFow;
                return object;
            };
    
            /**
             * Converts this SetParticleShouldCheckFoW to JSON.
             * @function toJSON
             * @memberof CUserMsg_ParticleManager.SetParticleShouldCheckFoW
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            SetParticleShouldCheckFoW.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            /**
             * Gets the default type url for SetParticleShouldCheckFoW
             * @function getTypeUrl
             * @memberof CUserMsg_ParticleManager.SetParticleShouldCheckFoW
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            SetParticleShouldCheckFoW.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/CUserMsg_ParticleManager.SetParticleShouldCheckFoW";
            };
    
            return SetParticleShouldCheckFoW;
        })();
    
        CUserMsg_ParticleManager.SetControlPointModel = (function() {
    
            /**
             * Properties of a SetControlPointModel.
             * @memberof CUserMsg_ParticleManager
             * @interface ISetControlPointModel
             * @property {number|null} [controlPoint] SetControlPointModel controlPoint
             * @property {string|null} [modelName] SetControlPointModel modelName
             */
    
            /**
             * Constructs a new SetControlPointModel.
             * @memberof CUserMsg_ParticleManager
             * @classdesc Represents a SetControlPointModel.
             * @implements ISetControlPointModel
             * @constructor
             * @param {CUserMsg_ParticleManager.ISetControlPointModel=} [properties] Properties to set
             */
            function SetControlPointModel(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * SetControlPointModel controlPoint.
             * @member {number} controlPoint
             * @memberof CUserMsg_ParticleManager.SetControlPointModel
             * @instance
             */
            SetControlPointModel.prototype.controlPoint = 0;
    
            /**
             * SetControlPointModel modelName.
             * @member {string} modelName
             * @memberof CUserMsg_ParticleManager.SetControlPointModel
             * @instance
             */
            SetControlPointModel.prototype.modelName = "";
    
            /**
             * Creates a new SetControlPointModel instance using the specified properties.
             * @function create
             * @memberof CUserMsg_ParticleManager.SetControlPointModel
             * @static
             * @param {CUserMsg_ParticleManager.ISetControlPointModel=} [properties] Properties to set
             * @returns {CUserMsg_ParticleManager.SetControlPointModel} SetControlPointModel instance
             */
            SetControlPointModel.create = function create(properties) {
                return new SetControlPointModel(properties);
            };
    
            /**
             * Encodes the specified SetControlPointModel message. Does not implicitly {@link CUserMsg_ParticleManager.SetControlPointModel.verify|verify} messages.
             * @function encode
             * @memberof CUserMsg_ParticleManager.SetControlPointModel
             * @static
             * @param {CUserMsg_ParticleManager.ISetControlPointModel} message SetControlPointModel message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SetControlPointModel.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.controlPoint != null && Object.hasOwnProperty.call(message, "controlPoint"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.controlPoint);
                if (message.modelName != null && Object.hasOwnProperty.call(message, "modelName"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.modelName);
                return writer;
            };
    
            /**
             * Encodes the specified SetControlPointModel message, length delimited. Does not implicitly {@link CUserMsg_ParticleManager.SetControlPointModel.verify|verify} messages.
             * @function encodeDelimited
             * @memberof CUserMsg_ParticleManager.SetControlPointModel
             * @static
             * @param {CUserMsg_ParticleManager.ISetControlPointModel} message SetControlPointModel message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SetControlPointModel.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a SetControlPointModel message from the specified reader or buffer.
             * @function decode
             * @memberof CUserMsg_ParticleManager.SetControlPointModel
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {CUserMsg_ParticleManager.SetControlPointModel} SetControlPointModel
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SetControlPointModel.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CUserMsg_ParticleManager.SetControlPointModel();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.controlPoint = reader.int32();
                            break;
                        }
                    case 2: {
                            message.modelName = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a SetControlPointModel message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof CUserMsg_ParticleManager.SetControlPointModel
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {CUserMsg_ParticleManager.SetControlPointModel} SetControlPointModel
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SetControlPointModel.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a SetControlPointModel message.
             * @function verify
             * @memberof CUserMsg_ParticleManager.SetControlPointModel
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SetControlPointModel.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.controlPoint != null && message.hasOwnProperty("controlPoint"))
                    if (!$util.isInteger(message.controlPoint))
                        return "controlPoint: integer expected";
                if (message.modelName != null && message.hasOwnProperty("modelName"))
                    if (!$util.isString(message.modelName))
                        return "modelName: string expected";
                return null;
            };
    
            /**
             * Creates a SetControlPointModel message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof CUserMsg_ParticleManager.SetControlPointModel
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {CUserMsg_ParticleManager.SetControlPointModel} SetControlPointModel
             */
            SetControlPointModel.fromObject = function fromObject(object) {
                if (object instanceof $root.CUserMsg_ParticleManager.SetControlPointModel)
                    return object;
                var message = new $root.CUserMsg_ParticleManager.SetControlPointModel();
                if (object.controlPoint != null)
                    message.controlPoint = object.controlPoint | 0;
                if (object.modelName != null)
                    message.modelName = String(object.modelName);
                return message;
            };
    
            /**
             * Creates a plain object from a SetControlPointModel message. Also converts values to other types if specified.
             * @function toObject
             * @memberof CUserMsg_ParticleManager.SetControlPointModel
             * @static
             * @param {CUserMsg_ParticleManager.SetControlPointModel} message SetControlPointModel
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SetControlPointModel.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.controlPoint = 0;
                    object.modelName = "";
                }
                if (message.controlPoint != null && message.hasOwnProperty("controlPoint"))
                    object.controlPoint = message.controlPoint;
                if (message.modelName != null && message.hasOwnProperty("modelName"))
                    object.modelName = message.modelName;
                return object;
            };
    
            /**
             * Converts this SetControlPointModel to JSON.
             * @function toJSON
             * @memberof CUserMsg_ParticleManager.SetControlPointModel
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            SetControlPointModel.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            /**
             * Gets the default type url for SetControlPointModel
             * @function getTypeUrl
             * @memberof CUserMsg_ParticleManager.SetControlPointModel
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            SetControlPointModel.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/CUserMsg_ParticleManager.SetControlPointModel";
            };
    
            return SetControlPointModel;
        })();
    
        CUserMsg_ParticleManager.SetControlPointSnapshot = (function() {
    
            /**
             * Properties of a SetControlPointSnapshot.
             * @memberof CUserMsg_ParticleManager
             * @interface ISetControlPointSnapshot
             * @property {number|null} [controlPoint] SetControlPointSnapshot controlPoint
             * @property {string|null} [snapshotName] SetControlPointSnapshot snapshotName
             */
    
            /**
             * Constructs a new SetControlPointSnapshot.
             * @memberof CUserMsg_ParticleManager
             * @classdesc Represents a SetControlPointSnapshot.
             * @implements ISetControlPointSnapshot
             * @constructor
             * @param {CUserMsg_ParticleManager.ISetControlPointSnapshot=} [properties] Properties to set
             */
            function SetControlPointSnapshot(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * SetControlPointSnapshot controlPoint.
             * @member {number} controlPoint
             * @memberof CUserMsg_ParticleManager.SetControlPointSnapshot
             * @instance
             */
            SetControlPointSnapshot.prototype.controlPoint = 0;
    
            /**
             * SetControlPointSnapshot snapshotName.
             * @member {string} snapshotName
             * @memberof CUserMsg_ParticleManager.SetControlPointSnapshot
             * @instance
             */
            SetControlPointSnapshot.prototype.snapshotName = "";
    
            /**
             * Creates a new SetControlPointSnapshot instance using the specified properties.
             * @function create
             * @memberof CUserMsg_ParticleManager.SetControlPointSnapshot
             * @static
             * @param {CUserMsg_ParticleManager.ISetControlPointSnapshot=} [properties] Properties to set
             * @returns {CUserMsg_ParticleManager.SetControlPointSnapshot} SetControlPointSnapshot instance
             */
            SetControlPointSnapshot.create = function create(properties) {
                return new SetControlPointSnapshot(properties);
            };
    
            /**
             * Encodes the specified SetControlPointSnapshot message. Does not implicitly {@link CUserMsg_ParticleManager.SetControlPointSnapshot.verify|verify} messages.
             * @function encode
             * @memberof CUserMsg_ParticleManager.SetControlPointSnapshot
             * @static
             * @param {CUserMsg_ParticleManager.ISetControlPointSnapshot} message SetControlPointSnapshot message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SetControlPointSnapshot.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.controlPoint != null && Object.hasOwnProperty.call(message, "controlPoint"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.controlPoint);
                if (message.snapshotName != null && Object.hasOwnProperty.call(message, "snapshotName"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.snapshotName);
                return writer;
            };
    
            /**
             * Encodes the specified SetControlPointSnapshot message, length delimited. Does not implicitly {@link CUserMsg_ParticleManager.SetControlPointSnapshot.verify|verify} messages.
             * @function encodeDelimited
             * @memberof CUserMsg_ParticleManager.SetControlPointSnapshot
             * @static
             * @param {CUserMsg_ParticleManager.ISetControlPointSnapshot} message SetControlPointSnapshot message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SetControlPointSnapshot.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a SetControlPointSnapshot message from the specified reader or buffer.
             * @function decode
             * @memberof CUserMsg_ParticleManager.SetControlPointSnapshot
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {CUserMsg_ParticleManager.SetControlPointSnapshot} SetControlPointSnapshot
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SetControlPointSnapshot.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CUserMsg_ParticleManager.SetControlPointSnapshot();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.controlPoint = reader.int32();
                            break;
                        }
                    case 2: {
                            message.snapshotName = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a SetControlPointSnapshot message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof CUserMsg_ParticleManager.SetControlPointSnapshot
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {CUserMsg_ParticleManager.SetControlPointSnapshot} SetControlPointSnapshot
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SetControlPointSnapshot.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a SetControlPointSnapshot message.
             * @function verify
             * @memberof CUserMsg_ParticleManager.SetControlPointSnapshot
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SetControlPointSnapshot.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.controlPoint != null && message.hasOwnProperty("controlPoint"))
                    if (!$util.isInteger(message.controlPoint))
                        return "controlPoint: integer expected";
                if (message.snapshotName != null && message.hasOwnProperty("snapshotName"))
                    if (!$util.isString(message.snapshotName))
                        return "snapshotName: string expected";
                return null;
            };
    
            /**
             * Creates a SetControlPointSnapshot message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof CUserMsg_ParticleManager.SetControlPointSnapshot
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {CUserMsg_ParticleManager.SetControlPointSnapshot} SetControlPointSnapshot
             */
            SetControlPointSnapshot.fromObject = function fromObject(object) {
                if (object instanceof $root.CUserMsg_ParticleManager.SetControlPointSnapshot)
                    return object;
                var message = new $root.CUserMsg_ParticleManager.SetControlPointSnapshot();
                if (object.controlPoint != null)
                    message.controlPoint = object.controlPoint | 0;
                if (object.snapshotName != null)
                    message.snapshotName = String(object.snapshotName);
                return message;
            };
    
            /**
             * Creates a plain object from a SetControlPointSnapshot message. Also converts values to other types if specified.
             * @function toObject
             * @memberof CUserMsg_ParticleManager.SetControlPointSnapshot
             * @static
             * @param {CUserMsg_ParticleManager.SetControlPointSnapshot} message SetControlPointSnapshot
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SetControlPointSnapshot.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.controlPoint = 0;
                    object.snapshotName = "";
                }
                if (message.controlPoint != null && message.hasOwnProperty("controlPoint"))
                    object.controlPoint = message.controlPoint;
                if (message.snapshotName != null && message.hasOwnProperty("snapshotName"))
                    object.snapshotName = message.snapshotName;
                return object;
            };
    
            /**
             * Converts this SetControlPointSnapshot to JSON.
             * @function toJSON
             * @memberof CUserMsg_ParticleManager.SetControlPointSnapshot
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            SetControlPointSnapshot.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            /**
             * Gets the default type url for SetControlPointSnapshot
             * @function getTypeUrl
             * @memberof CUserMsg_ParticleManager.SetControlPointSnapshot
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            SetControlPointSnapshot.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/CUserMsg_ParticleManager.SetControlPointSnapshot";
            };
    
            return SetControlPointSnapshot;
        })();
    
        CUserMsg_ParticleManager.SetParticleText = (function() {
    
            /**
             * Properties of a SetParticleText.
             * @memberof CUserMsg_ParticleManager
             * @interface ISetParticleText
             * @property {string|null} [text] SetParticleText text
             */
    
            /**
             * Constructs a new SetParticleText.
             * @memberof CUserMsg_ParticleManager
             * @classdesc Represents a SetParticleText.
             * @implements ISetParticleText
             * @constructor
             * @param {CUserMsg_ParticleManager.ISetParticleText=} [properties] Properties to set
             */
            function SetParticleText(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * SetParticleText text.
             * @member {string} text
             * @memberof CUserMsg_ParticleManager.SetParticleText
             * @instance
             */
            SetParticleText.prototype.text = "";
    
            /**
             * Creates a new SetParticleText instance using the specified properties.
             * @function create
             * @memberof CUserMsg_ParticleManager.SetParticleText
             * @static
             * @param {CUserMsg_ParticleManager.ISetParticleText=} [properties] Properties to set
             * @returns {CUserMsg_ParticleManager.SetParticleText} SetParticleText instance
             */
            SetParticleText.create = function create(properties) {
                return new SetParticleText(properties);
            };
    
            /**
             * Encodes the specified SetParticleText message. Does not implicitly {@link CUserMsg_ParticleManager.SetParticleText.verify|verify} messages.
             * @function encode
             * @memberof CUserMsg_ParticleManager.SetParticleText
             * @static
             * @param {CUserMsg_ParticleManager.ISetParticleText} message SetParticleText message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SetParticleText.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.text != null && Object.hasOwnProperty.call(message, "text"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.text);
                return writer;
            };
    
            /**
             * Encodes the specified SetParticleText message, length delimited. Does not implicitly {@link CUserMsg_ParticleManager.SetParticleText.verify|verify} messages.
             * @function encodeDelimited
             * @memberof CUserMsg_ParticleManager.SetParticleText
             * @static
             * @param {CUserMsg_ParticleManager.ISetParticleText} message SetParticleText message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SetParticleText.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a SetParticleText message from the specified reader or buffer.
             * @function decode
             * @memberof CUserMsg_ParticleManager.SetParticleText
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {CUserMsg_ParticleManager.SetParticleText} SetParticleText
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SetParticleText.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CUserMsg_ParticleManager.SetParticleText();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.text = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a SetParticleText message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof CUserMsg_ParticleManager.SetParticleText
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {CUserMsg_ParticleManager.SetParticleText} SetParticleText
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SetParticleText.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a SetParticleText message.
             * @function verify
             * @memberof CUserMsg_ParticleManager.SetParticleText
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SetParticleText.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.text != null && message.hasOwnProperty("text"))
                    if (!$util.isString(message.text))
                        return "text: string expected";
                return null;
            };
    
            /**
             * Creates a SetParticleText message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof CUserMsg_ParticleManager.SetParticleText
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {CUserMsg_ParticleManager.SetParticleText} SetParticleText
             */
            SetParticleText.fromObject = function fromObject(object) {
                if (object instanceof $root.CUserMsg_ParticleManager.SetParticleText)
                    return object;
                var message = new $root.CUserMsg_ParticleManager.SetParticleText();
                if (object.text != null)
                    message.text = String(object.text);
                return message;
            };
    
            /**
             * Creates a plain object from a SetParticleText message. Also converts values to other types if specified.
             * @function toObject
             * @memberof CUserMsg_ParticleManager.SetParticleText
             * @static
             * @param {CUserMsg_ParticleManager.SetParticleText} message SetParticleText
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SetParticleText.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.text = "";
                if (message.text != null && message.hasOwnProperty("text"))
                    object.text = message.text;
                return object;
            };
    
            /**
             * Converts this SetParticleText to JSON.
             * @function toJSON
             * @memberof CUserMsg_ParticleManager.SetParticleText
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            SetParticleText.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            /**
             * Gets the default type url for SetParticleText
             * @function getTypeUrl
             * @memberof CUserMsg_ParticleManager.SetParticleText
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            SetParticleText.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/CUserMsg_ParticleManager.SetParticleText";
            };
    
            return SetParticleText;
        })();
    
        CUserMsg_ParticleManager.SetTextureAttribute = (function() {
    
            /**
             * Properties of a SetTextureAttribute.
             * @memberof CUserMsg_ParticleManager
             * @interface ISetTextureAttribute
             * @property {string|null} [attributeName] SetTextureAttribute attributeName
             * @property {string|null} [textureName] SetTextureAttribute textureName
             */
    
            /**
             * Constructs a new SetTextureAttribute.
             * @memberof CUserMsg_ParticleManager
             * @classdesc Represents a SetTextureAttribute.
             * @implements ISetTextureAttribute
             * @constructor
             * @param {CUserMsg_ParticleManager.ISetTextureAttribute=} [properties] Properties to set
             */
            function SetTextureAttribute(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * SetTextureAttribute attributeName.
             * @member {string} attributeName
             * @memberof CUserMsg_ParticleManager.SetTextureAttribute
             * @instance
             */
            SetTextureAttribute.prototype.attributeName = "";
    
            /**
             * SetTextureAttribute textureName.
             * @member {string} textureName
             * @memberof CUserMsg_ParticleManager.SetTextureAttribute
             * @instance
             */
            SetTextureAttribute.prototype.textureName = "";
    
            /**
             * Creates a new SetTextureAttribute instance using the specified properties.
             * @function create
             * @memberof CUserMsg_ParticleManager.SetTextureAttribute
             * @static
             * @param {CUserMsg_ParticleManager.ISetTextureAttribute=} [properties] Properties to set
             * @returns {CUserMsg_ParticleManager.SetTextureAttribute} SetTextureAttribute instance
             */
            SetTextureAttribute.create = function create(properties) {
                return new SetTextureAttribute(properties);
            };
    
            /**
             * Encodes the specified SetTextureAttribute message. Does not implicitly {@link CUserMsg_ParticleManager.SetTextureAttribute.verify|verify} messages.
             * @function encode
             * @memberof CUserMsg_ParticleManager.SetTextureAttribute
             * @static
             * @param {CUserMsg_ParticleManager.ISetTextureAttribute} message SetTextureAttribute message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SetTextureAttribute.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.attributeName != null && Object.hasOwnProperty.call(message, "attributeName"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.attributeName);
                if (message.textureName != null && Object.hasOwnProperty.call(message, "textureName"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.textureName);
                return writer;
            };
    
            /**
             * Encodes the specified SetTextureAttribute message, length delimited. Does not implicitly {@link CUserMsg_ParticleManager.SetTextureAttribute.verify|verify} messages.
             * @function encodeDelimited
             * @memberof CUserMsg_ParticleManager.SetTextureAttribute
             * @static
             * @param {CUserMsg_ParticleManager.ISetTextureAttribute} message SetTextureAttribute message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SetTextureAttribute.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a SetTextureAttribute message from the specified reader or buffer.
             * @function decode
             * @memberof CUserMsg_ParticleManager.SetTextureAttribute
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {CUserMsg_ParticleManager.SetTextureAttribute} SetTextureAttribute
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SetTextureAttribute.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CUserMsg_ParticleManager.SetTextureAttribute();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.attributeName = reader.string();
                            break;
                        }
                    case 2: {
                            message.textureName = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a SetTextureAttribute message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof CUserMsg_ParticleManager.SetTextureAttribute
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {CUserMsg_ParticleManager.SetTextureAttribute} SetTextureAttribute
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SetTextureAttribute.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a SetTextureAttribute message.
             * @function verify
             * @memberof CUserMsg_ParticleManager.SetTextureAttribute
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SetTextureAttribute.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.attributeName != null && message.hasOwnProperty("attributeName"))
                    if (!$util.isString(message.attributeName))
                        return "attributeName: string expected";
                if (message.textureName != null && message.hasOwnProperty("textureName"))
                    if (!$util.isString(message.textureName))
                        return "textureName: string expected";
                return null;
            };
    
            /**
             * Creates a SetTextureAttribute message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof CUserMsg_ParticleManager.SetTextureAttribute
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {CUserMsg_ParticleManager.SetTextureAttribute} SetTextureAttribute
             */
            SetTextureAttribute.fromObject = function fromObject(object) {
                if (object instanceof $root.CUserMsg_ParticleManager.SetTextureAttribute)
                    return object;
                var message = new $root.CUserMsg_ParticleManager.SetTextureAttribute();
                if (object.attributeName != null)
                    message.attributeName = String(object.attributeName);
                if (object.textureName != null)
                    message.textureName = String(object.textureName);
                return message;
            };
    
            /**
             * Creates a plain object from a SetTextureAttribute message. Also converts values to other types if specified.
             * @function toObject
             * @memberof CUserMsg_ParticleManager.SetTextureAttribute
             * @static
             * @param {CUserMsg_ParticleManager.SetTextureAttribute} message SetTextureAttribute
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SetTextureAttribute.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.attributeName = "";
                    object.textureName = "";
                }
                if (message.attributeName != null && message.hasOwnProperty("attributeName"))
                    object.attributeName = message.attributeName;
                if (message.textureName != null && message.hasOwnProperty("textureName"))
                    object.textureName = message.textureName;
                return object;
            };
    
            /**
             * Converts this SetTextureAttribute to JSON.
             * @function toJSON
             * @memberof CUserMsg_ParticleManager.SetTextureAttribute
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            SetTextureAttribute.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            /**
             * Gets the default type url for SetTextureAttribute
             * @function getTypeUrl
             * @memberof CUserMsg_ParticleManager.SetTextureAttribute
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            SetTextureAttribute.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/CUserMsg_ParticleManager.SetTextureAttribute";
            };
    
            return SetTextureAttribute;
        })();
    
        CUserMsg_ParticleManager.SetSceneObjectGenericFlag = (function() {
    
            /**
             * Properties of a SetSceneObjectGenericFlag.
             * @memberof CUserMsg_ParticleManager
             * @interface ISetSceneObjectGenericFlag
             * @property {boolean|null} [flagValue] SetSceneObjectGenericFlag flagValue
             */
    
            /**
             * Constructs a new SetSceneObjectGenericFlag.
             * @memberof CUserMsg_ParticleManager
             * @classdesc Represents a SetSceneObjectGenericFlag.
             * @implements ISetSceneObjectGenericFlag
             * @constructor
             * @param {CUserMsg_ParticleManager.ISetSceneObjectGenericFlag=} [properties] Properties to set
             */
            function SetSceneObjectGenericFlag(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * SetSceneObjectGenericFlag flagValue.
             * @member {boolean} flagValue
             * @memberof CUserMsg_ParticleManager.SetSceneObjectGenericFlag
             * @instance
             */
            SetSceneObjectGenericFlag.prototype.flagValue = false;
    
            /**
             * Creates a new SetSceneObjectGenericFlag instance using the specified properties.
             * @function create
             * @memberof CUserMsg_ParticleManager.SetSceneObjectGenericFlag
             * @static
             * @param {CUserMsg_ParticleManager.ISetSceneObjectGenericFlag=} [properties] Properties to set
             * @returns {CUserMsg_ParticleManager.SetSceneObjectGenericFlag} SetSceneObjectGenericFlag instance
             */
            SetSceneObjectGenericFlag.create = function create(properties) {
                return new SetSceneObjectGenericFlag(properties);
            };
    
            /**
             * Encodes the specified SetSceneObjectGenericFlag message. Does not implicitly {@link CUserMsg_ParticleManager.SetSceneObjectGenericFlag.verify|verify} messages.
             * @function encode
             * @memberof CUserMsg_ParticleManager.SetSceneObjectGenericFlag
             * @static
             * @param {CUserMsg_ParticleManager.ISetSceneObjectGenericFlag} message SetSceneObjectGenericFlag message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SetSceneObjectGenericFlag.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.flagValue != null && Object.hasOwnProperty.call(message, "flagValue"))
                    writer.uint32(/* id 1, wireType 0 =*/8).bool(message.flagValue);
                return writer;
            };
    
            /**
             * Encodes the specified SetSceneObjectGenericFlag message, length delimited. Does not implicitly {@link CUserMsg_ParticleManager.SetSceneObjectGenericFlag.verify|verify} messages.
             * @function encodeDelimited
             * @memberof CUserMsg_ParticleManager.SetSceneObjectGenericFlag
             * @static
             * @param {CUserMsg_ParticleManager.ISetSceneObjectGenericFlag} message SetSceneObjectGenericFlag message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SetSceneObjectGenericFlag.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a SetSceneObjectGenericFlag message from the specified reader or buffer.
             * @function decode
             * @memberof CUserMsg_ParticleManager.SetSceneObjectGenericFlag
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {CUserMsg_ParticleManager.SetSceneObjectGenericFlag} SetSceneObjectGenericFlag
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SetSceneObjectGenericFlag.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CUserMsg_ParticleManager.SetSceneObjectGenericFlag();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.flagValue = reader.bool();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a SetSceneObjectGenericFlag message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof CUserMsg_ParticleManager.SetSceneObjectGenericFlag
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {CUserMsg_ParticleManager.SetSceneObjectGenericFlag} SetSceneObjectGenericFlag
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SetSceneObjectGenericFlag.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a SetSceneObjectGenericFlag message.
             * @function verify
             * @memberof CUserMsg_ParticleManager.SetSceneObjectGenericFlag
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SetSceneObjectGenericFlag.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.flagValue != null && message.hasOwnProperty("flagValue"))
                    if (typeof message.flagValue !== "boolean")
                        return "flagValue: boolean expected";
                return null;
            };
    
            /**
             * Creates a SetSceneObjectGenericFlag message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof CUserMsg_ParticleManager.SetSceneObjectGenericFlag
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {CUserMsg_ParticleManager.SetSceneObjectGenericFlag} SetSceneObjectGenericFlag
             */
            SetSceneObjectGenericFlag.fromObject = function fromObject(object) {
                if (object instanceof $root.CUserMsg_ParticleManager.SetSceneObjectGenericFlag)
                    return object;
                var message = new $root.CUserMsg_ParticleManager.SetSceneObjectGenericFlag();
                if (object.flagValue != null)
                    message.flagValue = Boolean(object.flagValue);
                return message;
            };
    
            /**
             * Creates a plain object from a SetSceneObjectGenericFlag message. Also converts values to other types if specified.
             * @function toObject
             * @memberof CUserMsg_ParticleManager.SetSceneObjectGenericFlag
             * @static
             * @param {CUserMsg_ParticleManager.SetSceneObjectGenericFlag} message SetSceneObjectGenericFlag
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SetSceneObjectGenericFlag.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.flagValue = false;
                if (message.flagValue != null && message.hasOwnProperty("flagValue"))
                    object.flagValue = message.flagValue;
                return object;
            };
    
            /**
             * Converts this SetSceneObjectGenericFlag to JSON.
             * @function toJSON
             * @memberof CUserMsg_ParticleManager.SetSceneObjectGenericFlag
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            SetSceneObjectGenericFlag.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            /**
             * Gets the default type url for SetSceneObjectGenericFlag
             * @function getTypeUrl
             * @memberof CUserMsg_ParticleManager.SetSceneObjectGenericFlag
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            SetSceneObjectGenericFlag.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/CUserMsg_ParticleManager.SetSceneObjectGenericFlag";
            };
    
            return SetSceneObjectGenericFlag;
        })();
    
        CUserMsg_ParticleManager.SetSceneObjectTintAndDesat = (function() {
    
            /**
             * Properties of a SetSceneObjectTintAndDesat.
             * @memberof CUserMsg_ParticleManager
             * @interface ISetSceneObjectTintAndDesat
             * @property {number|null} [tint] SetSceneObjectTintAndDesat tint
             * @property {number|null} [desat] SetSceneObjectTintAndDesat desat
             */
    
            /**
             * Constructs a new SetSceneObjectTintAndDesat.
             * @memberof CUserMsg_ParticleManager
             * @classdesc Represents a SetSceneObjectTintAndDesat.
             * @implements ISetSceneObjectTintAndDesat
             * @constructor
             * @param {CUserMsg_ParticleManager.ISetSceneObjectTintAndDesat=} [properties] Properties to set
             */
            function SetSceneObjectTintAndDesat(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * SetSceneObjectTintAndDesat tint.
             * @member {number} tint
             * @memberof CUserMsg_ParticleManager.SetSceneObjectTintAndDesat
             * @instance
             */
            SetSceneObjectTintAndDesat.prototype.tint = 0;
    
            /**
             * SetSceneObjectTintAndDesat desat.
             * @member {number} desat
             * @memberof CUserMsg_ParticleManager.SetSceneObjectTintAndDesat
             * @instance
             */
            SetSceneObjectTintAndDesat.prototype.desat = 0;
    
            /**
             * Creates a new SetSceneObjectTintAndDesat instance using the specified properties.
             * @function create
             * @memberof CUserMsg_ParticleManager.SetSceneObjectTintAndDesat
             * @static
             * @param {CUserMsg_ParticleManager.ISetSceneObjectTintAndDesat=} [properties] Properties to set
             * @returns {CUserMsg_ParticleManager.SetSceneObjectTintAndDesat} SetSceneObjectTintAndDesat instance
             */
            SetSceneObjectTintAndDesat.create = function create(properties) {
                return new SetSceneObjectTintAndDesat(properties);
            };
    
            /**
             * Encodes the specified SetSceneObjectTintAndDesat message. Does not implicitly {@link CUserMsg_ParticleManager.SetSceneObjectTintAndDesat.verify|verify} messages.
             * @function encode
             * @memberof CUserMsg_ParticleManager.SetSceneObjectTintAndDesat
             * @static
             * @param {CUserMsg_ParticleManager.ISetSceneObjectTintAndDesat} message SetSceneObjectTintAndDesat message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SetSceneObjectTintAndDesat.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.tint != null && Object.hasOwnProperty.call(message, "tint"))
                    writer.uint32(/* id 1, wireType 5 =*/13).fixed32(message.tint);
                if (message.desat != null && Object.hasOwnProperty.call(message, "desat"))
                    writer.uint32(/* id 2, wireType 5 =*/21).float(message.desat);
                return writer;
            };
    
            /**
             * Encodes the specified SetSceneObjectTintAndDesat message, length delimited. Does not implicitly {@link CUserMsg_ParticleManager.SetSceneObjectTintAndDesat.verify|verify} messages.
             * @function encodeDelimited
             * @memberof CUserMsg_ParticleManager.SetSceneObjectTintAndDesat
             * @static
             * @param {CUserMsg_ParticleManager.ISetSceneObjectTintAndDesat} message SetSceneObjectTintAndDesat message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SetSceneObjectTintAndDesat.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a SetSceneObjectTintAndDesat message from the specified reader or buffer.
             * @function decode
             * @memberof CUserMsg_ParticleManager.SetSceneObjectTintAndDesat
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {CUserMsg_ParticleManager.SetSceneObjectTintAndDesat} SetSceneObjectTintAndDesat
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SetSceneObjectTintAndDesat.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CUserMsg_ParticleManager.SetSceneObjectTintAndDesat();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.tint = reader.fixed32();
                            break;
                        }
                    case 2: {
                            message.desat = reader.float();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a SetSceneObjectTintAndDesat message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof CUserMsg_ParticleManager.SetSceneObjectTintAndDesat
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {CUserMsg_ParticleManager.SetSceneObjectTintAndDesat} SetSceneObjectTintAndDesat
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SetSceneObjectTintAndDesat.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a SetSceneObjectTintAndDesat message.
             * @function verify
             * @memberof CUserMsg_ParticleManager.SetSceneObjectTintAndDesat
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SetSceneObjectTintAndDesat.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.tint != null && message.hasOwnProperty("tint"))
                    if (!$util.isInteger(message.tint))
                        return "tint: integer expected";
                if (message.desat != null && message.hasOwnProperty("desat"))
                    if (typeof message.desat !== "number")
                        return "desat: number expected";
                return null;
            };
    
            /**
             * Creates a SetSceneObjectTintAndDesat message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof CUserMsg_ParticleManager.SetSceneObjectTintAndDesat
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {CUserMsg_ParticleManager.SetSceneObjectTintAndDesat} SetSceneObjectTintAndDesat
             */
            SetSceneObjectTintAndDesat.fromObject = function fromObject(object) {
                if (object instanceof $root.CUserMsg_ParticleManager.SetSceneObjectTintAndDesat)
                    return object;
                var message = new $root.CUserMsg_ParticleManager.SetSceneObjectTintAndDesat();
                if (object.tint != null)
                    message.tint = object.tint >>> 0;
                if (object.desat != null)
                    message.desat = Number(object.desat);
                return message;
            };
    
            /**
             * Creates a plain object from a SetSceneObjectTintAndDesat message. Also converts values to other types if specified.
             * @function toObject
             * @memberof CUserMsg_ParticleManager.SetSceneObjectTintAndDesat
             * @static
             * @param {CUserMsg_ParticleManager.SetSceneObjectTintAndDesat} message SetSceneObjectTintAndDesat
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SetSceneObjectTintAndDesat.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.tint = 0;
                    object.desat = 0;
                }
                if (message.tint != null && message.hasOwnProperty("tint"))
                    object.tint = message.tint;
                if (message.desat != null && message.hasOwnProperty("desat"))
                    object.desat = options.json && !isFinite(message.desat) ? String(message.desat) : message.desat;
                return object;
            };
    
            /**
             * Converts this SetSceneObjectTintAndDesat to JSON.
             * @function toJSON
             * @memberof CUserMsg_ParticleManager.SetSceneObjectTintAndDesat
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            SetSceneObjectTintAndDesat.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            /**
             * Gets the default type url for SetSceneObjectTintAndDesat
             * @function getTypeUrl
             * @memberof CUserMsg_ParticleManager.SetSceneObjectTintAndDesat
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            SetSceneObjectTintAndDesat.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/CUserMsg_ParticleManager.SetSceneObjectTintAndDesat";
            };
    
            return SetSceneObjectTintAndDesat;
        })();
    
        CUserMsg_ParticleManager.ParticleSkipToTime = (function() {
    
            /**
             * Properties of a ParticleSkipToTime.
             * @memberof CUserMsg_ParticleManager
             * @interface IParticleSkipToTime
             * @property {number|null} [skipToTime] ParticleSkipToTime skipToTime
             */
    
            /**
             * Constructs a new ParticleSkipToTime.
             * @memberof CUserMsg_ParticleManager
             * @classdesc Represents a ParticleSkipToTime.
             * @implements IParticleSkipToTime
             * @constructor
             * @param {CUserMsg_ParticleManager.IParticleSkipToTime=} [properties] Properties to set
             */
            function ParticleSkipToTime(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * ParticleSkipToTime skipToTime.
             * @member {number} skipToTime
             * @memberof CUserMsg_ParticleManager.ParticleSkipToTime
             * @instance
             */
            ParticleSkipToTime.prototype.skipToTime = 0;
    
            /**
             * Creates a new ParticleSkipToTime instance using the specified properties.
             * @function create
             * @memberof CUserMsg_ParticleManager.ParticleSkipToTime
             * @static
             * @param {CUserMsg_ParticleManager.IParticleSkipToTime=} [properties] Properties to set
             * @returns {CUserMsg_ParticleManager.ParticleSkipToTime} ParticleSkipToTime instance
             */
            ParticleSkipToTime.create = function create(properties) {
                return new ParticleSkipToTime(properties);
            };
    
            /**
             * Encodes the specified ParticleSkipToTime message. Does not implicitly {@link CUserMsg_ParticleManager.ParticleSkipToTime.verify|verify} messages.
             * @function encode
             * @memberof CUserMsg_ParticleManager.ParticleSkipToTime
             * @static
             * @param {CUserMsg_ParticleManager.IParticleSkipToTime} message ParticleSkipToTime message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ParticleSkipToTime.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.skipToTime != null && Object.hasOwnProperty.call(message, "skipToTime"))
                    writer.uint32(/* id 1, wireType 5 =*/13).float(message.skipToTime);
                return writer;
            };
    
            /**
             * Encodes the specified ParticleSkipToTime message, length delimited. Does not implicitly {@link CUserMsg_ParticleManager.ParticleSkipToTime.verify|verify} messages.
             * @function encodeDelimited
             * @memberof CUserMsg_ParticleManager.ParticleSkipToTime
             * @static
             * @param {CUserMsg_ParticleManager.IParticleSkipToTime} message ParticleSkipToTime message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ParticleSkipToTime.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a ParticleSkipToTime message from the specified reader or buffer.
             * @function decode
             * @memberof CUserMsg_ParticleManager.ParticleSkipToTime
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {CUserMsg_ParticleManager.ParticleSkipToTime} ParticleSkipToTime
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ParticleSkipToTime.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CUserMsg_ParticleManager.ParticleSkipToTime();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.skipToTime = reader.float();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a ParticleSkipToTime message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof CUserMsg_ParticleManager.ParticleSkipToTime
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {CUserMsg_ParticleManager.ParticleSkipToTime} ParticleSkipToTime
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ParticleSkipToTime.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a ParticleSkipToTime message.
             * @function verify
             * @memberof CUserMsg_ParticleManager.ParticleSkipToTime
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ParticleSkipToTime.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.skipToTime != null && message.hasOwnProperty("skipToTime"))
                    if (typeof message.skipToTime !== "number")
                        return "skipToTime: number expected";
                return null;
            };
    
            /**
             * Creates a ParticleSkipToTime message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof CUserMsg_ParticleManager.ParticleSkipToTime
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {CUserMsg_ParticleManager.ParticleSkipToTime} ParticleSkipToTime
             */
            ParticleSkipToTime.fromObject = function fromObject(object) {
                if (object instanceof $root.CUserMsg_ParticleManager.ParticleSkipToTime)
                    return object;
                var message = new $root.CUserMsg_ParticleManager.ParticleSkipToTime();
                if (object.skipToTime != null)
                    message.skipToTime = Number(object.skipToTime);
                return message;
            };
    
            /**
             * Creates a plain object from a ParticleSkipToTime message. Also converts values to other types if specified.
             * @function toObject
             * @memberof CUserMsg_ParticleManager.ParticleSkipToTime
             * @static
             * @param {CUserMsg_ParticleManager.ParticleSkipToTime} message ParticleSkipToTime
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ParticleSkipToTime.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.skipToTime = 0;
                if (message.skipToTime != null && message.hasOwnProperty("skipToTime"))
                    object.skipToTime = options.json && !isFinite(message.skipToTime) ? String(message.skipToTime) : message.skipToTime;
                return object;
            };
    
            /**
             * Converts this ParticleSkipToTime to JSON.
             * @function toJSON
             * @memberof CUserMsg_ParticleManager.ParticleSkipToTime
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ParticleSkipToTime.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            /**
             * Gets the default type url for ParticleSkipToTime
             * @function getTypeUrl
             * @memberof CUserMsg_ParticleManager.ParticleSkipToTime
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            ParticleSkipToTime.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/CUserMsg_ParticleManager.ParticleSkipToTime";
            };
    
            return ParticleSkipToTime;
        })();
    
        CUserMsg_ParticleManager.ParticleCanFreeze = (function() {
    
            /**
             * Properties of a ParticleCanFreeze.
             * @memberof CUserMsg_ParticleManager
             * @interface IParticleCanFreeze
             * @property {boolean|null} [canFreeze] ParticleCanFreeze canFreeze
             */
    
            /**
             * Constructs a new ParticleCanFreeze.
             * @memberof CUserMsg_ParticleManager
             * @classdesc Represents a ParticleCanFreeze.
             * @implements IParticleCanFreeze
             * @constructor
             * @param {CUserMsg_ParticleManager.IParticleCanFreeze=} [properties] Properties to set
             */
            function ParticleCanFreeze(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * ParticleCanFreeze canFreeze.
             * @member {boolean} canFreeze
             * @memberof CUserMsg_ParticleManager.ParticleCanFreeze
             * @instance
             */
            ParticleCanFreeze.prototype.canFreeze = false;
    
            /**
             * Creates a new ParticleCanFreeze instance using the specified properties.
             * @function create
             * @memberof CUserMsg_ParticleManager.ParticleCanFreeze
             * @static
             * @param {CUserMsg_ParticleManager.IParticleCanFreeze=} [properties] Properties to set
             * @returns {CUserMsg_ParticleManager.ParticleCanFreeze} ParticleCanFreeze instance
             */
            ParticleCanFreeze.create = function create(properties) {
                return new ParticleCanFreeze(properties);
            };
    
            /**
             * Encodes the specified ParticleCanFreeze message. Does not implicitly {@link CUserMsg_ParticleManager.ParticleCanFreeze.verify|verify} messages.
             * @function encode
             * @memberof CUserMsg_ParticleManager.ParticleCanFreeze
             * @static
             * @param {CUserMsg_ParticleManager.IParticleCanFreeze} message ParticleCanFreeze message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ParticleCanFreeze.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.canFreeze != null && Object.hasOwnProperty.call(message, "canFreeze"))
                    writer.uint32(/* id 1, wireType 0 =*/8).bool(message.canFreeze);
                return writer;
            };
    
            /**
             * Encodes the specified ParticleCanFreeze message, length delimited. Does not implicitly {@link CUserMsg_ParticleManager.ParticleCanFreeze.verify|verify} messages.
             * @function encodeDelimited
             * @memberof CUserMsg_ParticleManager.ParticleCanFreeze
             * @static
             * @param {CUserMsg_ParticleManager.IParticleCanFreeze} message ParticleCanFreeze message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ParticleCanFreeze.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a ParticleCanFreeze message from the specified reader or buffer.
             * @function decode
             * @memberof CUserMsg_ParticleManager.ParticleCanFreeze
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {CUserMsg_ParticleManager.ParticleCanFreeze} ParticleCanFreeze
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ParticleCanFreeze.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CUserMsg_ParticleManager.ParticleCanFreeze();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.canFreeze = reader.bool();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a ParticleCanFreeze message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof CUserMsg_ParticleManager.ParticleCanFreeze
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {CUserMsg_ParticleManager.ParticleCanFreeze} ParticleCanFreeze
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ParticleCanFreeze.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a ParticleCanFreeze message.
             * @function verify
             * @memberof CUserMsg_ParticleManager.ParticleCanFreeze
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ParticleCanFreeze.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.canFreeze != null && message.hasOwnProperty("canFreeze"))
                    if (typeof message.canFreeze !== "boolean")
                        return "canFreeze: boolean expected";
                return null;
            };
    
            /**
             * Creates a ParticleCanFreeze message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof CUserMsg_ParticleManager.ParticleCanFreeze
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {CUserMsg_ParticleManager.ParticleCanFreeze} ParticleCanFreeze
             */
            ParticleCanFreeze.fromObject = function fromObject(object) {
                if (object instanceof $root.CUserMsg_ParticleManager.ParticleCanFreeze)
                    return object;
                var message = new $root.CUserMsg_ParticleManager.ParticleCanFreeze();
                if (object.canFreeze != null)
                    message.canFreeze = Boolean(object.canFreeze);
                return message;
            };
    
            /**
             * Creates a plain object from a ParticleCanFreeze message. Also converts values to other types if specified.
             * @function toObject
             * @memberof CUserMsg_ParticleManager.ParticleCanFreeze
             * @static
             * @param {CUserMsg_ParticleManager.ParticleCanFreeze} message ParticleCanFreeze
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ParticleCanFreeze.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.canFreeze = false;
                if (message.canFreeze != null && message.hasOwnProperty("canFreeze"))
                    object.canFreeze = message.canFreeze;
                return object;
            };
    
            /**
             * Converts this ParticleCanFreeze to JSON.
             * @function toJSON
             * @memberof CUserMsg_ParticleManager.ParticleCanFreeze
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ParticleCanFreeze.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            /**
             * Gets the default type url for ParticleCanFreeze
             * @function getTypeUrl
             * @memberof CUserMsg_ParticleManager.ParticleCanFreeze
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            ParticleCanFreeze.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/CUserMsg_ParticleManager.ParticleCanFreeze";
            };
    
            return ParticleCanFreeze;
        })();
    
        CUserMsg_ParticleManager.ParticleFreezeTransitionOverride = (function() {
    
            /**
             * Properties of a ParticleFreezeTransitionOverride.
             * @memberof CUserMsg_ParticleManager
             * @interface IParticleFreezeTransitionOverride
             * @property {number|null} [freezeTransitionOverride] ParticleFreezeTransitionOverride freezeTransitionOverride
             */
    
            /**
             * Constructs a new ParticleFreezeTransitionOverride.
             * @memberof CUserMsg_ParticleManager
             * @classdesc Represents a ParticleFreezeTransitionOverride.
             * @implements IParticleFreezeTransitionOverride
             * @constructor
             * @param {CUserMsg_ParticleManager.IParticleFreezeTransitionOverride=} [properties] Properties to set
             */
            function ParticleFreezeTransitionOverride(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * ParticleFreezeTransitionOverride freezeTransitionOverride.
             * @member {number} freezeTransitionOverride
             * @memberof CUserMsg_ParticleManager.ParticleFreezeTransitionOverride
             * @instance
             */
            ParticleFreezeTransitionOverride.prototype.freezeTransitionOverride = 0;
    
            /**
             * Creates a new ParticleFreezeTransitionOverride instance using the specified properties.
             * @function create
             * @memberof CUserMsg_ParticleManager.ParticleFreezeTransitionOverride
             * @static
             * @param {CUserMsg_ParticleManager.IParticleFreezeTransitionOverride=} [properties] Properties to set
             * @returns {CUserMsg_ParticleManager.ParticleFreezeTransitionOverride} ParticleFreezeTransitionOverride instance
             */
            ParticleFreezeTransitionOverride.create = function create(properties) {
                return new ParticleFreezeTransitionOverride(properties);
            };
    
            /**
             * Encodes the specified ParticleFreezeTransitionOverride message. Does not implicitly {@link CUserMsg_ParticleManager.ParticleFreezeTransitionOverride.verify|verify} messages.
             * @function encode
             * @memberof CUserMsg_ParticleManager.ParticleFreezeTransitionOverride
             * @static
             * @param {CUserMsg_ParticleManager.IParticleFreezeTransitionOverride} message ParticleFreezeTransitionOverride message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ParticleFreezeTransitionOverride.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.freezeTransitionOverride != null && Object.hasOwnProperty.call(message, "freezeTransitionOverride"))
                    writer.uint32(/* id 1, wireType 5 =*/13).float(message.freezeTransitionOverride);
                return writer;
            };
    
            /**
             * Encodes the specified ParticleFreezeTransitionOverride message, length delimited. Does not implicitly {@link CUserMsg_ParticleManager.ParticleFreezeTransitionOverride.verify|verify} messages.
             * @function encodeDelimited
             * @memberof CUserMsg_ParticleManager.ParticleFreezeTransitionOverride
             * @static
             * @param {CUserMsg_ParticleManager.IParticleFreezeTransitionOverride} message ParticleFreezeTransitionOverride message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ParticleFreezeTransitionOverride.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a ParticleFreezeTransitionOverride message from the specified reader or buffer.
             * @function decode
             * @memberof CUserMsg_ParticleManager.ParticleFreezeTransitionOverride
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {CUserMsg_ParticleManager.ParticleFreezeTransitionOverride} ParticleFreezeTransitionOverride
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ParticleFreezeTransitionOverride.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CUserMsg_ParticleManager.ParticleFreezeTransitionOverride();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.freezeTransitionOverride = reader.float();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a ParticleFreezeTransitionOverride message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof CUserMsg_ParticleManager.ParticleFreezeTransitionOverride
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {CUserMsg_ParticleManager.ParticleFreezeTransitionOverride} ParticleFreezeTransitionOverride
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ParticleFreezeTransitionOverride.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a ParticleFreezeTransitionOverride message.
             * @function verify
             * @memberof CUserMsg_ParticleManager.ParticleFreezeTransitionOverride
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ParticleFreezeTransitionOverride.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.freezeTransitionOverride != null && message.hasOwnProperty("freezeTransitionOverride"))
                    if (typeof message.freezeTransitionOverride !== "number")
                        return "freezeTransitionOverride: number expected";
                return null;
            };
    
            /**
             * Creates a ParticleFreezeTransitionOverride message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof CUserMsg_ParticleManager.ParticleFreezeTransitionOverride
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {CUserMsg_ParticleManager.ParticleFreezeTransitionOverride} ParticleFreezeTransitionOverride
             */
            ParticleFreezeTransitionOverride.fromObject = function fromObject(object) {
                if (object instanceof $root.CUserMsg_ParticleManager.ParticleFreezeTransitionOverride)
                    return object;
                var message = new $root.CUserMsg_ParticleManager.ParticleFreezeTransitionOverride();
                if (object.freezeTransitionOverride != null)
                    message.freezeTransitionOverride = Number(object.freezeTransitionOverride);
                return message;
            };
    
            /**
             * Creates a plain object from a ParticleFreezeTransitionOverride message. Also converts values to other types if specified.
             * @function toObject
             * @memberof CUserMsg_ParticleManager.ParticleFreezeTransitionOverride
             * @static
             * @param {CUserMsg_ParticleManager.ParticleFreezeTransitionOverride} message ParticleFreezeTransitionOverride
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ParticleFreezeTransitionOverride.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.freezeTransitionOverride = 0;
                if (message.freezeTransitionOverride != null && message.hasOwnProperty("freezeTransitionOverride"))
                    object.freezeTransitionOverride = options.json && !isFinite(message.freezeTransitionOverride) ? String(message.freezeTransitionOverride) : message.freezeTransitionOverride;
                return object;
            };
    
            /**
             * Converts this ParticleFreezeTransitionOverride to JSON.
             * @function toJSON
             * @memberof CUserMsg_ParticleManager.ParticleFreezeTransitionOverride
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ParticleFreezeTransitionOverride.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            /**
             * Gets the default type url for ParticleFreezeTransitionOverride
             * @function getTypeUrl
             * @memberof CUserMsg_ParticleManager.ParticleFreezeTransitionOverride
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            ParticleFreezeTransitionOverride.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/CUserMsg_ParticleManager.ParticleFreezeTransitionOverride";
            };
    
            return ParticleFreezeTransitionOverride;
        })();
    
        CUserMsg_ParticleManager.FreezeParticleInvolving = (function() {
    
            /**
             * Properties of a FreezeParticleInvolving.
             * @memberof CUserMsg_ParticleManager
             * @interface IFreezeParticleInvolving
             * @property {boolean|null} [setFrozen] FreezeParticleInvolving setFrozen
             * @property {number|null} [transitionDuration] FreezeParticleInvolving transitionDuration
             * @property {number|null} [entityHandle] FreezeParticleInvolving entityHandle
             */
    
            /**
             * Constructs a new FreezeParticleInvolving.
             * @memberof CUserMsg_ParticleManager
             * @classdesc Represents a FreezeParticleInvolving.
             * @implements IFreezeParticleInvolving
             * @constructor
             * @param {CUserMsg_ParticleManager.IFreezeParticleInvolving=} [properties] Properties to set
             */
            function FreezeParticleInvolving(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * FreezeParticleInvolving setFrozen.
             * @member {boolean} setFrozen
             * @memberof CUserMsg_ParticleManager.FreezeParticleInvolving
             * @instance
             */
            FreezeParticleInvolving.prototype.setFrozen = false;
    
            /**
             * FreezeParticleInvolving transitionDuration.
             * @member {number} transitionDuration
             * @memberof CUserMsg_ParticleManager.FreezeParticleInvolving
             * @instance
             */
            FreezeParticleInvolving.prototype.transitionDuration = 0;
    
            /**
             * FreezeParticleInvolving entityHandle.
             * @member {number} entityHandle
             * @memberof CUserMsg_ParticleManager.FreezeParticleInvolving
             * @instance
             */
            FreezeParticleInvolving.prototype.entityHandle = 16777215;
    
            /**
             * Creates a new FreezeParticleInvolving instance using the specified properties.
             * @function create
             * @memberof CUserMsg_ParticleManager.FreezeParticleInvolving
             * @static
             * @param {CUserMsg_ParticleManager.IFreezeParticleInvolving=} [properties] Properties to set
             * @returns {CUserMsg_ParticleManager.FreezeParticleInvolving} FreezeParticleInvolving instance
             */
            FreezeParticleInvolving.create = function create(properties) {
                return new FreezeParticleInvolving(properties);
            };
    
            /**
             * Encodes the specified FreezeParticleInvolving message. Does not implicitly {@link CUserMsg_ParticleManager.FreezeParticleInvolving.verify|verify} messages.
             * @function encode
             * @memberof CUserMsg_ParticleManager.FreezeParticleInvolving
             * @static
             * @param {CUserMsg_ParticleManager.IFreezeParticleInvolving} message FreezeParticleInvolving message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FreezeParticleInvolving.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.setFrozen != null && Object.hasOwnProperty.call(message, "setFrozen"))
                    writer.uint32(/* id 1, wireType 0 =*/8).bool(message.setFrozen);
                if (message.transitionDuration != null && Object.hasOwnProperty.call(message, "transitionDuration"))
                    writer.uint32(/* id 2, wireType 5 =*/21).float(message.transitionDuration);
                if (message.entityHandle != null && Object.hasOwnProperty.call(message, "entityHandle"))
                    writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.entityHandle);
                return writer;
            };
    
            /**
             * Encodes the specified FreezeParticleInvolving message, length delimited. Does not implicitly {@link CUserMsg_ParticleManager.FreezeParticleInvolving.verify|verify} messages.
             * @function encodeDelimited
             * @memberof CUserMsg_ParticleManager.FreezeParticleInvolving
             * @static
             * @param {CUserMsg_ParticleManager.IFreezeParticleInvolving} message FreezeParticleInvolving message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FreezeParticleInvolving.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a FreezeParticleInvolving message from the specified reader or buffer.
             * @function decode
             * @memberof CUserMsg_ParticleManager.FreezeParticleInvolving
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {CUserMsg_ParticleManager.FreezeParticleInvolving} FreezeParticleInvolving
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FreezeParticleInvolving.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CUserMsg_ParticleManager.FreezeParticleInvolving();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.setFrozen = reader.bool();
                            break;
                        }
                    case 2: {
                            message.transitionDuration = reader.float();
                            break;
                        }
                    case 3: {
                            message.entityHandle = reader.uint32();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a FreezeParticleInvolving message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof CUserMsg_ParticleManager.FreezeParticleInvolving
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {CUserMsg_ParticleManager.FreezeParticleInvolving} FreezeParticleInvolving
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FreezeParticleInvolving.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a FreezeParticleInvolving message.
             * @function verify
             * @memberof CUserMsg_ParticleManager.FreezeParticleInvolving
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            FreezeParticleInvolving.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.setFrozen != null && message.hasOwnProperty("setFrozen"))
                    if (typeof message.setFrozen !== "boolean")
                        return "setFrozen: boolean expected";
                if (message.transitionDuration != null && message.hasOwnProperty("transitionDuration"))
                    if (typeof message.transitionDuration !== "number")
                        return "transitionDuration: number expected";
                if (message.entityHandle != null && message.hasOwnProperty("entityHandle"))
                    if (!$util.isInteger(message.entityHandle))
                        return "entityHandle: integer expected";
                return null;
            };
    
            /**
             * Creates a FreezeParticleInvolving message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof CUserMsg_ParticleManager.FreezeParticleInvolving
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {CUserMsg_ParticleManager.FreezeParticleInvolving} FreezeParticleInvolving
             */
            FreezeParticleInvolving.fromObject = function fromObject(object) {
                if (object instanceof $root.CUserMsg_ParticleManager.FreezeParticleInvolving)
                    return object;
                var message = new $root.CUserMsg_ParticleManager.FreezeParticleInvolving();
                if (object.setFrozen != null)
                    message.setFrozen = Boolean(object.setFrozen);
                if (object.transitionDuration != null)
                    message.transitionDuration = Number(object.transitionDuration);
                if (object.entityHandle != null)
                    message.entityHandle = object.entityHandle >>> 0;
                return message;
            };
    
            /**
             * Creates a plain object from a FreezeParticleInvolving message. Also converts values to other types if specified.
             * @function toObject
             * @memberof CUserMsg_ParticleManager.FreezeParticleInvolving
             * @static
             * @param {CUserMsg_ParticleManager.FreezeParticleInvolving} message FreezeParticleInvolving
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            FreezeParticleInvolving.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.setFrozen = false;
                    object.transitionDuration = 0;
                    object.entityHandle = 16777215;
                }
                if (message.setFrozen != null && message.hasOwnProperty("setFrozen"))
                    object.setFrozen = message.setFrozen;
                if (message.transitionDuration != null && message.hasOwnProperty("transitionDuration"))
                    object.transitionDuration = options.json && !isFinite(message.transitionDuration) ? String(message.transitionDuration) : message.transitionDuration;
                if (message.entityHandle != null && message.hasOwnProperty("entityHandle"))
                    object.entityHandle = message.entityHandle;
                return object;
            };
    
            /**
             * Converts this FreezeParticleInvolving to JSON.
             * @function toJSON
             * @memberof CUserMsg_ParticleManager.FreezeParticleInvolving
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            FreezeParticleInvolving.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            /**
             * Gets the default type url for FreezeParticleInvolving
             * @function getTypeUrl
             * @memberof CUserMsg_ParticleManager.FreezeParticleInvolving
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            FreezeParticleInvolving.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/CUserMsg_ParticleManager.FreezeParticleInvolving";
            };
    
            return FreezeParticleInvolving;
        })();
    
        CUserMsg_ParticleManager.SetParticleNamedValueContext = (function() {
    
            /**
             * Properties of a SetParticleNamedValueContext.
             * @memberof CUserMsg_ParticleManager
             * @interface ISetParticleNamedValueContext
             * @property {Array.<CUserMsg_ParticleManager.SetParticleNamedValueContext.IFloatContextValue>|null} [floatValues] SetParticleNamedValueContext floatValues
             * @property {Array.<CUserMsg_ParticleManager.SetParticleNamedValueContext.IVectorContextValue>|null} [vectorValues] SetParticleNamedValueContext vectorValues
             * @property {Array.<CUserMsg_ParticleManager.SetParticleNamedValueContext.ITransformContextValue>|null} [transformValues] SetParticleNamedValueContext transformValues
             * @property {Array.<CUserMsg_ParticleManager.SetParticleNamedValueContext.IEHandleContext>|null} [ehandleValues] SetParticleNamedValueContext ehandleValues
             */
    
            /**
             * Constructs a new SetParticleNamedValueContext.
             * @memberof CUserMsg_ParticleManager
             * @classdesc Represents a SetParticleNamedValueContext.
             * @implements ISetParticleNamedValueContext
             * @constructor
             * @param {CUserMsg_ParticleManager.ISetParticleNamedValueContext=} [properties] Properties to set
             */
            function SetParticleNamedValueContext(properties) {
                this.floatValues = [];
                this.vectorValues = [];
                this.transformValues = [];
                this.ehandleValues = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * SetParticleNamedValueContext floatValues.
             * @member {Array.<CUserMsg_ParticleManager.SetParticleNamedValueContext.IFloatContextValue>} floatValues
             * @memberof CUserMsg_ParticleManager.SetParticleNamedValueContext
             * @instance
             */
            SetParticleNamedValueContext.prototype.floatValues = $util.emptyArray;
    
            /**
             * SetParticleNamedValueContext vectorValues.
             * @member {Array.<CUserMsg_ParticleManager.SetParticleNamedValueContext.IVectorContextValue>} vectorValues
             * @memberof CUserMsg_ParticleManager.SetParticleNamedValueContext
             * @instance
             */
            SetParticleNamedValueContext.prototype.vectorValues = $util.emptyArray;
    
            /**
             * SetParticleNamedValueContext transformValues.
             * @member {Array.<CUserMsg_ParticleManager.SetParticleNamedValueContext.ITransformContextValue>} transformValues
             * @memberof CUserMsg_ParticleManager.SetParticleNamedValueContext
             * @instance
             */
            SetParticleNamedValueContext.prototype.transformValues = $util.emptyArray;
    
            /**
             * SetParticleNamedValueContext ehandleValues.
             * @member {Array.<CUserMsg_ParticleManager.SetParticleNamedValueContext.IEHandleContext>} ehandleValues
             * @memberof CUserMsg_ParticleManager.SetParticleNamedValueContext
             * @instance
             */
            SetParticleNamedValueContext.prototype.ehandleValues = $util.emptyArray;
    
            /**
             * Creates a new SetParticleNamedValueContext instance using the specified properties.
             * @function create
             * @memberof CUserMsg_ParticleManager.SetParticleNamedValueContext
             * @static
             * @param {CUserMsg_ParticleManager.ISetParticleNamedValueContext=} [properties] Properties to set
             * @returns {CUserMsg_ParticleManager.SetParticleNamedValueContext} SetParticleNamedValueContext instance
             */
            SetParticleNamedValueContext.create = function create(properties) {
                return new SetParticleNamedValueContext(properties);
            };
    
            /**
             * Encodes the specified SetParticleNamedValueContext message. Does not implicitly {@link CUserMsg_ParticleManager.SetParticleNamedValueContext.verify|verify} messages.
             * @function encode
             * @memberof CUserMsg_ParticleManager.SetParticleNamedValueContext
             * @static
             * @param {CUserMsg_ParticleManager.ISetParticleNamedValueContext} message SetParticleNamedValueContext message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SetParticleNamedValueContext.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.floatValues != null && message.floatValues.length)
                    for (var i = 0; i < message.floatValues.length; ++i)
                        $root.CUserMsg_ParticleManager.SetParticleNamedValueContext.FloatContextValue.encode(message.floatValues[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.vectorValues != null && message.vectorValues.length)
                    for (var i = 0; i < message.vectorValues.length; ++i)
                        $root.CUserMsg_ParticleManager.SetParticleNamedValueContext.VectorContextValue.encode(message.vectorValues[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.transformValues != null && message.transformValues.length)
                    for (var i = 0; i < message.transformValues.length; ++i)
                        $root.CUserMsg_ParticleManager.SetParticleNamedValueContext.TransformContextValue.encode(message.transformValues[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.ehandleValues != null && message.ehandleValues.length)
                    for (var i = 0; i < message.ehandleValues.length; ++i)
                        $root.CUserMsg_ParticleManager.SetParticleNamedValueContext.EHandleContext.encode(message.ehandleValues[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                return writer;
            };
    
            /**
             * Encodes the specified SetParticleNamedValueContext message, length delimited. Does not implicitly {@link CUserMsg_ParticleManager.SetParticleNamedValueContext.verify|verify} messages.
             * @function encodeDelimited
             * @memberof CUserMsg_ParticleManager.SetParticleNamedValueContext
             * @static
             * @param {CUserMsg_ParticleManager.ISetParticleNamedValueContext} message SetParticleNamedValueContext message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SetParticleNamedValueContext.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a SetParticleNamedValueContext message from the specified reader or buffer.
             * @function decode
             * @memberof CUserMsg_ParticleManager.SetParticleNamedValueContext
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {CUserMsg_ParticleManager.SetParticleNamedValueContext} SetParticleNamedValueContext
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SetParticleNamedValueContext.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CUserMsg_ParticleManager.SetParticleNamedValueContext();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            if (!(message.floatValues && message.floatValues.length))
                                message.floatValues = [];
                            message.floatValues.push($root.CUserMsg_ParticleManager.SetParticleNamedValueContext.FloatContextValue.decode(reader, reader.uint32()));
                            break;
                        }
                    case 2: {
                            if (!(message.vectorValues && message.vectorValues.length))
                                message.vectorValues = [];
                            message.vectorValues.push($root.CUserMsg_ParticleManager.SetParticleNamedValueContext.VectorContextValue.decode(reader, reader.uint32()));
                            break;
                        }
                    case 3: {
                            if (!(message.transformValues && message.transformValues.length))
                                message.transformValues = [];
                            message.transformValues.push($root.CUserMsg_ParticleManager.SetParticleNamedValueContext.TransformContextValue.decode(reader, reader.uint32()));
                            break;
                        }
                    case 4: {
                            if (!(message.ehandleValues && message.ehandleValues.length))
                                message.ehandleValues = [];
                            message.ehandleValues.push($root.CUserMsg_ParticleManager.SetParticleNamedValueContext.EHandleContext.decode(reader, reader.uint32()));
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a SetParticleNamedValueContext message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof CUserMsg_ParticleManager.SetParticleNamedValueContext
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {CUserMsg_ParticleManager.SetParticleNamedValueContext} SetParticleNamedValueContext
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SetParticleNamedValueContext.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a SetParticleNamedValueContext message.
             * @function verify
             * @memberof CUserMsg_ParticleManager.SetParticleNamedValueContext
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SetParticleNamedValueContext.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.floatValues != null && message.hasOwnProperty("floatValues")) {
                    if (!Array.isArray(message.floatValues))
                        return "floatValues: array expected";
                    for (var i = 0; i < message.floatValues.length; ++i) {
                        var error = $root.CUserMsg_ParticleManager.SetParticleNamedValueContext.FloatContextValue.verify(message.floatValues[i]);
                        if (error)
                            return "floatValues." + error;
                    }
                }
                if (message.vectorValues != null && message.hasOwnProperty("vectorValues")) {
                    if (!Array.isArray(message.vectorValues))
                        return "vectorValues: array expected";
                    for (var i = 0; i < message.vectorValues.length; ++i) {
                        var error = $root.CUserMsg_ParticleManager.SetParticleNamedValueContext.VectorContextValue.verify(message.vectorValues[i]);
                        if (error)
                            return "vectorValues." + error;
                    }
                }
                if (message.transformValues != null && message.hasOwnProperty("transformValues")) {
                    if (!Array.isArray(message.transformValues))
                        return "transformValues: array expected";
                    for (var i = 0; i < message.transformValues.length; ++i) {
                        var error = $root.CUserMsg_ParticleManager.SetParticleNamedValueContext.TransformContextValue.verify(message.transformValues[i]);
                        if (error)
                            return "transformValues." + error;
                    }
                }
                if (message.ehandleValues != null && message.hasOwnProperty("ehandleValues")) {
                    if (!Array.isArray(message.ehandleValues))
                        return "ehandleValues: array expected";
                    for (var i = 0; i < message.ehandleValues.length; ++i) {
                        var error = $root.CUserMsg_ParticleManager.SetParticleNamedValueContext.EHandleContext.verify(message.ehandleValues[i]);
                        if (error)
                            return "ehandleValues." + error;
                    }
                }
                return null;
            };
    
            /**
             * Creates a SetParticleNamedValueContext message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof CUserMsg_ParticleManager.SetParticleNamedValueContext
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {CUserMsg_ParticleManager.SetParticleNamedValueContext} SetParticleNamedValueContext
             */
            SetParticleNamedValueContext.fromObject = function fromObject(object) {
                if (object instanceof $root.CUserMsg_ParticleManager.SetParticleNamedValueContext)
                    return object;
                var message = new $root.CUserMsg_ParticleManager.SetParticleNamedValueContext();
                if (object.floatValues) {
                    if (!Array.isArray(object.floatValues))
                        throw TypeError(".CUserMsg_ParticleManager.SetParticleNamedValueContext.floatValues: array expected");
                    message.floatValues = [];
                    for (var i = 0; i < object.floatValues.length; ++i) {
                        if (typeof object.floatValues[i] !== "object")
                            throw TypeError(".CUserMsg_ParticleManager.SetParticleNamedValueContext.floatValues: object expected");
                        message.floatValues[i] = $root.CUserMsg_ParticleManager.SetParticleNamedValueContext.FloatContextValue.fromObject(object.floatValues[i]);
                    }
                }
                if (object.vectorValues) {
                    if (!Array.isArray(object.vectorValues))
                        throw TypeError(".CUserMsg_ParticleManager.SetParticleNamedValueContext.vectorValues: array expected");
                    message.vectorValues = [];
                    for (var i = 0; i < object.vectorValues.length; ++i) {
                        if (typeof object.vectorValues[i] !== "object")
                            throw TypeError(".CUserMsg_ParticleManager.SetParticleNamedValueContext.vectorValues: object expected");
                        message.vectorValues[i] = $root.CUserMsg_ParticleManager.SetParticleNamedValueContext.VectorContextValue.fromObject(object.vectorValues[i]);
                    }
                }
                if (object.transformValues) {
                    if (!Array.isArray(object.transformValues))
                        throw TypeError(".CUserMsg_ParticleManager.SetParticleNamedValueContext.transformValues: array expected");
                    message.transformValues = [];
                    for (var i = 0; i < object.transformValues.length; ++i) {
                        if (typeof object.transformValues[i] !== "object")
                            throw TypeError(".CUserMsg_ParticleManager.SetParticleNamedValueContext.transformValues: object expected");
                        message.transformValues[i] = $root.CUserMsg_ParticleManager.SetParticleNamedValueContext.TransformContextValue.fromObject(object.transformValues[i]);
                    }
                }
                if (object.ehandleValues) {
                    if (!Array.isArray(object.ehandleValues))
                        throw TypeError(".CUserMsg_ParticleManager.SetParticleNamedValueContext.ehandleValues: array expected");
                    message.ehandleValues = [];
                    for (var i = 0; i < object.ehandleValues.length; ++i) {
                        if (typeof object.ehandleValues[i] !== "object")
                            throw TypeError(".CUserMsg_ParticleManager.SetParticleNamedValueContext.ehandleValues: object expected");
                        message.ehandleValues[i] = $root.CUserMsg_ParticleManager.SetParticleNamedValueContext.EHandleContext.fromObject(object.ehandleValues[i]);
                    }
                }
                return message;
            };
    
            /**
             * Creates a plain object from a SetParticleNamedValueContext message. Also converts values to other types if specified.
             * @function toObject
             * @memberof CUserMsg_ParticleManager.SetParticleNamedValueContext
             * @static
             * @param {CUserMsg_ParticleManager.SetParticleNamedValueContext} message SetParticleNamedValueContext
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SetParticleNamedValueContext.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults) {
                    object.floatValues = [];
                    object.vectorValues = [];
                    object.transformValues = [];
                    object.ehandleValues = [];
                }
                if (message.floatValues && message.floatValues.length) {
                    object.floatValues = [];
                    for (var j = 0; j < message.floatValues.length; ++j)
                        object.floatValues[j] = $root.CUserMsg_ParticleManager.SetParticleNamedValueContext.FloatContextValue.toObject(message.floatValues[j], options);
                }
                if (message.vectorValues && message.vectorValues.length) {
                    object.vectorValues = [];
                    for (var j = 0; j < message.vectorValues.length; ++j)
                        object.vectorValues[j] = $root.CUserMsg_ParticleManager.SetParticleNamedValueContext.VectorContextValue.toObject(message.vectorValues[j], options);
                }
                if (message.transformValues && message.transformValues.length) {
                    object.transformValues = [];
                    for (var j = 0; j < message.transformValues.length; ++j)
                        object.transformValues[j] = $root.CUserMsg_ParticleManager.SetParticleNamedValueContext.TransformContextValue.toObject(message.transformValues[j], options);
                }
                if (message.ehandleValues && message.ehandleValues.length) {
                    object.ehandleValues = [];
                    for (var j = 0; j < message.ehandleValues.length; ++j)
                        object.ehandleValues[j] = $root.CUserMsg_ParticleManager.SetParticleNamedValueContext.EHandleContext.toObject(message.ehandleValues[j], options);
                }
                return object;
            };
    
            /**
             * Converts this SetParticleNamedValueContext to JSON.
             * @function toJSON
             * @memberof CUserMsg_ParticleManager.SetParticleNamedValueContext
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            SetParticleNamedValueContext.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            /**
             * Gets the default type url for SetParticleNamedValueContext
             * @function getTypeUrl
             * @memberof CUserMsg_ParticleManager.SetParticleNamedValueContext
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            SetParticleNamedValueContext.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/CUserMsg_ParticleManager.SetParticleNamedValueContext";
            };
    
            SetParticleNamedValueContext.FloatContextValue = (function() {
    
                /**
                 * Properties of a FloatContextValue.
                 * @memberof CUserMsg_ParticleManager.SetParticleNamedValueContext
                 * @interface IFloatContextValue
                 * @property {number|null} [valueNameHash] FloatContextValue valueNameHash
                 * @property {number|null} [value] FloatContextValue value
                 */
    
                /**
                 * Constructs a new FloatContextValue.
                 * @memberof CUserMsg_ParticleManager.SetParticleNamedValueContext
                 * @classdesc Represents a FloatContextValue.
                 * @implements IFloatContextValue
                 * @constructor
                 * @param {CUserMsg_ParticleManager.SetParticleNamedValueContext.IFloatContextValue=} [properties] Properties to set
                 */
                function FloatContextValue(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * FloatContextValue valueNameHash.
                 * @member {number} valueNameHash
                 * @memberof CUserMsg_ParticleManager.SetParticleNamedValueContext.FloatContextValue
                 * @instance
                 */
                FloatContextValue.prototype.valueNameHash = 0;
    
                /**
                 * FloatContextValue value.
                 * @member {number} value
                 * @memberof CUserMsg_ParticleManager.SetParticleNamedValueContext.FloatContextValue
                 * @instance
                 */
                FloatContextValue.prototype.value = 0;
    
                /**
                 * Creates a new FloatContextValue instance using the specified properties.
                 * @function create
                 * @memberof CUserMsg_ParticleManager.SetParticleNamedValueContext.FloatContextValue
                 * @static
                 * @param {CUserMsg_ParticleManager.SetParticleNamedValueContext.IFloatContextValue=} [properties] Properties to set
                 * @returns {CUserMsg_ParticleManager.SetParticleNamedValueContext.FloatContextValue} FloatContextValue instance
                 */
                FloatContextValue.create = function create(properties) {
                    return new FloatContextValue(properties);
                };
    
                /**
                 * Encodes the specified FloatContextValue message. Does not implicitly {@link CUserMsg_ParticleManager.SetParticleNamedValueContext.FloatContextValue.verify|verify} messages.
                 * @function encode
                 * @memberof CUserMsg_ParticleManager.SetParticleNamedValueContext.FloatContextValue
                 * @static
                 * @param {CUserMsg_ParticleManager.SetParticleNamedValueContext.IFloatContextValue} message FloatContextValue message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                FloatContextValue.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.valueNameHash != null && Object.hasOwnProperty.call(message, "valueNameHash"))
                        writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.valueNameHash);
                    if (message.value != null && Object.hasOwnProperty.call(message, "value"))
                        writer.uint32(/* id 2, wireType 5 =*/21).float(message.value);
                    return writer;
                };
    
                /**
                 * Encodes the specified FloatContextValue message, length delimited. Does not implicitly {@link CUserMsg_ParticleManager.SetParticleNamedValueContext.FloatContextValue.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof CUserMsg_ParticleManager.SetParticleNamedValueContext.FloatContextValue
                 * @static
                 * @param {CUserMsg_ParticleManager.SetParticleNamedValueContext.IFloatContextValue} message FloatContextValue message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                FloatContextValue.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a FloatContextValue message from the specified reader or buffer.
                 * @function decode
                 * @memberof CUserMsg_ParticleManager.SetParticleNamedValueContext.FloatContextValue
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {CUserMsg_ParticleManager.SetParticleNamedValueContext.FloatContextValue} FloatContextValue
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                FloatContextValue.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CUserMsg_ParticleManager.SetParticleNamedValueContext.FloatContextValue();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1: {
                                message.valueNameHash = reader.uint32();
                                break;
                            }
                        case 2: {
                                message.value = reader.float();
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a FloatContextValue message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof CUserMsg_ParticleManager.SetParticleNamedValueContext.FloatContextValue
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {CUserMsg_ParticleManager.SetParticleNamedValueContext.FloatContextValue} FloatContextValue
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                FloatContextValue.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a FloatContextValue message.
                 * @function verify
                 * @memberof CUserMsg_ParticleManager.SetParticleNamedValueContext.FloatContextValue
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                FloatContextValue.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.valueNameHash != null && message.hasOwnProperty("valueNameHash"))
                        if (!$util.isInteger(message.valueNameHash))
                            return "valueNameHash: integer expected";
                    if (message.value != null && message.hasOwnProperty("value"))
                        if (typeof message.value !== "number")
                            return "value: number expected";
                    return null;
                };
    
                /**
                 * Creates a FloatContextValue message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof CUserMsg_ParticleManager.SetParticleNamedValueContext.FloatContextValue
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {CUserMsg_ParticleManager.SetParticleNamedValueContext.FloatContextValue} FloatContextValue
                 */
                FloatContextValue.fromObject = function fromObject(object) {
                    if (object instanceof $root.CUserMsg_ParticleManager.SetParticleNamedValueContext.FloatContextValue)
                        return object;
                    var message = new $root.CUserMsg_ParticleManager.SetParticleNamedValueContext.FloatContextValue();
                    if (object.valueNameHash != null)
                        message.valueNameHash = object.valueNameHash >>> 0;
                    if (object.value != null)
                        message.value = Number(object.value);
                    return message;
                };
    
                /**
                 * Creates a plain object from a FloatContextValue message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof CUserMsg_ParticleManager.SetParticleNamedValueContext.FloatContextValue
                 * @static
                 * @param {CUserMsg_ParticleManager.SetParticleNamedValueContext.FloatContextValue} message FloatContextValue
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                FloatContextValue.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.valueNameHash = 0;
                        object.value = 0;
                    }
                    if (message.valueNameHash != null && message.hasOwnProperty("valueNameHash"))
                        object.valueNameHash = message.valueNameHash;
                    if (message.value != null && message.hasOwnProperty("value"))
                        object.value = options.json && !isFinite(message.value) ? String(message.value) : message.value;
                    return object;
                };
    
                /**
                 * Converts this FloatContextValue to JSON.
                 * @function toJSON
                 * @memberof CUserMsg_ParticleManager.SetParticleNamedValueContext.FloatContextValue
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                FloatContextValue.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                /**
                 * Gets the default type url for FloatContextValue
                 * @function getTypeUrl
                 * @memberof CUserMsg_ParticleManager.SetParticleNamedValueContext.FloatContextValue
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                FloatContextValue.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/CUserMsg_ParticleManager.SetParticleNamedValueContext.FloatContextValue";
                };
    
                return FloatContextValue;
            })();
    
            SetParticleNamedValueContext.VectorContextValue = (function() {
    
                /**
                 * Properties of a VectorContextValue.
                 * @memberof CUserMsg_ParticleManager.SetParticleNamedValueContext
                 * @interface IVectorContextValue
                 * @property {number|null} [valueNameHash] VectorContextValue valueNameHash
                 * @property {ICMsgVector|null} [value] VectorContextValue value
                 */
    
                /**
                 * Constructs a new VectorContextValue.
                 * @memberof CUserMsg_ParticleManager.SetParticleNamedValueContext
                 * @classdesc Represents a VectorContextValue.
                 * @implements IVectorContextValue
                 * @constructor
                 * @param {CUserMsg_ParticleManager.SetParticleNamedValueContext.IVectorContextValue=} [properties] Properties to set
                 */
                function VectorContextValue(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * VectorContextValue valueNameHash.
                 * @member {number} valueNameHash
                 * @memberof CUserMsg_ParticleManager.SetParticleNamedValueContext.VectorContextValue
                 * @instance
                 */
                VectorContextValue.prototype.valueNameHash = 0;
    
                /**
                 * VectorContextValue value.
                 * @member {ICMsgVector|null|undefined} value
                 * @memberof CUserMsg_ParticleManager.SetParticleNamedValueContext.VectorContextValue
                 * @instance
                 */
                VectorContextValue.prototype.value = null;
    
                /**
                 * Creates a new VectorContextValue instance using the specified properties.
                 * @function create
                 * @memberof CUserMsg_ParticleManager.SetParticleNamedValueContext.VectorContextValue
                 * @static
                 * @param {CUserMsg_ParticleManager.SetParticleNamedValueContext.IVectorContextValue=} [properties] Properties to set
                 * @returns {CUserMsg_ParticleManager.SetParticleNamedValueContext.VectorContextValue} VectorContextValue instance
                 */
                VectorContextValue.create = function create(properties) {
                    return new VectorContextValue(properties);
                };
    
                /**
                 * Encodes the specified VectorContextValue message. Does not implicitly {@link CUserMsg_ParticleManager.SetParticleNamedValueContext.VectorContextValue.verify|verify} messages.
                 * @function encode
                 * @memberof CUserMsg_ParticleManager.SetParticleNamedValueContext.VectorContextValue
                 * @static
                 * @param {CUserMsg_ParticleManager.SetParticleNamedValueContext.IVectorContextValue} message VectorContextValue message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                VectorContextValue.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.valueNameHash != null && Object.hasOwnProperty.call(message, "valueNameHash"))
                        writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.valueNameHash);
                    if (message.value != null && Object.hasOwnProperty.call(message, "value"))
                        $root.CMsgVector.encode(message.value, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified VectorContextValue message, length delimited. Does not implicitly {@link CUserMsg_ParticleManager.SetParticleNamedValueContext.VectorContextValue.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof CUserMsg_ParticleManager.SetParticleNamedValueContext.VectorContextValue
                 * @static
                 * @param {CUserMsg_ParticleManager.SetParticleNamedValueContext.IVectorContextValue} message VectorContextValue message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                VectorContextValue.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a VectorContextValue message from the specified reader or buffer.
                 * @function decode
                 * @memberof CUserMsg_ParticleManager.SetParticleNamedValueContext.VectorContextValue
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {CUserMsg_ParticleManager.SetParticleNamedValueContext.VectorContextValue} VectorContextValue
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                VectorContextValue.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CUserMsg_ParticleManager.SetParticleNamedValueContext.VectorContextValue();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1: {
                                message.valueNameHash = reader.uint32();
                                break;
                            }
                        case 2: {
                                message.value = $root.CMsgVector.decode(reader, reader.uint32());
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a VectorContextValue message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof CUserMsg_ParticleManager.SetParticleNamedValueContext.VectorContextValue
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {CUserMsg_ParticleManager.SetParticleNamedValueContext.VectorContextValue} VectorContextValue
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                VectorContextValue.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a VectorContextValue message.
                 * @function verify
                 * @memberof CUserMsg_ParticleManager.SetParticleNamedValueContext.VectorContextValue
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                VectorContextValue.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.valueNameHash != null && message.hasOwnProperty("valueNameHash"))
                        if (!$util.isInteger(message.valueNameHash))
                            return "valueNameHash: integer expected";
                    if (message.value != null && message.hasOwnProperty("value")) {
                        var error = $root.CMsgVector.verify(message.value);
                        if (error)
                            return "value." + error;
                    }
                    return null;
                };
    
                /**
                 * Creates a VectorContextValue message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof CUserMsg_ParticleManager.SetParticleNamedValueContext.VectorContextValue
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {CUserMsg_ParticleManager.SetParticleNamedValueContext.VectorContextValue} VectorContextValue
                 */
                VectorContextValue.fromObject = function fromObject(object) {
                    if (object instanceof $root.CUserMsg_ParticleManager.SetParticleNamedValueContext.VectorContextValue)
                        return object;
                    var message = new $root.CUserMsg_ParticleManager.SetParticleNamedValueContext.VectorContextValue();
                    if (object.valueNameHash != null)
                        message.valueNameHash = object.valueNameHash >>> 0;
                    if (object.value != null) {
                        if (typeof object.value !== "object")
                            throw TypeError(".CUserMsg_ParticleManager.SetParticleNamedValueContext.VectorContextValue.value: object expected");
                        message.value = $root.CMsgVector.fromObject(object.value);
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a VectorContextValue message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof CUserMsg_ParticleManager.SetParticleNamedValueContext.VectorContextValue
                 * @static
                 * @param {CUserMsg_ParticleManager.SetParticleNamedValueContext.VectorContextValue} message VectorContextValue
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                VectorContextValue.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.valueNameHash = 0;
                        object.value = null;
                    }
                    if (message.valueNameHash != null && message.hasOwnProperty("valueNameHash"))
                        object.valueNameHash = message.valueNameHash;
                    if (message.value != null && message.hasOwnProperty("value"))
                        object.value = $root.CMsgVector.toObject(message.value, options);
                    return object;
                };
    
                /**
                 * Converts this VectorContextValue to JSON.
                 * @function toJSON
                 * @memberof CUserMsg_ParticleManager.SetParticleNamedValueContext.VectorContextValue
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                VectorContextValue.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                /**
                 * Gets the default type url for VectorContextValue
                 * @function getTypeUrl
                 * @memberof CUserMsg_ParticleManager.SetParticleNamedValueContext.VectorContextValue
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                VectorContextValue.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/CUserMsg_ParticleManager.SetParticleNamedValueContext.VectorContextValue";
                };
    
                return VectorContextValue;
            })();
    
            SetParticleNamedValueContext.TransformContextValue = (function() {
    
                /**
                 * Properties of a TransformContextValue.
                 * @memberof CUserMsg_ParticleManager.SetParticleNamedValueContext
                 * @interface ITransformContextValue
                 * @property {number|null} [valueNameHash] TransformContextValue valueNameHash
                 * @property {ICMsgQAngle|null} [angles] TransformContextValue angles
                 * @property {ICMsgVector|null} [translation] TransformContextValue translation
                 */
    
                /**
                 * Constructs a new TransformContextValue.
                 * @memberof CUserMsg_ParticleManager.SetParticleNamedValueContext
                 * @classdesc Represents a TransformContextValue.
                 * @implements ITransformContextValue
                 * @constructor
                 * @param {CUserMsg_ParticleManager.SetParticleNamedValueContext.ITransformContextValue=} [properties] Properties to set
                 */
                function TransformContextValue(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * TransformContextValue valueNameHash.
                 * @member {number} valueNameHash
                 * @memberof CUserMsg_ParticleManager.SetParticleNamedValueContext.TransformContextValue
                 * @instance
                 */
                TransformContextValue.prototype.valueNameHash = 0;
    
                /**
                 * TransformContextValue angles.
                 * @member {ICMsgQAngle|null|undefined} angles
                 * @memberof CUserMsg_ParticleManager.SetParticleNamedValueContext.TransformContextValue
                 * @instance
                 */
                TransformContextValue.prototype.angles = null;
    
                /**
                 * TransformContextValue translation.
                 * @member {ICMsgVector|null|undefined} translation
                 * @memberof CUserMsg_ParticleManager.SetParticleNamedValueContext.TransformContextValue
                 * @instance
                 */
                TransformContextValue.prototype.translation = null;
    
                /**
                 * Creates a new TransformContextValue instance using the specified properties.
                 * @function create
                 * @memberof CUserMsg_ParticleManager.SetParticleNamedValueContext.TransformContextValue
                 * @static
                 * @param {CUserMsg_ParticleManager.SetParticleNamedValueContext.ITransformContextValue=} [properties] Properties to set
                 * @returns {CUserMsg_ParticleManager.SetParticleNamedValueContext.TransformContextValue} TransformContextValue instance
                 */
                TransformContextValue.create = function create(properties) {
                    return new TransformContextValue(properties);
                };
    
                /**
                 * Encodes the specified TransformContextValue message. Does not implicitly {@link CUserMsg_ParticleManager.SetParticleNamedValueContext.TransformContextValue.verify|verify} messages.
                 * @function encode
                 * @memberof CUserMsg_ParticleManager.SetParticleNamedValueContext.TransformContextValue
                 * @static
                 * @param {CUserMsg_ParticleManager.SetParticleNamedValueContext.ITransformContextValue} message TransformContextValue message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                TransformContextValue.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.valueNameHash != null && Object.hasOwnProperty.call(message, "valueNameHash"))
                        writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.valueNameHash);
                    if (message.angles != null && Object.hasOwnProperty.call(message, "angles"))
                        $root.CMsgQAngle.encode(message.angles, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    if (message.translation != null && Object.hasOwnProperty.call(message, "translation"))
                        $root.CMsgVector.encode(message.translation, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified TransformContextValue message, length delimited. Does not implicitly {@link CUserMsg_ParticleManager.SetParticleNamedValueContext.TransformContextValue.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof CUserMsg_ParticleManager.SetParticleNamedValueContext.TransformContextValue
                 * @static
                 * @param {CUserMsg_ParticleManager.SetParticleNamedValueContext.ITransformContextValue} message TransformContextValue message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                TransformContextValue.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a TransformContextValue message from the specified reader or buffer.
                 * @function decode
                 * @memberof CUserMsg_ParticleManager.SetParticleNamedValueContext.TransformContextValue
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {CUserMsg_ParticleManager.SetParticleNamedValueContext.TransformContextValue} TransformContextValue
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                TransformContextValue.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CUserMsg_ParticleManager.SetParticleNamedValueContext.TransformContextValue();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1: {
                                message.valueNameHash = reader.uint32();
                                break;
                            }
                        case 2: {
                                message.angles = $root.CMsgQAngle.decode(reader, reader.uint32());
                                break;
                            }
                        case 3: {
                                message.translation = $root.CMsgVector.decode(reader, reader.uint32());
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a TransformContextValue message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof CUserMsg_ParticleManager.SetParticleNamedValueContext.TransformContextValue
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {CUserMsg_ParticleManager.SetParticleNamedValueContext.TransformContextValue} TransformContextValue
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                TransformContextValue.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a TransformContextValue message.
                 * @function verify
                 * @memberof CUserMsg_ParticleManager.SetParticleNamedValueContext.TransformContextValue
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                TransformContextValue.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.valueNameHash != null && message.hasOwnProperty("valueNameHash"))
                        if (!$util.isInteger(message.valueNameHash))
                            return "valueNameHash: integer expected";
                    if (message.angles != null && message.hasOwnProperty("angles")) {
                        var error = $root.CMsgQAngle.verify(message.angles);
                        if (error)
                            return "angles." + error;
                    }
                    if (message.translation != null && message.hasOwnProperty("translation")) {
                        var error = $root.CMsgVector.verify(message.translation);
                        if (error)
                            return "translation." + error;
                    }
                    return null;
                };
    
                /**
                 * Creates a TransformContextValue message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof CUserMsg_ParticleManager.SetParticleNamedValueContext.TransformContextValue
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {CUserMsg_ParticleManager.SetParticleNamedValueContext.TransformContextValue} TransformContextValue
                 */
                TransformContextValue.fromObject = function fromObject(object) {
                    if (object instanceof $root.CUserMsg_ParticleManager.SetParticleNamedValueContext.TransformContextValue)
                        return object;
                    var message = new $root.CUserMsg_ParticleManager.SetParticleNamedValueContext.TransformContextValue();
                    if (object.valueNameHash != null)
                        message.valueNameHash = object.valueNameHash >>> 0;
                    if (object.angles != null) {
                        if (typeof object.angles !== "object")
                            throw TypeError(".CUserMsg_ParticleManager.SetParticleNamedValueContext.TransformContextValue.angles: object expected");
                        message.angles = $root.CMsgQAngle.fromObject(object.angles);
                    }
                    if (object.translation != null) {
                        if (typeof object.translation !== "object")
                            throw TypeError(".CUserMsg_ParticleManager.SetParticleNamedValueContext.TransformContextValue.translation: object expected");
                        message.translation = $root.CMsgVector.fromObject(object.translation);
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a TransformContextValue message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof CUserMsg_ParticleManager.SetParticleNamedValueContext.TransformContextValue
                 * @static
                 * @param {CUserMsg_ParticleManager.SetParticleNamedValueContext.TransformContextValue} message TransformContextValue
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                TransformContextValue.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.valueNameHash = 0;
                        object.angles = null;
                        object.translation = null;
                    }
                    if (message.valueNameHash != null && message.hasOwnProperty("valueNameHash"))
                        object.valueNameHash = message.valueNameHash;
                    if (message.angles != null && message.hasOwnProperty("angles"))
                        object.angles = $root.CMsgQAngle.toObject(message.angles, options);
                    if (message.translation != null && message.hasOwnProperty("translation"))
                        object.translation = $root.CMsgVector.toObject(message.translation, options);
                    return object;
                };
    
                /**
                 * Converts this TransformContextValue to JSON.
                 * @function toJSON
                 * @memberof CUserMsg_ParticleManager.SetParticleNamedValueContext.TransformContextValue
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                TransformContextValue.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                /**
                 * Gets the default type url for TransformContextValue
                 * @function getTypeUrl
                 * @memberof CUserMsg_ParticleManager.SetParticleNamedValueContext.TransformContextValue
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                TransformContextValue.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/CUserMsg_ParticleManager.SetParticleNamedValueContext.TransformContextValue";
                };
    
                return TransformContextValue;
            })();
    
            SetParticleNamedValueContext.EHandleContext = (function() {
    
                /**
                 * Properties of a EHandleContext.
                 * @memberof CUserMsg_ParticleManager.SetParticleNamedValueContext
                 * @interface IEHandleContext
                 * @property {number|null} [valueNameHash] EHandleContext valueNameHash
                 * @property {number|null} [entIndex] EHandleContext entIndex
                 */
    
                /**
                 * Constructs a new EHandleContext.
                 * @memberof CUserMsg_ParticleManager.SetParticleNamedValueContext
                 * @classdesc Represents a EHandleContext.
                 * @implements IEHandleContext
                 * @constructor
                 * @param {CUserMsg_ParticleManager.SetParticleNamedValueContext.IEHandleContext=} [properties] Properties to set
                 */
                function EHandleContext(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * EHandleContext valueNameHash.
                 * @member {number} valueNameHash
                 * @memberof CUserMsg_ParticleManager.SetParticleNamedValueContext.EHandleContext
                 * @instance
                 */
                EHandleContext.prototype.valueNameHash = 0;
    
                /**
                 * EHandleContext entIndex.
                 * @member {number} entIndex
                 * @memberof CUserMsg_ParticleManager.SetParticleNamedValueContext.EHandleContext
                 * @instance
                 */
                EHandleContext.prototype.entIndex = 16777215;
    
                /**
                 * Creates a new EHandleContext instance using the specified properties.
                 * @function create
                 * @memberof CUserMsg_ParticleManager.SetParticleNamedValueContext.EHandleContext
                 * @static
                 * @param {CUserMsg_ParticleManager.SetParticleNamedValueContext.IEHandleContext=} [properties] Properties to set
                 * @returns {CUserMsg_ParticleManager.SetParticleNamedValueContext.EHandleContext} EHandleContext instance
                 */
                EHandleContext.create = function create(properties) {
                    return new EHandleContext(properties);
                };
    
                /**
                 * Encodes the specified EHandleContext message. Does not implicitly {@link CUserMsg_ParticleManager.SetParticleNamedValueContext.EHandleContext.verify|verify} messages.
                 * @function encode
                 * @memberof CUserMsg_ParticleManager.SetParticleNamedValueContext.EHandleContext
                 * @static
                 * @param {CUserMsg_ParticleManager.SetParticleNamedValueContext.IEHandleContext} message EHandleContext message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                EHandleContext.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.valueNameHash != null && Object.hasOwnProperty.call(message, "valueNameHash"))
                        writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.valueNameHash);
                    if (message.entIndex != null && Object.hasOwnProperty.call(message, "entIndex"))
                        writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.entIndex);
                    return writer;
                };
    
                /**
                 * Encodes the specified EHandleContext message, length delimited. Does not implicitly {@link CUserMsg_ParticleManager.SetParticleNamedValueContext.EHandleContext.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof CUserMsg_ParticleManager.SetParticleNamedValueContext.EHandleContext
                 * @static
                 * @param {CUserMsg_ParticleManager.SetParticleNamedValueContext.IEHandleContext} message EHandleContext message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                EHandleContext.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a EHandleContext message from the specified reader or buffer.
                 * @function decode
                 * @memberof CUserMsg_ParticleManager.SetParticleNamedValueContext.EHandleContext
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {CUserMsg_ParticleManager.SetParticleNamedValueContext.EHandleContext} EHandleContext
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                EHandleContext.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CUserMsg_ParticleManager.SetParticleNamedValueContext.EHandleContext();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1: {
                                message.valueNameHash = reader.uint32();
                                break;
                            }
                        case 2: {
                                message.entIndex = reader.uint32();
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a EHandleContext message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof CUserMsg_ParticleManager.SetParticleNamedValueContext.EHandleContext
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {CUserMsg_ParticleManager.SetParticleNamedValueContext.EHandleContext} EHandleContext
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                EHandleContext.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a EHandleContext message.
                 * @function verify
                 * @memberof CUserMsg_ParticleManager.SetParticleNamedValueContext.EHandleContext
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                EHandleContext.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.valueNameHash != null && message.hasOwnProperty("valueNameHash"))
                        if (!$util.isInteger(message.valueNameHash))
                            return "valueNameHash: integer expected";
                    if (message.entIndex != null && message.hasOwnProperty("entIndex"))
                        if (!$util.isInteger(message.entIndex))
                            return "entIndex: integer expected";
                    return null;
                };
    
                /**
                 * Creates a EHandleContext message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof CUserMsg_ParticleManager.SetParticleNamedValueContext.EHandleContext
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {CUserMsg_ParticleManager.SetParticleNamedValueContext.EHandleContext} EHandleContext
                 */
                EHandleContext.fromObject = function fromObject(object) {
                    if (object instanceof $root.CUserMsg_ParticleManager.SetParticleNamedValueContext.EHandleContext)
                        return object;
                    var message = new $root.CUserMsg_ParticleManager.SetParticleNamedValueContext.EHandleContext();
                    if (object.valueNameHash != null)
                        message.valueNameHash = object.valueNameHash >>> 0;
                    if (object.entIndex != null)
                        message.entIndex = object.entIndex >>> 0;
                    return message;
                };
    
                /**
                 * Creates a plain object from a EHandleContext message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof CUserMsg_ParticleManager.SetParticleNamedValueContext.EHandleContext
                 * @static
                 * @param {CUserMsg_ParticleManager.SetParticleNamedValueContext.EHandleContext} message EHandleContext
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                EHandleContext.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.valueNameHash = 0;
                        object.entIndex = 16777215;
                    }
                    if (message.valueNameHash != null && message.hasOwnProperty("valueNameHash"))
                        object.valueNameHash = message.valueNameHash;
                    if (message.entIndex != null && message.hasOwnProperty("entIndex"))
                        object.entIndex = message.entIndex;
                    return object;
                };
    
                /**
                 * Converts this EHandleContext to JSON.
                 * @function toJSON
                 * @memberof CUserMsg_ParticleManager.SetParticleNamedValueContext.EHandleContext
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                EHandleContext.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                /**
                 * Gets the default type url for EHandleContext
                 * @function getTypeUrl
                 * @memberof CUserMsg_ParticleManager.SetParticleNamedValueContext.EHandleContext
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                EHandleContext.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/CUserMsg_ParticleManager.SetParticleNamedValueContext.EHandleContext";
                };
    
                return EHandleContext;
            })();
    
            return SetParticleNamedValueContext;
        })();
    
        return CUserMsg_ParticleManager;
    })();
    
    $root.CUserMsg_HudError = (function() {
    
        /**
         * Properties of a CUserMsg_HudError.
         * @exports ICUserMsg_HudError
         * @interface ICUserMsg_HudError
         * @property {number|null} [orderId] CUserMsg_HudError orderId
         */
    
        /**
         * Constructs a new CUserMsg_HudError.
         * @exports CUserMsg_HudError
         * @classdesc Represents a CUserMsg_HudError.
         * @implements ICUserMsg_HudError
         * @constructor
         * @param {ICUserMsg_HudError=} [properties] Properties to set
         */
        function CUserMsg_HudError(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CUserMsg_HudError orderId.
         * @member {number} orderId
         * @memberof CUserMsg_HudError
         * @instance
         */
        CUserMsg_HudError.prototype.orderId = 0;
    
        /**
         * Creates a new CUserMsg_HudError instance using the specified properties.
         * @function create
         * @memberof CUserMsg_HudError
         * @static
         * @param {ICUserMsg_HudError=} [properties] Properties to set
         * @returns {CUserMsg_HudError} CUserMsg_HudError instance
         */
        CUserMsg_HudError.create = function create(properties) {
            return new CUserMsg_HudError(properties);
        };
    
        /**
         * Encodes the specified CUserMsg_HudError message. Does not implicitly {@link CUserMsg_HudError.verify|verify} messages.
         * @function encode
         * @memberof CUserMsg_HudError
         * @static
         * @param {ICUserMsg_HudError} message CUserMsg_HudError message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CUserMsg_HudError.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.orderId != null && Object.hasOwnProperty.call(message, "orderId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.orderId);
            return writer;
        };
    
        /**
         * Encodes the specified CUserMsg_HudError message, length delimited. Does not implicitly {@link CUserMsg_HudError.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CUserMsg_HudError
         * @static
         * @param {ICUserMsg_HudError} message CUserMsg_HudError message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CUserMsg_HudError.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CUserMsg_HudError message from the specified reader or buffer.
         * @function decode
         * @memberof CUserMsg_HudError
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CUserMsg_HudError} CUserMsg_HudError
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CUserMsg_HudError.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CUserMsg_HudError();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.orderId = reader.int32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CUserMsg_HudError message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CUserMsg_HudError
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CUserMsg_HudError} CUserMsg_HudError
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CUserMsg_HudError.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CUserMsg_HudError message.
         * @function verify
         * @memberof CUserMsg_HudError
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CUserMsg_HudError.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.orderId != null && message.hasOwnProperty("orderId"))
                if (!$util.isInteger(message.orderId))
                    return "orderId: integer expected";
            return null;
        };
    
        /**
         * Creates a CUserMsg_HudError message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CUserMsg_HudError
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CUserMsg_HudError} CUserMsg_HudError
         */
        CUserMsg_HudError.fromObject = function fromObject(object) {
            if (object instanceof $root.CUserMsg_HudError)
                return object;
            var message = new $root.CUserMsg_HudError();
            if (object.orderId != null)
                message.orderId = object.orderId | 0;
            return message;
        };
    
        /**
         * Creates a plain object from a CUserMsg_HudError message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CUserMsg_HudError
         * @static
         * @param {CUserMsg_HudError} message CUserMsg_HudError
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CUserMsg_HudError.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.orderId = 0;
            if (message.orderId != null && message.hasOwnProperty("orderId"))
                object.orderId = message.orderId;
            return object;
        };
    
        /**
         * Converts this CUserMsg_HudError to JSON.
         * @function toJSON
         * @memberof CUserMsg_HudError
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CUserMsg_HudError.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * Gets the default type url for CUserMsg_HudError
         * @function getTypeUrl
         * @memberof CUserMsg_HudError
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        CUserMsg_HudError.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/CUserMsg_HudError";
        };
    
        return CUserMsg_HudError;
    })();
    
    $root.CUserMsg_CustomGameEvent = (function() {
    
        /**
         * Properties of a CUserMsg_CustomGameEvent.
         * @exports ICUserMsg_CustomGameEvent
         * @interface ICUserMsg_CustomGameEvent
         * @property {string|null} [eventName] CUserMsg_CustomGameEvent eventName
         * @property {Uint8Array|null} [data] CUserMsg_CustomGameEvent data
         */
    
        /**
         * Constructs a new CUserMsg_CustomGameEvent.
         * @exports CUserMsg_CustomGameEvent
         * @classdesc Represents a CUserMsg_CustomGameEvent.
         * @implements ICUserMsg_CustomGameEvent
         * @constructor
         * @param {ICUserMsg_CustomGameEvent=} [properties] Properties to set
         */
        function CUserMsg_CustomGameEvent(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CUserMsg_CustomGameEvent eventName.
         * @member {string} eventName
         * @memberof CUserMsg_CustomGameEvent
         * @instance
         */
        CUserMsg_CustomGameEvent.prototype.eventName = "";
    
        /**
         * CUserMsg_CustomGameEvent data.
         * @member {Uint8Array} data
         * @memberof CUserMsg_CustomGameEvent
         * @instance
         */
        CUserMsg_CustomGameEvent.prototype.data = $util.newBuffer([]);
    
        /**
         * Creates a new CUserMsg_CustomGameEvent instance using the specified properties.
         * @function create
         * @memberof CUserMsg_CustomGameEvent
         * @static
         * @param {ICUserMsg_CustomGameEvent=} [properties] Properties to set
         * @returns {CUserMsg_CustomGameEvent} CUserMsg_CustomGameEvent instance
         */
        CUserMsg_CustomGameEvent.create = function create(properties) {
            return new CUserMsg_CustomGameEvent(properties);
        };
    
        /**
         * Encodes the specified CUserMsg_CustomGameEvent message. Does not implicitly {@link CUserMsg_CustomGameEvent.verify|verify} messages.
         * @function encode
         * @memberof CUserMsg_CustomGameEvent
         * @static
         * @param {ICUserMsg_CustomGameEvent} message CUserMsg_CustomGameEvent message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CUserMsg_CustomGameEvent.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.eventName != null && Object.hasOwnProperty.call(message, "eventName"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.eventName);
            if (message.data != null && Object.hasOwnProperty.call(message, "data"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.data);
            return writer;
        };
    
        /**
         * Encodes the specified CUserMsg_CustomGameEvent message, length delimited. Does not implicitly {@link CUserMsg_CustomGameEvent.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CUserMsg_CustomGameEvent
         * @static
         * @param {ICUserMsg_CustomGameEvent} message CUserMsg_CustomGameEvent message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CUserMsg_CustomGameEvent.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CUserMsg_CustomGameEvent message from the specified reader or buffer.
         * @function decode
         * @memberof CUserMsg_CustomGameEvent
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CUserMsg_CustomGameEvent} CUserMsg_CustomGameEvent
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CUserMsg_CustomGameEvent.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CUserMsg_CustomGameEvent();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.eventName = reader.string();
                        break;
                    }
                case 2: {
                        message.data = reader.bytes();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CUserMsg_CustomGameEvent message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CUserMsg_CustomGameEvent
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CUserMsg_CustomGameEvent} CUserMsg_CustomGameEvent
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CUserMsg_CustomGameEvent.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CUserMsg_CustomGameEvent message.
         * @function verify
         * @memberof CUserMsg_CustomGameEvent
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CUserMsg_CustomGameEvent.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.eventName != null && message.hasOwnProperty("eventName"))
                if (!$util.isString(message.eventName))
                    return "eventName: string expected";
            if (message.data != null && message.hasOwnProperty("data"))
                if (!(message.data && typeof message.data.length === "number" || $util.isString(message.data)))
                    return "data: buffer expected";
            return null;
        };
    
        /**
         * Creates a CUserMsg_CustomGameEvent message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CUserMsg_CustomGameEvent
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CUserMsg_CustomGameEvent} CUserMsg_CustomGameEvent
         */
        CUserMsg_CustomGameEvent.fromObject = function fromObject(object) {
            if (object instanceof $root.CUserMsg_CustomGameEvent)
                return object;
            var message = new $root.CUserMsg_CustomGameEvent();
            if (object.eventName != null)
                message.eventName = String(object.eventName);
            if (object.data != null)
                if (typeof object.data === "string")
                    $util.base64.decode(object.data, message.data = $util.newBuffer($util.base64.length(object.data)), 0);
                else if (object.data.length >= 0)
                    message.data = object.data;
            return message;
        };
    
        /**
         * Creates a plain object from a CUserMsg_CustomGameEvent message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CUserMsg_CustomGameEvent
         * @static
         * @param {CUserMsg_CustomGameEvent} message CUserMsg_CustomGameEvent
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CUserMsg_CustomGameEvent.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.eventName = "";
                if (options.bytes === String)
                    object.data = "";
                else {
                    object.data = [];
                    if (options.bytes !== Array)
                        object.data = $util.newBuffer(object.data);
                }
            }
            if (message.eventName != null && message.hasOwnProperty("eventName"))
                object.eventName = message.eventName;
            if (message.data != null && message.hasOwnProperty("data"))
                object.data = options.bytes === String ? $util.base64.encode(message.data, 0, message.data.length) : options.bytes === Array ? Array.prototype.slice.call(message.data) : message.data;
            return object;
        };
    
        /**
         * Converts this CUserMsg_CustomGameEvent to JSON.
         * @function toJSON
         * @memberof CUserMsg_CustomGameEvent
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CUserMsg_CustomGameEvent.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * Gets the default type url for CUserMsg_CustomGameEvent
         * @function getTypeUrl
         * @memberof CUserMsg_CustomGameEvent
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        CUserMsg_CustomGameEvent.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/CUserMsg_CustomGameEvent";
        };
    
        return CUserMsg_CustomGameEvent;
    })();
    
    $root.CUserMessageHapticsManagerPulse = (function() {
    
        /**
         * Properties of a CUserMessageHapticsManagerPulse.
         * @exports ICUserMessageHapticsManagerPulse
         * @interface ICUserMessageHapticsManagerPulse
         * @property {number|null} [handId] CUserMessageHapticsManagerPulse handId
         * @property {number|null} [effectAmplitude] CUserMessageHapticsManagerPulse effectAmplitude
         * @property {number|null} [effectFrequency] CUserMessageHapticsManagerPulse effectFrequency
         * @property {number|null} [effectDuration] CUserMessageHapticsManagerPulse effectDuration
         */
    
        /**
         * Constructs a new CUserMessageHapticsManagerPulse.
         * @exports CUserMessageHapticsManagerPulse
         * @classdesc Represents a CUserMessageHapticsManagerPulse.
         * @implements ICUserMessageHapticsManagerPulse
         * @constructor
         * @param {ICUserMessageHapticsManagerPulse=} [properties] Properties to set
         */
        function CUserMessageHapticsManagerPulse(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CUserMessageHapticsManagerPulse handId.
         * @member {number} handId
         * @memberof CUserMessageHapticsManagerPulse
         * @instance
         */
        CUserMessageHapticsManagerPulse.prototype.handId = 0;
    
        /**
         * CUserMessageHapticsManagerPulse effectAmplitude.
         * @member {number} effectAmplitude
         * @memberof CUserMessageHapticsManagerPulse
         * @instance
         */
        CUserMessageHapticsManagerPulse.prototype.effectAmplitude = 0;
    
        /**
         * CUserMessageHapticsManagerPulse effectFrequency.
         * @member {number} effectFrequency
         * @memberof CUserMessageHapticsManagerPulse
         * @instance
         */
        CUserMessageHapticsManagerPulse.prototype.effectFrequency = 0;
    
        /**
         * CUserMessageHapticsManagerPulse effectDuration.
         * @member {number} effectDuration
         * @memberof CUserMessageHapticsManagerPulse
         * @instance
         */
        CUserMessageHapticsManagerPulse.prototype.effectDuration = 0;
    
        /**
         * Creates a new CUserMessageHapticsManagerPulse instance using the specified properties.
         * @function create
         * @memberof CUserMessageHapticsManagerPulse
         * @static
         * @param {ICUserMessageHapticsManagerPulse=} [properties] Properties to set
         * @returns {CUserMessageHapticsManagerPulse} CUserMessageHapticsManagerPulse instance
         */
        CUserMessageHapticsManagerPulse.create = function create(properties) {
            return new CUserMessageHapticsManagerPulse(properties);
        };
    
        /**
         * Encodes the specified CUserMessageHapticsManagerPulse message. Does not implicitly {@link CUserMessageHapticsManagerPulse.verify|verify} messages.
         * @function encode
         * @memberof CUserMessageHapticsManagerPulse
         * @static
         * @param {ICUserMessageHapticsManagerPulse} message CUserMessageHapticsManagerPulse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CUserMessageHapticsManagerPulse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.handId != null && Object.hasOwnProperty.call(message, "handId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.handId);
            if (message.effectAmplitude != null && Object.hasOwnProperty.call(message, "effectAmplitude"))
                writer.uint32(/* id 2, wireType 5 =*/21).float(message.effectAmplitude);
            if (message.effectFrequency != null && Object.hasOwnProperty.call(message, "effectFrequency"))
                writer.uint32(/* id 3, wireType 5 =*/29).float(message.effectFrequency);
            if (message.effectDuration != null && Object.hasOwnProperty.call(message, "effectDuration"))
                writer.uint32(/* id 4, wireType 5 =*/37).float(message.effectDuration);
            return writer;
        };
    
        /**
         * Encodes the specified CUserMessageHapticsManagerPulse message, length delimited. Does not implicitly {@link CUserMessageHapticsManagerPulse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CUserMessageHapticsManagerPulse
         * @static
         * @param {ICUserMessageHapticsManagerPulse} message CUserMessageHapticsManagerPulse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CUserMessageHapticsManagerPulse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CUserMessageHapticsManagerPulse message from the specified reader or buffer.
         * @function decode
         * @memberof CUserMessageHapticsManagerPulse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CUserMessageHapticsManagerPulse} CUserMessageHapticsManagerPulse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CUserMessageHapticsManagerPulse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CUserMessageHapticsManagerPulse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.handId = reader.int32();
                        break;
                    }
                case 2: {
                        message.effectAmplitude = reader.float();
                        break;
                    }
                case 3: {
                        message.effectFrequency = reader.float();
                        break;
                    }
                case 4: {
                        message.effectDuration = reader.float();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CUserMessageHapticsManagerPulse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CUserMessageHapticsManagerPulse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CUserMessageHapticsManagerPulse} CUserMessageHapticsManagerPulse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CUserMessageHapticsManagerPulse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CUserMessageHapticsManagerPulse message.
         * @function verify
         * @memberof CUserMessageHapticsManagerPulse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CUserMessageHapticsManagerPulse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.handId != null && message.hasOwnProperty("handId"))
                if (!$util.isInteger(message.handId))
                    return "handId: integer expected";
            if (message.effectAmplitude != null && message.hasOwnProperty("effectAmplitude"))
                if (typeof message.effectAmplitude !== "number")
                    return "effectAmplitude: number expected";
            if (message.effectFrequency != null && message.hasOwnProperty("effectFrequency"))
                if (typeof message.effectFrequency !== "number")
                    return "effectFrequency: number expected";
            if (message.effectDuration != null && message.hasOwnProperty("effectDuration"))
                if (typeof message.effectDuration !== "number")
                    return "effectDuration: number expected";
            return null;
        };
    
        /**
         * Creates a CUserMessageHapticsManagerPulse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CUserMessageHapticsManagerPulse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CUserMessageHapticsManagerPulse} CUserMessageHapticsManagerPulse
         */
        CUserMessageHapticsManagerPulse.fromObject = function fromObject(object) {
            if (object instanceof $root.CUserMessageHapticsManagerPulse)
                return object;
            var message = new $root.CUserMessageHapticsManagerPulse();
            if (object.handId != null)
                message.handId = object.handId | 0;
            if (object.effectAmplitude != null)
                message.effectAmplitude = Number(object.effectAmplitude);
            if (object.effectFrequency != null)
                message.effectFrequency = Number(object.effectFrequency);
            if (object.effectDuration != null)
                message.effectDuration = Number(object.effectDuration);
            return message;
        };
    
        /**
         * Creates a plain object from a CUserMessageHapticsManagerPulse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CUserMessageHapticsManagerPulse
         * @static
         * @param {CUserMessageHapticsManagerPulse} message CUserMessageHapticsManagerPulse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CUserMessageHapticsManagerPulse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.handId = 0;
                object.effectAmplitude = 0;
                object.effectFrequency = 0;
                object.effectDuration = 0;
            }
            if (message.handId != null && message.hasOwnProperty("handId"))
                object.handId = message.handId;
            if (message.effectAmplitude != null && message.hasOwnProperty("effectAmplitude"))
                object.effectAmplitude = options.json && !isFinite(message.effectAmplitude) ? String(message.effectAmplitude) : message.effectAmplitude;
            if (message.effectFrequency != null && message.hasOwnProperty("effectFrequency"))
                object.effectFrequency = options.json && !isFinite(message.effectFrequency) ? String(message.effectFrequency) : message.effectFrequency;
            if (message.effectDuration != null && message.hasOwnProperty("effectDuration"))
                object.effectDuration = options.json && !isFinite(message.effectDuration) ? String(message.effectDuration) : message.effectDuration;
            return object;
        };
    
        /**
         * Converts this CUserMessageHapticsManagerPulse to JSON.
         * @function toJSON
         * @memberof CUserMessageHapticsManagerPulse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CUserMessageHapticsManagerPulse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * Gets the default type url for CUserMessageHapticsManagerPulse
         * @function getTypeUrl
         * @memberof CUserMessageHapticsManagerPulse
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        CUserMessageHapticsManagerPulse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/CUserMessageHapticsManagerPulse";
        };
    
        return CUserMessageHapticsManagerPulse;
    })();
    
    $root.CUserMessageHapticsManagerEffect = (function() {
    
        /**
         * Properties of a CUserMessageHapticsManagerEffect.
         * @exports ICUserMessageHapticsManagerEffect
         * @interface ICUserMessageHapticsManagerEffect
         * @property {number|null} [handId] CUserMessageHapticsManagerEffect handId
         * @property {number|null} [effectNameHashCode] CUserMessageHapticsManagerEffect effectNameHashCode
         * @property {number|null} [effectScale] CUserMessageHapticsManagerEffect effectScale
         */
    
        /**
         * Constructs a new CUserMessageHapticsManagerEffect.
         * @exports CUserMessageHapticsManagerEffect
         * @classdesc Represents a CUserMessageHapticsManagerEffect.
         * @implements ICUserMessageHapticsManagerEffect
         * @constructor
         * @param {ICUserMessageHapticsManagerEffect=} [properties] Properties to set
         */
        function CUserMessageHapticsManagerEffect(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CUserMessageHapticsManagerEffect handId.
         * @member {number} handId
         * @memberof CUserMessageHapticsManagerEffect
         * @instance
         */
        CUserMessageHapticsManagerEffect.prototype.handId = 0;
    
        /**
         * CUserMessageHapticsManagerEffect effectNameHashCode.
         * @member {number} effectNameHashCode
         * @memberof CUserMessageHapticsManagerEffect
         * @instance
         */
        CUserMessageHapticsManagerEffect.prototype.effectNameHashCode = 0;
    
        /**
         * CUserMessageHapticsManagerEffect effectScale.
         * @member {number} effectScale
         * @memberof CUserMessageHapticsManagerEffect
         * @instance
         */
        CUserMessageHapticsManagerEffect.prototype.effectScale = 0;
    
        /**
         * Creates a new CUserMessageHapticsManagerEffect instance using the specified properties.
         * @function create
         * @memberof CUserMessageHapticsManagerEffect
         * @static
         * @param {ICUserMessageHapticsManagerEffect=} [properties] Properties to set
         * @returns {CUserMessageHapticsManagerEffect} CUserMessageHapticsManagerEffect instance
         */
        CUserMessageHapticsManagerEffect.create = function create(properties) {
            return new CUserMessageHapticsManagerEffect(properties);
        };
    
        /**
         * Encodes the specified CUserMessageHapticsManagerEffect message. Does not implicitly {@link CUserMessageHapticsManagerEffect.verify|verify} messages.
         * @function encode
         * @memberof CUserMessageHapticsManagerEffect
         * @static
         * @param {ICUserMessageHapticsManagerEffect} message CUserMessageHapticsManagerEffect message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CUserMessageHapticsManagerEffect.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.handId != null && Object.hasOwnProperty.call(message, "handId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.handId);
            if (message.effectNameHashCode != null && Object.hasOwnProperty.call(message, "effectNameHashCode"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.effectNameHashCode);
            if (message.effectScale != null && Object.hasOwnProperty.call(message, "effectScale"))
                writer.uint32(/* id 3, wireType 5 =*/29).float(message.effectScale);
            return writer;
        };
    
        /**
         * Encodes the specified CUserMessageHapticsManagerEffect message, length delimited. Does not implicitly {@link CUserMessageHapticsManagerEffect.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CUserMessageHapticsManagerEffect
         * @static
         * @param {ICUserMessageHapticsManagerEffect} message CUserMessageHapticsManagerEffect message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CUserMessageHapticsManagerEffect.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CUserMessageHapticsManagerEffect message from the specified reader or buffer.
         * @function decode
         * @memberof CUserMessageHapticsManagerEffect
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CUserMessageHapticsManagerEffect} CUserMessageHapticsManagerEffect
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CUserMessageHapticsManagerEffect.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CUserMessageHapticsManagerEffect();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.handId = reader.int32();
                        break;
                    }
                case 2: {
                        message.effectNameHashCode = reader.uint32();
                        break;
                    }
                case 3: {
                        message.effectScale = reader.float();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CUserMessageHapticsManagerEffect message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CUserMessageHapticsManagerEffect
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CUserMessageHapticsManagerEffect} CUserMessageHapticsManagerEffect
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CUserMessageHapticsManagerEffect.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CUserMessageHapticsManagerEffect message.
         * @function verify
         * @memberof CUserMessageHapticsManagerEffect
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CUserMessageHapticsManagerEffect.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.handId != null && message.hasOwnProperty("handId"))
                if (!$util.isInteger(message.handId))
                    return "handId: integer expected";
            if (message.effectNameHashCode != null && message.hasOwnProperty("effectNameHashCode"))
                if (!$util.isInteger(message.effectNameHashCode))
                    return "effectNameHashCode: integer expected";
            if (message.effectScale != null && message.hasOwnProperty("effectScale"))
                if (typeof message.effectScale !== "number")
                    return "effectScale: number expected";
            return null;
        };
    
        /**
         * Creates a CUserMessageHapticsManagerEffect message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CUserMessageHapticsManagerEffect
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CUserMessageHapticsManagerEffect} CUserMessageHapticsManagerEffect
         */
        CUserMessageHapticsManagerEffect.fromObject = function fromObject(object) {
            if (object instanceof $root.CUserMessageHapticsManagerEffect)
                return object;
            var message = new $root.CUserMessageHapticsManagerEffect();
            if (object.handId != null)
                message.handId = object.handId | 0;
            if (object.effectNameHashCode != null)
                message.effectNameHashCode = object.effectNameHashCode >>> 0;
            if (object.effectScale != null)
                message.effectScale = Number(object.effectScale);
            return message;
        };
    
        /**
         * Creates a plain object from a CUserMessageHapticsManagerEffect message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CUserMessageHapticsManagerEffect
         * @static
         * @param {CUserMessageHapticsManagerEffect} message CUserMessageHapticsManagerEffect
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CUserMessageHapticsManagerEffect.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.handId = 0;
                object.effectNameHashCode = 0;
                object.effectScale = 0;
            }
            if (message.handId != null && message.hasOwnProperty("handId"))
                object.handId = message.handId;
            if (message.effectNameHashCode != null && message.hasOwnProperty("effectNameHashCode"))
                object.effectNameHashCode = message.effectNameHashCode;
            if (message.effectScale != null && message.hasOwnProperty("effectScale"))
                object.effectScale = options.json && !isFinite(message.effectScale) ? String(message.effectScale) : message.effectScale;
            return object;
        };
    
        /**
         * Converts this CUserMessageHapticsManagerEffect to JSON.
         * @function toJSON
         * @memberof CUserMessageHapticsManagerEffect
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CUserMessageHapticsManagerEffect.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * Gets the default type url for CUserMessageHapticsManagerEffect
         * @function getTypeUrl
         * @memberof CUserMessageHapticsManagerEffect
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        CUserMessageHapticsManagerEffect.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/CUserMessageHapticsManagerEffect";
        };
    
        return CUserMessageHapticsManagerEffect;
    })();
    
    $root.CUserMessageAnimStateGraphState = (function() {
    
        /**
         * Properties of a CUserMessageAnimStateGraphState.
         * @exports ICUserMessageAnimStateGraphState
         * @interface ICUserMessageAnimStateGraphState
         * @property {number|null} [entityIndex] CUserMessageAnimStateGraphState entityIndex
         * @property {Uint8Array|null} [data] CUserMessageAnimStateGraphState data
         */
    
        /**
         * Constructs a new CUserMessageAnimStateGraphState.
         * @exports CUserMessageAnimStateGraphState
         * @classdesc Represents a CUserMessageAnimStateGraphState.
         * @implements ICUserMessageAnimStateGraphState
         * @constructor
         * @param {ICUserMessageAnimStateGraphState=} [properties] Properties to set
         */
        function CUserMessageAnimStateGraphState(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CUserMessageAnimStateGraphState entityIndex.
         * @member {number} entityIndex
         * @memberof CUserMessageAnimStateGraphState
         * @instance
         */
        CUserMessageAnimStateGraphState.prototype.entityIndex = 0;
    
        /**
         * CUserMessageAnimStateGraphState data.
         * @member {Uint8Array} data
         * @memberof CUserMessageAnimStateGraphState
         * @instance
         */
        CUserMessageAnimStateGraphState.prototype.data = $util.newBuffer([]);
    
        /**
         * Creates a new CUserMessageAnimStateGraphState instance using the specified properties.
         * @function create
         * @memberof CUserMessageAnimStateGraphState
         * @static
         * @param {ICUserMessageAnimStateGraphState=} [properties] Properties to set
         * @returns {CUserMessageAnimStateGraphState} CUserMessageAnimStateGraphState instance
         */
        CUserMessageAnimStateGraphState.create = function create(properties) {
            return new CUserMessageAnimStateGraphState(properties);
        };
    
        /**
         * Encodes the specified CUserMessageAnimStateGraphState message. Does not implicitly {@link CUserMessageAnimStateGraphState.verify|verify} messages.
         * @function encode
         * @memberof CUserMessageAnimStateGraphState
         * @static
         * @param {ICUserMessageAnimStateGraphState} message CUserMessageAnimStateGraphState message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CUserMessageAnimStateGraphState.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.entityIndex != null && Object.hasOwnProperty.call(message, "entityIndex"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.entityIndex);
            if (message.data != null && Object.hasOwnProperty.call(message, "data"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.data);
            return writer;
        };
    
        /**
         * Encodes the specified CUserMessageAnimStateGraphState message, length delimited. Does not implicitly {@link CUserMessageAnimStateGraphState.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CUserMessageAnimStateGraphState
         * @static
         * @param {ICUserMessageAnimStateGraphState} message CUserMessageAnimStateGraphState message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CUserMessageAnimStateGraphState.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CUserMessageAnimStateGraphState message from the specified reader or buffer.
         * @function decode
         * @memberof CUserMessageAnimStateGraphState
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CUserMessageAnimStateGraphState} CUserMessageAnimStateGraphState
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CUserMessageAnimStateGraphState.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CUserMessageAnimStateGraphState();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.entityIndex = reader.int32();
                        break;
                    }
                case 2: {
                        message.data = reader.bytes();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CUserMessageAnimStateGraphState message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CUserMessageAnimStateGraphState
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CUserMessageAnimStateGraphState} CUserMessageAnimStateGraphState
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CUserMessageAnimStateGraphState.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CUserMessageAnimStateGraphState message.
         * @function verify
         * @memberof CUserMessageAnimStateGraphState
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CUserMessageAnimStateGraphState.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.entityIndex != null && message.hasOwnProperty("entityIndex"))
                if (!$util.isInteger(message.entityIndex))
                    return "entityIndex: integer expected";
            if (message.data != null && message.hasOwnProperty("data"))
                if (!(message.data && typeof message.data.length === "number" || $util.isString(message.data)))
                    return "data: buffer expected";
            return null;
        };
    
        /**
         * Creates a CUserMessageAnimStateGraphState message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CUserMessageAnimStateGraphState
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CUserMessageAnimStateGraphState} CUserMessageAnimStateGraphState
         */
        CUserMessageAnimStateGraphState.fromObject = function fromObject(object) {
            if (object instanceof $root.CUserMessageAnimStateGraphState)
                return object;
            var message = new $root.CUserMessageAnimStateGraphState();
            if (object.entityIndex != null)
                message.entityIndex = object.entityIndex | 0;
            if (object.data != null)
                if (typeof object.data === "string")
                    $util.base64.decode(object.data, message.data = $util.newBuffer($util.base64.length(object.data)), 0);
                else if (object.data.length >= 0)
                    message.data = object.data;
            return message;
        };
    
        /**
         * Creates a plain object from a CUserMessageAnimStateGraphState message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CUserMessageAnimStateGraphState
         * @static
         * @param {CUserMessageAnimStateGraphState} message CUserMessageAnimStateGraphState
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CUserMessageAnimStateGraphState.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.entityIndex = 0;
                if (options.bytes === String)
                    object.data = "";
                else {
                    object.data = [];
                    if (options.bytes !== Array)
                        object.data = $util.newBuffer(object.data);
                }
            }
            if (message.entityIndex != null && message.hasOwnProperty("entityIndex"))
                object.entityIndex = message.entityIndex;
            if (message.data != null && message.hasOwnProperty("data"))
                object.data = options.bytes === String ? $util.base64.encode(message.data, 0, message.data.length) : options.bytes === Array ? Array.prototype.slice.call(message.data) : message.data;
            return object;
        };
    
        /**
         * Converts this CUserMessageAnimStateGraphState to JSON.
         * @function toJSON
         * @memberof CUserMessageAnimStateGraphState
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CUserMessageAnimStateGraphState.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * Gets the default type url for CUserMessageAnimStateGraphState
         * @function getTypeUrl
         * @memberof CUserMessageAnimStateGraphState
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        CUserMessageAnimStateGraphState.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/CUserMessageAnimStateGraphState";
        };
    
        return CUserMessageAnimStateGraphState;
    })();
    
    $root.CUserMessageCommandQueueState = (function() {
    
        /**
         * Properties of a CUserMessageCommandQueueState.
         * @exports ICUserMessageCommandQueueState
         * @interface ICUserMessageCommandQueueState
         * @property {number|null} [playerSlot] CUserMessageCommandQueueState playerSlot
         * @property {CUserMessageCommandQueueState.Icommand_queue_info_t|null} [commandQueueInfo] CUserMessageCommandQueueState commandQueueInfo
         */
    
        /**
         * Constructs a new CUserMessageCommandQueueState.
         * @exports CUserMessageCommandQueueState
         * @classdesc Represents a CUserMessageCommandQueueState.
         * @implements ICUserMessageCommandQueueState
         * @constructor
         * @param {ICUserMessageCommandQueueState=} [properties] Properties to set
         */
        function CUserMessageCommandQueueState(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CUserMessageCommandQueueState playerSlot.
         * @member {number} playerSlot
         * @memberof CUserMessageCommandQueueState
         * @instance
         */
        CUserMessageCommandQueueState.prototype.playerSlot = -1;
    
        /**
         * CUserMessageCommandQueueState commandQueueInfo.
         * @member {CUserMessageCommandQueueState.Icommand_queue_info_t|null|undefined} commandQueueInfo
         * @memberof CUserMessageCommandQueueState
         * @instance
         */
        CUserMessageCommandQueueState.prototype.commandQueueInfo = null;
    
        /**
         * Creates a new CUserMessageCommandQueueState instance using the specified properties.
         * @function create
         * @memberof CUserMessageCommandQueueState
         * @static
         * @param {ICUserMessageCommandQueueState=} [properties] Properties to set
         * @returns {CUserMessageCommandQueueState} CUserMessageCommandQueueState instance
         */
        CUserMessageCommandQueueState.create = function create(properties) {
            return new CUserMessageCommandQueueState(properties);
        };
    
        /**
         * Encodes the specified CUserMessageCommandQueueState message. Does not implicitly {@link CUserMessageCommandQueueState.verify|verify} messages.
         * @function encode
         * @memberof CUserMessageCommandQueueState
         * @static
         * @param {ICUserMessageCommandQueueState} message CUserMessageCommandQueueState message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CUserMessageCommandQueueState.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.playerSlot != null && Object.hasOwnProperty.call(message, "playerSlot"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.playerSlot);
            if (message.commandQueueInfo != null && Object.hasOwnProperty.call(message, "commandQueueInfo"))
                $root.CUserMessageCommandQueueState.command_queue_info_t.encode(message.commandQueueInfo, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };
    
        /**
         * Encodes the specified CUserMessageCommandQueueState message, length delimited. Does not implicitly {@link CUserMessageCommandQueueState.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CUserMessageCommandQueueState
         * @static
         * @param {ICUserMessageCommandQueueState} message CUserMessageCommandQueueState message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CUserMessageCommandQueueState.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CUserMessageCommandQueueState message from the specified reader or buffer.
         * @function decode
         * @memberof CUserMessageCommandQueueState
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CUserMessageCommandQueueState} CUserMessageCommandQueueState
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CUserMessageCommandQueueState.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CUserMessageCommandQueueState();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.playerSlot = reader.int32();
                        break;
                    }
                case 2: {
                        message.commandQueueInfo = $root.CUserMessageCommandQueueState.command_queue_info_t.decode(reader, reader.uint32());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CUserMessageCommandQueueState message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CUserMessageCommandQueueState
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CUserMessageCommandQueueState} CUserMessageCommandQueueState
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CUserMessageCommandQueueState.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CUserMessageCommandQueueState message.
         * @function verify
         * @memberof CUserMessageCommandQueueState
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CUserMessageCommandQueueState.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.playerSlot != null && message.hasOwnProperty("playerSlot"))
                if (!$util.isInteger(message.playerSlot))
                    return "playerSlot: integer expected";
            if (message.commandQueueInfo != null && message.hasOwnProperty("commandQueueInfo")) {
                var error = $root.CUserMessageCommandQueueState.command_queue_info_t.verify(message.commandQueueInfo);
                if (error)
                    return "commandQueueInfo." + error;
            }
            return null;
        };
    
        /**
         * Creates a CUserMessageCommandQueueState message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CUserMessageCommandQueueState
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CUserMessageCommandQueueState} CUserMessageCommandQueueState
         */
        CUserMessageCommandQueueState.fromObject = function fromObject(object) {
            if (object instanceof $root.CUserMessageCommandQueueState)
                return object;
            var message = new $root.CUserMessageCommandQueueState();
            if (object.playerSlot != null)
                message.playerSlot = object.playerSlot | 0;
            if (object.commandQueueInfo != null) {
                if (typeof object.commandQueueInfo !== "object")
                    throw TypeError(".CUserMessageCommandQueueState.commandQueueInfo: object expected");
                message.commandQueueInfo = $root.CUserMessageCommandQueueState.command_queue_info_t.fromObject(object.commandQueueInfo);
            }
            return message;
        };
    
        /**
         * Creates a plain object from a CUserMessageCommandQueueState message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CUserMessageCommandQueueState
         * @static
         * @param {CUserMessageCommandQueueState} message CUserMessageCommandQueueState
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CUserMessageCommandQueueState.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.playerSlot = -1;
                object.commandQueueInfo = null;
            }
            if (message.playerSlot != null && message.hasOwnProperty("playerSlot"))
                object.playerSlot = message.playerSlot;
            if (message.commandQueueInfo != null && message.hasOwnProperty("commandQueueInfo"))
                object.commandQueueInfo = $root.CUserMessageCommandQueueState.command_queue_info_t.toObject(message.commandQueueInfo, options);
            return object;
        };
    
        /**
         * Converts this CUserMessageCommandQueueState to JSON.
         * @function toJSON
         * @memberof CUserMessageCommandQueueState
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CUserMessageCommandQueueState.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * Gets the default type url for CUserMessageCommandQueueState
         * @function getTypeUrl
         * @memberof CUserMessageCommandQueueState
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        CUserMessageCommandQueueState.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/CUserMessageCommandQueueState";
        };
    
        CUserMessageCommandQueueState.command_queue_info_t = (function() {
    
            /**
             * Properties of a command_queue_info_t.
             * @memberof CUserMessageCommandQueueState
             * @interface Icommand_queue_info_t
             * @property {number|null} [commandsQueued] command_queue_info_t commandsQueued
             * @property {number|null} [commandQueueDesiredSize] command_queue_info_t commandQueueDesiredSize
             * @property {number|null} [starvedCommandTicks] command_queue_info_t starvedCommandTicks
             * @property {number|null} [timeDilationPercent] command_queue_info_t timeDilationPercent
             */
    
            /**
             * Constructs a new command_queue_info_t.
             * @memberof CUserMessageCommandQueueState
             * @classdesc Represents a command_queue_info_t.
             * @implements Icommand_queue_info_t
             * @constructor
             * @param {CUserMessageCommandQueueState.Icommand_queue_info_t=} [properties] Properties to set
             */
            function command_queue_info_t(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * command_queue_info_t commandsQueued.
             * @member {number} commandsQueued
             * @memberof CUserMessageCommandQueueState.command_queue_info_t
             * @instance
             */
            command_queue_info_t.prototype.commandsQueued = 0;
    
            /**
             * command_queue_info_t commandQueueDesiredSize.
             * @member {number} commandQueueDesiredSize
             * @memberof CUserMessageCommandQueueState.command_queue_info_t
             * @instance
             */
            command_queue_info_t.prototype.commandQueueDesiredSize = 0;
    
            /**
             * command_queue_info_t starvedCommandTicks.
             * @member {number} starvedCommandTicks
             * @memberof CUserMessageCommandQueueState.command_queue_info_t
             * @instance
             */
            command_queue_info_t.prototype.starvedCommandTicks = 0;
    
            /**
             * command_queue_info_t timeDilationPercent.
             * @member {number} timeDilationPercent
             * @memberof CUserMessageCommandQueueState.command_queue_info_t
             * @instance
             */
            command_queue_info_t.prototype.timeDilationPercent = 0;
    
            /**
             * Creates a new command_queue_info_t instance using the specified properties.
             * @function create
             * @memberof CUserMessageCommandQueueState.command_queue_info_t
             * @static
             * @param {CUserMessageCommandQueueState.Icommand_queue_info_t=} [properties] Properties to set
             * @returns {CUserMessageCommandQueueState.command_queue_info_t} command_queue_info_t instance
             */
            command_queue_info_t.create = function create(properties) {
                return new command_queue_info_t(properties);
            };
    
            /**
             * Encodes the specified command_queue_info_t message. Does not implicitly {@link CUserMessageCommandQueueState.command_queue_info_t.verify|verify} messages.
             * @function encode
             * @memberof CUserMessageCommandQueueState.command_queue_info_t
             * @static
             * @param {CUserMessageCommandQueueState.Icommand_queue_info_t} message command_queue_info_t message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            command_queue_info_t.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.commandsQueued != null && Object.hasOwnProperty.call(message, "commandsQueued"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.commandsQueued);
                if (message.commandQueueDesiredSize != null && Object.hasOwnProperty.call(message, "commandQueueDesiredSize"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.commandQueueDesiredSize);
                if (message.starvedCommandTicks != null && Object.hasOwnProperty.call(message, "starvedCommandTicks"))
                    writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.starvedCommandTicks);
                if (message.timeDilationPercent != null && Object.hasOwnProperty.call(message, "timeDilationPercent"))
                    writer.uint32(/* id 4, wireType 0 =*/32).int32(message.timeDilationPercent);
                return writer;
            };
    
            /**
             * Encodes the specified command_queue_info_t message, length delimited. Does not implicitly {@link CUserMessageCommandQueueState.command_queue_info_t.verify|verify} messages.
             * @function encodeDelimited
             * @memberof CUserMessageCommandQueueState.command_queue_info_t
             * @static
             * @param {CUserMessageCommandQueueState.Icommand_queue_info_t} message command_queue_info_t message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            command_queue_info_t.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a command_queue_info_t message from the specified reader or buffer.
             * @function decode
             * @memberof CUserMessageCommandQueueState.command_queue_info_t
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {CUserMessageCommandQueueState.command_queue_info_t} command_queue_info_t
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            command_queue_info_t.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CUserMessageCommandQueueState.command_queue_info_t();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.commandsQueued = reader.uint32();
                            break;
                        }
                    case 2: {
                            message.commandQueueDesiredSize = reader.uint32();
                            break;
                        }
                    case 3: {
                            message.starvedCommandTicks = reader.uint32();
                            break;
                        }
                    case 4: {
                            message.timeDilationPercent = reader.int32();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a command_queue_info_t message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof CUserMessageCommandQueueState.command_queue_info_t
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {CUserMessageCommandQueueState.command_queue_info_t} command_queue_info_t
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            command_queue_info_t.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a command_queue_info_t message.
             * @function verify
             * @memberof CUserMessageCommandQueueState.command_queue_info_t
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            command_queue_info_t.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.commandsQueued != null && message.hasOwnProperty("commandsQueued"))
                    if (!$util.isInteger(message.commandsQueued))
                        return "commandsQueued: integer expected";
                if (message.commandQueueDesiredSize != null && message.hasOwnProperty("commandQueueDesiredSize"))
                    if (!$util.isInteger(message.commandQueueDesiredSize))
                        return "commandQueueDesiredSize: integer expected";
                if (message.starvedCommandTicks != null && message.hasOwnProperty("starvedCommandTicks"))
                    if (!$util.isInteger(message.starvedCommandTicks))
                        return "starvedCommandTicks: integer expected";
                if (message.timeDilationPercent != null && message.hasOwnProperty("timeDilationPercent"))
                    if (!$util.isInteger(message.timeDilationPercent))
                        return "timeDilationPercent: integer expected";
                return null;
            };
    
            /**
             * Creates a command_queue_info_t message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof CUserMessageCommandQueueState.command_queue_info_t
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {CUserMessageCommandQueueState.command_queue_info_t} command_queue_info_t
             */
            command_queue_info_t.fromObject = function fromObject(object) {
                if (object instanceof $root.CUserMessageCommandQueueState.command_queue_info_t)
                    return object;
                var message = new $root.CUserMessageCommandQueueState.command_queue_info_t();
                if (object.commandsQueued != null)
                    message.commandsQueued = object.commandsQueued >>> 0;
                if (object.commandQueueDesiredSize != null)
                    message.commandQueueDesiredSize = object.commandQueueDesiredSize >>> 0;
                if (object.starvedCommandTicks != null)
                    message.starvedCommandTicks = object.starvedCommandTicks >>> 0;
                if (object.timeDilationPercent != null)
                    message.timeDilationPercent = object.timeDilationPercent | 0;
                return message;
            };
    
            /**
             * Creates a plain object from a command_queue_info_t message. Also converts values to other types if specified.
             * @function toObject
             * @memberof CUserMessageCommandQueueState.command_queue_info_t
             * @static
             * @param {CUserMessageCommandQueueState.command_queue_info_t} message command_queue_info_t
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            command_queue_info_t.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.commandsQueued = 0;
                    object.commandQueueDesiredSize = 0;
                    object.starvedCommandTicks = 0;
                    object.timeDilationPercent = 0;
                }
                if (message.commandsQueued != null && message.hasOwnProperty("commandsQueued"))
                    object.commandsQueued = message.commandsQueued;
                if (message.commandQueueDesiredSize != null && message.hasOwnProperty("commandQueueDesiredSize"))
                    object.commandQueueDesiredSize = message.commandQueueDesiredSize;
                if (message.starvedCommandTicks != null && message.hasOwnProperty("starvedCommandTicks"))
                    object.starvedCommandTicks = message.starvedCommandTicks;
                if (message.timeDilationPercent != null && message.hasOwnProperty("timeDilationPercent"))
                    object.timeDilationPercent = message.timeDilationPercent;
                return object;
            };
    
            /**
             * Converts this command_queue_info_t to JSON.
             * @function toJSON
             * @memberof CUserMessageCommandQueueState.command_queue_info_t
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            command_queue_info_t.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            /**
             * Gets the default type url for command_queue_info_t
             * @function getTypeUrl
             * @memberof CUserMessageCommandQueueState.command_queue_info_t
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            command_queue_info_t.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/CUserMessageCommandQueueState.command_queue_info_t";
            };
    
            return command_queue_info_t;
        })();
    
        return CUserMessageCommandQueueState;
    })();
    
    $root.CUserMessageUpdateCssClasses = (function() {
    
        /**
         * Properties of a CUserMessageUpdateCssClasses.
         * @exports ICUserMessageUpdateCssClasses
         * @interface ICUserMessageUpdateCssClasses
         * @property {number|null} [targetWorldPanel] CUserMessageUpdateCssClasses targetWorldPanel
         * @property {string|null} [cssClasses] CUserMessageUpdateCssClasses cssClasses
         * @property {boolean|null} [isAdd] CUserMessageUpdateCssClasses isAdd
         */
    
        /**
         * Constructs a new CUserMessageUpdateCssClasses.
         * @exports CUserMessageUpdateCssClasses
         * @classdesc Represents a CUserMessageUpdateCssClasses.
         * @implements ICUserMessageUpdateCssClasses
         * @constructor
         * @param {ICUserMessageUpdateCssClasses=} [properties] Properties to set
         */
        function CUserMessageUpdateCssClasses(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CUserMessageUpdateCssClasses targetWorldPanel.
         * @member {number} targetWorldPanel
         * @memberof CUserMessageUpdateCssClasses
         * @instance
         */
        CUserMessageUpdateCssClasses.prototype.targetWorldPanel = 0;
    
        /**
         * CUserMessageUpdateCssClasses cssClasses.
         * @member {string} cssClasses
         * @memberof CUserMessageUpdateCssClasses
         * @instance
         */
        CUserMessageUpdateCssClasses.prototype.cssClasses = "";
    
        /**
         * CUserMessageUpdateCssClasses isAdd.
         * @member {boolean} isAdd
         * @memberof CUserMessageUpdateCssClasses
         * @instance
         */
        CUserMessageUpdateCssClasses.prototype.isAdd = false;
    
        /**
         * Creates a new CUserMessageUpdateCssClasses instance using the specified properties.
         * @function create
         * @memberof CUserMessageUpdateCssClasses
         * @static
         * @param {ICUserMessageUpdateCssClasses=} [properties] Properties to set
         * @returns {CUserMessageUpdateCssClasses} CUserMessageUpdateCssClasses instance
         */
        CUserMessageUpdateCssClasses.create = function create(properties) {
            return new CUserMessageUpdateCssClasses(properties);
        };
    
        /**
         * Encodes the specified CUserMessageUpdateCssClasses message. Does not implicitly {@link CUserMessageUpdateCssClasses.verify|verify} messages.
         * @function encode
         * @memberof CUserMessageUpdateCssClasses
         * @static
         * @param {ICUserMessageUpdateCssClasses} message CUserMessageUpdateCssClasses message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CUserMessageUpdateCssClasses.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.targetWorldPanel != null && Object.hasOwnProperty.call(message, "targetWorldPanel"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.targetWorldPanel);
            if (message.cssClasses != null && Object.hasOwnProperty.call(message, "cssClasses"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.cssClasses);
            if (message.isAdd != null && Object.hasOwnProperty.call(message, "isAdd"))
                writer.uint32(/* id 3, wireType 0 =*/24).bool(message.isAdd);
            return writer;
        };
    
        /**
         * Encodes the specified CUserMessageUpdateCssClasses message, length delimited. Does not implicitly {@link CUserMessageUpdateCssClasses.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CUserMessageUpdateCssClasses
         * @static
         * @param {ICUserMessageUpdateCssClasses} message CUserMessageUpdateCssClasses message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CUserMessageUpdateCssClasses.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CUserMessageUpdateCssClasses message from the specified reader or buffer.
         * @function decode
         * @memberof CUserMessageUpdateCssClasses
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CUserMessageUpdateCssClasses} CUserMessageUpdateCssClasses
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CUserMessageUpdateCssClasses.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CUserMessageUpdateCssClasses();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.targetWorldPanel = reader.int32();
                        break;
                    }
                case 2: {
                        message.cssClasses = reader.string();
                        break;
                    }
                case 3: {
                        message.isAdd = reader.bool();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CUserMessageUpdateCssClasses message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CUserMessageUpdateCssClasses
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CUserMessageUpdateCssClasses} CUserMessageUpdateCssClasses
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CUserMessageUpdateCssClasses.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CUserMessageUpdateCssClasses message.
         * @function verify
         * @memberof CUserMessageUpdateCssClasses
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CUserMessageUpdateCssClasses.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.targetWorldPanel != null && message.hasOwnProperty("targetWorldPanel"))
                if (!$util.isInteger(message.targetWorldPanel))
                    return "targetWorldPanel: integer expected";
            if (message.cssClasses != null && message.hasOwnProperty("cssClasses"))
                if (!$util.isString(message.cssClasses))
                    return "cssClasses: string expected";
            if (message.isAdd != null && message.hasOwnProperty("isAdd"))
                if (typeof message.isAdd !== "boolean")
                    return "isAdd: boolean expected";
            return null;
        };
    
        /**
         * Creates a CUserMessageUpdateCssClasses message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CUserMessageUpdateCssClasses
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CUserMessageUpdateCssClasses} CUserMessageUpdateCssClasses
         */
        CUserMessageUpdateCssClasses.fromObject = function fromObject(object) {
            if (object instanceof $root.CUserMessageUpdateCssClasses)
                return object;
            var message = new $root.CUserMessageUpdateCssClasses();
            if (object.targetWorldPanel != null)
                message.targetWorldPanel = object.targetWorldPanel | 0;
            if (object.cssClasses != null)
                message.cssClasses = String(object.cssClasses);
            if (object.isAdd != null)
                message.isAdd = Boolean(object.isAdd);
            return message;
        };
    
        /**
         * Creates a plain object from a CUserMessageUpdateCssClasses message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CUserMessageUpdateCssClasses
         * @static
         * @param {CUserMessageUpdateCssClasses} message CUserMessageUpdateCssClasses
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CUserMessageUpdateCssClasses.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.targetWorldPanel = 0;
                object.cssClasses = "";
                object.isAdd = false;
            }
            if (message.targetWorldPanel != null && message.hasOwnProperty("targetWorldPanel"))
                object.targetWorldPanel = message.targetWorldPanel;
            if (message.cssClasses != null && message.hasOwnProperty("cssClasses"))
                object.cssClasses = message.cssClasses;
            if (message.isAdd != null && message.hasOwnProperty("isAdd"))
                object.isAdd = message.isAdd;
            return object;
        };
    
        /**
         * Converts this CUserMessageUpdateCssClasses to JSON.
         * @function toJSON
         * @memberof CUserMessageUpdateCssClasses
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CUserMessageUpdateCssClasses.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * Gets the default type url for CUserMessageUpdateCssClasses
         * @function getTypeUrl
         * @memberof CUserMessageUpdateCssClasses
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        CUserMessageUpdateCssClasses.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/CUserMessageUpdateCssClasses";
        };
    
        return CUserMessageUpdateCssClasses;
    })();
    
    $root.CUserMessageServerFrameTime = (function() {
    
        /**
         * Properties of a CUserMessageServerFrameTime.
         * @exports ICUserMessageServerFrameTime
         * @interface ICUserMessageServerFrameTime
         * @property {number|null} [frameTime] CUserMessageServerFrameTime frameTime
         */
    
        /**
         * Constructs a new CUserMessageServerFrameTime.
         * @exports CUserMessageServerFrameTime
         * @classdesc Represents a CUserMessageServerFrameTime.
         * @implements ICUserMessageServerFrameTime
         * @constructor
         * @param {ICUserMessageServerFrameTime=} [properties] Properties to set
         */
        function CUserMessageServerFrameTime(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CUserMessageServerFrameTime frameTime.
         * @member {number} frameTime
         * @memberof CUserMessageServerFrameTime
         * @instance
         */
        CUserMessageServerFrameTime.prototype.frameTime = 0;
    
        /**
         * Creates a new CUserMessageServerFrameTime instance using the specified properties.
         * @function create
         * @memberof CUserMessageServerFrameTime
         * @static
         * @param {ICUserMessageServerFrameTime=} [properties] Properties to set
         * @returns {CUserMessageServerFrameTime} CUserMessageServerFrameTime instance
         */
        CUserMessageServerFrameTime.create = function create(properties) {
            return new CUserMessageServerFrameTime(properties);
        };
    
        /**
         * Encodes the specified CUserMessageServerFrameTime message. Does not implicitly {@link CUserMessageServerFrameTime.verify|verify} messages.
         * @function encode
         * @memberof CUserMessageServerFrameTime
         * @static
         * @param {ICUserMessageServerFrameTime} message CUserMessageServerFrameTime message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CUserMessageServerFrameTime.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.frameTime != null && Object.hasOwnProperty.call(message, "frameTime"))
                writer.uint32(/* id 1, wireType 5 =*/13).float(message.frameTime);
            return writer;
        };
    
        /**
         * Encodes the specified CUserMessageServerFrameTime message, length delimited. Does not implicitly {@link CUserMessageServerFrameTime.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CUserMessageServerFrameTime
         * @static
         * @param {ICUserMessageServerFrameTime} message CUserMessageServerFrameTime message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CUserMessageServerFrameTime.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CUserMessageServerFrameTime message from the specified reader or buffer.
         * @function decode
         * @memberof CUserMessageServerFrameTime
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CUserMessageServerFrameTime} CUserMessageServerFrameTime
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CUserMessageServerFrameTime.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CUserMessageServerFrameTime();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.frameTime = reader.float();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CUserMessageServerFrameTime message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CUserMessageServerFrameTime
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CUserMessageServerFrameTime} CUserMessageServerFrameTime
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CUserMessageServerFrameTime.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CUserMessageServerFrameTime message.
         * @function verify
         * @memberof CUserMessageServerFrameTime
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CUserMessageServerFrameTime.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.frameTime != null && message.hasOwnProperty("frameTime"))
                if (typeof message.frameTime !== "number")
                    return "frameTime: number expected";
            return null;
        };
    
        /**
         * Creates a CUserMessageServerFrameTime message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CUserMessageServerFrameTime
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CUserMessageServerFrameTime} CUserMessageServerFrameTime
         */
        CUserMessageServerFrameTime.fromObject = function fromObject(object) {
            if (object instanceof $root.CUserMessageServerFrameTime)
                return object;
            var message = new $root.CUserMessageServerFrameTime();
            if (object.frameTime != null)
                message.frameTime = Number(object.frameTime);
            return message;
        };
    
        /**
         * Creates a plain object from a CUserMessageServerFrameTime message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CUserMessageServerFrameTime
         * @static
         * @param {CUserMessageServerFrameTime} message CUserMessageServerFrameTime
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CUserMessageServerFrameTime.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.frameTime = 0;
            if (message.frameTime != null && message.hasOwnProperty("frameTime"))
                object.frameTime = options.json && !isFinite(message.frameTime) ? String(message.frameTime) : message.frameTime;
            return object;
        };
    
        /**
         * Converts this CUserMessageServerFrameTime to JSON.
         * @function toJSON
         * @memberof CUserMessageServerFrameTime
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CUserMessageServerFrameTime.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * Gets the default type url for CUserMessageServerFrameTime
         * @function getTypeUrl
         * @memberof CUserMessageServerFrameTime
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        CUserMessageServerFrameTime.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/CUserMessageServerFrameTime";
        };
    
        return CUserMessageServerFrameTime;
    })();
    
    $root.CUserMessageLagCompensationError = (function() {
    
        /**
         * Properties of a CUserMessageLagCompensationError.
         * @exports ICUserMessageLagCompensationError
         * @interface ICUserMessageLagCompensationError
         * @property {number|null} [distance] CUserMessageLagCompensationError distance
         */
    
        /**
         * Constructs a new CUserMessageLagCompensationError.
         * @exports CUserMessageLagCompensationError
         * @classdesc Represents a CUserMessageLagCompensationError.
         * @implements ICUserMessageLagCompensationError
         * @constructor
         * @param {ICUserMessageLagCompensationError=} [properties] Properties to set
         */
        function CUserMessageLagCompensationError(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CUserMessageLagCompensationError distance.
         * @member {number} distance
         * @memberof CUserMessageLagCompensationError
         * @instance
         */
        CUserMessageLagCompensationError.prototype.distance = 0;
    
        /**
         * Creates a new CUserMessageLagCompensationError instance using the specified properties.
         * @function create
         * @memberof CUserMessageLagCompensationError
         * @static
         * @param {ICUserMessageLagCompensationError=} [properties] Properties to set
         * @returns {CUserMessageLagCompensationError} CUserMessageLagCompensationError instance
         */
        CUserMessageLagCompensationError.create = function create(properties) {
            return new CUserMessageLagCompensationError(properties);
        };
    
        /**
         * Encodes the specified CUserMessageLagCompensationError message. Does not implicitly {@link CUserMessageLagCompensationError.verify|verify} messages.
         * @function encode
         * @memberof CUserMessageLagCompensationError
         * @static
         * @param {ICUserMessageLagCompensationError} message CUserMessageLagCompensationError message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CUserMessageLagCompensationError.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.distance != null && Object.hasOwnProperty.call(message, "distance"))
                writer.uint32(/* id 1, wireType 5 =*/13).float(message.distance);
            return writer;
        };
    
        /**
         * Encodes the specified CUserMessageLagCompensationError message, length delimited. Does not implicitly {@link CUserMessageLagCompensationError.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CUserMessageLagCompensationError
         * @static
         * @param {ICUserMessageLagCompensationError} message CUserMessageLagCompensationError message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CUserMessageLagCompensationError.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CUserMessageLagCompensationError message from the specified reader or buffer.
         * @function decode
         * @memberof CUserMessageLagCompensationError
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CUserMessageLagCompensationError} CUserMessageLagCompensationError
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CUserMessageLagCompensationError.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CUserMessageLagCompensationError();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.distance = reader.float();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CUserMessageLagCompensationError message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CUserMessageLagCompensationError
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CUserMessageLagCompensationError} CUserMessageLagCompensationError
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CUserMessageLagCompensationError.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CUserMessageLagCompensationError message.
         * @function verify
         * @memberof CUserMessageLagCompensationError
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CUserMessageLagCompensationError.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.distance != null && message.hasOwnProperty("distance"))
                if (typeof message.distance !== "number")
                    return "distance: number expected";
            return null;
        };
    
        /**
         * Creates a CUserMessageLagCompensationError message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CUserMessageLagCompensationError
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CUserMessageLagCompensationError} CUserMessageLagCompensationError
         */
        CUserMessageLagCompensationError.fromObject = function fromObject(object) {
            if (object instanceof $root.CUserMessageLagCompensationError)
                return object;
            var message = new $root.CUserMessageLagCompensationError();
            if (object.distance != null)
                message.distance = Number(object.distance);
            return message;
        };
    
        /**
         * Creates a plain object from a CUserMessageLagCompensationError message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CUserMessageLagCompensationError
         * @static
         * @param {CUserMessageLagCompensationError} message CUserMessageLagCompensationError
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CUserMessageLagCompensationError.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.distance = 0;
            if (message.distance != null && message.hasOwnProperty("distance"))
                object.distance = options.json && !isFinite(message.distance) ? String(message.distance) : message.distance;
            return object;
        };
    
        /**
         * Converts this CUserMessageLagCompensationError to JSON.
         * @function toJSON
         * @memberof CUserMessageLagCompensationError
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CUserMessageLagCompensationError.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * Gets the default type url for CUserMessageLagCompensationError
         * @function getTypeUrl
         * @memberof CUserMessageLagCompensationError
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        CUserMessageLagCompensationError.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/CUserMessageLagCompensationError";
        };
    
        return CUserMessageLagCompensationError;
    })();
    
    $root.CUserMessageRequestDllStatus = (function() {
    
        /**
         * Properties of a CUserMessageRequestDllStatus.
         * @exports ICUserMessageRequestDllStatus
         * @interface ICUserMessageRequestDllStatus
         * @property {string|null} [dllAction] CUserMessageRequestDllStatus dllAction
         * @property {boolean|null} [fullReport] CUserMessageRequestDllStatus fullReport
         */
    
        /**
         * Constructs a new CUserMessageRequestDllStatus.
         * @exports CUserMessageRequestDllStatus
         * @classdesc Represents a CUserMessageRequestDllStatus.
         * @implements ICUserMessageRequestDllStatus
         * @constructor
         * @param {ICUserMessageRequestDllStatus=} [properties] Properties to set
         */
        function CUserMessageRequestDllStatus(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CUserMessageRequestDllStatus dllAction.
         * @member {string} dllAction
         * @memberof CUserMessageRequestDllStatus
         * @instance
         */
        CUserMessageRequestDllStatus.prototype.dllAction = "";
    
        /**
         * CUserMessageRequestDllStatus fullReport.
         * @member {boolean} fullReport
         * @memberof CUserMessageRequestDllStatus
         * @instance
         */
        CUserMessageRequestDllStatus.prototype.fullReport = false;
    
        /**
         * Creates a new CUserMessageRequestDllStatus instance using the specified properties.
         * @function create
         * @memberof CUserMessageRequestDllStatus
         * @static
         * @param {ICUserMessageRequestDllStatus=} [properties] Properties to set
         * @returns {CUserMessageRequestDllStatus} CUserMessageRequestDllStatus instance
         */
        CUserMessageRequestDllStatus.create = function create(properties) {
            return new CUserMessageRequestDllStatus(properties);
        };
    
        /**
         * Encodes the specified CUserMessageRequestDllStatus message. Does not implicitly {@link CUserMessageRequestDllStatus.verify|verify} messages.
         * @function encode
         * @memberof CUserMessageRequestDllStatus
         * @static
         * @param {ICUserMessageRequestDllStatus} message CUserMessageRequestDllStatus message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CUserMessageRequestDllStatus.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.dllAction != null && Object.hasOwnProperty.call(message, "dllAction"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.dllAction);
            if (message.fullReport != null && Object.hasOwnProperty.call(message, "fullReport"))
                writer.uint32(/* id 2, wireType 0 =*/16).bool(message.fullReport);
            return writer;
        };
    
        /**
         * Encodes the specified CUserMessageRequestDllStatus message, length delimited. Does not implicitly {@link CUserMessageRequestDllStatus.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CUserMessageRequestDllStatus
         * @static
         * @param {ICUserMessageRequestDllStatus} message CUserMessageRequestDllStatus message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CUserMessageRequestDllStatus.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CUserMessageRequestDllStatus message from the specified reader or buffer.
         * @function decode
         * @memberof CUserMessageRequestDllStatus
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CUserMessageRequestDllStatus} CUserMessageRequestDllStatus
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CUserMessageRequestDllStatus.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CUserMessageRequestDllStatus();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.dllAction = reader.string();
                        break;
                    }
                case 2: {
                        message.fullReport = reader.bool();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CUserMessageRequestDllStatus message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CUserMessageRequestDllStatus
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CUserMessageRequestDllStatus} CUserMessageRequestDllStatus
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CUserMessageRequestDllStatus.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CUserMessageRequestDllStatus message.
         * @function verify
         * @memberof CUserMessageRequestDllStatus
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CUserMessageRequestDllStatus.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.dllAction != null && message.hasOwnProperty("dllAction"))
                if (!$util.isString(message.dllAction))
                    return "dllAction: string expected";
            if (message.fullReport != null && message.hasOwnProperty("fullReport"))
                if (typeof message.fullReport !== "boolean")
                    return "fullReport: boolean expected";
            return null;
        };
    
        /**
         * Creates a CUserMessageRequestDllStatus message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CUserMessageRequestDllStatus
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CUserMessageRequestDllStatus} CUserMessageRequestDllStatus
         */
        CUserMessageRequestDllStatus.fromObject = function fromObject(object) {
            if (object instanceof $root.CUserMessageRequestDllStatus)
                return object;
            var message = new $root.CUserMessageRequestDllStatus();
            if (object.dllAction != null)
                message.dllAction = String(object.dllAction);
            if (object.fullReport != null)
                message.fullReport = Boolean(object.fullReport);
            return message;
        };
    
        /**
         * Creates a plain object from a CUserMessageRequestDllStatus message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CUserMessageRequestDllStatus
         * @static
         * @param {CUserMessageRequestDllStatus} message CUserMessageRequestDllStatus
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CUserMessageRequestDllStatus.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.dllAction = "";
                object.fullReport = false;
            }
            if (message.dllAction != null && message.hasOwnProperty("dllAction"))
                object.dllAction = message.dllAction;
            if (message.fullReport != null && message.hasOwnProperty("fullReport"))
                object.fullReport = message.fullReport;
            return object;
        };
    
        /**
         * Converts this CUserMessageRequestDllStatus to JSON.
         * @function toJSON
         * @memberof CUserMessageRequestDllStatus
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CUserMessageRequestDllStatus.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * Gets the default type url for CUserMessageRequestDllStatus
         * @function getTypeUrl
         * @memberof CUserMessageRequestDllStatus
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        CUserMessageRequestDllStatus.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/CUserMessageRequestDllStatus";
        };
    
        return CUserMessageRequestDllStatus;
    })();
    
    $root.CUserMessageRequestUtilAction = (function() {
    
        /**
         * Properties of a CUserMessageRequestUtilAction.
         * @exports ICUserMessageRequestUtilAction
         * @interface ICUserMessageRequestUtilAction
         * @property {number|null} [util1] CUserMessageRequestUtilAction util1
         * @property {number|null} [util2] CUserMessageRequestUtilAction util2
         * @property {number|null} [util3] CUserMessageRequestUtilAction util3
         * @property {number|null} [util4] CUserMessageRequestUtilAction util4
         * @property {number|null} [util5] CUserMessageRequestUtilAction util5
         */
    
        /**
         * Constructs a new CUserMessageRequestUtilAction.
         * @exports CUserMessageRequestUtilAction
         * @classdesc Represents a CUserMessageRequestUtilAction.
         * @implements ICUserMessageRequestUtilAction
         * @constructor
         * @param {ICUserMessageRequestUtilAction=} [properties] Properties to set
         */
        function CUserMessageRequestUtilAction(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CUserMessageRequestUtilAction util1.
         * @member {number} util1
         * @memberof CUserMessageRequestUtilAction
         * @instance
         */
        CUserMessageRequestUtilAction.prototype.util1 = 0;
    
        /**
         * CUserMessageRequestUtilAction util2.
         * @member {number} util2
         * @memberof CUserMessageRequestUtilAction
         * @instance
         */
        CUserMessageRequestUtilAction.prototype.util2 = 0;
    
        /**
         * CUserMessageRequestUtilAction util3.
         * @member {number} util3
         * @memberof CUserMessageRequestUtilAction
         * @instance
         */
        CUserMessageRequestUtilAction.prototype.util3 = 0;
    
        /**
         * CUserMessageRequestUtilAction util4.
         * @member {number} util4
         * @memberof CUserMessageRequestUtilAction
         * @instance
         */
        CUserMessageRequestUtilAction.prototype.util4 = 0;
    
        /**
         * CUserMessageRequestUtilAction util5.
         * @member {number} util5
         * @memberof CUserMessageRequestUtilAction
         * @instance
         */
        CUserMessageRequestUtilAction.prototype.util5 = 0;
    
        /**
         * Creates a new CUserMessageRequestUtilAction instance using the specified properties.
         * @function create
         * @memberof CUserMessageRequestUtilAction
         * @static
         * @param {ICUserMessageRequestUtilAction=} [properties] Properties to set
         * @returns {CUserMessageRequestUtilAction} CUserMessageRequestUtilAction instance
         */
        CUserMessageRequestUtilAction.create = function create(properties) {
            return new CUserMessageRequestUtilAction(properties);
        };
    
        /**
         * Encodes the specified CUserMessageRequestUtilAction message. Does not implicitly {@link CUserMessageRequestUtilAction.verify|verify} messages.
         * @function encode
         * @memberof CUserMessageRequestUtilAction
         * @static
         * @param {ICUserMessageRequestUtilAction} message CUserMessageRequestUtilAction message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CUserMessageRequestUtilAction.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.util1 != null && Object.hasOwnProperty.call(message, "util1"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.util1);
            if (message.util2 != null && Object.hasOwnProperty.call(message, "util2"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.util2);
            if (message.util3 != null && Object.hasOwnProperty.call(message, "util3"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.util3);
            if (message.util4 != null && Object.hasOwnProperty.call(message, "util4"))
                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.util4);
            if (message.util5 != null && Object.hasOwnProperty.call(message, "util5"))
                writer.uint32(/* id 6, wireType 0 =*/48).int32(message.util5);
            return writer;
        };
    
        /**
         * Encodes the specified CUserMessageRequestUtilAction message, length delimited. Does not implicitly {@link CUserMessageRequestUtilAction.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CUserMessageRequestUtilAction
         * @static
         * @param {ICUserMessageRequestUtilAction} message CUserMessageRequestUtilAction message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CUserMessageRequestUtilAction.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CUserMessageRequestUtilAction message from the specified reader or buffer.
         * @function decode
         * @memberof CUserMessageRequestUtilAction
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CUserMessageRequestUtilAction} CUserMessageRequestUtilAction
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CUserMessageRequestUtilAction.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CUserMessageRequestUtilAction();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 2: {
                        message.util1 = reader.int32();
                        break;
                    }
                case 3: {
                        message.util2 = reader.int32();
                        break;
                    }
                case 4: {
                        message.util3 = reader.int32();
                        break;
                    }
                case 5: {
                        message.util4 = reader.int32();
                        break;
                    }
                case 6: {
                        message.util5 = reader.int32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CUserMessageRequestUtilAction message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CUserMessageRequestUtilAction
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CUserMessageRequestUtilAction} CUserMessageRequestUtilAction
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CUserMessageRequestUtilAction.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CUserMessageRequestUtilAction message.
         * @function verify
         * @memberof CUserMessageRequestUtilAction
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CUserMessageRequestUtilAction.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.util1 != null && message.hasOwnProperty("util1"))
                if (!$util.isInteger(message.util1))
                    return "util1: integer expected";
            if (message.util2 != null && message.hasOwnProperty("util2"))
                if (!$util.isInteger(message.util2))
                    return "util2: integer expected";
            if (message.util3 != null && message.hasOwnProperty("util3"))
                if (!$util.isInteger(message.util3))
                    return "util3: integer expected";
            if (message.util4 != null && message.hasOwnProperty("util4"))
                if (!$util.isInteger(message.util4))
                    return "util4: integer expected";
            if (message.util5 != null && message.hasOwnProperty("util5"))
                if (!$util.isInteger(message.util5))
                    return "util5: integer expected";
            return null;
        };
    
        /**
         * Creates a CUserMessageRequestUtilAction message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CUserMessageRequestUtilAction
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CUserMessageRequestUtilAction} CUserMessageRequestUtilAction
         */
        CUserMessageRequestUtilAction.fromObject = function fromObject(object) {
            if (object instanceof $root.CUserMessageRequestUtilAction)
                return object;
            var message = new $root.CUserMessageRequestUtilAction();
            if (object.util1 != null)
                message.util1 = object.util1 | 0;
            if (object.util2 != null)
                message.util2 = object.util2 | 0;
            if (object.util3 != null)
                message.util3 = object.util3 | 0;
            if (object.util4 != null)
                message.util4 = object.util4 | 0;
            if (object.util5 != null)
                message.util5 = object.util5 | 0;
            return message;
        };
    
        /**
         * Creates a plain object from a CUserMessageRequestUtilAction message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CUserMessageRequestUtilAction
         * @static
         * @param {CUserMessageRequestUtilAction} message CUserMessageRequestUtilAction
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CUserMessageRequestUtilAction.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.util1 = 0;
                object.util2 = 0;
                object.util3 = 0;
                object.util4 = 0;
                object.util5 = 0;
            }
            if (message.util1 != null && message.hasOwnProperty("util1"))
                object.util1 = message.util1;
            if (message.util2 != null && message.hasOwnProperty("util2"))
                object.util2 = message.util2;
            if (message.util3 != null && message.hasOwnProperty("util3"))
                object.util3 = message.util3;
            if (message.util4 != null && message.hasOwnProperty("util4"))
                object.util4 = message.util4;
            if (message.util5 != null && message.hasOwnProperty("util5"))
                object.util5 = message.util5;
            return object;
        };
    
        /**
         * Converts this CUserMessageRequestUtilAction to JSON.
         * @function toJSON
         * @memberof CUserMessageRequestUtilAction
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CUserMessageRequestUtilAction.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * Gets the default type url for CUserMessageRequestUtilAction
         * @function getTypeUrl
         * @memberof CUserMessageRequestUtilAction
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        CUserMessageRequestUtilAction.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/CUserMessageRequestUtilAction";
        };
    
        return CUserMessageRequestUtilAction;
    })();
    
    $root.CUserMessage_UtilMsg_Response = (function() {
    
        /**
         * Properties of a CUserMessage_UtilMsg_Response.
         * @exports ICUserMessage_UtilMsg_Response
         * @interface ICUserMessage_UtilMsg_Response
         * @property {number|null} [crc] CUserMessage_UtilMsg_Response crc
         * @property {number|null} [itemCount] CUserMessage_UtilMsg_Response itemCount
         * @property {number|null} [crc2] CUserMessage_UtilMsg_Response crc2
         * @property {number|null} [itemCount2] CUserMessage_UtilMsg_Response itemCount2
         * @property {Array.<number>|null} [crcPart] CUserMessage_UtilMsg_Response crcPart
         * @property {Array.<number>|null} [crcPart2] CUserMessage_UtilMsg_Response crcPart2
         * @property {number|null} [clientTimestamp] CUserMessage_UtilMsg_Response clientTimestamp
         * @property {number|null} [platform] CUserMessage_UtilMsg_Response platform
         * @property {Array.<CUserMessage_UtilMsg_Response.IItemDetail>|null} [itemdetails] CUserMessage_UtilMsg_Response itemdetails
         * @property {number|null} [itemgroup] CUserMessage_UtilMsg_Response itemgroup
         * @property {number|null} [totalCount] CUserMessage_UtilMsg_Response totalCount
         * @property {number|null} [totalCount2] CUserMessage_UtilMsg_Response totalCount2
         */
    
        /**
         * Constructs a new CUserMessage_UtilMsg_Response.
         * @exports CUserMessage_UtilMsg_Response
         * @classdesc Represents a CUserMessage_UtilMsg_Response.
         * @implements ICUserMessage_UtilMsg_Response
         * @constructor
         * @param {ICUserMessage_UtilMsg_Response=} [properties] Properties to set
         */
        function CUserMessage_UtilMsg_Response(properties) {
            this.crcPart = [];
            this.crcPart2 = [];
            this.itemdetails = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CUserMessage_UtilMsg_Response crc.
         * @member {number} crc
         * @memberof CUserMessage_UtilMsg_Response
         * @instance
         */
        CUserMessage_UtilMsg_Response.prototype.crc = 0;
    
        /**
         * CUserMessage_UtilMsg_Response itemCount.
         * @member {number} itemCount
         * @memberof CUserMessage_UtilMsg_Response
         * @instance
         */
        CUserMessage_UtilMsg_Response.prototype.itemCount = 0;
    
        /**
         * CUserMessage_UtilMsg_Response crc2.
         * @member {number} crc2
         * @memberof CUserMessage_UtilMsg_Response
         * @instance
         */
        CUserMessage_UtilMsg_Response.prototype.crc2 = 0;
    
        /**
         * CUserMessage_UtilMsg_Response itemCount2.
         * @member {number} itemCount2
         * @memberof CUserMessage_UtilMsg_Response
         * @instance
         */
        CUserMessage_UtilMsg_Response.prototype.itemCount2 = 0;
    
        /**
         * CUserMessage_UtilMsg_Response crcPart.
         * @member {Array.<number>} crcPart
         * @memberof CUserMessage_UtilMsg_Response
         * @instance
         */
        CUserMessage_UtilMsg_Response.prototype.crcPart = $util.emptyArray;
    
        /**
         * CUserMessage_UtilMsg_Response crcPart2.
         * @member {Array.<number>} crcPart2
         * @memberof CUserMessage_UtilMsg_Response
         * @instance
         */
        CUserMessage_UtilMsg_Response.prototype.crcPart2 = $util.emptyArray;
    
        /**
         * CUserMessage_UtilMsg_Response clientTimestamp.
         * @member {number} clientTimestamp
         * @memberof CUserMessage_UtilMsg_Response
         * @instance
         */
        CUserMessage_UtilMsg_Response.prototype.clientTimestamp = 0;
    
        /**
         * CUserMessage_UtilMsg_Response platform.
         * @member {number} platform
         * @memberof CUserMessage_UtilMsg_Response
         * @instance
         */
        CUserMessage_UtilMsg_Response.prototype.platform = 0;
    
        /**
         * CUserMessage_UtilMsg_Response itemdetails.
         * @member {Array.<CUserMessage_UtilMsg_Response.IItemDetail>} itemdetails
         * @memberof CUserMessage_UtilMsg_Response
         * @instance
         */
        CUserMessage_UtilMsg_Response.prototype.itemdetails = $util.emptyArray;
    
        /**
         * CUserMessage_UtilMsg_Response itemgroup.
         * @member {number} itemgroup
         * @memberof CUserMessage_UtilMsg_Response
         * @instance
         */
        CUserMessage_UtilMsg_Response.prototype.itemgroup = 0;
    
        /**
         * CUserMessage_UtilMsg_Response totalCount.
         * @member {number} totalCount
         * @memberof CUserMessage_UtilMsg_Response
         * @instance
         */
        CUserMessage_UtilMsg_Response.prototype.totalCount = 0;
    
        /**
         * CUserMessage_UtilMsg_Response totalCount2.
         * @member {number} totalCount2
         * @memberof CUserMessage_UtilMsg_Response
         * @instance
         */
        CUserMessage_UtilMsg_Response.prototype.totalCount2 = 0;
    
        /**
         * Creates a new CUserMessage_UtilMsg_Response instance using the specified properties.
         * @function create
         * @memberof CUserMessage_UtilMsg_Response
         * @static
         * @param {ICUserMessage_UtilMsg_Response=} [properties] Properties to set
         * @returns {CUserMessage_UtilMsg_Response} CUserMessage_UtilMsg_Response instance
         */
        CUserMessage_UtilMsg_Response.create = function create(properties) {
            return new CUserMessage_UtilMsg_Response(properties);
        };
    
        /**
         * Encodes the specified CUserMessage_UtilMsg_Response message. Does not implicitly {@link CUserMessage_UtilMsg_Response.verify|verify} messages.
         * @function encode
         * @memberof CUserMessage_UtilMsg_Response
         * @static
         * @param {ICUserMessage_UtilMsg_Response} message CUserMessage_UtilMsg_Response message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CUserMessage_UtilMsg_Response.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.crc != null && Object.hasOwnProperty.call(message, "crc"))
                writer.uint32(/* id 1, wireType 5 =*/13).fixed32(message.crc);
            if (message.itemCount != null && Object.hasOwnProperty.call(message, "itemCount"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.itemCount);
            if (message.crc2 != null && Object.hasOwnProperty.call(message, "crc2"))
                writer.uint32(/* id 3, wireType 5 =*/29).fixed32(message.crc2);
            if (message.itemCount2 != null && Object.hasOwnProperty.call(message, "itemCount2"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.itemCount2);
            if (message.crcPart != null && message.crcPart.length)
                for (var i = 0; i < message.crcPart.length; ++i)
                    writer.uint32(/* id 5, wireType 0 =*/40).int32(message.crcPart[i]);
            if (message.crcPart2 != null && message.crcPart2.length)
                for (var i = 0; i < message.crcPart2.length; ++i)
                    writer.uint32(/* id 6, wireType 0 =*/48).int32(message.crcPart2[i]);
            if (message.clientTimestamp != null && Object.hasOwnProperty.call(message, "clientTimestamp"))
                writer.uint32(/* id 7, wireType 0 =*/56).int32(message.clientTimestamp);
            if (message.platform != null && Object.hasOwnProperty.call(message, "platform"))
                writer.uint32(/* id 8, wireType 0 =*/64).int32(message.platform);
            if (message.itemdetails != null && message.itemdetails.length)
                for (var i = 0; i < message.itemdetails.length; ++i)
                    $root.CUserMessage_UtilMsg_Response.ItemDetail.encode(message.itemdetails[i], writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
            if (message.itemgroup != null && Object.hasOwnProperty.call(message, "itemgroup"))
                writer.uint32(/* id 10, wireType 0 =*/80).int32(message.itemgroup);
            if (message.totalCount != null && Object.hasOwnProperty.call(message, "totalCount"))
                writer.uint32(/* id 11, wireType 0 =*/88).int32(message.totalCount);
            if (message.totalCount2 != null && Object.hasOwnProperty.call(message, "totalCount2"))
                writer.uint32(/* id 12, wireType 0 =*/96).int32(message.totalCount2);
            return writer;
        };
    
        /**
         * Encodes the specified CUserMessage_UtilMsg_Response message, length delimited. Does not implicitly {@link CUserMessage_UtilMsg_Response.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CUserMessage_UtilMsg_Response
         * @static
         * @param {ICUserMessage_UtilMsg_Response} message CUserMessage_UtilMsg_Response message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CUserMessage_UtilMsg_Response.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CUserMessage_UtilMsg_Response message from the specified reader or buffer.
         * @function decode
         * @memberof CUserMessage_UtilMsg_Response
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CUserMessage_UtilMsg_Response} CUserMessage_UtilMsg_Response
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CUserMessage_UtilMsg_Response.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CUserMessage_UtilMsg_Response();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.crc = reader.fixed32();
                        break;
                    }
                case 2: {
                        message.itemCount = reader.int32();
                        break;
                    }
                case 3: {
                        message.crc2 = reader.fixed32();
                        break;
                    }
                case 4: {
                        message.itemCount2 = reader.int32();
                        break;
                    }
                case 5: {
                        if (!(message.crcPart && message.crcPart.length))
                            message.crcPart = [];
                        if ((tag & 7) === 2) {
                            var end2 = reader.uint32() + reader.pos;
                            while (reader.pos < end2)
                                message.crcPart.push(reader.int32());
                        } else
                            message.crcPart.push(reader.int32());
                        break;
                    }
                case 6: {
                        if (!(message.crcPart2 && message.crcPart2.length))
                            message.crcPart2 = [];
                        if ((tag & 7) === 2) {
                            var end2 = reader.uint32() + reader.pos;
                            while (reader.pos < end2)
                                message.crcPart2.push(reader.int32());
                        } else
                            message.crcPart2.push(reader.int32());
                        break;
                    }
                case 7: {
                        message.clientTimestamp = reader.int32();
                        break;
                    }
                case 8: {
                        message.platform = reader.int32();
                        break;
                    }
                case 9: {
                        if (!(message.itemdetails && message.itemdetails.length))
                            message.itemdetails = [];
                        message.itemdetails.push($root.CUserMessage_UtilMsg_Response.ItemDetail.decode(reader, reader.uint32()));
                        break;
                    }
                case 10: {
                        message.itemgroup = reader.int32();
                        break;
                    }
                case 11: {
                        message.totalCount = reader.int32();
                        break;
                    }
                case 12: {
                        message.totalCount2 = reader.int32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CUserMessage_UtilMsg_Response message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CUserMessage_UtilMsg_Response
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CUserMessage_UtilMsg_Response} CUserMessage_UtilMsg_Response
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CUserMessage_UtilMsg_Response.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CUserMessage_UtilMsg_Response message.
         * @function verify
         * @memberof CUserMessage_UtilMsg_Response
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CUserMessage_UtilMsg_Response.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.crc != null && message.hasOwnProperty("crc"))
                if (!$util.isInteger(message.crc))
                    return "crc: integer expected";
            if (message.itemCount != null && message.hasOwnProperty("itemCount"))
                if (!$util.isInteger(message.itemCount))
                    return "itemCount: integer expected";
            if (message.crc2 != null && message.hasOwnProperty("crc2"))
                if (!$util.isInteger(message.crc2))
                    return "crc2: integer expected";
            if (message.itemCount2 != null && message.hasOwnProperty("itemCount2"))
                if (!$util.isInteger(message.itemCount2))
                    return "itemCount2: integer expected";
            if (message.crcPart != null && message.hasOwnProperty("crcPart")) {
                if (!Array.isArray(message.crcPart))
                    return "crcPart: array expected";
                for (var i = 0; i < message.crcPart.length; ++i)
                    if (!$util.isInteger(message.crcPart[i]))
                        return "crcPart: integer[] expected";
            }
            if (message.crcPart2 != null && message.hasOwnProperty("crcPart2")) {
                if (!Array.isArray(message.crcPart2))
                    return "crcPart2: array expected";
                for (var i = 0; i < message.crcPart2.length; ++i)
                    if (!$util.isInteger(message.crcPart2[i]))
                        return "crcPart2: integer[] expected";
            }
            if (message.clientTimestamp != null && message.hasOwnProperty("clientTimestamp"))
                if (!$util.isInteger(message.clientTimestamp))
                    return "clientTimestamp: integer expected";
            if (message.platform != null && message.hasOwnProperty("platform"))
                if (!$util.isInteger(message.platform))
                    return "platform: integer expected";
            if (message.itemdetails != null && message.hasOwnProperty("itemdetails")) {
                if (!Array.isArray(message.itemdetails))
                    return "itemdetails: array expected";
                for (var i = 0; i < message.itemdetails.length; ++i) {
                    var error = $root.CUserMessage_UtilMsg_Response.ItemDetail.verify(message.itemdetails[i]);
                    if (error)
                        return "itemdetails." + error;
                }
            }
            if (message.itemgroup != null && message.hasOwnProperty("itemgroup"))
                if (!$util.isInteger(message.itemgroup))
                    return "itemgroup: integer expected";
            if (message.totalCount != null && message.hasOwnProperty("totalCount"))
                if (!$util.isInteger(message.totalCount))
                    return "totalCount: integer expected";
            if (message.totalCount2 != null && message.hasOwnProperty("totalCount2"))
                if (!$util.isInteger(message.totalCount2))
                    return "totalCount2: integer expected";
            return null;
        };
    
        /**
         * Creates a CUserMessage_UtilMsg_Response message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CUserMessage_UtilMsg_Response
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CUserMessage_UtilMsg_Response} CUserMessage_UtilMsg_Response
         */
        CUserMessage_UtilMsg_Response.fromObject = function fromObject(object) {
            if (object instanceof $root.CUserMessage_UtilMsg_Response)
                return object;
            var message = new $root.CUserMessage_UtilMsg_Response();
            if (object.crc != null)
                message.crc = object.crc >>> 0;
            if (object.itemCount != null)
                message.itemCount = object.itemCount | 0;
            if (object.crc2 != null)
                message.crc2 = object.crc2 >>> 0;
            if (object.itemCount2 != null)
                message.itemCount2 = object.itemCount2 | 0;
            if (object.crcPart) {
                if (!Array.isArray(object.crcPart))
                    throw TypeError(".CUserMessage_UtilMsg_Response.crcPart: array expected");
                message.crcPart = [];
                for (var i = 0; i < object.crcPart.length; ++i)
                    message.crcPart[i] = object.crcPart[i] | 0;
            }
            if (object.crcPart2) {
                if (!Array.isArray(object.crcPart2))
                    throw TypeError(".CUserMessage_UtilMsg_Response.crcPart2: array expected");
                message.crcPart2 = [];
                for (var i = 0; i < object.crcPart2.length; ++i)
                    message.crcPart2[i] = object.crcPart2[i] | 0;
            }
            if (object.clientTimestamp != null)
                message.clientTimestamp = object.clientTimestamp | 0;
            if (object.platform != null)
                message.platform = object.platform | 0;
            if (object.itemdetails) {
                if (!Array.isArray(object.itemdetails))
                    throw TypeError(".CUserMessage_UtilMsg_Response.itemdetails: array expected");
                message.itemdetails = [];
                for (var i = 0; i < object.itemdetails.length; ++i) {
                    if (typeof object.itemdetails[i] !== "object")
                        throw TypeError(".CUserMessage_UtilMsg_Response.itemdetails: object expected");
                    message.itemdetails[i] = $root.CUserMessage_UtilMsg_Response.ItemDetail.fromObject(object.itemdetails[i]);
                }
            }
            if (object.itemgroup != null)
                message.itemgroup = object.itemgroup | 0;
            if (object.totalCount != null)
                message.totalCount = object.totalCount | 0;
            if (object.totalCount2 != null)
                message.totalCount2 = object.totalCount2 | 0;
            return message;
        };
    
        /**
         * Creates a plain object from a CUserMessage_UtilMsg_Response message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CUserMessage_UtilMsg_Response
         * @static
         * @param {CUserMessage_UtilMsg_Response} message CUserMessage_UtilMsg_Response
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CUserMessage_UtilMsg_Response.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults) {
                object.crcPart = [];
                object.crcPart2 = [];
                object.itemdetails = [];
            }
            if (options.defaults) {
                object.crc = 0;
                object.itemCount = 0;
                object.crc2 = 0;
                object.itemCount2 = 0;
                object.clientTimestamp = 0;
                object.platform = 0;
                object.itemgroup = 0;
                object.totalCount = 0;
                object.totalCount2 = 0;
            }
            if (message.crc != null && message.hasOwnProperty("crc"))
                object.crc = message.crc;
            if (message.itemCount != null && message.hasOwnProperty("itemCount"))
                object.itemCount = message.itemCount;
            if (message.crc2 != null && message.hasOwnProperty("crc2"))
                object.crc2 = message.crc2;
            if (message.itemCount2 != null && message.hasOwnProperty("itemCount2"))
                object.itemCount2 = message.itemCount2;
            if (message.crcPart && message.crcPart.length) {
                object.crcPart = [];
                for (var j = 0; j < message.crcPart.length; ++j)
                    object.crcPart[j] = message.crcPart[j];
            }
            if (message.crcPart2 && message.crcPart2.length) {
                object.crcPart2 = [];
                for (var j = 0; j < message.crcPart2.length; ++j)
                    object.crcPart2[j] = message.crcPart2[j];
            }
            if (message.clientTimestamp != null && message.hasOwnProperty("clientTimestamp"))
                object.clientTimestamp = message.clientTimestamp;
            if (message.platform != null && message.hasOwnProperty("platform"))
                object.platform = message.platform;
            if (message.itemdetails && message.itemdetails.length) {
                object.itemdetails = [];
                for (var j = 0; j < message.itemdetails.length; ++j)
                    object.itemdetails[j] = $root.CUserMessage_UtilMsg_Response.ItemDetail.toObject(message.itemdetails[j], options);
            }
            if (message.itemgroup != null && message.hasOwnProperty("itemgroup"))
                object.itemgroup = message.itemgroup;
            if (message.totalCount != null && message.hasOwnProperty("totalCount"))
                object.totalCount = message.totalCount;
            if (message.totalCount2 != null && message.hasOwnProperty("totalCount2"))
                object.totalCount2 = message.totalCount2;
            return object;
        };
    
        /**
         * Converts this CUserMessage_UtilMsg_Response to JSON.
         * @function toJSON
         * @memberof CUserMessage_UtilMsg_Response
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CUserMessage_UtilMsg_Response.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * Gets the default type url for CUserMessage_UtilMsg_Response
         * @function getTypeUrl
         * @memberof CUserMessage_UtilMsg_Response
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        CUserMessage_UtilMsg_Response.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/CUserMessage_UtilMsg_Response";
        };
    
        CUserMessage_UtilMsg_Response.ItemDetail = (function() {
    
            /**
             * Properties of an ItemDetail.
             * @memberof CUserMessage_UtilMsg_Response
             * @interface IItemDetail
             * @property {number|null} [index] ItemDetail index
             * @property {number|null} [hash] ItemDetail hash
             * @property {number|null} [crc] ItemDetail crc
             * @property {string|null} [name] ItemDetail name
             */
    
            /**
             * Constructs a new ItemDetail.
             * @memberof CUserMessage_UtilMsg_Response
             * @classdesc Represents an ItemDetail.
             * @implements IItemDetail
             * @constructor
             * @param {CUserMessage_UtilMsg_Response.IItemDetail=} [properties] Properties to set
             */
            function ItemDetail(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * ItemDetail index.
             * @member {number} index
             * @memberof CUserMessage_UtilMsg_Response.ItemDetail
             * @instance
             */
            ItemDetail.prototype.index = 0;
    
            /**
             * ItemDetail hash.
             * @member {number} hash
             * @memberof CUserMessage_UtilMsg_Response.ItemDetail
             * @instance
             */
            ItemDetail.prototype.hash = 0;
    
            /**
             * ItemDetail crc.
             * @member {number} crc
             * @memberof CUserMessage_UtilMsg_Response.ItemDetail
             * @instance
             */
            ItemDetail.prototype.crc = 0;
    
            /**
             * ItemDetail name.
             * @member {string} name
             * @memberof CUserMessage_UtilMsg_Response.ItemDetail
             * @instance
             */
            ItemDetail.prototype.name = "";
    
            /**
             * Creates a new ItemDetail instance using the specified properties.
             * @function create
             * @memberof CUserMessage_UtilMsg_Response.ItemDetail
             * @static
             * @param {CUserMessage_UtilMsg_Response.IItemDetail=} [properties] Properties to set
             * @returns {CUserMessage_UtilMsg_Response.ItemDetail} ItemDetail instance
             */
            ItemDetail.create = function create(properties) {
                return new ItemDetail(properties);
            };
    
            /**
             * Encodes the specified ItemDetail message. Does not implicitly {@link CUserMessage_UtilMsg_Response.ItemDetail.verify|verify} messages.
             * @function encode
             * @memberof CUserMessage_UtilMsg_Response.ItemDetail
             * @static
             * @param {CUserMessage_UtilMsg_Response.IItemDetail} message ItemDetail message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ItemDetail.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.index != null && Object.hasOwnProperty.call(message, "index"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.index);
                if (message.hash != null && Object.hasOwnProperty.call(message, "hash"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.hash);
                if (message.crc != null && Object.hasOwnProperty.call(message, "crc"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int32(message.crc);
                if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.name);
                return writer;
            };
    
            /**
             * Encodes the specified ItemDetail message, length delimited. Does not implicitly {@link CUserMessage_UtilMsg_Response.ItemDetail.verify|verify} messages.
             * @function encodeDelimited
             * @memberof CUserMessage_UtilMsg_Response.ItemDetail
             * @static
             * @param {CUserMessage_UtilMsg_Response.IItemDetail} message ItemDetail message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ItemDetail.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes an ItemDetail message from the specified reader or buffer.
             * @function decode
             * @memberof CUserMessage_UtilMsg_Response.ItemDetail
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {CUserMessage_UtilMsg_Response.ItemDetail} ItemDetail
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ItemDetail.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CUserMessage_UtilMsg_Response.ItemDetail();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.index = reader.int32();
                            break;
                        }
                    case 2: {
                            message.hash = reader.int32();
                            break;
                        }
                    case 3: {
                            message.crc = reader.int32();
                            break;
                        }
                    case 4: {
                            message.name = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes an ItemDetail message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof CUserMessage_UtilMsg_Response.ItemDetail
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {CUserMessage_UtilMsg_Response.ItemDetail} ItemDetail
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ItemDetail.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies an ItemDetail message.
             * @function verify
             * @memberof CUserMessage_UtilMsg_Response.ItemDetail
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ItemDetail.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.index != null && message.hasOwnProperty("index"))
                    if (!$util.isInteger(message.index))
                        return "index: integer expected";
                if (message.hash != null && message.hasOwnProperty("hash"))
                    if (!$util.isInteger(message.hash))
                        return "hash: integer expected";
                if (message.crc != null && message.hasOwnProperty("crc"))
                    if (!$util.isInteger(message.crc))
                        return "crc: integer expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                return null;
            };
    
            /**
             * Creates an ItemDetail message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof CUserMessage_UtilMsg_Response.ItemDetail
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {CUserMessage_UtilMsg_Response.ItemDetail} ItemDetail
             */
            ItemDetail.fromObject = function fromObject(object) {
                if (object instanceof $root.CUserMessage_UtilMsg_Response.ItemDetail)
                    return object;
                var message = new $root.CUserMessage_UtilMsg_Response.ItemDetail();
                if (object.index != null)
                    message.index = object.index | 0;
                if (object.hash != null)
                    message.hash = object.hash | 0;
                if (object.crc != null)
                    message.crc = object.crc | 0;
                if (object.name != null)
                    message.name = String(object.name);
                return message;
            };
    
            /**
             * Creates a plain object from an ItemDetail message. Also converts values to other types if specified.
             * @function toObject
             * @memberof CUserMessage_UtilMsg_Response.ItemDetail
             * @static
             * @param {CUserMessage_UtilMsg_Response.ItemDetail} message ItemDetail
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ItemDetail.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.index = 0;
                    object.hash = 0;
                    object.crc = 0;
                    object.name = "";
                }
                if (message.index != null && message.hasOwnProperty("index"))
                    object.index = message.index;
                if (message.hash != null && message.hasOwnProperty("hash"))
                    object.hash = message.hash;
                if (message.crc != null && message.hasOwnProperty("crc"))
                    object.crc = message.crc;
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                return object;
            };
    
            /**
             * Converts this ItemDetail to JSON.
             * @function toJSON
             * @memberof CUserMessage_UtilMsg_Response.ItemDetail
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ItemDetail.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            /**
             * Gets the default type url for ItemDetail
             * @function getTypeUrl
             * @memberof CUserMessage_UtilMsg_Response.ItemDetail
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            ItemDetail.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/CUserMessage_UtilMsg_Response.ItemDetail";
            };
    
            return ItemDetail;
        })();
    
        return CUserMessage_UtilMsg_Response;
    })();
    
    $root.CUserMessage_DllStatus = (function() {
    
        /**
         * Properties of a CUserMessage_DllStatus.
         * @exports ICUserMessage_DllStatus
         * @interface ICUserMessage_DllStatus
         * @property {string|null} [fileReport] CUserMessage_DllStatus fileReport
         * @property {string|null} [commandLine] CUserMessage_DllStatus commandLine
         * @property {number|null} [totalFiles] CUserMessage_DllStatus totalFiles
         * @property {number|null} [processId] CUserMessage_DllStatus processId
         * @property {number|null} [osversion] CUserMessage_DllStatus osversion
         * @property {number|Long|null} [clientTime] CUserMessage_DllStatus clientTime
         * @property {Array.<CUserMessage_DllStatus.ICVDiagnostic>|null} [diagnostics] CUserMessage_DllStatus diagnostics
         * @property {Array.<CUserMessage_DllStatus.ICModule>|null} [modules] CUserMessage_DllStatus modules
         */
    
        /**
         * Constructs a new CUserMessage_DllStatus.
         * @exports CUserMessage_DllStatus
         * @classdesc Represents a CUserMessage_DllStatus.
         * @implements ICUserMessage_DllStatus
         * @constructor
         * @param {ICUserMessage_DllStatus=} [properties] Properties to set
         */
        function CUserMessage_DllStatus(properties) {
            this.diagnostics = [];
            this.modules = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CUserMessage_DllStatus fileReport.
         * @member {string} fileReport
         * @memberof CUserMessage_DllStatus
         * @instance
         */
        CUserMessage_DllStatus.prototype.fileReport = "";
    
        /**
         * CUserMessage_DllStatus commandLine.
         * @member {string} commandLine
         * @memberof CUserMessage_DllStatus
         * @instance
         */
        CUserMessage_DllStatus.prototype.commandLine = "";
    
        /**
         * CUserMessage_DllStatus totalFiles.
         * @member {number} totalFiles
         * @memberof CUserMessage_DllStatus
         * @instance
         */
        CUserMessage_DllStatus.prototype.totalFiles = 0;
    
        /**
         * CUserMessage_DllStatus processId.
         * @member {number} processId
         * @memberof CUserMessage_DllStatus
         * @instance
         */
        CUserMessage_DllStatus.prototype.processId = 0;
    
        /**
         * CUserMessage_DllStatus osversion.
         * @member {number} osversion
         * @memberof CUserMessage_DllStatus
         * @instance
         */
        CUserMessage_DllStatus.prototype.osversion = 0;
    
        /**
         * CUserMessage_DllStatus clientTime.
         * @member {number|Long} clientTime
         * @memberof CUserMessage_DllStatus
         * @instance
         */
        CUserMessage_DllStatus.prototype.clientTime = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
        /**
         * CUserMessage_DllStatus diagnostics.
         * @member {Array.<CUserMessage_DllStatus.ICVDiagnostic>} diagnostics
         * @memberof CUserMessage_DllStatus
         * @instance
         */
        CUserMessage_DllStatus.prototype.diagnostics = $util.emptyArray;
    
        /**
         * CUserMessage_DllStatus modules.
         * @member {Array.<CUserMessage_DllStatus.ICModule>} modules
         * @memberof CUserMessage_DllStatus
         * @instance
         */
        CUserMessage_DllStatus.prototype.modules = $util.emptyArray;
    
        /**
         * Creates a new CUserMessage_DllStatus instance using the specified properties.
         * @function create
         * @memberof CUserMessage_DllStatus
         * @static
         * @param {ICUserMessage_DllStatus=} [properties] Properties to set
         * @returns {CUserMessage_DllStatus} CUserMessage_DllStatus instance
         */
        CUserMessage_DllStatus.create = function create(properties) {
            return new CUserMessage_DllStatus(properties);
        };
    
        /**
         * Encodes the specified CUserMessage_DllStatus message. Does not implicitly {@link CUserMessage_DllStatus.verify|verify} messages.
         * @function encode
         * @memberof CUserMessage_DllStatus
         * @static
         * @param {ICUserMessage_DllStatus} message CUserMessage_DllStatus message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CUserMessage_DllStatus.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.fileReport != null && Object.hasOwnProperty.call(message, "fileReport"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.fileReport);
            if (message.commandLine != null && Object.hasOwnProperty.call(message, "commandLine"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.commandLine);
            if (message.totalFiles != null && Object.hasOwnProperty.call(message, "totalFiles"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.totalFiles);
            if (message.processId != null && Object.hasOwnProperty.call(message, "processId"))
                writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.processId);
            if (message.osversion != null && Object.hasOwnProperty.call(message, "osversion"))
                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.osversion);
            if (message.clientTime != null && Object.hasOwnProperty.call(message, "clientTime"))
                writer.uint32(/* id 6, wireType 0 =*/48).uint64(message.clientTime);
            if (message.diagnostics != null && message.diagnostics.length)
                for (var i = 0; i < message.diagnostics.length; ++i)
                    $root.CUserMessage_DllStatus.CVDiagnostic.encode(message.diagnostics[i], writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
            if (message.modules != null && message.modules.length)
                for (var i = 0; i < message.modules.length; ++i)
                    $root.CUserMessage_DllStatus.CModule.encode(message.modules[i], writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
            return writer;
        };
    
        /**
         * Encodes the specified CUserMessage_DllStatus message, length delimited. Does not implicitly {@link CUserMessage_DllStatus.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CUserMessage_DllStatus
         * @static
         * @param {ICUserMessage_DllStatus} message CUserMessage_DllStatus message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CUserMessage_DllStatus.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CUserMessage_DllStatus message from the specified reader or buffer.
         * @function decode
         * @memberof CUserMessage_DllStatus
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CUserMessage_DllStatus} CUserMessage_DllStatus
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CUserMessage_DllStatus.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CUserMessage_DllStatus();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.fileReport = reader.string();
                        break;
                    }
                case 2: {
                        message.commandLine = reader.string();
                        break;
                    }
                case 3: {
                        message.totalFiles = reader.uint32();
                        break;
                    }
                case 4: {
                        message.processId = reader.uint32();
                        break;
                    }
                case 5: {
                        message.osversion = reader.int32();
                        break;
                    }
                case 6: {
                        message.clientTime = reader.uint64();
                        break;
                    }
                case 7: {
                        if (!(message.diagnostics && message.diagnostics.length))
                            message.diagnostics = [];
                        message.diagnostics.push($root.CUserMessage_DllStatus.CVDiagnostic.decode(reader, reader.uint32()));
                        break;
                    }
                case 8: {
                        if (!(message.modules && message.modules.length))
                            message.modules = [];
                        message.modules.push($root.CUserMessage_DllStatus.CModule.decode(reader, reader.uint32()));
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CUserMessage_DllStatus message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CUserMessage_DllStatus
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CUserMessage_DllStatus} CUserMessage_DllStatus
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CUserMessage_DllStatus.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CUserMessage_DllStatus message.
         * @function verify
         * @memberof CUserMessage_DllStatus
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CUserMessage_DllStatus.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.fileReport != null && message.hasOwnProperty("fileReport"))
                if (!$util.isString(message.fileReport))
                    return "fileReport: string expected";
            if (message.commandLine != null && message.hasOwnProperty("commandLine"))
                if (!$util.isString(message.commandLine))
                    return "commandLine: string expected";
            if (message.totalFiles != null && message.hasOwnProperty("totalFiles"))
                if (!$util.isInteger(message.totalFiles))
                    return "totalFiles: integer expected";
            if (message.processId != null && message.hasOwnProperty("processId"))
                if (!$util.isInteger(message.processId))
                    return "processId: integer expected";
            if (message.osversion != null && message.hasOwnProperty("osversion"))
                if (!$util.isInteger(message.osversion))
                    return "osversion: integer expected";
            if (message.clientTime != null && message.hasOwnProperty("clientTime"))
                if (!$util.isInteger(message.clientTime) && !(message.clientTime && $util.isInteger(message.clientTime.low) && $util.isInteger(message.clientTime.high)))
                    return "clientTime: integer|Long expected";
            if (message.diagnostics != null && message.hasOwnProperty("diagnostics")) {
                if (!Array.isArray(message.diagnostics))
                    return "diagnostics: array expected";
                for (var i = 0; i < message.diagnostics.length; ++i) {
                    var error = $root.CUserMessage_DllStatus.CVDiagnostic.verify(message.diagnostics[i]);
                    if (error)
                        return "diagnostics." + error;
                }
            }
            if (message.modules != null && message.hasOwnProperty("modules")) {
                if (!Array.isArray(message.modules))
                    return "modules: array expected";
                for (var i = 0; i < message.modules.length; ++i) {
                    var error = $root.CUserMessage_DllStatus.CModule.verify(message.modules[i]);
                    if (error)
                        return "modules." + error;
                }
            }
            return null;
        };
    
        /**
         * Creates a CUserMessage_DllStatus message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CUserMessage_DllStatus
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CUserMessage_DllStatus} CUserMessage_DllStatus
         */
        CUserMessage_DllStatus.fromObject = function fromObject(object) {
            if (object instanceof $root.CUserMessage_DllStatus)
                return object;
            var message = new $root.CUserMessage_DllStatus();
            if (object.fileReport != null)
                message.fileReport = String(object.fileReport);
            if (object.commandLine != null)
                message.commandLine = String(object.commandLine);
            if (object.totalFiles != null)
                message.totalFiles = object.totalFiles >>> 0;
            if (object.processId != null)
                message.processId = object.processId >>> 0;
            if (object.osversion != null)
                message.osversion = object.osversion | 0;
            if (object.clientTime != null)
                if ($util.Long)
                    (message.clientTime = $util.Long.fromValue(object.clientTime)).unsigned = true;
                else if (typeof object.clientTime === "string")
                    message.clientTime = parseInt(object.clientTime, 10);
                else if (typeof object.clientTime === "number")
                    message.clientTime = object.clientTime;
                else if (typeof object.clientTime === "object")
                    message.clientTime = new $util.LongBits(object.clientTime.low >>> 0, object.clientTime.high >>> 0).toNumber(true);
            if (object.diagnostics) {
                if (!Array.isArray(object.diagnostics))
                    throw TypeError(".CUserMessage_DllStatus.diagnostics: array expected");
                message.diagnostics = [];
                for (var i = 0; i < object.diagnostics.length; ++i) {
                    if (typeof object.diagnostics[i] !== "object")
                        throw TypeError(".CUserMessage_DllStatus.diagnostics: object expected");
                    message.diagnostics[i] = $root.CUserMessage_DllStatus.CVDiagnostic.fromObject(object.diagnostics[i]);
                }
            }
            if (object.modules) {
                if (!Array.isArray(object.modules))
                    throw TypeError(".CUserMessage_DllStatus.modules: array expected");
                message.modules = [];
                for (var i = 0; i < object.modules.length; ++i) {
                    if (typeof object.modules[i] !== "object")
                        throw TypeError(".CUserMessage_DllStatus.modules: object expected");
                    message.modules[i] = $root.CUserMessage_DllStatus.CModule.fromObject(object.modules[i]);
                }
            }
            return message;
        };
    
        /**
         * Creates a plain object from a CUserMessage_DllStatus message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CUserMessage_DllStatus
         * @static
         * @param {CUserMessage_DllStatus} message CUserMessage_DllStatus
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CUserMessage_DllStatus.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults) {
                object.diagnostics = [];
                object.modules = [];
            }
            if (options.defaults) {
                object.fileReport = "";
                object.commandLine = "";
                object.totalFiles = 0;
                object.processId = 0;
                object.osversion = 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.clientTime = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.clientTime = options.longs === String ? "0" : 0;
            }
            if (message.fileReport != null && message.hasOwnProperty("fileReport"))
                object.fileReport = message.fileReport;
            if (message.commandLine != null && message.hasOwnProperty("commandLine"))
                object.commandLine = message.commandLine;
            if (message.totalFiles != null && message.hasOwnProperty("totalFiles"))
                object.totalFiles = message.totalFiles;
            if (message.processId != null && message.hasOwnProperty("processId"))
                object.processId = message.processId;
            if (message.osversion != null && message.hasOwnProperty("osversion"))
                object.osversion = message.osversion;
            if (message.clientTime != null && message.hasOwnProperty("clientTime"))
                if (typeof message.clientTime === "number")
                    object.clientTime = options.longs === String ? String(message.clientTime) : message.clientTime;
                else
                    object.clientTime = options.longs === String ? $util.Long.prototype.toString.call(message.clientTime) : options.longs === Number ? new $util.LongBits(message.clientTime.low >>> 0, message.clientTime.high >>> 0).toNumber(true) : message.clientTime;
            if (message.diagnostics && message.diagnostics.length) {
                object.diagnostics = [];
                for (var j = 0; j < message.diagnostics.length; ++j)
                    object.diagnostics[j] = $root.CUserMessage_DllStatus.CVDiagnostic.toObject(message.diagnostics[j], options);
            }
            if (message.modules && message.modules.length) {
                object.modules = [];
                for (var j = 0; j < message.modules.length; ++j)
                    object.modules[j] = $root.CUserMessage_DllStatus.CModule.toObject(message.modules[j], options);
            }
            return object;
        };
    
        /**
         * Converts this CUserMessage_DllStatus to JSON.
         * @function toJSON
         * @memberof CUserMessage_DllStatus
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CUserMessage_DllStatus.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * Gets the default type url for CUserMessage_DllStatus
         * @function getTypeUrl
         * @memberof CUserMessage_DllStatus
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        CUserMessage_DllStatus.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/CUserMessage_DllStatus";
        };
    
        CUserMessage_DllStatus.CVDiagnostic = (function() {
    
            /**
             * Properties of a CVDiagnostic.
             * @memberof CUserMessage_DllStatus
             * @interface ICVDiagnostic
             * @property {number|null} [id] CVDiagnostic id
             * @property {number|null} [extended] CVDiagnostic extended
             * @property {number|Long|null} [value] CVDiagnostic value
             * @property {string|null} [stringValue] CVDiagnostic stringValue
             */
    
            /**
             * Constructs a new CVDiagnostic.
             * @memberof CUserMessage_DllStatus
             * @classdesc Represents a CVDiagnostic.
             * @implements ICVDiagnostic
             * @constructor
             * @param {CUserMessage_DllStatus.ICVDiagnostic=} [properties] Properties to set
             */
            function CVDiagnostic(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * CVDiagnostic id.
             * @member {number} id
             * @memberof CUserMessage_DllStatus.CVDiagnostic
             * @instance
             */
            CVDiagnostic.prototype.id = 0;
    
            /**
             * CVDiagnostic extended.
             * @member {number} extended
             * @memberof CUserMessage_DllStatus.CVDiagnostic
             * @instance
             */
            CVDiagnostic.prototype.extended = 0;
    
            /**
             * CVDiagnostic value.
             * @member {number|Long} value
             * @memberof CUserMessage_DllStatus.CVDiagnostic
             * @instance
             */
            CVDiagnostic.prototype.value = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
            /**
             * CVDiagnostic stringValue.
             * @member {string} stringValue
             * @memberof CUserMessage_DllStatus.CVDiagnostic
             * @instance
             */
            CVDiagnostic.prototype.stringValue = "";
    
            /**
             * Creates a new CVDiagnostic instance using the specified properties.
             * @function create
             * @memberof CUserMessage_DllStatus.CVDiagnostic
             * @static
             * @param {CUserMessage_DllStatus.ICVDiagnostic=} [properties] Properties to set
             * @returns {CUserMessage_DllStatus.CVDiagnostic} CVDiagnostic instance
             */
            CVDiagnostic.create = function create(properties) {
                return new CVDiagnostic(properties);
            };
    
            /**
             * Encodes the specified CVDiagnostic message. Does not implicitly {@link CUserMessage_DllStatus.CVDiagnostic.verify|verify} messages.
             * @function encode
             * @memberof CUserMessage_DllStatus.CVDiagnostic
             * @static
             * @param {CUserMessage_DllStatus.ICVDiagnostic} message CVDiagnostic message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CVDiagnostic.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.id);
                if (message.extended != null && Object.hasOwnProperty.call(message, "extended"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.extended);
                if (message.value != null && Object.hasOwnProperty.call(message, "value"))
                    writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.value);
                if (message.stringValue != null && Object.hasOwnProperty.call(message, "stringValue"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.stringValue);
                return writer;
            };
    
            /**
             * Encodes the specified CVDiagnostic message, length delimited. Does not implicitly {@link CUserMessage_DllStatus.CVDiagnostic.verify|verify} messages.
             * @function encodeDelimited
             * @memberof CUserMessage_DllStatus.CVDiagnostic
             * @static
             * @param {CUserMessage_DllStatus.ICVDiagnostic} message CVDiagnostic message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CVDiagnostic.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a CVDiagnostic message from the specified reader or buffer.
             * @function decode
             * @memberof CUserMessage_DllStatus.CVDiagnostic
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {CUserMessage_DllStatus.CVDiagnostic} CVDiagnostic
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CVDiagnostic.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CUserMessage_DllStatus.CVDiagnostic();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.id = reader.uint32();
                            break;
                        }
                    case 2: {
                            message.extended = reader.uint32();
                            break;
                        }
                    case 3: {
                            message.value = reader.uint64();
                            break;
                        }
                    case 4: {
                            message.stringValue = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a CVDiagnostic message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof CUserMessage_DllStatus.CVDiagnostic
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {CUserMessage_DllStatus.CVDiagnostic} CVDiagnostic
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CVDiagnostic.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a CVDiagnostic message.
             * @function verify
             * @memberof CUserMessage_DllStatus.CVDiagnostic
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            CVDiagnostic.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.id != null && message.hasOwnProperty("id"))
                    if (!$util.isInteger(message.id))
                        return "id: integer expected";
                if (message.extended != null && message.hasOwnProperty("extended"))
                    if (!$util.isInteger(message.extended))
                        return "extended: integer expected";
                if (message.value != null && message.hasOwnProperty("value"))
                    if (!$util.isInteger(message.value) && !(message.value && $util.isInteger(message.value.low) && $util.isInteger(message.value.high)))
                        return "value: integer|Long expected";
                if (message.stringValue != null && message.hasOwnProperty("stringValue"))
                    if (!$util.isString(message.stringValue))
                        return "stringValue: string expected";
                return null;
            };
    
            /**
             * Creates a CVDiagnostic message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof CUserMessage_DllStatus.CVDiagnostic
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {CUserMessage_DllStatus.CVDiagnostic} CVDiagnostic
             */
            CVDiagnostic.fromObject = function fromObject(object) {
                if (object instanceof $root.CUserMessage_DllStatus.CVDiagnostic)
                    return object;
                var message = new $root.CUserMessage_DllStatus.CVDiagnostic();
                if (object.id != null)
                    message.id = object.id >>> 0;
                if (object.extended != null)
                    message.extended = object.extended >>> 0;
                if (object.value != null)
                    if ($util.Long)
                        (message.value = $util.Long.fromValue(object.value)).unsigned = true;
                    else if (typeof object.value === "string")
                        message.value = parseInt(object.value, 10);
                    else if (typeof object.value === "number")
                        message.value = object.value;
                    else if (typeof object.value === "object")
                        message.value = new $util.LongBits(object.value.low >>> 0, object.value.high >>> 0).toNumber(true);
                if (object.stringValue != null)
                    message.stringValue = String(object.stringValue);
                return message;
            };
    
            /**
             * Creates a plain object from a CVDiagnostic message. Also converts values to other types if specified.
             * @function toObject
             * @memberof CUserMessage_DllStatus.CVDiagnostic
             * @static
             * @param {CUserMessage_DllStatus.CVDiagnostic} message CVDiagnostic
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            CVDiagnostic.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.id = 0;
                    object.extended = 0;
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, true);
                        object.value = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.value = options.longs === String ? "0" : 0;
                    object.stringValue = "";
                }
                if (message.id != null && message.hasOwnProperty("id"))
                    object.id = message.id;
                if (message.extended != null && message.hasOwnProperty("extended"))
                    object.extended = message.extended;
                if (message.value != null && message.hasOwnProperty("value"))
                    if (typeof message.value === "number")
                        object.value = options.longs === String ? String(message.value) : message.value;
                    else
                        object.value = options.longs === String ? $util.Long.prototype.toString.call(message.value) : options.longs === Number ? new $util.LongBits(message.value.low >>> 0, message.value.high >>> 0).toNumber(true) : message.value;
                if (message.stringValue != null && message.hasOwnProperty("stringValue"))
                    object.stringValue = message.stringValue;
                return object;
            };
    
            /**
             * Converts this CVDiagnostic to JSON.
             * @function toJSON
             * @memberof CUserMessage_DllStatus.CVDiagnostic
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            CVDiagnostic.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            /**
             * Gets the default type url for CVDiagnostic
             * @function getTypeUrl
             * @memberof CUserMessage_DllStatus.CVDiagnostic
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            CVDiagnostic.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/CUserMessage_DllStatus.CVDiagnostic";
            };
    
            return CVDiagnostic;
        })();
    
        CUserMessage_DllStatus.CModule = (function() {
    
            /**
             * Properties of a CModule.
             * @memberof CUserMessage_DllStatus
             * @interface ICModule
             * @property {number|Long|null} [baseAddr] CModule baseAddr
             * @property {string|null} [name] CModule name
             * @property {number|null} [size] CModule size
             * @property {number|null} [timestamp] CModule timestamp
             */
    
            /**
             * Constructs a new CModule.
             * @memberof CUserMessage_DllStatus
             * @classdesc Represents a CModule.
             * @implements ICModule
             * @constructor
             * @param {CUserMessage_DllStatus.ICModule=} [properties] Properties to set
             */
            function CModule(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * CModule baseAddr.
             * @member {number|Long} baseAddr
             * @memberof CUserMessage_DllStatus.CModule
             * @instance
             */
            CModule.prototype.baseAddr = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
            /**
             * CModule name.
             * @member {string} name
             * @memberof CUserMessage_DllStatus.CModule
             * @instance
             */
            CModule.prototype.name = "";
    
            /**
             * CModule size.
             * @member {number} size
             * @memberof CUserMessage_DllStatus.CModule
             * @instance
             */
            CModule.prototype.size = 0;
    
            /**
             * CModule timestamp.
             * @member {number} timestamp
             * @memberof CUserMessage_DllStatus.CModule
             * @instance
             */
            CModule.prototype.timestamp = 0;
    
            /**
             * Creates a new CModule instance using the specified properties.
             * @function create
             * @memberof CUserMessage_DllStatus.CModule
             * @static
             * @param {CUserMessage_DllStatus.ICModule=} [properties] Properties to set
             * @returns {CUserMessage_DllStatus.CModule} CModule instance
             */
            CModule.create = function create(properties) {
                return new CModule(properties);
            };
    
            /**
             * Encodes the specified CModule message. Does not implicitly {@link CUserMessage_DllStatus.CModule.verify|verify} messages.
             * @function encode
             * @memberof CUserMessage_DllStatus.CModule
             * @static
             * @param {CUserMessage_DllStatus.ICModule} message CModule message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CModule.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.baseAddr != null && Object.hasOwnProperty.call(message, "baseAddr"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.baseAddr);
                if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.name);
                if (message.size != null && Object.hasOwnProperty.call(message, "size"))
                    writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.size);
                if (message.timestamp != null && Object.hasOwnProperty.call(message, "timestamp"))
                    writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.timestamp);
                return writer;
            };
    
            /**
             * Encodes the specified CModule message, length delimited. Does not implicitly {@link CUserMessage_DllStatus.CModule.verify|verify} messages.
             * @function encodeDelimited
             * @memberof CUserMessage_DllStatus.CModule
             * @static
             * @param {CUserMessage_DllStatus.ICModule} message CModule message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CModule.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a CModule message from the specified reader or buffer.
             * @function decode
             * @memberof CUserMessage_DllStatus.CModule
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {CUserMessage_DllStatus.CModule} CModule
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CModule.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CUserMessage_DllStatus.CModule();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.baseAddr = reader.uint64();
                            break;
                        }
                    case 2: {
                            message.name = reader.string();
                            break;
                        }
                    case 3: {
                            message.size = reader.uint32();
                            break;
                        }
                    case 4: {
                            message.timestamp = reader.uint32();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a CModule message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof CUserMessage_DllStatus.CModule
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {CUserMessage_DllStatus.CModule} CModule
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CModule.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a CModule message.
             * @function verify
             * @memberof CUserMessage_DllStatus.CModule
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            CModule.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.baseAddr != null && message.hasOwnProperty("baseAddr"))
                    if (!$util.isInteger(message.baseAddr) && !(message.baseAddr && $util.isInteger(message.baseAddr.low) && $util.isInteger(message.baseAddr.high)))
                        return "baseAddr: integer|Long expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                if (message.size != null && message.hasOwnProperty("size"))
                    if (!$util.isInteger(message.size))
                        return "size: integer expected";
                if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                    if (!$util.isInteger(message.timestamp))
                        return "timestamp: integer expected";
                return null;
            };
    
            /**
             * Creates a CModule message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof CUserMessage_DllStatus.CModule
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {CUserMessage_DllStatus.CModule} CModule
             */
            CModule.fromObject = function fromObject(object) {
                if (object instanceof $root.CUserMessage_DllStatus.CModule)
                    return object;
                var message = new $root.CUserMessage_DllStatus.CModule();
                if (object.baseAddr != null)
                    if ($util.Long)
                        (message.baseAddr = $util.Long.fromValue(object.baseAddr)).unsigned = true;
                    else if (typeof object.baseAddr === "string")
                        message.baseAddr = parseInt(object.baseAddr, 10);
                    else if (typeof object.baseAddr === "number")
                        message.baseAddr = object.baseAddr;
                    else if (typeof object.baseAddr === "object")
                        message.baseAddr = new $util.LongBits(object.baseAddr.low >>> 0, object.baseAddr.high >>> 0).toNumber(true);
                if (object.name != null)
                    message.name = String(object.name);
                if (object.size != null)
                    message.size = object.size >>> 0;
                if (object.timestamp != null)
                    message.timestamp = object.timestamp >>> 0;
                return message;
            };
    
            /**
             * Creates a plain object from a CModule message. Also converts values to other types if specified.
             * @function toObject
             * @memberof CUserMessage_DllStatus.CModule
             * @static
             * @param {CUserMessage_DllStatus.CModule} message CModule
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            CModule.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, true);
                        object.baseAddr = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.baseAddr = options.longs === String ? "0" : 0;
                    object.name = "";
                    object.size = 0;
                    object.timestamp = 0;
                }
                if (message.baseAddr != null && message.hasOwnProperty("baseAddr"))
                    if (typeof message.baseAddr === "number")
                        object.baseAddr = options.longs === String ? String(message.baseAddr) : message.baseAddr;
                    else
                        object.baseAddr = options.longs === String ? $util.Long.prototype.toString.call(message.baseAddr) : options.longs === Number ? new $util.LongBits(message.baseAddr.low >>> 0, message.baseAddr.high >>> 0).toNumber(true) : message.baseAddr;
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                if (message.size != null && message.hasOwnProperty("size"))
                    object.size = message.size;
                if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                    object.timestamp = message.timestamp;
                return object;
            };
    
            /**
             * Converts this CModule to JSON.
             * @function toJSON
             * @memberof CUserMessage_DllStatus.CModule
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            CModule.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            /**
             * Gets the default type url for CModule
             * @function getTypeUrl
             * @memberof CUserMessage_DllStatus.CModule
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            CModule.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/CUserMessage_DllStatus.CModule";
            };
    
            return CModule;
        })();
    
        return CUserMessage_DllStatus;
    })();
    
    $root.CUserMessageRequestInventory = (function() {
    
        /**
         * Properties of a CUserMessageRequestInventory.
         * @exports ICUserMessageRequestInventory
         * @interface ICUserMessageRequestInventory
         * @property {number|null} [inventory] CUserMessageRequestInventory inventory
         * @property {number|null} [offset] CUserMessageRequestInventory offset
         * @property {number|null} [options] CUserMessageRequestInventory options
         */
    
        /**
         * Constructs a new CUserMessageRequestInventory.
         * @exports CUserMessageRequestInventory
         * @classdesc Represents a CUserMessageRequestInventory.
         * @implements ICUserMessageRequestInventory
         * @constructor
         * @param {ICUserMessageRequestInventory=} [properties] Properties to set
         */
        function CUserMessageRequestInventory(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CUserMessageRequestInventory inventory.
         * @member {number} inventory
         * @memberof CUserMessageRequestInventory
         * @instance
         */
        CUserMessageRequestInventory.prototype.inventory = 0;
    
        /**
         * CUserMessageRequestInventory offset.
         * @member {number} offset
         * @memberof CUserMessageRequestInventory
         * @instance
         */
        CUserMessageRequestInventory.prototype.offset = 0;
    
        /**
         * CUserMessageRequestInventory options.
         * @member {number} options
         * @memberof CUserMessageRequestInventory
         * @instance
         */
        CUserMessageRequestInventory.prototype.options = 0;
    
        /**
         * Creates a new CUserMessageRequestInventory instance using the specified properties.
         * @function create
         * @memberof CUserMessageRequestInventory
         * @static
         * @param {ICUserMessageRequestInventory=} [properties] Properties to set
         * @returns {CUserMessageRequestInventory} CUserMessageRequestInventory instance
         */
        CUserMessageRequestInventory.create = function create(properties) {
            return new CUserMessageRequestInventory(properties);
        };
    
        /**
         * Encodes the specified CUserMessageRequestInventory message. Does not implicitly {@link CUserMessageRequestInventory.verify|verify} messages.
         * @function encode
         * @memberof CUserMessageRequestInventory
         * @static
         * @param {ICUserMessageRequestInventory} message CUserMessageRequestInventory message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CUserMessageRequestInventory.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.inventory != null && Object.hasOwnProperty.call(message, "inventory"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.inventory);
            if (message.offset != null && Object.hasOwnProperty.call(message, "offset"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.offset);
            if (message.options != null && Object.hasOwnProperty.call(message, "options"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.options);
            return writer;
        };
    
        /**
         * Encodes the specified CUserMessageRequestInventory message, length delimited. Does not implicitly {@link CUserMessageRequestInventory.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CUserMessageRequestInventory
         * @static
         * @param {ICUserMessageRequestInventory} message CUserMessageRequestInventory message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CUserMessageRequestInventory.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CUserMessageRequestInventory message from the specified reader or buffer.
         * @function decode
         * @memberof CUserMessageRequestInventory
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CUserMessageRequestInventory} CUserMessageRequestInventory
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CUserMessageRequestInventory.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CUserMessageRequestInventory();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.inventory = reader.int32();
                        break;
                    }
                case 2: {
                        message.offset = reader.int32();
                        break;
                    }
                case 3: {
                        message.options = reader.int32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CUserMessageRequestInventory message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CUserMessageRequestInventory
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CUserMessageRequestInventory} CUserMessageRequestInventory
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CUserMessageRequestInventory.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CUserMessageRequestInventory message.
         * @function verify
         * @memberof CUserMessageRequestInventory
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CUserMessageRequestInventory.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.inventory != null && message.hasOwnProperty("inventory"))
                if (!$util.isInteger(message.inventory))
                    return "inventory: integer expected";
            if (message.offset != null && message.hasOwnProperty("offset"))
                if (!$util.isInteger(message.offset))
                    return "offset: integer expected";
            if (message.options != null && message.hasOwnProperty("options"))
                if (!$util.isInteger(message.options))
                    return "options: integer expected";
            return null;
        };
    
        /**
         * Creates a CUserMessageRequestInventory message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CUserMessageRequestInventory
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CUserMessageRequestInventory} CUserMessageRequestInventory
         */
        CUserMessageRequestInventory.fromObject = function fromObject(object) {
            if (object instanceof $root.CUserMessageRequestInventory)
                return object;
            var message = new $root.CUserMessageRequestInventory();
            if (object.inventory != null)
                message.inventory = object.inventory | 0;
            if (object.offset != null)
                message.offset = object.offset | 0;
            if (object.options != null)
                message.options = object.options | 0;
            return message;
        };
    
        /**
         * Creates a plain object from a CUserMessageRequestInventory message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CUserMessageRequestInventory
         * @static
         * @param {CUserMessageRequestInventory} message CUserMessageRequestInventory
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CUserMessageRequestInventory.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.inventory = 0;
                object.offset = 0;
                object.options = 0;
            }
            if (message.inventory != null && message.hasOwnProperty("inventory"))
                object.inventory = message.inventory;
            if (message.offset != null && message.hasOwnProperty("offset"))
                object.offset = message.offset;
            if (message.options != null && message.hasOwnProperty("options"))
                object.options = message.options;
            return object;
        };
    
        /**
         * Converts this CUserMessageRequestInventory to JSON.
         * @function toJSON
         * @memberof CUserMessageRequestInventory
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CUserMessageRequestInventory.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * Gets the default type url for CUserMessageRequestInventory
         * @function getTypeUrl
         * @memberof CUserMessageRequestInventory
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        CUserMessageRequestInventory.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/CUserMessageRequestInventory";
        };
    
        return CUserMessageRequestInventory;
    })();
    
    $root.CUserMessage_Inventory_Response = (function() {
    
        /**
         * Properties of a CUserMessage_Inventory_Response.
         * @exports ICUserMessage_Inventory_Response
         * @interface ICUserMessage_Inventory_Response
         * @property {number|null} [crc] CUserMessage_Inventory_Response crc
         * @property {number|null} [itemCount] CUserMessage_Inventory_Response itemCount
         * @property {number|null} [osversion] CUserMessage_Inventory_Response osversion
         * @property {number|null} [perfTime] CUserMessage_Inventory_Response perfTime
         * @property {number|null} [clientTimestamp] CUserMessage_Inventory_Response clientTimestamp
         * @property {number|null} [platform] CUserMessage_Inventory_Response platform
         * @property {Array.<CUserMessage_Inventory_Response.IInventoryDetail>|null} [inventories] CUserMessage_Inventory_Response inventories
         * @property {Array.<CUserMessage_Inventory_Response.IInventoryDetail>|null} [inventories2] CUserMessage_Inventory_Response inventories2
         * @property {Array.<CUserMessage_Inventory_Response.IInventoryDetail>|null} [inventories3] CUserMessage_Inventory_Response inventories3
         * @property {number|null} [invType] CUserMessage_Inventory_Response invType
         * @property {number|null} [buildVersion] CUserMessage_Inventory_Response buildVersion
         * @property {number|null} [instance] CUserMessage_Inventory_Response instance
         * @property {number|Long|null} [startTime] CUserMessage_Inventory_Response startTime
         */
    
        /**
         * Constructs a new CUserMessage_Inventory_Response.
         * @exports CUserMessage_Inventory_Response
         * @classdesc Represents a CUserMessage_Inventory_Response.
         * @implements ICUserMessage_Inventory_Response
         * @constructor
         * @param {ICUserMessage_Inventory_Response=} [properties] Properties to set
         */
        function CUserMessage_Inventory_Response(properties) {
            this.inventories = [];
            this.inventories2 = [];
            this.inventories3 = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CUserMessage_Inventory_Response crc.
         * @member {number} crc
         * @memberof CUserMessage_Inventory_Response
         * @instance
         */
        CUserMessage_Inventory_Response.prototype.crc = 0;
    
        /**
         * CUserMessage_Inventory_Response itemCount.
         * @member {number} itemCount
         * @memberof CUserMessage_Inventory_Response
         * @instance
         */
        CUserMessage_Inventory_Response.prototype.itemCount = 0;
    
        /**
         * CUserMessage_Inventory_Response osversion.
         * @member {number} osversion
         * @memberof CUserMessage_Inventory_Response
         * @instance
         */
        CUserMessage_Inventory_Response.prototype.osversion = 0;
    
        /**
         * CUserMessage_Inventory_Response perfTime.
         * @member {number} perfTime
         * @memberof CUserMessage_Inventory_Response
         * @instance
         */
        CUserMessage_Inventory_Response.prototype.perfTime = 0;
    
        /**
         * CUserMessage_Inventory_Response clientTimestamp.
         * @member {number} clientTimestamp
         * @memberof CUserMessage_Inventory_Response
         * @instance
         */
        CUserMessage_Inventory_Response.prototype.clientTimestamp = 0;
    
        /**
         * CUserMessage_Inventory_Response platform.
         * @member {number} platform
         * @memberof CUserMessage_Inventory_Response
         * @instance
         */
        CUserMessage_Inventory_Response.prototype.platform = 0;
    
        /**
         * CUserMessage_Inventory_Response inventories.
         * @member {Array.<CUserMessage_Inventory_Response.IInventoryDetail>} inventories
         * @memberof CUserMessage_Inventory_Response
         * @instance
         */
        CUserMessage_Inventory_Response.prototype.inventories = $util.emptyArray;
    
        /**
         * CUserMessage_Inventory_Response inventories2.
         * @member {Array.<CUserMessage_Inventory_Response.IInventoryDetail>} inventories2
         * @memberof CUserMessage_Inventory_Response
         * @instance
         */
        CUserMessage_Inventory_Response.prototype.inventories2 = $util.emptyArray;
    
        /**
         * CUserMessage_Inventory_Response inventories3.
         * @member {Array.<CUserMessage_Inventory_Response.IInventoryDetail>} inventories3
         * @memberof CUserMessage_Inventory_Response
         * @instance
         */
        CUserMessage_Inventory_Response.prototype.inventories3 = $util.emptyArray;
    
        /**
         * CUserMessage_Inventory_Response invType.
         * @member {number} invType
         * @memberof CUserMessage_Inventory_Response
         * @instance
         */
        CUserMessage_Inventory_Response.prototype.invType = 0;
    
        /**
         * CUserMessage_Inventory_Response buildVersion.
         * @member {number} buildVersion
         * @memberof CUserMessage_Inventory_Response
         * @instance
         */
        CUserMessage_Inventory_Response.prototype.buildVersion = 0;
    
        /**
         * CUserMessage_Inventory_Response instance.
         * @member {number} instance
         * @memberof CUserMessage_Inventory_Response
         * @instance
         */
        CUserMessage_Inventory_Response.prototype.instance = 0;
    
        /**
         * CUserMessage_Inventory_Response startTime.
         * @member {number|Long} startTime
         * @memberof CUserMessage_Inventory_Response
         * @instance
         */
        CUserMessage_Inventory_Response.prototype.startTime = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
        /**
         * Creates a new CUserMessage_Inventory_Response instance using the specified properties.
         * @function create
         * @memberof CUserMessage_Inventory_Response
         * @static
         * @param {ICUserMessage_Inventory_Response=} [properties] Properties to set
         * @returns {CUserMessage_Inventory_Response} CUserMessage_Inventory_Response instance
         */
        CUserMessage_Inventory_Response.create = function create(properties) {
            return new CUserMessage_Inventory_Response(properties);
        };
    
        /**
         * Encodes the specified CUserMessage_Inventory_Response message. Does not implicitly {@link CUserMessage_Inventory_Response.verify|verify} messages.
         * @function encode
         * @memberof CUserMessage_Inventory_Response
         * @static
         * @param {ICUserMessage_Inventory_Response} message CUserMessage_Inventory_Response message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CUserMessage_Inventory_Response.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.crc != null && Object.hasOwnProperty.call(message, "crc"))
                writer.uint32(/* id 1, wireType 5 =*/13).fixed32(message.crc);
            if (message.itemCount != null && Object.hasOwnProperty.call(message, "itemCount"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.itemCount);
            if (message.osversion != null && Object.hasOwnProperty.call(message, "osversion"))
                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.osversion);
            if (message.perfTime != null && Object.hasOwnProperty.call(message, "perfTime"))
                writer.uint32(/* id 6, wireType 0 =*/48).int32(message.perfTime);
            if (message.clientTimestamp != null && Object.hasOwnProperty.call(message, "clientTimestamp"))
                writer.uint32(/* id 7, wireType 0 =*/56).int32(message.clientTimestamp);
            if (message.platform != null && Object.hasOwnProperty.call(message, "platform"))
                writer.uint32(/* id 8, wireType 0 =*/64).int32(message.platform);
            if (message.inventories != null && message.inventories.length)
                for (var i = 0; i < message.inventories.length; ++i)
                    $root.CUserMessage_Inventory_Response.InventoryDetail.encode(message.inventories[i], writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
            if (message.inventories2 != null && message.inventories2.length)
                for (var i = 0; i < message.inventories2.length; ++i)
                    $root.CUserMessage_Inventory_Response.InventoryDetail.encode(message.inventories2[i], writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();
            if (message.invType != null && Object.hasOwnProperty.call(message, "invType"))
                writer.uint32(/* id 11, wireType 0 =*/88).int32(message.invType);
            if (message.buildVersion != null && Object.hasOwnProperty.call(message, "buildVersion"))
                writer.uint32(/* id 12, wireType 0 =*/96).int32(message.buildVersion);
            if (message.instance != null && Object.hasOwnProperty.call(message, "instance"))
                writer.uint32(/* id 13, wireType 0 =*/104).int32(message.instance);
            if (message.inventories3 != null && message.inventories3.length)
                for (var i = 0; i < message.inventories3.length; ++i)
                    $root.CUserMessage_Inventory_Response.InventoryDetail.encode(message.inventories3[i], writer.uint32(/* id 14, wireType 2 =*/114).fork()).ldelim();
            if (message.startTime != null && Object.hasOwnProperty.call(message, "startTime"))
                writer.uint32(/* id 15, wireType 0 =*/120).int64(message.startTime);
            return writer;
        };
    
        /**
         * Encodes the specified CUserMessage_Inventory_Response message, length delimited. Does not implicitly {@link CUserMessage_Inventory_Response.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CUserMessage_Inventory_Response
         * @static
         * @param {ICUserMessage_Inventory_Response} message CUserMessage_Inventory_Response message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CUserMessage_Inventory_Response.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CUserMessage_Inventory_Response message from the specified reader or buffer.
         * @function decode
         * @memberof CUserMessage_Inventory_Response
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CUserMessage_Inventory_Response} CUserMessage_Inventory_Response
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CUserMessage_Inventory_Response.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CUserMessage_Inventory_Response();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.crc = reader.fixed32();
                        break;
                    }
                case 2: {
                        message.itemCount = reader.int32();
                        break;
                    }
                case 5: {
                        message.osversion = reader.int32();
                        break;
                    }
                case 6: {
                        message.perfTime = reader.int32();
                        break;
                    }
                case 7: {
                        message.clientTimestamp = reader.int32();
                        break;
                    }
                case 8: {
                        message.platform = reader.int32();
                        break;
                    }
                case 9: {
                        if (!(message.inventories && message.inventories.length))
                            message.inventories = [];
                        message.inventories.push($root.CUserMessage_Inventory_Response.InventoryDetail.decode(reader, reader.uint32()));
                        break;
                    }
                case 10: {
                        if (!(message.inventories2 && message.inventories2.length))
                            message.inventories2 = [];
                        message.inventories2.push($root.CUserMessage_Inventory_Response.InventoryDetail.decode(reader, reader.uint32()));
                        break;
                    }
                case 14: {
                        if (!(message.inventories3 && message.inventories3.length))
                            message.inventories3 = [];
                        message.inventories3.push($root.CUserMessage_Inventory_Response.InventoryDetail.decode(reader, reader.uint32()));
                        break;
                    }
                case 11: {
                        message.invType = reader.int32();
                        break;
                    }
                case 12: {
                        message.buildVersion = reader.int32();
                        break;
                    }
                case 13: {
                        message.instance = reader.int32();
                        break;
                    }
                case 15: {
                        message.startTime = reader.int64();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CUserMessage_Inventory_Response message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CUserMessage_Inventory_Response
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CUserMessage_Inventory_Response} CUserMessage_Inventory_Response
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CUserMessage_Inventory_Response.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CUserMessage_Inventory_Response message.
         * @function verify
         * @memberof CUserMessage_Inventory_Response
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CUserMessage_Inventory_Response.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.crc != null && message.hasOwnProperty("crc"))
                if (!$util.isInteger(message.crc))
                    return "crc: integer expected";
            if (message.itemCount != null && message.hasOwnProperty("itemCount"))
                if (!$util.isInteger(message.itemCount))
                    return "itemCount: integer expected";
            if (message.osversion != null && message.hasOwnProperty("osversion"))
                if (!$util.isInteger(message.osversion))
                    return "osversion: integer expected";
            if (message.perfTime != null && message.hasOwnProperty("perfTime"))
                if (!$util.isInteger(message.perfTime))
                    return "perfTime: integer expected";
            if (message.clientTimestamp != null && message.hasOwnProperty("clientTimestamp"))
                if (!$util.isInteger(message.clientTimestamp))
                    return "clientTimestamp: integer expected";
            if (message.platform != null && message.hasOwnProperty("platform"))
                if (!$util.isInteger(message.platform))
                    return "platform: integer expected";
            if (message.inventories != null && message.hasOwnProperty("inventories")) {
                if (!Array.isArray(message.inventories))
                    return "inventories: array expected";
                for (var i = 0; i < message.inventories.length; ++i) {
                    var error = $root.CUserMessage_Inventory_Response.InventoryDetail.verify(message.inventories[i]);
                    if (error)
                        return "inventories." + error;
                }
            }
            if (message.inventories2 != null && message.hasOwnProperty("inventories2")) {
                if (!Array.isArray(message.inventories2))
                    return "inventories2: array expected";
                for (var i = 0; i < message.inventories2.length; ++i) {
                    var error = $root.CUserMessage_Inventory_Response.InventoryDetail.verify(message.inventories2[i]);
                    if (error)
                        return "inventories2." + error;
                }
            }
            if (message.inventories3 != null && message.hasOwnProperty("inventories3")) {
                if (!Array.isArray(message.inventories3))
                    return "inventories3: array expected";
                for (var i = 0; i < message.inventories3.length; ++i) {
                    var error = $root.CUserMessage_Inventory_Response.InventoryDetail.verify(message.inventories3[i]);
                    if (error)
                        return "inventories3." + error;
                }
            }
            if (message.invType != null && message.hasOwnProperty("invType"))
                if (!$util.isInteger(message.invType))
                    return "invType: integer expected";
            if (message.buildVersion != null && message.hasOwnProperty("buildVersion"))
                if (!$util.isInteger(message.buildVersion))
                    return "buildVersion: integer expected";
            if (message.instance != null && message.hasOwnProperty("instance"))
                if (!$util.isInteger(message.instance))
                    return "instance: integer expected";
            if (message.startTime != null && message.hasOwnProperty("startTime"))
                if (!$util.isInteger(message.startTime) && !(message.startTime && $util.isInteger(message.startTime.low) && $util.isInteger(message.startTime.high)))
                    return "startTime: integer|Long expected";
            return null;
        };
    
        /**
         * Creates a CUserMessage_Inventory_Response message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CUserMessage_Inventory_Response
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CUserMessage_Inventory_Response} CUserMessage_Inventory_Response
         */
        CUserMessage_Inventory_Response.fromObject = function fromObject(object) {
            if (object instanceof $root.CUserMessage_Inventory_Response)
                return object;
            var message = new $root.CUserMessage_Inventory_Response();
            if (object.crc != null)
                message.crc = object.crc >>> 0;
            if (object.itemCount != null)
                message.itemCount = object.itemCount | 0;
            if (object.osversion != null)
                message.osversion = object.osversion | 0;
            if (object.perfTime != null)
                message.perfTime = object.perfTime | 0;
            if (object.clientTimestamp != null)
                message.clientTimestamp = object.clientTimestamp | 0;
            if (object.platform != null)
                message.platform = object.platform | 0;
            if (object.inventories) {
                if (!Array.isArray(object.inventories))
                    throw TypeError(".CUserMessage_Inventory_Response.inventories: array expected");
                message.inventories = [];
                for (var i = 0; i < object.inventories.length; ++i) {
                    if (typeof object.inventories[i] !== "object")
                        throw TypeError(".CUserMessage_Inventory_Response.inventories: object expected");
                    message.inventories[i] = $root.CUserMessage_Inventory_Response.InventoryDetail.fromObject(object.inventories[i]);
                }
            }
            if (object.inventories2) {
                if (!Array.isArray(object.inventories2))
                    throw TypeError(".CUserMessage_Inventory_Response.inventories2: array expected");
                message.inventories2 = [];
                for (var i = 0; i < object.inventories2.length; ++i) {
                    if (typeof object.inventories2[i] !== "object")
                        throw TypeError(".CUserMessage_Inventory_Response.inventories2: object expected");
                    message.inventories2[i] = $root.CUserMessage_Inventory_Response.InventoryDetail.fromObject(object.inventories2[i]);
                }
            }
            if (object.inventories3) {
                if (!Array.isArray(object.inventories3))
                    throw TypeError(".CUserMessage_Inventory_Response.inventories3: array expected");
                message.inventories3 = [];
                for (var i = 0; i < object.inventories3.length; ++i) {
                    if (typeof object.inventories3[i] !== "object")
                        throw TypeError(".CUserMessage_Inventory_Response.inventories3: object expected");
                    message.inventories3[i] = $root.CUserMessage_Inventory_Response.InventoryDetail.fromObject(object.inventories3[i]);
                }
            }
            if (object.invType != null)
                message.invType = object.invType | 0;
            if (object.buildVersion != null)
                message.buildVersion = object.buildVersion | 0;
            if (object.instance != null)
                message.instance = object.instance | 0;
            if (object.startTime != null)
                if ($util.Long)
                    (message.startTime = $util.Long.fromValue(object.startTime)).unsigned = false;
                else if (typeof object.startTime === "string")
                    message.startTime = parseInt(object.startTime, 10);
                else if (typeof object.startTime === "number")
                    message.startTime = object.startTime;
                else if (typeof object.startTime === "object")
                    message.startTime = new $util.LongBits(object.startTime.low >>> 0, object.startTime.high >>> 0).toNumber();
            return message;
        };
    
        /**
         * Creates a plain object from a CUserMessage_Inventory_Response message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CUserMessage_Inventory_Response
         * @static
         * @param {CUserMessage_Inventory_Response} message CUserMessage_Inventory_Response
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CUserMessage_Inventory_Response.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults) {
                object.inventories = [];
                object.inventories2 = [];
                object.inventories3 = [];
            }
            if (options.defaults) {
                object.crc = 0;
                object.itemCount = 0;
                object.osversion = 0;
                object.perfTime = 0;
                object.clientTimestamp = 0;
                object.platform = 0;
                object.invType = 0;
                object.buildVersion = 0;
                object.instance = 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.startTime = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.startTime = options.longs === String ? "0" : 0;
            }
            if (message.crc != null && message.hasOwnProperty("crc"))
                object.crc = message.crc;
            if (message.itemCount != null && message.hasOwnProperty("itemCount"))
                object.itemCount = message.itemCount;
            if (message.osversion != null && message.hasOwnProperty("osversion"))
                object.osversion = message.osversion;
            if (message.perfTime != null && message.hasOwnProperty("perfTime"))
                object.perfTime = message.perfTime;
            if (message.clientTimestamp != null && message.hasOwnProperty("clientTimestamp"))
                object.clientTimestamp = message.clientTimestamp;
            if (message.platform != null && message.hasOwnProperty("platform"))
                object.platform = message.platform;
            if (message.inventories && message.inventories.length) {
                object.inventories = [];
                for (var j = 0; j < message.inventories.length; ++j)
                    object.inventories[j] = $root.CUserMessage_Inventory_Response.InventoryDetail.toObject(message.inventories[j], options);
            }
            if (message.inventories2 && message.inventories2.length) {
                object.inventories2 = [];
                for (var j = 0; j < message.inventories2.length; ++j)
                    object.inventories2[j] = $root.CUserMessage_Inventory_Response.InventoryDetail.toObject(message.inventories2[j], options);
            }
            if (message.invType != null && message.hasOwnProperty("invType"))
                object.invType = message.invType;
            if (message.buildVersion != null && message.hasOwnProperty("buildVersion"))
                object.buildVersion = message.buildVersion;
            if (message.instance != null && message.hasOwnProperty("instance"))
                object.instance = message.instance;
            if (message.inventories3 && message.inventories3.length) {
                object.inventories3 = [];
                for (var j = 0; j < message.inventories3.length; ++j)
                    object.inventories3[j] = $root.CUserMessage_Inventory_Response.InventoryDetail.toObject(message.inventories3[j], options);
            }
            if (message.startTime != null && message.hasOwnProperty("startTime"))
                if (typeof message.startTime === "number")
                    object.startTime = options.longs === String ? String(message.startTime) : message.startTime;
                else
                    object.startTime = options.longs === String ? $util.Long.prototype.toString.call(message.startTime) : options.longs === Number ? new $util.LongBits(message.startTime.low >>> 0, message.startTime.high >>> 0).toNumber() : message.startTime;
            return object;
        };
    
        /**
         * Converts this CUserMessage_Inventory_Response to JSON.
         * @function toJSON
         * @memberof CUserMessage_Inventory_Response
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CUserMessage_Inventory_Response.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * Gets the default type url for CUserMessage_Inventory_Response
         * @function getTypeUrl
         * @memberof CUserMessage_Inventory_Response
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        CUserMessage_Inventory_Response.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/CUserMessage_Inventory_Response";
        };
    
        CUserMessage_Inventory_Response.InventoryDetail = (function() {
    
            /**
             * Properties of an InventoryDetail.
             * @memberof CUserMessage_Inventory_Response
             * @interface IInventoryDetail
             * @property {number|null} [index] InventoryDetail index
             * @property {number|Long|null} [primary] InventoryDetail primary
             * @property {number|Long|null} [offset] InventoryDetail offset
             * @property {number|Long|null} [first] InventoryDetail first
             * @property {number|Long|null} [base] InventoryDetail base
             * @property {string|null} [name] InventoryDetail name
             * @property {string|null} [baseName] InventoryDetail baseName
             * @property {number|null} [baseDetail] InventoryDetail baseDetail
             * @property {number|null} [baseTime] InventoryDetail baseTime
             * @property {number|null} [baseHash] InventoryDetail baseHash
             */
    
            /**
             * Constructs a new InventoryDetail.
             * @memberof CUserMessage_Inventory_Response
             * @classdesc Represents an InventoryDetail.
             * @implements IInventoryDetail
             * @constructor
             * @param {CUserMessage_Inventory_Response.IInventoryDetail=} [properties] Properties to set
             */
            function InventoryDetail(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * InventoryDetail index.
             * @member {number} index
             * @memberof CUserMessage_Inventory_Response.InventoryDetail
             * @instance
             */
            InventoryDetail.prototype.index = 0;
    
            /**
             * InventoryDetail primary.
             * @member {number|Long} primary
             * @memberof CUserMessage_Inventory_Response.InventoryDetail
             * @instance
             */
            InventoryDetail.prototype.primary = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
            /**
             * InventoryDetail offset.
             * @member {number|Long} offset
             * @memberof CUserMessage_Inventory_Response.InventoryDetail
             * @instance
             */
            InventoryDetail.prototype.offset = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
            /**
             * InventoryDetail first.
             * @member {number|Long} first
             * @memberof CUserMessage_Inventory_Response.InventoryDetail
             * @instance
             */
            InventoryDetail.prototype.first = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
            /**
             * InventoryDetail base.
             * @member {number|Long} base
             * @memberof CUserMessage_Inventory_Response.InventoryDetail
             * @instance
             */
            InventoryDetail.prototype.base = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
            /**
             * InventoryDetail name.
             * @member {string} name
             * @memberof CUserMessage_Inventory_Response.InventoryDetail
             * @instance
             */
            InventoryDetail.prototype.name = "";
    
            /**
             * InventoryDetail baseName.
             * @member {string} baseName
             * @memberof CUserMessage_Inventory_Response.InventoryDetail
             * @instance
             */
            InventoryDetail.prototype.baseName = "";
    
            /**
             * InventoryDetail baseDetail.
             * @member {number} baseDetail
             * @memberof CUserMessage_Inventory_Response.InventoryDetail
             * @instance
             */
            InventoryDetail.prototype.baseDetail = 0;
    
            /**
             * InventoryDetail baseTime.
             * @member {number} baseTime
             * @memberof CUserMessage_Inventory_Response.InventoryDetail
             * @instance
             */
            InventoryDetail.prototype.baseTime = 0;
    
            /**
             * InventoryDetail baseHash.
             * @member {number} baseHash
             * @memberof CUserMessage_Inventory_Response.InventoryDetail
             * @instance
             */
            InventoryDetail.prototype.baseHash = 0;
    
            /**
             * Creates a new InventoryDetail instance using the specified properties.
             * @function create
             * @memberof CUserMessage_Inventory_Response.InventoryDetail
             * @static
             * @param {CUserMessage_Inventory_Response.IInventoryDetail=} [properties] Properties to set
             * @returns {CUserMessage_Inventory_Response.InventoryDetail} InventoryDetail instance
             */
            InventoryDetail.create = function create(properties) {
                return new InventoryDetail(properties);
            };
    
            /**
             * Encodes the specified InventoryDetail message. Does not implicitly {@link CUserMessage_Inventory_Response.InventoryDetail.verify|verify} messages.
             * @function encode
             * @memberof CUserMessage_Inventory_Response.InventoryDetail
             * @static
             * @param {CUserMessage_Inventory_Response.IInventoryDetail} message InventoryDetail message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            InventoryDetail.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.index != null && Object.hasOwnProperty.call(message, "index"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.index);
                if (message.primary != null && Object.hasOwnProperty.call(message, "primary"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int64(message.primary);
                if (message.offset != null && Object.hasOwnProperty.call(message, "offset"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int64(message.offset);
                if (message.first != null && Object.hasOwnProperty.call(message, "first"))
                    writer.uint32(/* id 4, wireType 0 =*/32).int64(message.first);
                if (message.base != null && Object.hasOwnProperty.call(message, "base"))
                    writer.uint32(/* id 5, wireType 0 =*/40).int64(message.base);
                if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                    writer.uint32(/* id 6, wireType 2 =*/50).string(message.name);
                if (message.baseName != null && Object.hasOwnProperty.call(message, "baseName"))
                    writer.uint32(/* id 7, wireType 2 =*/58).string(message.baseName);
                if (message.baseDetail != null && Object.hasOwnProperty.call(message, "baseDetail"))
                    writer.uint32(/* id 8, wireType 0 =*/64).int32(message.baseDetail);
                if (message.baseTime != null && Object.hasOwnProperty.call(message, "baseTime"))
                    writer.uint32(/* id 9, wireType 0 =*/72).int32(message.baseTime);
                if (message.baseHash != null && Object.hasOwnProperty.call(message, "baseHash"))
                    writer.uint32(/* id 10, wireType 0 =*/80).int32(message.baseHash);
                return writer;
            };
    
            /**
             * Encodes the specified InventoryDetail message, length delimited. Does not implicitly {@link CUserMessage_Inventory_Response.InventoryDetail.verify|verify} messages.
             * @function encodeDelimited
             * @memberof CUserMessage_Inventory_Response.InventoryDetail
             * @static
             * @param {CUserMessage_Inventory_Response.IInventoryDetail} message InventoryDetail message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            InventoryDetail.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes an InventoryDetail message from the specified reader or buffer.
             * @function decode
             * @memberof CUserMessage_Inventory_Response.InventoryDetail
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {CUserMessage_Inventory_Response.InventoryDetail} InventoryDetail
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            InventoryDetail.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CUserMessage_Inventory_Response.InventoryDetail();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.index = reader.int32();
                            break;
                        }
                    case 2: {
                            message.primary = reader.int64();
                            break;
                        }
                    case 3: {
                            message.offset = reader.int64();
                            break;
                        }
                    case 4: {
                            message.first = reader.int64();
                            break;
                        }
                    case 5: {
                            message.base = reader.int64();
                            break;
                        }
                    case 6: {
                            message.name = reader.string();
                            break;
                        }
                    case 7: {
                            message.baseName = reader.string();
                            break;
                        }
                    case 8: {
                            message.baseDetail = reader.int32();
                            break;
                        }
                    case 9: {
                            message.baseTime = reader.int32();
                            break;
                        }
                    case 10: {
                            message.baseHash = reader.int32();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes an InventoryDetail message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof CUserMessage_Inventory_Response.InventoryDetail
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {CUserMessage_Inventory_Response.InventoryDetail} InventoryDetail
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            InventoryDetail.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies an InventoryDetail message.
             * @function verify
             * @memberof CUserMessage_Inventory_Response.InventoryDetail
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            InventoryDetail.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.index != null && message.hasOwnProperty("index"))
                    if (!$util.isInteger(message.index))
                        return "index: integer expected";
                if (message.primary != null && message.hasOwnProperty("primary"))
                    if (!$util.isInteger(message.primary) && !(message.primary && $util.isInteger(message.primary.low) && $util.isInteger(message.primary.high)))
                        return "primary: integer|Long expected";
                if (message.offset != null && message.hasOwnProperty("offset"))
                    if (!$util.isInteger(message.offset) && !(message.offset && $util.isInteger(message.offset.low) && $util.isInteger(message.offset.high)))
                        return "offset: integer|Long expected";
                if (message.first != null && message.hasOwnProperty("first"))
                    if (!$util.isInteger(message.first) && !(message.first && $util.isInteger(message.first.low) && $util.isInteger(message.first.high)))
                        return "first: integer|Long expected";
                if (message.base != null && message.hasOwnProperty("base"))
                    if (!$util.isInteger(message.base) && !(message.base && $util.isInteger(message.base.low) && $util.isInteger(message.base.high)))
                        return "base: integer|Long expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                if (message.baseName != null && message.hasOwnProperty("baseName"))
                    if (!$util.isString(message.baseName))
                        return "baseName: string expected";
                if (message.baseDetail != null && message.hasOwnProperty("baseDetail"))
                    if (!$util.isInteger(message.baseDetail))
                        return "baseDetail: integer expected";
                if (message.baseTime != null && message.hasOwnProperty("baseTime"))
                    if (!$util.isInteger(message.baseTime))
                        return "baseTime: integer expected";
                if (message.baseHash != null && message.hasOwnProperty("baseHash"))
                    if (!$util.isInteger(message.baseHash))
                        return "baseHash: integer expected";
                return null;
            };
    
            /**
             * Creates an InventoryDetail message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof CUserMessage_Inventory_Response.InventoryDetail
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {CUserMessage_Inventory_Response.InventoryDetail} InventoryDetail
             */
            InventoryDetail.fromObject = function fromObject(object) {
                if (object instanceof $root.CUserMessage_Inventory_Response.InventoryDetail)
                    return object;
                var message = new $root.CUserMessage_Inventory_Response.InventoryDetail();
                if (object.index != null)
                    message.index = object.index | 0;
                if (object.primary != null)
                    if ($util.Long)
                        (message.primary = $util.Long.fromValue(object.primary)).unsigned = false;
                    else if (typeof object.primary === "string")
                        message.primary = parseInt(object.primary, 10);
                    else if (typeof object.primary === "number")
                        message.primary = object.primary;
                    else if (typeof object.primary === "object")
                        message.primary = new $util.LongBits(object.primary.low >>> 0, object.primary.high >>> 0).toNumber();
                if (object.offset != null)
                    if ($util.Long)
                        (message.offset = $util.Long.fromValue(object.offset)).unsigned = false;
                    else if (typeof object.offset === "string")
                        message.offset = parseInt(object.offset, 10);
                    else if (typeof object.offset === "number")
                        message.offset = object.offset;
                    else if (typeof object.offset === "object")
                        message.offset = new $util.LongBits(object.offset.low >>> 0, object.offset.high >>> 0).toNumber();
                if (object.first != null)
                    if ($util.Long)
                        (message.first = $util.Long.fromValue(object.first)).unsigned = false;
                    else if (typeof object.first === "string")
                        message.first = parseInt(object.first, 10);
                    else if (typeof object.first === "number")
                        message.first = object.first;
                    else if (typeof object.first === "object")
                        message.first = new $util.LongBits(object.first.low >>> 0, object.first.high >>> 0).toNumber();
                if (object.base != null)
                    if ($util.Long)
                        (message.base = $util.Long.fromValue(object.base)).unsigned = false;
                    else if (typeof object.base === "string")
                        message.base = parseInt(object.base, 10);
                    else if (typeof object.base === "number")
                        message.base = object.base;
                    else if (typeof object.base === "object")
                        message.base = new $util.LongBits(object.base.low >>> 0, object.base.high >>> 0).toNumber();
                if (object.name != null)
                    message.name = String(object.name);
                if (object.baseName != null)
                    message.baseName = String(object.baseName);
                if (object.baseDetail != null)
                    message.baseDetail = object.baseDetail | 0;
                if (object.baseTime != null)
                    message.baseTime = object.baseTime | 0;
                if (object.baseHash != null)
                    message.baseHash = object.baseHash | 0;
                return message;
            };
    
            /**
             * Creates a plain object from an InventoryDetail message. Also converts values to other types if specified.
             * @function toObject
             * @memberof CUserMessage_Inventory_Response.InventoryDetail
             * @static
             * @param {CUserMessage_Inventory_Response.InventoryDetail} message InventoryDetail
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            InventoryDetail.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.index = 0;
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.primary = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.primary = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.offset = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.offset = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.first = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.first = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.base = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.base = options.longs === String ? "0" : 0;
                    object.name = "";
                    object.baseName = "";
                    object.baseDetail = 0;
                    object.baseTime = 0;
                    object.baseHash = 0;
                }
                if (message.index != null && message.hasOwnProperty("index"))
                    object.index = message.index;
                if (message.primary != null && message.hasOwnProperty("primary"))
                    if (typeof message.primary === "number")
                        object.primary = options.longs === String ? String(message.primary) : message.primary;
                    else
                        object.primary = options.longs === String ? $util.Long.prototype.toString.call(message.primary) : options.longs === Number ? new $util.LongBits(message.primary.low >>> 0, message.primary.high >>> 0).toNumber() : message.primary;
                if (message.offset != null && message.hasOwnProperty("offset"))
                    if (typeof message.offset === "number")
                        object.offset = options.longs === String ? String(message.offset) : message.offset;
                    else
                        object.offset = options.longs === String ? $util.Long.prototype.toString.call(message.offset) : options.longs === Number ? new $util.LongBits(message.offset.low >>> 0, message.offset.high >>> 0).toNumber() : message.offset;
                if (message.first != null && message.hasOwnProperty("first"))
                    if (typeof message.first === "number")
                        object.first = options.longs === String ? String(message.first) : message.first;
                    else
                        object.first = options.longs === String ? $util.Long.prototype.toString.call(message.first) : options.longs === Number ? new $util.LongBits(message.first.low >>> 0, message.first.high >>> 0).toNumber() : message.first;
                if (message.base != null && message.hasOwnProperty("base"))
                    if (typeof message.base === "number")
                        object.base = options.longs === String ? String(message.base) : message.base;
                    else
                        object.base = options.longs === String ? $util.Long.prototype.toString.call(message.base) : options.longs === Number ? new $util.LongBits(message.base.low >>> 0, message.base.high >>> 0).toNumber() : message.base;
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                if (message.baseName != null && message.hasOwnProperty("baseName"))
                    object.baseName = message.baseName;
                if (message.baseDetail != null && message.hasOwnProperty("baseDetail"))
                    object.baseDetail = message.baseDetail;
                if (message.baseTime != null && message.hasOwnProperty("baseTime"))
                    object.baseTime = message.baseTime;
                if (message.baseHash != null && message.hasOwnProperty("baseHash"))
                    object.baseHash = message.baseHash;
                return object;
            };
    
            /**
             * Converts this InventoryDetail to JSON.
             * @function toJSON
             * @memberof CUserMessage_Inventory_Response.InventoryDetail
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            InventoryDetail.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            /**
             * Gets the default type url for InventoryDetail
             * @function getTypeUrl
             * @memberof CUserMessage_Inventory_Response.InventoryDetail
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            InventoryDetail.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/CUserMessage_Inventory_Response.InventoryDetail";
            };
    
            return InventoryDetail;
        })();
    
        return CUserMessage_Inventory_Response;
    })();
    
    $root.CUserMessageRequestDiagnostic = (function() {
    
        /**
         * Properties of a CUserMessageRequestDiagnostic.
         * @exports ICUserMessageRequestDiagnostic
         * @interface ICUserMessageRequestDiagnostic
         * @property {Array.<CUserMessageRequestDiagnostic.IDiagnostic>|null} [diagnostics] CUserMessageRequestDiagnostic diagnostics
         */
    
        /**
         * Constructs a new CUserMessageRequestDiagnostic.
         * @exports CUserMessageRequestDiagnostic
         * @classdesc Represents a CUserMessageRequestDiagnostic.
         * @implements ICUserMessageRequestDiagnostic
         * @constructor
         * @param {ICUserMessageRequestDiagnostic=} [properties] Properties to set
         */
        function CUserMessageRequestDiagnostic(properties) {
            this.diagnostics = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CUserMessageRequestDiagnostic diagnostics.
         * @member {Array.<CUserMessageRequestDiagnostic.IDiagnostic>} diagnostics
         * @memberof CUserMessageRequestDiagnostic
         * @instance
         */
        CUserMessageRequestDiagnostic.prototype.diagnostics = $util.emptyArray;
    
        /**
         * Creates a new CUserMessageRequestDiagnostic instance using the specified properties.
         * @function create
         * @memberof CUserMessageRequestDiagnostic
         * @static
         * @param {ICUserMessageRequestDiagnostic=} [properties] Properties to set
         * @returns {CUserMessageRequestDiagnostic} CUserMessageRequestDiagnostic instance
         */
        CUserMessageRequestDiagnostic.create = function create(properties) {
            return new CUserMessageRequestDiagnostic(properties);
        };
    
        /**
         * Encodes the specified CUserMessageRequestDiagnostic message. Does not implicitly {@link CUserMessageRequestDiagnostic.verify|verify} messages.
         * @function encode
         * @memberof CUserMessageRequestDiagnostic
         * @static
         * @param {ICUserMessageRequestDiagnostic} message CUserMessageRequestDiagnostic message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CUserMessageRequestDiagnostic.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.diagnostics != null && message.diagnostics.length)
                for (var i = 0; i < message.diagnostics.length; ++i)
                    $root.CUserMessageRequestDiagnostic.Diagnostic.encode(message.diagnostics[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };
    
        /**
         * Encodes the specified CUserMessageRequestDiagnostic message, length delimited. Does not implicitly {@link CUserMessageRequestDiagnostic.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CUserMessageRequestDiagnostic
         * @static
         * @param {ICUserMessageRequestDiagnostic} message CUserMessageRequestDiagnostic message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CUserMessageRequestDiagnostic.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CUserMessageRequestDiagnostic message from the specified reader or buffer.
         * @function decode
         * @memberof CUserMessageRequestDiagnostic
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CUserMessageRequestDiagnostic} CUserMessageRequestDiagnostic
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CUserMessageRequestDiagnostic.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CUserMessageRequestDiagnostic();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        if (!(message.diagnostics && message.diagnostics.length))
                            message.diagnostics = [];
                        message.diagnostics.push($root.CUserMessageRequestDiagnostic.Diagnostic.decode(reader, reader.uint32()));
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CUserMessageRequestDiagnostic message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CUserMessageRequestDiagnostic
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CUserMessageRequestDiagnostic} CUserMessageRequestDiagnostic
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CUserMessageRequestDiagnostic.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CUserMessageRequestDiagnostic message.
         * @function verify
         * @memberof CUserMessageRequestDiagnostic
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CUserMessageRequestDiagnostic.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.diagnostics != null && message.hasOwnProperty("diagnostics")) {
                if (!Array.isArray(message.diagnostics))
                    return "diagnostics: array expected";
                for (var i = 0; i < message.diagnostics.length; ++i) {
                    var error = $root.CUserMessageRequestDiagnostic.Diagnostic.verify(message.diagnostics[i]);
                    if (error)
                        return "diagnostics." + error;
                }
            }
            return null;
        };
    
        /**
         * Creates a CUserMessageRequestDiagnostic message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CUserMessageRequestDiagnostic
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CUserMessageRequestDiagnostic} CUserMessageRequestDiagnostic
         */
        CUserMessageRequestDiagnostic.fromObject = function fromObject(object) {
            if (object instanceof $root.CUserMessageRequestDiagnostic)
                return object;
            var message = new $root.CUserMessageRequestDiagnostic();
            if (object.diagnostics) {
                if (!Array.isArray(object.diagnostics))
                    throw TypeError(".CUserMessageRequestDiagnostic.diagnostics: array expected");
                message.diagnostics = [];
                for (var i = 0; i < object.diagnostics.length; ++i) {
                    if (typeof object.diagnostics[i] !== "object")
                        throw TypeError(".CUserMessageRequestDiagnostic.diagnostics: object expected");
                    message.diagnostics[i] = $root.CUserMessageRequestDiagnostic.Diagnostic.fromObject(object.diagnostics[i]);
                }
            }
            return message;
        };
    
        /**
         * Creates a plain object from a CUserMessageRequestDiagnostic message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CUserMessageRequestDiagnostic
         * @static
         * @param {CUserMessageRequestDiagnostic} message CUserMessageRequestDiagnostic
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CUserMessageRequestDiagnostic.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.diagnostics = [];
            if (message.diagnostics && message.diagnostics.length) {
                object.diagnostics = [];
                for (var j = 0; j < message.diagnostics.length; ++j)
                    object.diagnostics[j] = $root.CUserMessageRequestDiagnostic.Diagnostic.toObject(message.diagnostics[j], options);
            }
            return object;
        };
    
        /**
         * Converts this CUserMessageRequestDiagnostic to JSON.
         * @function toJSON
         * @memberof CUserMessageRequestDiagnostic
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CUserMessageRequestDiagnostic.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * Gets the default type url for CUserMessageRequestDiagnostic
         * @function getTypeUrl
         * @memberof CUserMessageRequestDiagnostic
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        CUserMessageRequestDiagnostic.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/CUserMessageRequestDiagnostic";
        };
    
        CUserMessageRequestDiagnostic.Diagnostic = (function() {
    
            /**
             * Properties of a Diagnostic.
             * @memberof CUserMessageRequestDiagnostic
             * @interface IDiagnostic
             * @property {number|null} [index] Diagnostic index
             * @property {number|Long|null} [offset] Diagnostic offset
             * @property {number|null} [param] Diagnostic param
             * @property {number|null} [length] Diagnostic length
             * @property {number|null} [type] Diagnostic type
             * @property {number|Long|null} [base] Diagnostic base
             * @property {number|Long|null} [range] Diagnostic range
             * @property {number|Long|null} [extent] Diagnostic extent
             * @property {number|Long|null} [detail] Diagnostic detail
             * @property {string|null} [name] Diagnostic name
             * @property {string|null} [alias] Diagnostic alias
             * @property {Uint8Array|null} [vardetail] Diagnostic vardetail
             * @property {number|null} [context] Diagnostic context
             */
    
            /**
             * Constructs a new Diagnostic.
             * @memberof CUserMessageRequestDiagnostic
             * @classdesc Represents a Diagnostic.
             * @implements IDiagnostic
             * @constructor
             * @param {CUserMessageRequestDiagnostic.IDiagnostic=} [properties] Properties to set
             */
            function Diagnostic(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * Diagnostic index.
             * @member {number} index
             * @memberof CUserMessageRequestDiagnostic.Diagnostic
             * @instance
             */
            Diagnostic.prototype.index = 0;
    
            /**
             * Diagnostic offset.
             * @member {number|Long} offset
             * @memberof CUserMessageRequestDiagnostic.Diagnostic
             * @instance
             */
            Diagnostic.prototype.offset = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
            /**
             * Diagnostic param.
             * @member {number} param
             * @memberof CUserMessageRequestDiagnostic.Diagnostic
             * @instance
             */
            Diagnostic.prototype.param = 0;
    
            /**
             * Diagnostic length.
             * @member {number} length
             * @memberof CUserMessageRequestDiagnostic.Diagnostic
             * @instance
             */
            Diagnostic.prototype.length = 0;
    
            /**
             * Diagnostic type.
             * @member {number} type
             * @memberof CUserMessageRequestDiagnostic.Diagnostic
             * @instance
             */
            Diagnostic.prototype.type = 0;
    
            /**
             * Diagnostic base.
             * @member {number|Long} base
             * @memberof CUserMessageRequestDiagnostic.Diagnostic
             * @instance
             */
            Diagnostic.prototype.base = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
            /**
             * Diagnostic range.
             * @member {number|Long} range
             * @memberof CUserMessageRequestDiagnostic.Diagnostic
             * @instance
             */
            Diagnostic.prototype.range = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
            /**
             * Diagnostic extent.
             * @member {number|Long} extent
             * @memberof CUserMessageRequestDiagnostic.Diagnostic
             * @instance
             */
            Diagnostic.prototype.extent = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
            /**
             * Diagnostic detail.
             * @member {number|Long} detail
             * @memberof CUserMessageRequestDiagnostic.Diagnostic
             * @instance
             */
            Diagnostic.prototype.detail = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
            /**
             * Diagnostic name.
             * @member {string} name
             * @memberof CUserMessageRequestDiagnostic.Diagnostic
             * @instance
             */
            Diagnostic.prototype.name = "";
    
            /**
             * Diagnostic alias.
             * @member {string} alias
             * @memberof CUserMessageRequestDiagnostic.Diagnostic
             * @instance
             */
            Diagnostic.prototype.alias = "";
    
            /**
             * Diagnostic vardetail.
             * @member {Uint8Array} vardetail
             * @memberof CUserMessageRequestDiagnostic.Diagnostic
             * @instance
             */
            Diagnostic.prototype.vardetail = $util.newBuffer([]);
    
            /**
             * Diagnostic context.
             * @member {number} context
             * @memberof CUserMessageRequestDiagnostic.Diagnostic
             * @instance
             */
            Diagnostic.prototype.context = 0;
    
            /**
             * Creates a new Diagnostic instance using the specified properties.
             * @function create
             * @memberof CUserMessageRequestDiagnostic.Diagnostic
             * @static
             * @param {CUserMessageRequestDiagnostic.IDiagnostic=} [properties] Properties to set
             * @returns {CUserMessageRequestDiagnostic.Diagnostic} Diagnostic instance
             */
            Diagnostic.create = function create(properties) {
                return new Diagnostic(properties);
            };
    
            /**
             * Encodes the specified Diagnostic message. Does not implicitly {@link CUserMessageRequestDiagnostic.Diagnostic.verify|verify} messages.
             * @function encode
             * @memberof CUserMessageRequestDiagnostic.Diagnostic
             * @static
             * @param {CUserMessageRequestDiagnostic.IDiagnostic} message Diagnostic message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Diagnostic.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.index != null && Object.hasOwnProperty.call(message, "index"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.index);
                if (message.offset != null && Object.hasOwnProperty.call(message, "offset"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int64(message.offset);
                if (message.param != null && Object.hasOwnProperty.call(message, "param"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int32(message.param);
                if (message.length != null && Object.hasOwnProperty.call(message, "length"))
                    writer.uint32(/* id 4, wireType 0 =*/32).int32(message.length);
                if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                    writer.uint32(/* id 5, wireType 0 =*/40).int32(message.type);
                if (message.base != null && Object.hasOwnProperty.call(message, "base"))
                    writer.uint32(/* id 6, wireType 0 =*/48).int64(message.base);
                if (message.range != null && Object.hasOwnProperty.call(message, "range"))
                    writer.uint32(/* id 7, wireType 0 =*/56).int64(message.range);
                if (message.extent != null && Object.hasOwnProperty.call(message, "extent"))
                    writer.uint32(/* id 8, wireType 0 =*/64).int64(message.extent);
                if (message.detail != null && Object.hasOwnProperty.call(message, "detail"))
                    writer.uint32(/* id 9, wireType 0 =*/72).int64(message.detail);
                if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                    writer.uint32(/* id 10, wireType 2 =*/82).string(message.name);
                if (message.alias != null && Object.hasOwnProperty.call(message, "alias"))
                    writer.uint32(/* id 11, wireType 2 =*/90).string(message.alias);
                if (message.vardetail != null && Object.hasOwnProperty.call(message, "vardetail"))
                    writer.uint32(/* id 12, wireType 2 =*/98).bytes(message.vardetail);
                if (message.context != null && Object.hasOwnProperty.call(message, "context"))
                    writer.uint32(/* id 13, wireType 0 =*/104).int32(message.context);
                return writer;
            };
    
            /**
             * Encodes the specified Diagnostic message, length delimited. Does not implicitly {@link CUserMessageRequestDiagnostic.Diagnostic.verify|verify} messages.
             * @function encodeDelimited
             * @memberof CUserMessageRequestDiagnostic.Diagnostic
             * @static
             * @param {CUserMessageRequestDiagnostic.IDiagnostic} message Diagnostic message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Diagnostic.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a Diagnostic message from the specified reader or buffer.
             * @function decode
             * @memberof CUserMessageRequestDiagnostic.Diagnostic
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {CUserMessageRequestDiagnostic.Diagnostic} Diagnostic
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Diagnostic.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CUserMessageRequestDiagnostic.Diagnostic();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.index = reader.int32();
                            break;
                        }
                    case 2: {
                            message.offset = reader.int64();
                            break;
                        }
                    case 3: {
                            message.param = reader.int32();
                            break;
                        }
                    case 4: {
                            message.length = reader.int32();
                            break;
                        }
                    case 5: {
                            message.type = reader.int32();
                            break;
                        }
                    case 6: {
                            message.base = reader.int64();
                            break;
                        }
                    case 7: {
                            message.range = reader.int64();
                            break;
                        }
                    case 8: {
                            message.extent = reader.int64();
                            break;
                        }
                    case 9: {
                            message.detail = reader.int64();
                            break;
                        }
                    case 10: {
                            message.name = reader.string();
                            break;
                        }
                    case 11: {
                            message.alias = reader.string();
                            break;
                        }
                    case 12: {
                            message.vardetail = reader.bytes();
                            break;
                        }
                    case 13: {
                            message.context = reader.int32();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a Diagnostic message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof CUserMessageRequestDiagnostic.Diagnostic
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {CUserMessageRequestDiagnostic.Diagnostic} Diagnostic
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Diagnostic.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a Diagnostic message.
             * @function verify
             * @memberof CUserMessageRequestDiagnostic.Diagnostic
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Diagnostic.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.index != null && message.hasOwnProperty("index"))
                    if (!$util.isInteger(message.index))
                        return "index: integer expected";
                if (message.offset != null && message.hasOwnProperty("offset"))
                    if (!$util.isInteger(message.offset) && !(message.offset && $util.isInteger(message.offset.low) && $util.isInteger(message.offset.high)))
                        return "offset: integer|Long expected";
                if (message.param != null && message.hasOwnProperty("param"))
                    if (!$util.isInteger(message.param))
                        return "param: integer expected";
                if (message.length != null && message.hasOwnProperty("length"))
                    if (!$util.isInteger(message.length))
                        return "length: integer expected";
                if (message.type != null && message.hasOwnProperty("type"))
                    if (!$util.isInteger(message.type))
                        return "type: integer expected";
                if (message.base != null && message.hasOwnProperty("base"))
                    if (!$util.isInteger(message.base) && !(message.base && $util.isInteger(message.base.low) && $util.isInteger(message.base.high)))
                        return "base: integer|Long expected";
                if (message.range != null && message.hasOwnProperty("range"))
                    if (!$util.isInteger(message.range) && !(message.range && $util.isInteger(message.range.low) && $util.isInteger(message.range.high)))
                        return "range: integer|Long expected";
                if (message.extent != null && message.hasOwnProperty("extent"))
                    if (!$util.isInteger(message.extent) && !(message.extent && $util.isInteger(message.extent.low) && $util.isInteger(message.extent.high)))
                        return "extent: integer|Long expected";
                if (message.detail != null && message.hasOwnProperty("detail"))
                    if (!$util.isInteger(message.detail) && !(message.detail && $util.isInteger(message.detail.low) && $util.isInteger(message.detail.high)))
                        return "detail: integer|Long expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                if (message.alias != null && message.hasOwnProperty("alias"))
                    if (!$util.isString(message.alias))
                        return "alias: string expected";
                if (message.vardetail != null && message.hasOwnProperty("vardetail"))
                    if (!(message.vardetail && typeof message.vardetail.length === "number" || $util.isString(message.vardetail)))
                        return "vardetail: buffer expected";
                if (message.context != null && message.hasOwnProperty("context"))
                    if (!$util.isInteger(message.context))
                        return "context: integer expected";
                return null;
            };
    
            /**
             * Creates a Diagnostic message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof CUserMessageRequestDiagnostic.Diagnostic
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {CUserMessageRequestDiagnostic.Diagnostic} Diagnostic
             */
            Diagnostic.fromObject = function fromObject(object) {
                if (object instanceof $root.CUserMessageRequestDiagnostic.Diagnostic)
                    return object;
                var message = new $root.CUserMessageRequestDiagnostic.Diagnostic();
                if (object.index != null)
                    message.index = object.index | 0;
                if (object.offset != null)
                    if ($util.Long)
                        (message.offset = $util.Long.fromValue(object.offset)).unsigned = false;
                    else if (typeof object.offset === "string")
                        message.offset = parseInt(object.offset, 10);
                    else if (typeof object.offset === "number")
                        message.offset = object.offset;
                    else if (typeof object.offset === "object")
                        message.offset = new $util.LongBits(object.offset.low >>> 0, object.offset.high >>> 0).toNumber();
                if (object.param != null)
                    message.param = object.param | 0;
                if (object.length != null)
                    message.length = object.length | 0;
                if (object.type != null)
                    message.type = object.type | 0;
                if (object.base != null)
                    if ($util.Long)
                        (message.base = $util.Long.fromValue(object.base)).unsigned = false;
                    else if (typeof object.base === "string")
                        message.base = parseInt(object.base, 10);
                    else if (typeof object.base === "number")
                        message.base = object.base;
                    else if (typeof object.base === "object")
                        message.base = new $util.LongBits(object.base.low >>> 0, object.base.high >>> 0).toNumber();
                if (object.range != null)
                    if ($util.Long)
                        (message.range = $util.Long.fromValue(object.range)).unsigned = false;
                    else if (typeof object.range === "string")
                        message.range = parseInt(object.range, 10);
                    else if (typeof object.range === "number")
                        message.range = object.range;
                    else if (typeof object.range === "object")
                        message.range = new $util.LongBits(object.range.low >>> 0, object.range.high >>> 0).toNumber();
                if (object.extent != null)
                    if ($util.Long)
                        (message.extent = $util.Long.fromValue(object.extent)).unsigned = false;
                    else if (typeof object.extent === "string")
                        message.extent = parseInt(object.extent, 10);
                    else if (typeof object.extent === "number")
                        message.extent = object.extent;
                    else if (typeof object.extent === "object")
                        message.extent = new $util.LongBits(object.extent.low >>> 0, object.extent.high >>> 0).toNumber();
                if (object.detail != null)
                    if ($util.Long)
                        (message.detail = $util.Long.fromValue(object.detail)).unsigned = false;
                    else if (typeof object.detail === "string")
                        message.detail = parseInt(object.detail, 10);
                    else if (typeof object.detail === "number")
                        message.detail = object.detail;
                    else if (typeof object.detail === "object")
                        message.detail = new $util.LongBits(object.detail.low >>> 0, object.detail.high >>> 0).toNumber();
                if (object.name != null)
                    message.name = String(object.name);
                if (object.alias != null)
                    message.alias = String(object.alias);
                if (object.vardetail != null)
                    if (typeof object.vardetail === "string")
                        $util.base64.decode(object.vardetail, message.vardetail = $util.newBuffer($util.base64.length(object.vardetail)), 0);
                    else if (object.vardetail.length >= 0)
                        message.vardetail = object.vardetail;
                if (object.context != null)
                    message.context = object.context | 0;
                return message;
            };
    
            /**
             * Creates a plain object from a Diagnostic message. Also converts values to other types if specified.
             * @function toObject
             * @memberof CUserMessageRequestDiagnostic.Diagnostic
             * @static
             * @param {CUserMessageRequestDiagnostic.Diagnostic} message Diagnostic
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Diagnostic.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.index = 0;
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.offset = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.offset = options.longs === String ? "0" : 0;
                    object.param = 0;
                    object.length = 0;
                    object.type = 0;
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.base = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.base = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.range = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.range = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.extent = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.extent = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.detail = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.detail = options.longs === String ? "0" : 0;
                    object.name = "";
                    object.alias = "";
                    if (options.bytes === String)
                        object.vardetail = "";
                    else {
                        object.vardetail = [];
                        if (options.bytes !== Array)
                            object.vardetail = $util.newBuffer(object.vardetail);
                    }
                    object.context = 0;
                }
                if (message.index != null && message.hasOwnProperty("index"))
                    object.index = message.index;
                if (message.offset != null && message.hasOwnProperty("offset"))
                    if (typeof message.offset === "number")
                        object.offset = options.longs === String ? String(message.offset) : message.offset;
                    else
                        object.offset = options.longs === String ? $util.Long.prototype.toString.call(message.offset) : options.longs === Number ? new $util.LongBits(message.offset.low >>> 0, message.offset.high >>> 0).toNumber() : message.offset;
                if (message.param != null && message.hasOwnProperty("param"))
                    object.param = message.param;
                if (message.length != null && message.hasOwnProperty("length"))
                    object.length = message.length;
                if (message.type != null && message.hasOwnProperty("type"))
                    object.type = message.type;
                if (message.base != null && message.hasOwnProperty("base"))
                    if (typeof message.base === "number")
                        object.base = options.longs === String ? String(message.base) : message.base;
                    else
                        object.base = options.longs === String ? $util.Long.prototype.toString.call(message.base) : options.longs === Number ? new $util.LongBits(message.base.low >>> 0, message.base.high >>> 0).toNumber() : message.base;
                if (message.range != null && message.hasOwnProperty("range"))
                    if (typeof message.range === "number")
                        object.range = options.longs === String ? String(message.range) : message.range;
                    else
                        object.range = options.longs === String ? $util.Long.prototype.toString.call(message.range) : options.longs === Number ? new $util.LongBits(message.range.low >>> 0, message.range.high >>> 0).toNumber() : message.range;
                if (message.extent != null && message.hasOwnProperty("extent"))
                    if (typeof message.extent === "number")
                        object.extent = options.longs === String ? String(message.extent) : message.extent;
                    else
                        object.extent = options.longs === String ? $util.Long.prototype.toString.call(message.extent) : options.longs === Number ? new $util.LongBits(message.extent.low >>> 0, message.extent.high >>> 0).toNumber() : message.extent;
                if (message.detail != null && message.hasOwnProperty("detail"))
                    if (typeof message.detail === "number")
                        object.detail = options.longs === String ? String(message.detail) : message.detail;
                    else
                        object.detail = options.longs === String ? $util.Long.prototype.toString.call(message.detail) : options.longs === Number ? new $util.LongBits(message.detail.low >>> 0, message.detail.high >>> 0).toNumber() : message.detail;
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                if (message.alias != null && message.hasOwnProperty("alias"))
                    object.alias = message.alias;
                if (message.vardetail != null && message.hasOwnProperty("vardetail"))
                    object.vardetail = options.bytes === String ? $util.base64.encode(message.vardetail, 0, message.vardetail.length) : options.bytes === Array ? Array.prototype.slice.call(message.vardetail) : message.vardetail;
                if (message.context != null && message.hasOwnProperty("context"))
                    object.context = message.context;
                return object;
            };
    
            /**
             * Converts this Diagnostic to JSON.
             * @function toJSON
             * @memberof CUserMessageRequestDiagnostic.Diagnostic
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Diagnostic.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            /**
             * Gets the default type url for Diagnostic
             * @function getTypeUrl
             * @memberof CUserMessageRequestDiagnostic.Diagnostic
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            Diagnostic.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/CUserMessageRequestDiagnostic.Diagnostic";
            };
    
            return Diagnostic;
        })();
    
        return CUserMessageRequestDiagnostic;
    })();
    
    $root.CUserMessage_Diagnostic_Response = (function() {
    
        /**
         * Properties of a CUserMessage_Diagnostic_Response.
         * @exports ICUserMessage_Diagnostic_Response
         * @interface ICUserMessage_Diagnostic_Response
         * @property {Array.<CUserMessage_Diagnostic_Response.IDiagnostic>|null} [diagnostics] CUserMessage_Diagnostic_Response diagnostics
         * @property {number|null} [buildVersion] CUserMessage_Diagnostic_Response buildVersion
         * @property {number|null} [instance] CUserMessage_Diagnostic_Response instance
         * @property {number|Long|null} [startTime] CUserMessage_Diagnostic_Response startTime
         * @property {number|null} [osversion] CUserMessage_Diagnostic_Response osversion
         * @property {number|null} [platform] CUserMessage_Diagnostic_Response platform
         */
    
        /**
         * Constructs a new CUserMessage_Diagnostic_Response.
         * @exports CUserMessage_Diagnostic_Response
         * @classdesc Represents a CUserMessage_Diagnostic_Response.
         * @implements ICUserMessage_Diagnostic_Response
         * @constructor
         * @param {ICUserMessage_Diagnostic_Response=} [properties] Properties to set
         */
        function CUserMessage_Diagnostic_Response(properties) {
            this.diagnostics = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CUserMessage_Diagnostic_Response diagnostics.
         * @member {Array.<CUserMessage_Diagnostic_Response.IDiagnostic>} diagnostics
         * @memberof CUserMessage_Diagnostic_Response
         * @instance
         */
        CUserMessage_Diagnostic_Response.prototype.diagnostics = $util.emptyArray;
    
        /**
         * CUserMessage_Diagnostic_Response buildVersion.
         * @member {number} buildVersion
         * @memberof CUserMessage_Diagnostic_Response
         * @instance
         */
        CUserMessage_Diagnostic_Response.prototype.buildVersion = 0;
    
        /**
         * CUserMessage_Diagnostic_Response instance.
         * @member {number} instance
         * @memberof CUserMessage_Diagnostic_Response
         * @instance
         */
        CUserMessage_Diagnostic_Response.prototype.instance = 0;
    
        /**
         * CUserMessage_Diagnostic_Response startTime.
         * @member {number|Long} startTime
         * @memberof CUserMessage_Diagnostic_Response
         * @instance
         */
        CUserMessage_Diagnostic_Response.prototype.startTime = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
        /**
         * CUserMessage_Diagnostic_Response osversion.
         * @member {number} osversion
         * @memberof CUserMessage_Diagnostic_Response
         * @instance
         */
        CUserMessage_Diagnostic_Response.prototype.osversion = 0;
    
        /**
         * CUserMessage_Diagnostic_Response platform.
         * @member {number} platform
         * @memberof CUserMessage_Diagnostic_Response
         * @instance
         */
        CUserMessage_Diagnostic_Response.prototype.platform = 0;
    
        /**
         * Creates a new CUserMessage_Diagnostic_Response instance using the specified properties.
         * @function create
         * @memberof CUserMessage_Diagnostic_Response
         * @static
         * @param {ICUserMessage_Diagnostic_Response=} [properties] Properties to set
         * @returns {CUserMessage_Diagnostic_Response} CUserMessage_Diagnostic_Response instance
         */
        CUserMessage_Diagnostic_Response.create = function create(properties) {
            return new CUserMessage_Diagnostic_Response(properties);
        };
    
        /**
         * Encodes the specified CUserMessage_Diagnostic_Response message. Does not implicitly {@link CUserMessage_Diagnostic_Response.verify|verify} messages.
         * @function encode
         * @memberof CUserMessage_Diagnostic_Response
         * @static
         * @param {ICUserMessage_Diagnostic_Response} message CUserMessage_Diagnostic_Response message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CUserMessage_Diagnostic_Response.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.diagnostics != null && message.diagnostics.length)
                for (var i = 0; i < message.diagnostics.length; ++i)
                    $root.CUserMessage_Diagnostic_Response.Diagnostic.encode(message.diagnostics[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.buildVersion != null && Object.hasOwnProperty.call(message, "buildVersion"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.buildVersion);
            if (message.instance != null && Object.hasOwnProperty.call(message, "instance"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.instance);
            if (message.startTime != null && Object.hasOwnProperty.call(message, "startTime"))
                writer.uint32(/* id 4, wireType 0 =*/32).int64(message.startTime);
            if (message.osversion != null && Object.hasOwnProperty.call(message, "osversion"))
                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.osversion);
            if (message.platform != null && Object.hasOwnProperty.call(message, "platform"))
                writer.uint32(/* id 6, wireType 0 =*/48).int32(message.platform);
            return writer;
        };
    
        /**
         * Encodes the specified CUserMessage_Diagnostic_Response message, length delimited. Does not implicitly {@link CUserMessage_Diagnostic_Response.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CUserMessage_Diagnostic_Response
         * @static
         * @param {ICUserMessage_Diagnostic_Response} message CUserMessage_Diagnostic_Response message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CUserMessage_Diagnostic_Response.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CUserMessage_Diagnostic_Response message from the specified reader or buffer.
         * @function decode
         * @memberof CUserMessage_Diagnostic_Response
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CUserMessage_Diagnostic_Response} CUserMessage_Diagnostic_Response
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CUserMessage_Diagnostic_Response.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CUserMessage_Diagnostic_Response();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        if (!(message.diagnostics && message.diagnostics.length))
                            message.diagnostics = [];
                        message.diagnostics.push($root.CUserMessage_Diagnostic_Response.Diagnostic.decode(reader, reader.uint32()));
                        break;
                    }
                case 2: {
                        message.buildVersion = reader.int32();
                        break;
                    }
                case 3: {
                        message.instance = reader.int32();
                        break;
                    }
                case 4: {
                        message.startTime = reader.int64();
                        break;
                    }
                case 5: {
                        message.osversion = reader.int32();
                        break;
                    }
                case 6: {
                        message.platform = reader.int32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CUserMessage_Diagnostic_Response message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CUserMessage_Diagnostic_Response
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CUserMessage_Diagnostic_Response} CUserMessage_Diagnostic_Response
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CUserMessage_Diagnostic_Response.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CUserMessage_Diagnostic_Response message.
         * @function verify
         * @memberof CUserMessage_Diagnostic_Response
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CUserMessage_Diagnostic_Response.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.diagnostics != null && message.hasOwnProperty("diagnostics")) {
                if (!Array.isArray(message.diagnostics))
                    return "diagnostics: array expected";
                for (var i = 0; i < message.diagnostics.length; ++i) {
                    var error = $root.CUserMessage_Diagnostic_Response.Diagnostic.verify(message.diagnostics[i]);
                    if (error)
                        return "diagnostics." + error;
                }
            }
            if (message.buildVersion != null && message.hasOwnProperty("buildVersion"))
                if (!$util.isInteger(message.buildVersion))
                    return "buildVersion: integer expected";
            if (message.instance != null && message.hasOwnProperty("instance"))
                if (!$util.isInteger(message.instance))
                    return "instance: integer expected";
            if (message.startTime != null && message.hasOwnProperty("startTime"))
                if (!$util.isInteger(message.startTime) && !(message.startTime && $util.isInteger(message.startTime.low) && $util.isInteger(message.startTime.high)))
                    return "startTime: integer|Long expected";
            if (message.osversion != null && message.hasOwnProperty("osversion"))
                if (!$util.isInteger(message.osversion))
                    return "osversion: integer expected";
            if (message.platform != null && message.hasOwnProperty("platform"))
                if (!$util.isInteger(message.platform))
                    return "platform: integer expected";
            return null;
        };
    
        /**
         * Creates a CUserMessage_Diagnostic_Response message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CUserMessage_Diagnostic_Response
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CUserMessage_Diagnostic_Response} CUserMessage_Diagnostic_Response
         */
        CUserMessage_Diagnostic_Response.fromObject = function fromObject(object) {
            if (object instanceof $root.CUserMessage_Diagnostic_Response)
                return object;
            var message = new $root.CUserMessage_Diagnostic_Response();
            if (object.diagnostics) {
                if (!Array.isArray(object.diagnostics))
                    throw TypeError(".CUserMessage_Diagnostic_Response.diagnostics: array expected");
                message.diagnostics = [];
                for (var i = 0; i < object.diagnostics.length; ++i) {
                    if (typeof object.diagnostics[i] !== "object")
                        throw TypeError(".CUserMessage_Diagnostic_Response.diagnostics: object expected");
                    message.diagnostics[i] = $root.CUserMessage_Diagnostic_Response.Diagnostic.fromObject(object.diagnostics[i]);
                }
            }
            if (object.buildVersion != null)
                message.buildVersion = object.buildVersion | 0;
            if (object.instance != null)
                message.instance = object.instance | 0;
            if (object.startTime != null)
                if ($util.Long)
                    (message.startTime = $util.Long.fromValue(object.startTime)).unsigned = false;
                else if (typeof object.startTime === "string")
                    message.startTime = parseInt(object.startTime, 10);
                else if (typeof object.startTime === "number")
                    message.startTime = object.startTime;
                else if (typeof object.startTime === "object")
                    message.startTime = new $util.LongBits(object.startTime.low >>> 0, object.startTime.high >>> 0).toNumber();
            if (object.osversion != null)
                message.osversion = object.osversion | 0;
            if (object.platform != null)
                message.platform = object.platform | 0;
            return message;
        };
    
        /**
         * Creates a plain object from a CUserMessage_Diagnostic_Response message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CUserMessage_Diagnostic_Response
         * @static
         * @param {CUserMessage_Diagnostic_Response} message CUserMessage_Diagnostic_Response
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CUserMessage_Diagnostic_Response.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.diagnostics = [];
            if (options.defaults) {
                object.buildVersion = 0;
                object.instance = 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.startTime = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.startTime = options.longs === String ? "0" : 0;
                object.osversion = 0;
                object.platform = 0;
            }
            if (message.diagnostics && message.diagnostics.length) {
                object.diagnostics = [];
                for (var j = 0; j < message.diagnostics.length; ++j)
                    object.diagnostics[j] = $root.CUserMessage_Diagnostic_Response.Diagnostic.toObject(message.diagnostics[j], options);
            }
            if (message.buildVersion != null && message.hasOwnProperty("buildVersion"))
                object.buildVersion = message.buildVersion;
            if (message.instance != null && message.hasOwnProperty("instance"))
                object.instance = message.instance;
            if (message.startTime != null && message.hasOwnProperty("startTime"))
                if (typeof message.startTime === "number")
                    object.startTime = options.longs === String ? String(message.startTime) : message.startTime;
                else
                    object.startTime = options.longs === String ? $util.Long.prototype.toString.call(message.startTime) : options.longs === Number ? new $util.LongBits(message.startTime.low >>> 0, message.startTime.high >>> 0).toNumber() : message.startTime;
            if (message.osversion != null && message.hasOwnProperty("osversion"))
                object.osversion = message.osversion;
            if (message.platform != null && message.hasOwnProperty("platform"))
                object.platform = message.platform;
            return object;
        };
    
        /**
         * Converts this CUserMessage_Diagnostic_Response to JSON.
         * @function toJSON
         * @memberof CUserMessage_Diagnostic_Response
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CUserMessage_Diagnostic_Response.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * Gets the default type url for CUserMessage_Diagnostic_Response
         * @function getTypeUrl
         * @memberof CUserMessage_Diagnostic_Response
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        CUserMessage_Diagnostic_Response.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/CUserMessage_Diagnostic_Response";
        };
    
        CUserMessage_Diagnostic_Response.Diagnostic = (function() {
    
            /**
             * Properties of a Diagnostic.
             * @memberof CUserMessage_Diagnostic_Response
             * @interface IDiagnostic
             * @property {number|null} [index] Diagnostic index
             * @property {number|Long|null} [offset] Diagnostic offset
             * @property {number|null} [param] Diagnostic param
             * @property {number|null} [length] Diagnostic length
             * @property {Uint8Array|null} [detail] Diagnostic detail
             * @property {number|Long|null} [base] Diagnostic base
             * @property {number|Long|null} [range] Diagnostic range
             * @property {number|null} [type] Diagnostic type
             * @property {string|null} [name] Diagnostic name
             * @property {string|null} [alias] Diagnostic alias
             * @property {Uint8Array|null} [backup] Diagnostic backup
             * @property {number|null} [context] Diagnostic context
             * @property {number|Long|null} [control] Diagnostic control
             * @property {number|Long|null} [augment] Diagnostic augment
             * @property {number|Long|null} [placebo] Diagnostic placebo
             */
    
            /**
             * Constructs a new Diagnostic.
             * @memberof CUserMessage_Diagnostic_Response
             * @classdesc Represents a Diagnostic.
             * @implements IDiagnostic
             * @constructor
             * @param {CUserMessage_Diagnostic_Response.IDiagnostic=} [properties] Properties to set
             */
            function Diagnostic(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * Diagnostic index.
             * @member {number} index
             * @memberof CUserMessage_Diagnostic_Response.Diagnostic
             * @instance
             */
            Diagnostic.prototype.index = 0;
    
            /**
             * Diagnostic offset.
             * @member {number|Long} offset
             * @memberof CUserMessage_Diagnostic_Response.Diagnostic
             * @instance
             */
            Diagnostic.prototype.offset = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
            /**
             * Diagnostic param.
             * @member {number} param
             * @memberof CUserMessage_Diagnostic_Response.Diagnostic
             * @instance
             */
            Diagnostic.prototype.param = 0;
    
            /**
             * Diagnostic length.
             * @member {number} length
             * @memberof CUserMessage_Diagnostic_Response.Diagnostic
             * @instance
             */
            Diagnostic.prototype.length = 0;
    
            /**
             * Diagnostic detail.
             * @member {Uint8Array} detail
             * @memberof CUserMessage_Diagnostic_Response.Diagnostic
             * @instance
             */
            Diagnostic.prototype.detail = $util.newBuffer([]);
    
            /**
             * Diagnostic base.
             * @member {number|Long} base
             * @memberof CUserMessage_Diagnostic_Response.Diagnostic
             * @instance
             */
            Diagnostic.prototype.base = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
            /**
             * Diagnostic range.
             * @member {number|Long} range
             * @memberof CUserMessage_Diagnostic_Response.Diagnostic
             * @instance
             */
            Diagnostic.prototype.range = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
            /**
             * Diagnostic type.
             * @member {number} type
             * @memberof CUserMessage_Diagnostic_Response.Diagnostic
             * @instance
             */
            Diagnostic.prototype.type = 0;
    
            /**
             * Diagnostic name.
             * @member {string} name
             * @memberof CUserMessage_Diagnostic_Response.Diagnostic
             * @instance
             */
            Diagnostic.prototype.name = "";
    
            /**
             * Diagnostic alias.
             * @member {string} alias
             * @memberof CUserMessage_Diagnostic_Response.Diagnostic
             * @instance
             */
            Diagnostic.prototype.alias = "";
    
            /**
             * Diagnostic backup.
             * @member {Uint8Array} backup
             * @memberof CUserMessage_Diagnostic_Response.Diagnostic
             * @instance
             */
            Diagnostic.prototype.backup = $util.newBuffer([]);
    
            /**
             * Diagnostic context.
             * @member {number} context
             * @memberof CUserMessage_Diagnostic_Response.Diagnostic
             * @instance
             */
            Diagnostic.prototype.context = 0;
    
            /**
             * Diagnostic control.
             * @member {number|Long} control
             * @memberof CUserMessage_Diagnostic_Response.Diagnostic
             * @instance
             */
            Diagnostic.prototype.control = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
            /**
             * Diagnostic augment.
             * @member {number|Long} augment
             * @memberof CUserMessage_Diagnostic_Response.Diagnostic
             * @instance
             */
            Diagnostic.prototype.augment = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
            /**
             * Diagnostic placebo.
             * @member {number|Long} placebo
             * @memberof CUserMessage_Diagnostic_Response.Diagnostic
             * @instance
             */
            Diagnostic.prototype.placebo = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
            /**
             * Creates a new Diagnostic instance using the specified properties.
             * @function create
             * @memberof CUserMessage_Diagnostic_Response.Diagnostic
             * @static
             * @param {CUserMessage_Diagnostic_Response.IDiagnostic=} [properties] Properties to set
             * @returns {CUserMessage_Diagnostic_Response.Diagnostic} Diagnostic instance
             */
            Diagnostic.create = function create(properties) {
                return new Diagnostic(properties);
            };
    
            /**
             * Encodes the specified Diagnostic message. Does not implicitly {@link CUserMessage_Diagnostic_Response.Diagnostic.verify|verify} messages.
             * @function encode
             * @memberof CUserMessage_Diagnostic_Response.Diagnostic
             * @static
             * @param {CUserMessage_Diagnostic_Response.IDiagnostic} message Diagnostic message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Diagnostic.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.index != null && Object.hasOwnProperty.call(message, "index"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.index);
                if (message.offset != null && Object.hasOwnProperty.call(message, "offset"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int64(message.offset);
                if (message.param != null && Object.hasOwnProperty.call(message, "param"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int32(message.param);
                if (message.length != null && Object.hasOwnProperty.call(message, "length"))
                    writer.uint32(/* id 4, wireType 0 =*/32).int32(message.length);
                if (message.detail != null && Object.hasOwnProperty.call(message, "detail"))
                    writer.uint32(/* id 5, wireType 2 =*/42).bytes(message.detail);
                if (message.base != null && Object.hasOwnProperty.call(message, "base"))
                    writer.uint32(/* id 6, wireType 0 =*/48).int64(message.base);
                if (message.range != null && Object.hasOwnProperty.call(message, "range"))
                    writer.uint32(/* id 7, wireType 0 =*/56).int64(message.range);
                if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                    writer.uint32(/* id 8, wireType 0 =*/64).int32(message.type);
                if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                    writer.uint32(/* id 10, wireType 2 =*/82).string(message.name);
                if (message.alias != null && Object.hasOwnProperty.call(message, "alias"))
                    writer.uint32(/* id 11, wireType 2 =*/90).string(message.alias);
                if (message.backup != null && Object.hasOwnProperty.call(message, "backup"))
                    writer.uint32(/* id 12, wireType 2 =*/98).bytes(message.backup);
                if (message.context != null && Object.hasOwnProperty.call(message, "context"))
                    writer.uint32(/* id 13, wireType 0 =*/104).int32(message.context);
                if (message.control != null && Object.hasOwnProperty.call(message, "control"))
                    writer.uint32(/* id 14, wireType 0 =*/112).int64(message.control);
                if (message.augment != null && Object.hasOwnProperty.call(message, "augment"))
                    writer.uint32(/* id 15, wireType 0 =*/120).int64(message.augment);
                if (message.placebo != null && Object.hasOwnProperty.call(message, "placebo"))
                    writer.uint32(/* id 16, wireType 0 =*/128).int64(message.placebo);
                return writer;
            };
    
            /**
             * Encodes the specified Diagnostic message, length delimited. Does not implicitly {@link CUserMessage_Diagnostic_Response.Diagnostic.verify|verify} messages.
             * @function encodeDelimited
             * @memberof CUserMessage_Diagnostic_Response.Diagnostic
             * @static
             * @param {CUserMessage_Diagnostic_Response.IDiagnostic} message Diagnostic message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Diagnostic.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a Diagnostic message from the specified reader or buffer.
             * @function decode
             * @memberof CUserMessage_Diagnostic_Response.Diagnostic
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {CUserMessage_Diagnostic_Response.Diagnostic} Diagnostic
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Diagnostic.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CUserMessage_Diagnostic_Response.Diagnostic();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.index = reader.int32();
                            break;
                        }
                    case 2: {
                            message.offset = reader.int64();
                            break;
                        }
                    case 3: {
                            message.param = reader.int32();
                            break;
                        }
                    case 4: {
                            message.length = reader.int32();
                            break;
                        }
                    case 5: {
                            message.detail = reader.bytes();
                            break;
                        }
                    case 6: {
                            message.base = reader.int64();
                            break;
                        }
                    case 7: {
                            message.range = reader.int64();
                            break;
                        }
                    case 8: {
                            message.type = reader.int32();
                            break;
                        }
                    case 10: {
                            message.name = reader.string();
                            break;
                        }
                    case 11: {
                            message.alias = reader.string();
                            break;
                        }
                    case 12: {
                            message.backup = reader.bytes();
                            break;
                        }
                    case 13: {
                            message.context = reader.int32();
                            break;
                        }
                    case 14: {
                            message.control = reader.int64();
                            break;
                        }
                    case 15: {
                            message.augment = reader.int64();
                            break;
                        }
                    case 16: {
                            message.placebo = reader.int64();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a Diagnostic message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof CUserMessage_Diagnostic_Response.Diagnostic
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {CUserMessage_Diagnostic_Response.Diagnostic} Diagnostic
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Diagnostic.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a Diagnostic message.
             * @function verify
             * @memberof CUserMessage_Diagnostic_Response.Diagnostic
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Diagnostic.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.index != null && message.hasOwnProperty("index"))
                    if (!$util.isInteger(message.index))
                        return "index: integer expected";
                if (message.offset != null && message.hasOwnProperty("offset"))
                    if (!$util.isInteger(message.offset) && !(message.offset && $util.isInteger(message.offset.low) && $util.isInteger(message.offset.high)))
                        return "offset: integer|Long expected";
                if (message.param != null && message.hasOwnProperty("param"))
                    if (!$util.isInteger(message.param))
                        return "param: integer expected";
                if (message.length != null && message.hasOwnProperty("length"))
                    if (!$util.isInteger(message.length))
                        return "length: integer expected";
                if (message.detail != null && message.hasOwnProperty("detail"))
                    if (!(message.detail && typeof message.detail.length === "number" || $util.isString(message.detail)))
                        return "detail: buffer expected";
                if (message.base != null && message.hasOwnProperty("base"))
                    if (!$util.isInteger(message.base) && !(message.base && $util.isInteger(message.base.low) && $util.isInteger(message.base.high)))
                        return "base: integer|Long expected";
                if (message.range != null && message.hasOwnProperty("range"))
                    if (!$util.isInteger(message.range) && !(message.range && $util.isInteger(message.range.low) && $util.isInteger(message.range.high)))
                        return "range: integer|Long expected";
                if (message.type != null && message.hasOwnProperty("type"))
                    if (!$util.isInteger(message.type))
                        return "type: integer expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                if (message.alias != null && message.hasOwnProperty("alias"))
                    if (!$util.isString(message.alias))
                        return "alias: string expected";
                if (message.backup != null && message.hasOwnProperty("backup"))
                    if (!(message.backup && typeof message.backup.length === "number" || $util.isString(message.backup)))
                        return "backup: buffer expected";
                if (message.context != null && message.hasOwnProperty("context"))
                    if (!$util.isInteger(message.context))
                        return "context: integer expected";
                if (message.control != null && message.hasOwnProperty("control"))
                    if (!$util.isInteger(message.control) && !(message.control && $util.isInteger(message.control.low) && $util.isInteger(message.control.high)))
                        return "control: integer|Long expected";
                if (message.augment != null && message.hasOwnProperty("augment"))
                    if (!$util.isInteger(message.augment) && !(message.augment && $util.isInteger(message.augment.low) && $util.isInteger(message.augment.high)))
                        return "augment: integer|Long expected";
                if (message.placebo != null && message.hasOwnProperty("placebo"))
                    if (!$util.isInteger(message.placebo) && !(message.placebo && $util.isInteger(message.placebo.low) && $util.isInteger(message.placebo.high)))
                        return "placebo: integer|Long expected";
                return null;
            };
    
            /**
             * Creates a Diagnostic message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof CUserMessage_Diagnostic_Response.Diagnostic
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {CUserMessage_Diagnostic_Response.Diagnostic} Diagnostic
             */
            Diagnostic.fromObject = function fromObject(object) {
                if (object instanceof $root.CUserMessage_Diagnostic_Response.Diagnostic)
                    return object;
                var message = new $root.CUserMessage_Diagnostic_Response.Diagnostic();
                if (object.index != null)
                    message.index = object.index | 0;
                if (object.offset != null)
                    if ($util.Long)
                        (message.offset = $util.Long.fromValue(object.offset)).unsigned = false;
                    else if (typeof object.offset === "string")
                        message.offset = parseInt(object.offset, 10);
                    else if (typeof object.offset === "number")
                        message.offset = object.offset;
                    else if (typeof object.offset === "object")
                        message.offset = new $util.LongBits(object.offset.low >>> 0, object.offset.high >>> 0).toNumber();
                if (object.param != null)
                    message.param = object.param | 0;
                if (object.length != null)
                    message.length = object.length | 0;
                if (object.detail != null)
                    if (typeof object.detail === "string")
                        $util.base64.decode(object.detail, message.detail = $util.newBuffer($util.base64.length(object.detail)), 0);
                    else if (object.detail.length >= 0)
                        message.detail = object.detail;
                if (object.base != null)
                    if ($util.Long)
                        (message.base = $util.Long.fromValue(object.base)).unsigned = false;
                    else if (typeof object.base === "string")
                        message.base = parseInt(object.base, 10);
                    else if (typeof object.base === "number")
                        message.base = object.base;
                    else if (typeof object.base === "object")
                        message.base = new $util.LongBits(object.base.low >>> 0, object.base.high >>> 0).toNumber();
                if (object.range != null)
                    if ($util.Long)
                        (message.range = $util.Long.fromValue(object.range)).unsigned = false;
                    else if (typeof object.range === "string")
                        message.range = parseInt(object.range, 10);
                    else if (typeof object.range === "number")
                        message.range = object.range;
                    else if (typeof object.range === "object")
                        message.range = new $util.LongBits(object.range.low >>> 0, object.range.high >>> 0).toNumber();
                if (object.type != null)
                    message.type = object.type | 0;
                if (object.name != null)
                    message.name = String(object.name);
                if (object.alias != null)
                    message.alias = String(object.alias);
                if (object.backup != null)
                    if (typeof object.backup === "string")
                        $util.base64.decode(object.backup, message.backup = $util.newBuffer($util.base64.length(object.backup)), 0);
                    else if (object.backup.length >= 0)
                        message.backup = object.backup;
                if (object.context != null)
                    message.context = object.context | 0;
                if (object.control != null)
                    if ($util.Long)
                        (message.control = $util.Long.fromValue(object.control)).unsigned = false;
                    else if (typeof object.control === "string")
                        message.control = parseInt(object.control, 10);
                    else if (typeof object.control === "number")
                        message.control = object.control;
                    else if (typeof object.control === "object")
                        message.control = new $util.LongBits(object.control.low >>> 0, object.control.high >>> 0).toNumber();
                if (object.augment != null)
                    if ($util.Long)
                        (message.augment = $util.Long.fromValue(object.augment)).unsigned = false;
                    else if (typeof object.augment === "string")
                        message.augment = parseInt(object.augment, 10);
                    else if (typeof object.augment === "number")
                        message.augment = object.augment;
                    else if (typeof object.augment === "object")
                        message.augment = new $util.LongBits(object.augment.low >>> 0, object.augment.high >>> 0).toNumber();
                if (object.placebo != null)
                    if ($util.Long)
                        (message.placebo = $util.Long.fromValue(object.placebo)).unsigned = false;
                    else if (typeof object.placebo === "string")
                        message.placebo = parseInt(object.placebo, 10);
                    else if (typeof object.placebo === "number")
                        message.placebo = object.placebo;
                    else if (typeof object.placebo === "object")
                        message.placebo = new $util.LongBits(object.placebo.low >>> 0, object.placebo.high >>> 0).toNumber();
                return message;
            };
    
            /**
             * Creates a plain object from a Diagnostic message. Also converts values to other types if specified.
             * @function toObject
             * @memberof CUserMessage_Diagnostic_Response.Diagnostic
             * @static
             * @param {CUserMessage_Diagnostic_Response.Diagnostic} message Diagnostic
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Diagnostic.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.index = 0;
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.offset = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.offset = options.longs === String ? "0" : 0;
                    object.param = 0;
                    object.length = 0;
                    if (options.bytes === String)
                        object.detail = "";
                    else {
                        object.detail = [];
                        if (options.bytes !== Array)
                            object.detail = $util.newBuffer(object.detail);
                    }
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.base = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.base = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.range = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.range = options.longs === String ? "0" : 0;
                    object.type = 0;
                    object.name = "";
                    object.alias = "";
                    if (options.bytes === String)
                        object.backup = "";
                    else {
                        object.backup = [];
                        if (options.bytes !== Array)
                            object.backup = $util.newBuffer(object.backup);
                    }
                    object.context = 0;
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.control = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.control = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.augment = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.augment = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.placebo = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.placebo = options.longs === String ? "0" : 0;
                }
                if (message.index != null && message.hasOwnProperty("index"))
                    object.index = message.index;
                if (message.offset != null && message.hasOwnProperty("offset"))
                    if (typeof message.offset === "number")
                        object.offset = options.longs === String ? String(message.offset) : message.offset;
                    else
                        object.offset = options.longs === String ? $util.Long.prototype.toString.call(message.offset) : options.longs === Number ? new $util.LongBits(message.offset.low >>> 0, message.offset.high >>> 0).toNumber() : message.offset;
                if (message.param != null && message.hasOwnProperty("param"))
                    object.param = message.param;
                if (message.length != null && message.hasOwnProperty("length"))
                    object.length = message.length;
                if (message.detail != null && message.hasOwnProperty("detail"))
                    object.detail = options.bytes === String ? $util.base64.encode(message.detail, 0, message.detail.length) : options.bytes === Array ? Array.prototype.slice.call(message.detail) : message.detail;
                if (message.base != null && message.hasOwnProperty("base"))
                    if (typeof message.base === "number")
                        object.base = options.longs === String ? String(message.base) : message.base;
                    else
                        object.base = options.longs === String ? $util.Long.prototype.toString.call(message.base) : options.longs === Number ? new $util.LongBits(message.base.low >>> 0, message.base.high >>> 0).toNumber() : message.base;
                if (message.range != null && message.hasOwnProperty("range"))
                    if (typeof message.range === "number")
                        object.range = options.longs === String ? String(message.range) : message.range;
                    else
                        object.range = options.longs === String ? $util.Long.prototype.toString.call(message.range) : options.longs === Number ? new $util.LongBits(message.range.low >>> 0, message.range.high >>> 0).toNumber() : message.range;
                if (message.type != null && message.hasOwnProperty("type"))
                    object.type = message.type;
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                if (message.alias != null && message.hasOwnProperty("alias"))
                    object.alias = message.alias;
                if (message.backup != null && message.hasOwnProperty("backup"))
                    object.backup = options.bytes === String ? $util.base64.encode(message.backup, 0, message.backup.length) : options.bytes === Array ? Array.prototype.slice.call(message.backup) : message.backup;
                if (message.context != null && message.hasOwnProperty("context"))
                    object.context = message.context;
                if (message.control != null && message.hasOwnProperty("control"))
                    if (typeof message.control === "number")
                        object.control = options.longs === String ? String(message.control) : message.control;
                    else
                        object.control = options.longs === String ? $util.Long.prototype.toString.call(message.control) : options.longs === Number ? new $util.LongBits(message.control.low >>> 0, message.control.high >>> 0).toNumber() : message.control;
                if (message.augment != null && message.hasOwnProperty("augment"))
                    if (typeof message.augment === "number")
                        object.augment = options.longs === String ? String(message.augment) : message.augment;
                    else
                        object.augment = options.longs === String ? $util.Long.prototype.toString.call(message.augment) : options.longs === Number ? new $util.LongBits(message.augment.low >>> 0, message.augment.high >>> 0).toNumber() : message.augment;
                if (message.placebo != null && message.hasOwnProperty("placebo"))
                    if (typeof message.placebo === "number")
                        object.placebo = options.longs === String ? String(message.placebo) : message.placebo;
                    else
                        object.placebo = options.longs === String ? $util.Long.prototype.toString.call(message.placebo) : options.longs === Number ? new $util.LongBits(message.placebo.low >>> 0, message.placebo.high >>> 0).toNumber() : message.placebo;
                return object;
            };
    
            /**
             * Converts this Diagnostic to JSON.
             * @function toJSON
             * @memberof CUserMessage_Diagnostic_Response.Diagnostic
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Diagnostic.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            /**
             * Gets the default type url for Diagnostic
             * @function getTypeUrl
             * @memberof CUserMessage_Diagnostic_Response.Diagnostic
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            Diagnostic.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/CUserMessage_Diagnostic_Response.Diagnostic";
            };
    
            return Diagnostic;
        })();
    
        return CUserMessage_Diagnostic_Response;
    })();
    
    $root.CUserMessage_ExtraUserData = (function() {
    
        /**
         * Properties of a CUserMessage_ExtraUserData.
         * @exports ICUserMessage_ExtraUserData
         * @interface ICUserMessage_ExtraUserData
         * @property {number|null} [item] CUserMessage_ExtraUserData item
         * @property {number|Long|null} [value1] CUserMessage_ExtraUserData value1
         * @property {number|Long|null} [value2] CUserMessage_ExtraUserData value2
         * @property {Array.<Uint8Array>|null} [detail1] CUserMessage_ExtraUserData detail1
         * @property {Array.<Uint8Array>|null} [detail2] CUserMessage_ExtraUserData detail2
         */
    
        /**
         * Constructs a new CUserMessage_ExtraUserData.
         * @exports CUserMessage_ExtraUserData
         * @classdesc Represents a CUserMessage_ExtraUserData.
         * @implements ICUserMessage_ExtraUserData
         * @constructor
         * @param {ICUserMessage_ExtraUserData=} [properties] Properties to set
         */
        function CUserMessage_ExtraUserData(properties) {
            this.detail1 = [];
            this.detail2 = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CUserMessage_ExtraUserData item.
         * @member {number} item
         * @memberof CUserMessage_ExtraUserData
         * @instance
         */
        CUserMessage_ExtraUserData.prototype.item = 0;
    
        /**
         * CUserMessage_ExtraUserData value1.
         * @member {number|Long} value1
         * @memberof CUserMessage_ExtraUserData
         * @instance
         */
        CUserMessage_ExtraUserData.prototype.value1 = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
        /**
         * CUserMessage_ExtraUserData value2.
         * @member {number|Long} value2
         * @memberof CUserMessage_ExtraUserData
         * @instance
         */
        CUserMessage_ExtraUserData.prototype.value2 = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
        /**
         * CUserMessage_ExtraUserData detail1.
         * @member {Array.<Uint8Array>} detail1
         * @memberof CUserMessage_ExtraUserData
         * @instance
         */
        CUserMessage_ExtraUserData.prototype.detail1 = $util.emptyArray;
    
        /**
         * CUserMessage_ExtraUserData detail2.
         * @member {Array.<Uint8Array>} detail2
         * @memberof CUserMessage_ExtraUserData
         * @instance
         */
        CUserMessage_ExtraUserData.prototype.detail2 = $util.emptyArray;
    
        /**
         * Creates a new CUserMessage_ExtraUserData instance using the specified properties.
         * @function create
         * @memberof CUserMessage_ExtraUserData
         * @static
         * @param {ICUserMessage_ExtraUserData=} [properties] Properties to set
         * @returns {CUserMessage_ExtraUserData} CUserMessage_ExtraUserData instance
         */
        CUserMessage_ExtraUserData.create = function create(properties) {
            return new CUserMessage_ExtraUserData(properties);
        };
    
        /**
         * Encodes the specified CUserMessage_ExtraUserData message. Does not implicitly {@link CUserMessage_ExtraUserData.verify|verify} messages.
         * @function encode
         * @memberof CUserMessage_ExtraUserData
         * @static
         * @param {ICUserMessage_ExtraUserData} message CUserMessage_ExtraUserData message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CUserMessage_ExtraUserData.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.item != null && Object.hasOwnProperty.call(message, "item"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.item);
            if (message.value1 != null && Object.hasOwnProperty.call(message, "value1"))
                writer.uint32(/* id 2, wireType 0 =*/16).int64(message.value1);
            if (message.value2 != null && Object.hasOwnProperty.call(message, "value2"))
                writer.uint32(/* id 3, wireType 0 =*/24).int64(message.value2);
            if (message.detail1 != null && message.detail1.length)
                for (var i = 0; i < message.detail1.length; ++i)
                    writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.detail1[i]);
            if (message.detail2 != null && message.detail2.length)
                for (var i = 0; i < message.detail2.length; ++i)
                    writer.uint32(/* id 5, wireType 2 =*/42).bytes(message.detail2[i]);
            return writer;
        };
    
        /**
         * Encodes the specified CUserMessage_ExtraUserData message, length delimited. Does not implicitly {@link CUserMessage_ExtraUserData.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CUserMessage_ExtraUserData
         * @static
         * @param {ICUserMessage_ExtraUserData} message CUserMessage_ExtraUserData message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CUserMessage_ExtraUserData.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CUserMessage_ExtraUserData message from the specified reader or buffer.
         * @function decode
         * @memberof CUserMessage_ExtraUserData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CUserMessage_ExtraUserData} CUserMessage_ExtraUserData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CUserMessage_ExtraUserData.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CUserMessage_ExtraUserData();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.item = reader.int32();
                        break;
                    }
                case 2: {
                        message.value1 = reader.int64();
                        break;
                    }
                case 3: {
                        message.value2 = reader.int64();
                        break;
                    }
                case 4: {
                        if (!(message.detail1 && message.detail1.length))
                            message.detail1 = [];
                        message.detail1.push(reader.bytes());
                        break;
                    }
                case 5: {
                        if (!(message.detail2 && message.detail2.length))
                            message.detail2 = [];
                        message.detail2.push(reader.bytes());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CUserMessage_ExtraUserData message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CUserMessage_ExtraUserData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CUserMessage_ExtraUserData} CUserMessage_ExtraUserData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CUserMessage_ExtraUserData.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CUserMessage_ExtraUserData message.
         * @function verify
         * @memberof CUserMessage_ExtraUserData
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CUserMessage_ExtraUserData.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.item != null && message.hasOwnProperty("item"))
                if (!$util.isInteger(message.item))
                    return "item: integer expected";
            if (message.value1 != null && message.hasOwnProperty("value1"))
                if (!$util.isInteger(message.value1) && !(message.value1 && $util.isInteger(message.value1.low) && $util.isInteger(message.value1.high)))
                    return "value1: integer|Long expected";
            if (message.value2 != null && message.hasOwnProperty("value2"))
                if (!$util.isInteger(message.value2) && !(message.value2 && $util.isInteger(message.value2.low) && $util.isInteger(message.value2.high)))
                    return "value2: integer|Long expected";
            if (message.detail1 != null && message.hasOwnProperty("detail1")) {
                if (!Array.isArray(message.detail1))
                    return "detail1: array expected";
                for (var i = 0; i < message.detail1.length; ++i)
                    if (!(message.detail1[i] && typeof message.detail1[i].length === "number" || $util.isString(message.detail1[i])))
                        return "detail1: buffer[] expected";
            }
            if (message.detail2 != null && message.hasOwnProperty("detail2")) {
                if (!Array.isArray(message.detail2))
                    return "detail2: array expected";
                for (var i = 0; i < message.detail2.length; ++i)
                    if (!(message.detail2[i] && typeof message.detail2[i].length === "number" || $util.isString(message.detail2[i])))
                        return "detail2: buffer[] expected";
            }
            return null;
        };
    
        /**
         * Creates a CUserMessage_ExtraUserData message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CUserMessage_ExtraUserData
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CUserMessage_ExtraUserData} CUserMessage_ExtraUserData
         */
        CUserMessage_ExtraUserData.fromObject = function fromObject(object) {
            if (object instanceof $root.CUserMessage_ExtraUserData)
                return object;
            var message = new $root.CUserMessage_ExtraUserData();
            if (object.item != null)
                message.item = object.item | 0;
            if (object.value1 != null)
                if ($util.Long)
                    (message.value1 = $util.Long.fromValue(object.value1)).unsigned = false;
                else if (typeof object.value1 === "string")
                    message.value1 = parseInt(object.value1, 10);
                else if (typeof object.value1 === "number")
                    message.value1 = object.value1;
                else if (typeof object.value1 === "object")
                    message.value1 = new $util.LongBits(object.value1.low >>> 0, object.value1.high >>> 0).toNumber();
            if (object.value2 != null)
                if ($util.Long)
                    (message.value2 = $util.Long.fromValue(object.value2)).unsigned = false;
                else if (typeof object.value2 === "string")
                    message.value2 = parseInt(object.value2, 10);
                else if (typeof object.value2 === "number")
                    message.value2 = object.value2;
                else if (typeof object.value2 === "object")
                    message.value2 = new $util.LongBits(object.value2.low >>> 0, object.value2.high >>> 0).toNumber();
            if (object.detail1) {
                if (!Array.isArray(object.detail1))
                    throw TypeError(".CUserMessage_ExtraUserData.detail1: array expected");
                message.detail1 = [];
                for (var i = 0; i < object.detail1.length; ++i)
                    if (typeof object.detail1[i] === "string")
                        $util.base64.decode(object.detail1[i], message.detail1[i] = $util.newBuffer($util.base64.length(object.detail1[i])), 0);
                    else if (object.detail1[i].length >= 0)
                        message.detail1[i] = object.detail1[i];
            }
            if (object.detail2) {
                if (!Array.isArray(object.detail2))
                    throw TypeError(".CUserMessage_ExtraUserData.detail2: array expected");
                message.detail2 = [];
                for (var i = 0; i < object.detail2.length; ++i)
                    if (typeof object.detail2[i] === "string")
                        $util.base64.decode(object.detail2[i], message.detail2[i] = $util.newBuffer($util.base64.length(object.detail2[i])), 0);
                    else if (object.detail2[i].length >= 0)
                        message.detail2[i] = object.detail2[i];
            }
            return message;
        };
    
        /**
         * Creates a plain object from a CUserMessage_ExtraUserData message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CUserMessage_ExtraUserData
         * @static
         * @param {CUserMessage_ExtraUserData} message CUserMessage_ExtraUserData
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CUserMessage_ExtraUserData.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults) {
                object.detail1 = [];
                object.detail2 = [];
            }
            if (options.defaults) {
                object.item = 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.value1 = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.value1 = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.value2 = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.value2 = options.longs === String ? "0" : 0;
            }
            if (message.item != null && message.hasOwnProperty("item"))
                object.item = message.item;
            if (message.value1 != null && message.hasOwnProperty("value1"))
                if (typeof message.value1 === "number")
                    object.value1 = options.longs === String ? String(message.value1) : message.value1;
                else
                    object.value1 = options.longs === String ? $util.Long.prototype.toString.call(message.value1) : options.longs === Number ? new $util.LongBits(message.value1.low >>> 0, message.value1.high >>> 0).toNumber() : message.value1;
            if (message.value2 != null && message.hasOwnProperty("value2"))
                if (typeof message.value2 === "number")
                    object.value2 = options.longs === String ? String(message.value2) : message.value2;
                else
                    object.value2 = options.longs === String ? $util.Long.prototype.toString.call(message.value2) : options.longs === Number ? new $util.LongBits(message.value2.low >>> 0, message.value2.high >>> 0).toNumber() : message.value2;
            if (message.detail1 && message.detail1.length) {
                object.detail1 = [];
                for (var j = 0; j < message.detail1.length; ++j)
                    object.detail1[j] = options.bytes === String ? $util.base64.encode(message.detail1[j], 0, message.detail1[j].length) : options.bytes === Array ? Array.prototype.slice.call(message.detail1[j]) : message.detail1[j];
            }
            if (message.detail2 && message.detail2.length) {
                object.detail2 = [];
                for (var j = 0; j < message.detail2.length; ++j)
                    object.detail2[j] = options.bytes === String ? $util.base64.encode(message.detail2[j], 0, message.detail2[j].length) : options.bytes === Array ? Array.prototype.slice.call(message.detail2[j]) : message.detail2[j];
            }
            return object;
        };
    
        /**
         * Converts this CUserMessage_ExtraUserData to JSON.
         * @function toJSON
         * @memberof CUserMessage_ExtraUserData
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CUserMessage_ExtraUserData.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * Gets the default type url for CUserMessage_ExtraUserData
         * @function getTypeUrl
         * @memberof CUserMessage_ExtraUserData
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        CUserMessage_ExtraUserData.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/CUserMessage_ExtraUserData";
        };
    
        return CUserMessage_ExtraUserData;
    })();
    
    /**
     * SignonState_t enum.
     * @exports SignonState_t
     * @enum {number}
     * @property {number} SIGNONSTATE_NONE=0 SIGNONSTATE_NONE value
     * @property {number} SIGNONSTATE_CHALLENGE=1 SIGNONSTATE_CHALLENGE value
     * @property {number} SIGNONSTATE_CONNECTED=2 SIGNONSTATE_CONNECTED value
     * @property {number} SIGNONSTATE_NEW=3 SIGNONSTATE_NEW value
     * @property {number} SIGNONSTATE_PRESPAWN=4 SIGNONSTATE_PRESPAWN value
     * @property {number} SIGNONSTATE_SPAWN=5 SIGNONSTATE_SPAWN value
     * @property {number} SIGNONSTATE_FULL=6 SIGNONSTATE_FULL value
     * @property {number} SIGNONSTATE_CHANGELEVEL=7 SIGNONSTATE_CHANGELEVEL value
     */
    $root.SignonState_t = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "SIGNONSTATE_NONE"] = 0;
        values[valuesById[1] = "SIGNONSTATE_CHALLENGE"] = 1;
        values[valuesById[2] = "SIGNONSTATE_CONNECTED"] = 2;
        values[valuesById[3] = "SIGNONSTATE_NEW"] = 3;
        values[valuesById[4] = "SIGNONSTATE_PRESPAWN"] = 4;
        values[valuesById[5] = "SIGNONSTATE_SPAWN"] = 5;
        values[valuesById[6] = "SIGNONSTATE_FULL"] = 6;
        values[valuesById[7] = "SIGNONSTATE_CHANGELEVEL"] = 7;
        return values;
    })();
    
    /**
     * NET_Messages enum.
     * @exports NET_Messages
     * @enum {number}
     * @property {number} net_NOP=0 net_NOP value
     * @property {number} net_Disconnect=1 net_Disconnect value
     * @property {number} net_SplitScreenUser=3 net_SplitScreenUser value
     * @property {number} net_Tick=4 net_Tick value
     * @property {number} net_StringCmd=5 net_StringCmd value
     * @property {number} net_SetConVar=6 net_SetConVar value
     * @property {number} net_SignonState=7 net_SignonState value
     * @property {number} net_SpawnGroup_Load=8 net_SpawnGroup_Load value
     * @property {number} net_SpawnGroup_ManifestUpdate=9 net_SpawnGroup_ManifestUpdate value
     * @property {number} net_SpawnGroup_SetCreationTick=11 net_SpawnGroup_SetCreationTick value
     * @property {number} net_SpawnGroup_Unload=12 net_SpawnGroup_Unload value
     * @property {number} net_SpawnGroup_LoadCompleted=13 net_SpawnGroup_LoadCompleted value
     * @property {number} net_DebugOverlay=15 net_DebugOverlay value
     */
    $root.NET_Messages = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "net_NOP"] = 0;
        values[valuesById[1] = "net_Disconnect"] = 1;
        values[valuesById[3] = "net_SplitScreenUser"] = 3;
        values[valuesById[4] = "net_Tick"] = 4;
        values[valuesById[5] = "net_StringCmd"] = 5;
        values[valuesById[6] = "net_SetConVar"] = 6;
        values[valuesById[7] = "net_SignonState"] = 7;
        values[valuesById[8] = "net_SpawnGroup_Load"] = 8;
        values[valuesById[9] = "net_SpawnGroup_ManifestUpdate"] = 9;
        values[valuesById[11] = "net_SpawnGroup_SetCreationTick"] = 11;
        values[valuesById[12] = "net_SpawnGroup_Unload"] = 12;
        values[valuesById[13] = "net_SpawnGroup_LoadCompleted"] = 13;
        values[valuesById[15] = "net_DebugOverlay"] = 15;
        return values;
    })();
    
    /**
     * SpawnGroupFlags_t enum.
     * @exports SpawnGroupFlags_t
     * @enum {number}
     * @property {number} SPAWN_GROUP_LOAD_ENTITIES_FROM_SAVE=1 SPAWN_GROUP_LOAD_ENTITIES_FROM_SAVE value
     * @property {number} SPAWN_GROUP_DONT_SPAWN_ENTITIES=2 SPAWN_GROUP_DONT_SPAWN_ENTITIES value
     * @property {number} SPAWN_GROUP_SYNCHRONOUS_SPAWN=4 SPAWN_GROUP_SYNCHRONOUS_SPAWN value
     * @property {number} SPAWN_GROUP_IS_INITIAL_SPAWN_GROUP=8 SPAWN_GROUP_IS_INITIAL_SPAWN_GROUP value
     * @property {number} SPAWN_GROUP_CREATE_CLIENT_ONLY_ENTITIES=16 SPAWN_GROUP_CREATE_CLIENT_ONLY_ENTITIES value
     * @property {number} SPAWN_GROUP_BLOCK_UNTIL_LOADED=64 SPAWN_GROUP_BLOCK_UNTIL_LOADED value
     * @property {number} SPAWN_GROUP_LOAD_STREAMING_DATA=128 SPAWN_GROUP_LOAD_STREAMING_DATA value
     * @property {number} SPAWN_GROUP_CREATE_NEW_SCENE_WORLD=256 SPAWN_GROUP_CREATE_NEW_SCENE_WORLD value
     */
    $root.SpawnGroupFlags_t = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[1] = "SPAWN_GROUP_LOAD_ENTITIES_FROM_SAVE"] = 1;
        values[valuesById[2] = "SPAWN_GROUP_DONT_SPAWN_ENTITIES"] = 2;
        values[valuesById[4] = "SPAWN_GROUP_SYNCHRONOUS_SPAWN"] = 4;
        values[valuesById[8] = "SPAWN_GROUP_IS_INITIAL_SPAWN_GROUP"] = 8;
        values[valuesById[16] = "SPAWN_GROUP_CREATE_CLIENT_ONLY_ENTITIES"] = 16;
        values[valuesById[64] = "SPAWN_GROUP_BLOCK_UNTIL_LOADED"] = 64;
        values[valuesById[128] = "SPAWN_GROUP_LOAD_STREAMING_DATA"] = 128;
        values[valuesById[256] = "SPAWN_GROUP_CREATE_NEW_SCENE_WORLD"] = 256;
        return values;
    })();
    
    $root.CMsgVector = (function() {
    
        /**
         * Properties of a CMsgVector.
         * @exports ICMsgVector
         * @interface ICMsgVector
         * @property {number|null} [x] CMsgVector x
         * @property {number|null} [y] CMsgVector y
         * @property {number|null} [z] CMsgVector z
         * @property {number|null} [w] CMsgVector w
         */
    
        /**
         * Constructs a new CMsgVector.
         * @exports CMsgVector
         * @classdesc Represents a CMsgVector.
         * @implements ICMsgVector
         * @constructor
         * @param {ICMsgVector=} [properties] Properties to set
         */
        function CMsgVector(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CMsgVector x.
         * @member {number} x
         * @memberof CMsgVector
         * @instance
         */
        CMsgVector.prototype.x = 0;
    
        /**
         * CMsgVector y.
         * @member {number} y
         * @memberof CMsgVector
         * @instance
         */
        CMsgVector.prototype.y = 0;
    
        /**
         * CMsgVector z.
         * @member {number} z
         * @memberof CMsgVector
         * @instance
         */
        CMsgVector.prototype.z = 0;
    
        /**
         * CMsgVector w.
         * @member {number} w
         * @memberof CMsgVector
         * @instance
         */
        CMsgVector.prototype.w = 0;
    
        /**
         * Creates a new CMsgVector instance using the specified properties.
         * @function create
         * @memberof CMsgVector
         * @static
         * @param {ICMsgVector=} [properties] Properties to set
         * @returns {CMsgVector} CMsgVector instance
         */
        CMsgVector.create = function create(properties) {
            return new CMsgVector(properties);
        };
    
        /**
         * Encodes the specified CMsgVector message. Does not implicitly {@link CMsgVector.verify|verify} messages.
         * @function encode
         * @memberof CMsgVector
         * @static
         * @param {ICMsgVector} message CMsgVector message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CMsgVector.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.x != null && Object.hasOwnProperty.call(message, "x"))
                writer.uint32(/* id 1, wireType 5 =*/13).float(message.x);
            if (message.y != null && Object.hasOwnProperty.call(message, "y"))
                writer.uint32(/* id 2, wireType 5 =*/21).float(message.y);
            if (message.z != null && Object.hasOwnProperty.call(message, "z"))
                writer.uint32(/* id 3, wireType 5 =*/29).float(message.z);
            if (message.w != null && Object.hasOwnProperty.call(message, "w"))
                writer.uint32(/* id 4, wireType 5 =*/37).float(message.w);
            return writer;
        };
    
        /**
         * Encodes the specified CMsgVector message, length delimited. Does not implicitly {@link CMsgVector.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CMsgVector
         * @static
         * @param {ICMsgVector} message CMsgVector message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CMsgVector.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CMsgVector message from the specified reader or buffer.
         * @function decode
         * @memberof CMsgVector
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CMsgVector} CMsgVector
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CMsgVector.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgVector();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.x = reader.float();
                        break;
                    }
                case 2: {
                        message.y = reader.float();
                        break;
                    }
                case 3: {
                        message.z = reader.float();
                        break;
                    }
                case 4: {
                        message.w = reader.float();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CMsgVector message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CMsgVector
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CMsgVector} CMsgVector
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CMsgVector.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CMsgVector message.
         * @function verify
         * @memberof CMsgVector
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CMsgVector.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.x != null && message.hasOwnProperty("x"))
                if (typeof message.x !== "number")
                    return "x: number expected";
            if (message.y != null && message.hasOwnProperty("y"))
                if (typeof message.y !== "number")
                    return "y: number expected";
            if (message.z != null && message.hasOwnProperty("z"))
                if (typeof message.z !== "number")
                    return "z: number expected";
            if (message.w != null && message.hasOwnProperty("w"))
                if (typeof message.w !== "number")
                    return "w: number expected";
            return null;
        };
    
        /**
         * Creates a CMsgVector message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CMsgVector
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CMsgVector} CMsgVector
         */
        CMsgVector.fromObject = function fromObject(object) {
            if (object instanceof $root.CMsgVector)
                return object;
            var message = new $root.CMsgVector();
            if (object.x != null)
                message.x = Number(object.x);
            if (object.y != null)
                message.y = Number(object.y);
            if (object.z != null)
                message.z = Number(object.z);
            if (object.w != null)
                message.w = Number(object.w);
            return message;
        };
    
        /**
         * Creates a plain object from a CMsgVector message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CMsgVector
         * @static
         * @param {CMsgVector} message CMsgVector
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CMsgVector.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.x = 0;
                object.y = 0;
                object.z = 0;
                object.w = 0;
            }
            if (message.x != null && message.hasOwnProperty("x"))
                object.x = options.json && !isFinite(message.x) ? String(message.x) : message.x;
            if (message.y != null && message.hasOwnProperty("y"))
                object.y = options.json && !isFinite(message.y) ? String(message.y) : message.y;
            if (message.z != null && message.hasOwnProperty("z"))
                object.z = options.json && !isFinite(message.z) ? String(message.z) : message.z;
            if (message.w != null && message.hasOwnProperty("w"))
                object.w = options.json && !isFinite(message.w) ? String(message.w) : message.w;
            return object;
        };
    
        /**
         * Converts this CMsgVector to JSON.
         * @function toJSON
         * @memberof CMsgVector
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CMsgVector.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * Gets the default type url for CMsgVector
         * @function getTypeUrl
         * @memberof CMsgVector
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        CMsgVector.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/CMsgVector";
        };
    
        return CMsgVector;
    })();
    
    $root.CMsgVector2D = (function() {
    
        /**
         * Properties of a CMsgVector2D.
         * @exports ICMsgVector2D
         * @interface ICMsgVector2D
         * @property {number|null} [x] CMsgVector2D x
         * @property {number|null} [y] CMsgVector2D y
         */
    
        /**
         * Constructs a new CMsgVector2D.
         * @exports CMsgVector2D
         * @classdesc Represents a CMsgVector2D.
         * @implements ICMsgVector2D
         * @constructor
         * @param {ICMsgVector2D=} [properties] Properties to set
         */
        function CMsgVector2D(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CMsgVector2D x.
         * @member {number} x
         * @memberof CMsgVector2D
         * @instance
         */
        CMsgVector2D.prototype.x = 0;
    
        /**
         * CMsgVector2D y.
         * @member {number} y
         * @memberof CMsgVector2D
         * @instance
         */
        CMsgVector2D.prototype.y = 0;
    
        /**
         * Creates a new CMsgVector2D instance using the specified properties.
         * @function create
         * @memberof CMsgVector2D
         * @static
         * @param {ICMsgVector2D=} [properties] Properties to set
         * @returns {CMsgVector2D} CMsgVector2D instance
         */
        CMsgVector2D.create = function create(properties) {
            return new CMsgVector2D(properties);
        };
    
        /**
         * Encodes the specified CMsgVector2D message. Does not implicitly {@link CMsgVector2D.verify|verify} messages.
         * @function encode
         * @memberof CMsgVector2D
         * @static
         * @param {ICMsgVector2D} message CMsgVector2D message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CMsgVector2D.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.x != null && Object.hasOwnProperty.call(message, "x"))
                writer.uint32(/* id 1, wireType 5 =*/13).float(message.x);
            if (message.y != null && Object.hasOwnProperty.call(message, "y"))
                writer.uint32(/* id 2, wireType 5 =*/21).float(message.y);
            return writer;
        };
    
        /**
         * Encodes the specified CMsgVector2D message, length delimited. Does not implicitly {@link CMsgVector2D.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CMsgVector2D
         * @static
         * @param {ICMsgVector2D} message CMsgVector2D message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CMsgVector2D.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CMsgVector2D message from the specified reader or buffer.
         * @function decode
         * @memberof CMsgVector2D
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CMsgVector2D} CMsgVector2D
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CMsgVector2D.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgVector2D();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.x = reader.float();
                        break;
                    }
                case 2: {
                        message.y = reader.float();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CMsgVector2D message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CMsgVector2D
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CMsgVector2D} CMsgVector2D
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CMsgVector2D.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CMsgVector2D message.
         * @function verify
         * @memberof CMsgVector2D
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CMsgVector2D.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.x != null && message.hasOwnProperty("x"))
                if (typeof message.x !== "number")
                    return "x: number expected";
            if (message.y != null && message.hasOwnProperty("y"))
                if (typeof message.y !== "number")
                    return "y: number expected";
            return null;
        };
    
        /**
         * Creates a CMsgVector2D message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CMsgVector2D
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CMsgVector2D} CMsgVector2D
         */
        CMsgVector2D.fromObject = function fromObject(object) {
            if (object instanceof $root.CMsgVector2D)
                return object;
            var message = new $root.CMsgVector2D();
            if (object.x != null)
                message.x = Number(object.x);
            if (object.y != null)
                message.y = Number(object.y);
            return message;
        };
    
        /**
         * Creates a plain object from a CMsgVector2D message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CMsgVector2D
         * @static
         * @param {CMsgVector2D} message CMsgVector2D
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CMsgVector2D.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.x = 0;
                object.y = 0;
            }
            if (message.x != null && message.hasOwnProperty("x"))
                object.x = options.json && !isFinite(message.x) ? String(message.x) : message.x;
            if (message.y != null && message.hasOwnProperty("y"))
                object.y = options.json && !isFinite(message.y) ? String(message.y) : message.y;
            return object;
        };
    
        /**
         * Converts this CMsgVector2D to JSON.
         * @function toJSON
         * @memberof CMsgVector2D
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CMsgVector2D.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * Gets the default type url for CMsgVector2D
         * @function getTypeUrl
         * @memberof CMsgVector2D
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        CMsgVector2D.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/CMsgVector2D";
        };
    
        return CMsgVector2D;
    })();
    
    $root.CMsgQAngle = (function() {
    
        /**
         * Properties of a CMsgQAngle.
         * @exports ICMsgQAngle
         * @interface ICMsgQAngle
         * @property {number|null} [x] CMsgQAngle x
         * @property {number|null} [y] CMsgQAngle y
         * @property {number|null} [z] CMsgQAngle z
         */
    
        /**
         * Constructs a new CMsgQAngle.
         * @exports CMsgQAngle
         * @classdesc Represents a CMsgQAngle.
         * @implements ICMsgQAngle
         * @constructor
         * @param {ICMsgQAngle=} [properties] Properties to set
         */
        function CMsgQAngle(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CMsgQAngle x.
         * @member {number} x
         * @memberof CMsgQAngle
         * @instance
         */
        CMsgQAngle.prototype.x = 0;
    
        /**
         * CMsgQAngle y.
         * @member {number} y
         * @memberof CMsgQAngle
         * @instance
         */
        CMsgQAngle.prototype.y = 0;
    
        /**
         * CMsgQAngle z.
         * @member {number} z
         * @memberof CMsgQAngle
         * @instance
         */
        CMsgQAngle.prototype.z = 0;
    
        /**
         * Creates a new CMsgQAngle instance using the specified properties.
         * @function create
         * @memberof CMsgQAngle
         * @static
         * @param {ICMsgQAngle=} [properties] Properties to set
         * @returns {CMsgQAngle} CMsgQAngle instance
         */
        CMsgQAngle.create = function create(properties) {
            return new CMsgQAngle(properties);
        };
    
        /**
         * Encodes the specified CMsgQAngle message. Does not implicitly {@link CMsgQAngle.verify|verify} messages.
         * @function encode
         * @memberof CMsgQAngle
         * @static
         * @param {ICMsgQAngle} message CMsgQAngle message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CMsgQAngle.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.x != null && Object.hasOwnProperty.call(message, "x"))
                writer.uint32(/* id 1, wireType 5 =*/13).float(message.x);
            if (message.y != null && Object.hasOwnProperty.call(message, "y"))
                writer.uint32(/* id 2, wireType 5 =*/21).float(message.y);
            if (message.z != null && Object.hasOwnProperty.call(message, "z"))
                writer.uint32(/* id 3, wireType 5 =*/29).float(message.z);
            return writer;
        };
    
        /**
         * Encodes the specified CMsgQAngle message, length delimited. Does not implicitly {@link CMsgQAngle.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CMsgQAngle
         * @static
         * @param {ICMsgQAngle} message CMsgQAngle message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CMsgQAngle.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CMsgQAngle message from the specified reader or buffer.
         * @function decode
         * @memberof CMsgQAngle
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CMsgQAngle} CMsgQAngle
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CMsgQAngle.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgQAngle();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.x = reader.float();
                        break;
                    }
                case 2: {
                        message.y = reader.float();
                        break;
                    }
                case 3: {
                        message.z = reader.float();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CMsgQAngle message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CMsgQAngle
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CMsgQAngle} CMsgQAngle
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CMsgQAngle.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CMsgQAngle message.
         * @function verify
         * @memberof CMsgQAngle
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CMsgQAngle.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.x != null && message.hasOwnProperty("x"))
                if (typeof message.x !== "number")
                    return "x: number expected";
            if (message.y != null && message.hasOwnProperty("y"))
                if (typeof message.y !== "number")
                    return "y: number expected";
            if (message.z != null && message.hasOwnProperty("z"))
                if (typeof message.z !== "number")
                    return "z: number expected";
            return null;
        };
    
        /**
         * Creates a CMsgQAngle message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CMsgQAngle
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CMsgQAngle} CMsgQAngle
         */
        CMsgQAngle.fromObject = function fromObject(object) {
            if (object instanceof $root.CMsgQAngle)
                return object;
            var message = new $root.CMsgQAngle();
            if (object.x != null)
                message.x = Number(object.x);
            if (object.y != null)
                message.y = Number(object.y);
            if (object.z != null)
                message.z = Number(object.z);
            return message;
        };
    
        /**
         * Creates a plain object from a CMsgQAngle message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CMsgQAngle
         * @static
         * @param {CMsgQAngle} message CMsgQAngle
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CMsgQAngle.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.x = 0;
                object.y = 0;
                object.z = 0;
            }
            if (message.x != null && message.hasOwnProperty("x"))
                object.x = options.json && !isFinite(message.x) ? String(message.x) : message.x;
            if (message.y != null && message.hasOwnProperty("y"))
                object.y = options.json && !isFinite(message.y) ? String(message.y) : message.y;
            if (message.z != null && message.hasOwnProperty("z"))
                object.z = options.json && !isFinite(message.z) ? String(message.z) : message.z;
            return object;
        };
    
        /**
         * Converts this CMsgQAngle to JSON.
         * @function toJSON
         * @memberof CMsgQAngle
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CMsgQAngle.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * Gets the default type url for CMsgQAngle
         * @function getTypeUrl
         * @memberof CMsgQAngle
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        CMsgQAngle.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/CMsgQAngle";
        };
    
        return CMsgQAngle;
    })();
    
    $root.CMsgQuaternion = (function() {
    
        /**
         * Properties of a CMsgQuaternion.
         * @exports ICMsgQuaternion
         * @interface ICMsgQuaternion
         * @property {number|null} [x] CMsgQuaternion x
         * @property {number|null} [y] CMsgQuaternion y
         * @property {number|null} [z] CMsgQuaternion z
         * @property {number|null} [w] CMsgQuaternion w
         */
    
        /**
         * Constructs a new CMsgQuaternion.
         * @exports CMsgQuaternion
         * @classdesc Represents a CMsgQuaternion.
         * @implements ICMsgQuaternion
         * @constructor
         * @param {ICMsgQuaternion=} [properties] Properties to set
         */
        function CMsgQuaternion(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CMsgQuaternion x.
         * @member {number} x
         * @memberof CMsgQuaternion
         * @instance
         */
        CMsgQuaternion.prototype.x = 0;
    
        /**
         * CMsgQuaternion y.
         * @member {number} y
         * @memberof CMsgQuaternion
         * @instance
         */
        CMsgQuaternion.prototype.y = 0;
    
        /**
         * CMsgQuaternion z.
         * @member {number} z
         * @memberof CMsgQuaternion
         * @instance
         */
        CMsgQuaternion.prototype.z = 0;
    
        /**
         * CMsgQuaternion w.
         * @member {number} w
         * @memberof CMsgQuaternion
         * @instance
         */
        CMsgQuaternion.prototype.w = 0;
    
        /**
         * Creates a new CMsgQuaternion instance using the specified properties.
         * @function create
         * @memberof CMsgQuaternion
         * @static
         * @param {ICMsgQuaternion=} [properties] Properties to set
         * @returns {CMsgQuaternion} CMsgQuaternion instance
         */
        CMsgQuaternion.create = function create(properties) {
            return new CMsgQuaternion(properties);
        };
    
        /**
         * Encodes the specified CMsgQuaternion message. Does not implicitly {@link CMsgQuaternion.verify|verify} messages.
         * @function encode
         * @memberof CMsgQuaternion
         * @static
         * @param {ICMsgQuaternion} message CMsgQuaternion message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CMsgQuaternion.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.x != null && Object.hasOwnProperty.call(message, "x"))
                writer.uint32(/* id 1, wireType 5 =*/13).float(message.x);
            if (message.y != null && Object.hasOwnProperty.call(message, "y"))
                writer.uint32(/* id 2, wireType 5 =*/21).float(message.y);
            if (message.z != null && Object.hasOwnProperty.call(message, "z"))
                writer.uint32(/* id 3, wireType 5 =*/29).float(message.z);
            if (message.w != null && Object.hasOwnProperty.call(message, "w"))
                writer.uint32(/* id 4, wireType 5 =*/37).float(message.w);
            return writer;
        };
    
        /**
         * Encodes the specified CMsgQuaternion message, length delimited. Does not implicitly {@link CMsgQuaternion.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CMsgQuaternion
         * @static
         * @param {ICMsgQuaternion} message CMsgQuaternion message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CMsgQuaternion.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CMsgQuaternion message from the specified reader or buffer.
         * @function decode
         * @memberof CMsgQuaternion
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CMsgQuaternion} CMsgQuaternion
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CMsgQuaternion.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgQuaternion();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.x = reader.float();
                        break;
                    }
                case 2: {
                        message.y = reader.float();
                        break;
                    }
                case 3: {
                        message.z = reader.float();
                        break;
                    }
                case 4: {
                        message.w = reader.float();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CMsgQuaternion message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CMsgQuaternion
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CMsgQuaternion} CMsgQuaternion
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CMsgQuaternion.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CMsgQuaternion message.
         * @function verify
         * @memberof CMsgQuaternion
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CMsgQuaternion.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.x != null && message.hasOwnProperty("x"))
                if (typeof message.x !== "number")
                    return "x: number expected";
            if (message.y != null && message.hasOwnProperty("y"))
                if (typeof message.y !== "number")
                    return "y: number expected";
            if (message.z != null && message.hasOwnProperty("z"))
                if (typeof message.z !== "number")
                    return "z: number expected";
            if (message.w != null && message.hasOwnProperty("w"))
                if (typeof message.w !== "number")
                    return "w: number expected";
            return null;
        };
    
        /**
         * Creates a CMsgQuaternion message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CMsgQuaternion
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CMsgQuaternion} CMsgQuaternion
         */
        CMsgQuaternion.fromObject = function fromObject(object) {
            if (object instanceof $root.CMsgQuaternion)
                return object;
            var message = new $root.CMsgQuaternion();
            if (object.x != null)
                message.x = Number(object.x);
            if (object.y != null)
                message.y = Number(object.y);
            if (object.z != null)
                message.z = Number(object.z);
            if (object.w != null)
                message.w = Number(object.w);
            return message;
        };
    
        /**
         * Creates a plain object from a CMsgQuaternion message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CMsgQuaternion
         * @static
         * @param {CMsgQuaternion} message CMsgQuaternion
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CMsgQuaternion.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.x = 0;
                object.y = 0;
                object.z = 0;
                object.w = 0;
            }
            if (message.x != null && message.hasOwnProperty("x"))
                object.x = options.json && !isFinite(message.x) ? String(message.x) : message.x;
            if (message.y != null && message.hasOwnProperty("y"))
                object.y = options.json && !isFinite(message.y) ? String(message.y) : message.y;
            if (message.z != null && message.hasOwnProperty("z"))
                object.z = options.json && !isFinite(message.z) ? String(message.z) : message.z;
            if (message.w != null && message.hasOwnProperty("w"))
                object.w = options.json && !isFinite(message.w) ? String(message.w) : message.w;
            return object;
        };
    
        /**
         * Converts this CMsgQuaternion to JSON.
         * @function toJSON
         * @memberof CMsgQuaternion
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CMsgQuaternion.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * Gets the default type url for CMsgQuaternion
         * @function getTypeUrl
         * @memberof CMsgQuaternion
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        CMsgQuaternion.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/CMsgQuaternion";
        };
    
        return CMsgQuaternion;
    })();
    
    $root.CMsgTransform = (function() {
    
        /**
         * Properties of a CMsgTransform.
         * @exports ICMsgTransform
         * @interface ICMsgTransform
         * @property {ICMsgVector|null} [position] CMsgTransform position
         * @property {number|null} [scale] CMsgTransform scale
         * @property {ICMsgQuaternion|null} [orientation] CMsgTransform orientation
         */
    
        /**
         * Constructs a new CMsgTransform.
         * @exports CMsgTransform
         * @classdesc Represents a CMsgTransform.
         * @implements ICMsgTransform
         * @constructor
         * @param {ICMsgTransform=} [properties] Properties to set
         */
        function CMsgTransform(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CMsgTransform position.
         * @member {ICMsgVector|null|undefined} position
         * @memberof CMsgTransform
         * @instance
         */
        CMsgTransform.prototype.position = null;
    
        /**
         * CMsgTransform scale.
         * @member {number} scale
         * @memberof CMsgTransform
         * @instance
         */
        CMsgTransform.prototype.scale = 0;
    
        /**
         * CMsgTransform orientation.
         * @member {ICMsgQuaternion|null|undefined} orientation
         * @memberof CMsgTransform
         * @instance
         */
        CMsgTransform.prototype.orientation = null;
    
        /**
         * Creates a new CMsgTransform instance using the specified properties.
         * @function create
         * @memberof CMsgTransform
         * @static
         * @param {ICMsgTransform=} [properties] Properties to set
         * @returns {CMsgTransform} CMsgTransform instance
         */
        CMsgTransform.create = function create(properties) {
            return new CMsgTransform(properties);
        };
    
        /**
         * Encodes the specified CMsgTransform message. Does not implicitly {@link CMsgTransform.verify|verify} messages.
         * @function encode
         * @memberof CMsgTransform
         * @static
         * @param {ICMsgTransform} message CMsgTransform message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CMsgTransform.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.position != null && Object.hasOwnProperty.call(message, "position"))
                $root.CMsgVector.encode(message.position, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.scale != null && Object.hasOwnProperty.call(message, "scale"))
                writer.uint32(/* id 2, wireType 5 =*/21).float(message.scale);
            if (message.orientation != null && Object.hasOwnProperty.call(message, "orientation"))
                $root.CMsgQuaternion.encode(message.orientation, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            return writer;
        };
    
        /**
         * Encodes the specified CMsgTransform message, length delimited. Does not implicitly {@link CMsgTransform.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CMsgTransform
         * @static
         * @param {ICMsgTransform} message CMsgTransform message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CMsgTransform.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CMsgTransform message from the specified reader or buffer.
         * @function decode
         * @memberof CMsgTransform
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CMsgTransform} CMsgTransform
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CMsgTransform.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgTransform();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.position = $root.CMsgVector.decode(reader, reader.uint32());
                        break;
                    }
                case 2: {
                        message.scale = reader.float();
                        break;
                    }
                case 3: {
                        message.orientation = $root.CMsgQuaternion.decode(reader, reader.uint32());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CMsgTransform message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CMsgTransform
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CMsgTransform} CMsgTransform
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CMsgTransform.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CMsgTransform message.
         * @function verify
         * @memberof CMsgTransform
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CMsgTransform.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.position != null && message.hasOwnProperty("position")) {
                var error = $root.CMsgVector.verify(message.position);
                if (error)
                    return "position." + error;
            }
            if (message.scale != null && message.hasOwnProperty("scale"))
                if (typeof message.scale !== "number")
                    return "scale: number expected";
            if (message.orientation != null && message.hasOwnProperty("orientation")) {
                var error = $root.CMsgQuaternion.verify(message.orientation);
                if (error)
                    return "orientation." + error;
            }
            return null;
        };
    
        /**
         * Creates a CMsgTransform message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CMsgTransform
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CMsgTransform} CMsgTransform
         */
        CMsgTransform.fromObject = function fromObject(object) {
            if (object instanceof $root.CMsgTransform)
                return object;
            var message = new $root.CMsgTransform();
            if (object.position != null) {
                if (typeof object.position !== "object")
                    throw TypeError(".CMsgTransform.position: object expected");
                message.position = $root.CMsgVector.fromObject(object.position);
            }
            if (object.scale != null)
                message.scale = Number(object.scale);
            if (object.orientation != null) {
                if (typeof object.orientation !== "object")
                    throw TypeError(".CMsgTransform.orientation: object expected");
                message.orientation = $root.CMsgQuaternion.fromObject(object.orientation);
            }
            return message;
        };
    
        /**
         * Creates a plain object from a CMsgTransform message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CMsgTransform
         * @static
         * @param {CMsgTransform} message CMsgTransform
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CMsgTransform.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.position = null;
                object.scale = 0;
                object.orientation = null;
            }
            if (message.position != null && message.hasOwnProperty("position"))
                object.position = $root.CMsgVector.toObject(message.position, options);
            if (message.scale != null && message.hasOwnProperty("scale"))
                object.scale = options.json && !isFinite(message.scale) ? String(message.scale) : message.scale;
            if (message.orientation != null && message.hasOwnProperty("orientation"))
                object.orientation = $root.CMsgQuaternion.toObject(message.orientation, options);
            return object;
        };
    
        /**
         * Converts this CMsgTransform to JSON.
         * @function toJSON
         * @memberof CMsgTransform
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CMsgTransform.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * Gets the default type url for CMsgTransform
         * @function getTypeUrl
         * @memberof CMsgTransform
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        CMsgTransform.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/CMsgTransform";
        };
    
        return CMsgTransform;
    })();
    
    $root.CMsgRGBA = (function() {
    
        /**
         * Properties of a CMsgRGBA.
         * @exports ICMsgRGBA
         * @interface ICMsgRGBA
         * @property {number|null} [r] CMsgRGBA r
         * @property {number|null} [g] CMsgRGBA g
         * @property {number|null} [b] CMsgRGBA b
         * @property {number|null} [a] CMsgRGBA a
         */
    
        /**
         * Constructs a new CMsgRGBA.
         * @exports CMsgRGBA
         * @classdesc Represents a CMsgRGBA.
         * @implements ICMsgRGBA
         * @constructor
         * @param {ICMsgRGBA=} [properties] Properties to set
         */
        function CMsgRGBA(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CMsgRGBA r.
         * @member {number} r
         * @memberof CMsgRGBA
         * @instance
         */
        CMsgRGBA.prototype.r = 0;
    
        /**
         * CMsgRGBA g.
         * @member {number} g
         * @memberof CMsgRGBA
         * @instance
         */
        CMsgRGBA.prototype.g = 0;
    
        /**
         * CMsgRGBA b.
         * @member {number} b
         * @memberof CMsgRGBA
         * @instance
         */
        CMsgRGBA.prototype.b = 0;
    
        /**
         * CMsgRGBA a.
         * @member {number} a
         * @memberof CMsgRGBA
         * @instance
         */
        CMsgRGBA.prototype.a = 0;
    
        /**
         * Creates a new CMsgRGBA instance using the specified properties.
         * @function create
         * @memberof CMsgRGBA
         * @static
         * @param {ICMsgRGBA=} [properties] Properties to set
         * @returns {CMsgRGBA} CMsgRGBA instance
         */
        CMsgRGBA.create = function create(properties) {
            return new CMsgRGBA(properties);
        };
    
        /**
         * Encodes the specified CMsgRGBA message. Does not implicitly {@link CMsgRGBA.verify|verify} messages.
         * @function encode
         * @memberof CMsgRGBA
         * @static
         * @param {ICMsgRGBA} message CMsgRGBA message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CMsgRGBA.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.r != null && Object.hasOwnProperty.call(message, "r"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.r);
            if (message.g != null && Object.hasOwnProperty.call(message, "g"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.g);
            if (message.b != null && Object.hasOwnProperty.call(message, "b"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.b);
            if (message.a != null && Object.hasOwnProperty.call(message, "a"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.a);
            return writer;
        };
    
        /**
         * Encodes the specified CMsgRGBA message, length delimited. Does not implicitly {@link CMsgRGBA.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CMsgRGBA
         * @static
         * @param {ICMsgRGBA} message CMsgRGBA message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CMsgRGBA.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CMsgRGBA message from the specified reader or buffer.
         * @function decode
         * @memberof CMsgRGBA
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CMsgRGBA} CMsgRGBA
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CMsgRGBA.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgRGBA();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.r = reader.int32();
                        break;
                    }
                case 2: {
                        message.g = reader.int32();
                        break;
                    }
                case 3: {
                        message.b = reader.int32();
                        break;
                    }
                case 4: {
                        message.a = reader.int32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CMsgRGBA message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CMsgRGBA
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CMsgRGBA} CMsgRGBA
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CMsgRGBA.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CMsgRGBA message.
         * @function verify
         * @memberof CMsgRGBA
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CMsgRGBA.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.r != null && message.hasOwnProperty("r"))
                if (!$util.isInteger(message.r))
                    return "r: integer expected";
            if (message.g != null && message.hasOwnProperty("g"))
                if (!$util.isInteger(message.g))
                    return "g: integer expected";
            if (message.b != null && message.hasOwnProperty("b"))
                if (!$util.isInteger(message.b))
                    return "b: integer expected";
            if (message.a != null && message.hasOwnProperty("a"))
                if (!$util.isInteger(message.a))
                    return "a: integer expected";
            return null;
        };
    
        /**
         * Creates a CMsgRGBA message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CMsgRGBA
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CMsgRGBA} CMsgRGBA
         */
        CMsgRGBA.fromObject = function fromObject(object) {
            if (object instanceof $root.CMsgRGBA)
                return object;
            var message = new $root.CMsgRGBA();
            if (object.r != null)
                message.r = object.r | 0;
            if (object.g != null)
                message.g = object.g | 0;
            if (object.b != null)
                message.b = object.b | 0;
            if (object.a != null)
                message.a = object.a | 0;
            return message;
        };
    
        /**
         * Creates a plain object from a CMsgRGBA message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CMsgRGBA
         * @static
         * @param {CMsgRGBA} message CMsgRGBA
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CMsgRGBA.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.r = 0;
                object.g = 0;
                object.b = 0;
                object.a = 0;
            }
            if (message.r != null && message.hasOwnProperty("r"))
                object.r = message.r;
            if (message.g != null && message.hasOwnProperty("g"))
                object.g = message.g;
            if (message.b != null && message.hasOwnProperty("b"))
                object.b = message.b;
            if (message.a != null && message.hasOwnProperty("a"))
                object.a = message.a;
            return object;
        };
    
        /**
         * Converts this CMsgRGBA to JSON.
         * @function toJSON
         * @memberof CMsgRGBA
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CMsgRGBA.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * Gets the default type url for CMsgRGBA
         * @function getTypeUrl
         * @memberof CMsgRGBA
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        CMsgRGBA.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/CMsgRGBA";
        };
    
        return CMsgRGBA;
    })();
    
    $root.CMsgPlayerInfo = (function() {
    
        /**
         * Properties of a CMsgPlayerInfo.
         * @exports ICMsgPlayerInfo
         * @interface ICMsgPlayerInfo
         * @property {string|null} [name] CMsgPlayerInfo name
         * @property {number|Long|null} [xuid] CMsgPlayerInfo xuid
         * @property {number|null} [userid] CMsgPlayerInfo userid
         * @property {number|Long|null} [steamid] CMsgPlayerInfo steamid
         * @property {boolean|null} [fakeplayer] CMsgPlayerInfo fakeplayer
         * @property {boolean|null} [ishltv] CMsgPlayerInfo ishltv
         */
    
        /**
         * Constructs a new CMsgPlayerInfo.
         * @exports CMsgPlayerInfo
         * @classdesc Represents a CMsgPlayerInfo.
         * @implements ICMsgPlayerInfo
         * @constructor
         * @param {ICMsgPlayerInfo=} [properties] Properties to set
         */
        function CMsgPlayerInfo(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CMsgPlayerInfo name.
         * @member {string} name
         * @memberof CMsgPlayerInfo
         * @instance
         */
        CMsgPlayerInfo.prototype.name = "";
    
        /**
         * CMsgPlayerInfo xuid.
         * @member {number|Long} xuid
         * @memberof CMsgPlayerInfo
         * @instance
         */
        CMsgPlayerInfo.prototype.xuid = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
        /**
         * CMsgPlayerInfo userid.
         * @member {number} userid
         * @memberof CMsgPlayerInfo
         * @instance
         */
        CMsgPlayerInfo.prototype.userid = 0;
    
        /**
         * CMsgPlayerInfo steamid.
         * @member {number|Long} steamid
         * @memberof CMsgPlayerInfo
         * @instance
         */
        CMsgPlayerInfo.prototype.steamid = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
        /**
         * CMsgPlayerInfo fakeplayer.
         * @member {boolean} fakeplayer
         * @memberof CMsgPlayerInfo
         * @instance
         */
        CMsgPlayerInfo.prototype.fakeplayer = false;
    
        /**
         * CMsgPlayerInfo ishltv.
         * @member {boolean} ishltv
         * @memberof CMsgPlayerInfo
         * @instance
         */
        CMsgPlayerInfo.prototype.ishltv = false;
    
        /**
         * Creates a new CMsgPlayerInfo instance using the specified properties.
         * @function create
         * @memberof CMsgPlayerInfo
         * @static
         * @param {ICMsgPlayerInfo=} [properties] Properties to set
         * @returns {CMsgPlayerInfo} CMsgPlayerInfo instance
         */
        CMsgPlayerInfo.create = function create(properties) {
            return new CMsgPlayerInfo(properties);
        };
    
        /**
         * Encodes the specified CMsgPlayerInfo message. Does not implicitly {@link CMsgPlayerInfo.verify|verify} messages.
         * @function encode
         * @memberof CMsgPlayerInfo
         * @static
         * @param {ICMsgPlayerInfo} message CMsgPlayerInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CMsgPlayerInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
            if (message.xuid != null && Object.hasOwnProperty.call(message, "xuid"))
                writer.uint32(/* id 2, wireType 1 =*/17).fixed64(message.xuid);
            if (message.userid != null && Object.hasOwnProperty.call(message, "userid"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.userid);
            if (message.steamid != null && Object.hasOwnProperty.call(message, "steamid"))
                writer.uint32(/* id 4, wireType 1 =*/33).fixed64(message.steamid);
            if (message.fakeplayer != null && Object.hasOwnProperty.call(message, "fakeplayer"))
                writer.uint32(/* id 5, wireType 0 =*/40).bool(message.fakeplayer);
            if (message.ishltv != null && Object.hasOwnProperty.call(message, "ishltv"))
                writer.uint32(/* id 6, wireType 0 =*/48).bool(message.ishltv);
            return writer;
        };
    
        /**
         * Encodes the specified CMsgPlayerInfo message, length delimited. Does not implicitly {@link CMsgPlayerInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CMsgPlayerInfo
         * @static
         * @param {ICMsgPlayerInfo} message CMsgPlayerInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CMsgPlayerInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CMsgPlayerInfo message from the specified reader or buffer.
         * @function decode
         * @memberof CMsgPlayerInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CMsgPlayerInfo} CMsgPlayerInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CMsgPlayerInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgPlayerInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.name = reader.string();
                        break;
                    }
                case 2: {
                        message.xuid = reader.fixed64();
                        break;
                    }
                case 3: {
                        message.userid = reader.int32();
                        break;
                    }
                case 4: {
                        message.steamid = reader.fixed64();
                        break;
                    }
                case 5: {
                        message.fakeplayer = reader.bool();
                        break;
                    }
                case 6: {
                        message.ishltv = reader.bool();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CMsgPlayerInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CMsgPlayerInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CMsgPlayerInfo} CMsgPlayerInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CMsgPlayerInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CMsgPlayerInfo message.
         * @function verify
         * @memberof CMsgPlayerInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CMsgPlayerInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.name != null && message.hasOwnProperty("name"))
                if (!$util.isString(message.name))
                    return "name: string expected";
            if (message.xuid != null && message.hasOwnProperty("xuid"))
                if (!$util.isInteger(message.xuid) && !(message.xuid && $util.isInteger(message.xuid.low) && $util.isInteger(message.xuid.high)))
                    return "xuid: integer|Long expected";
            if (message.userid != null && message.hasOwnProperty("userid"))
                if (!$util.isInteger(message.userid))
                    return "userid: integer expected";
            if (message.steamid != null && message.hasOwnProperty("steamid"))
                if (!$util.isInteger(message.steamid) && !(message.steamid && $util.isInteger(message.steamid.low) && $util.isInteger(message.steamid.high)))
                    return "steamid: integer|Long expected";
            if (message.fakeplayer != null && message.hasOwnProperty("fakeplayer"))
                if (typeof message.fakeplayer !== "boolean")
                    return "fakeplayer: boolean expected";
            if (message.ishltv != null && message.hasOwnProperty("ishltv"))
                if (typeof message.ishltv !== "boolean")
                    return "ishltv: boolean expected";
            return null;
        };
    
        /**
         * Creates a CMsgPlayerInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CMsgPlayerInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CMsgPlayerInfo} CMsgPlayerInfo
         */
        CMsgPlayerInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.CMsgPlayerInfo)
                return object;
            var message = new $root.CMsgPlayerInfo();
            if (object.name != null)
                message.name = String(object.name);
            if (object.xuid != null)
                if ($util.Long)
                    (message.xuid = $util.Long.fromValue(object.xuid)).unsigned = false;
                else if (typeof object.xuid === "string")
                    message.xuid = parseInt(object.xuid, 10);
                else if (typeof object.xuid === "number")
                    message.xuid = object.xuid;
                else if (typeof object.xuid === "object")
                    message.xuid = new $util.LongBits(object.xuid.low >>> 0, object.xuid.high >>> 0).toNumber();
            if (object.userid != null)
                message.userid = object.userid | 0;
            if (object.steamid != null)
                if ($util.Long)
                    (message.steamid = $util.Long.fromValue(object.steamid)).unsigned = false;
                else if (typeof object.steamid === "string")
                    message.steamid = parseInt(object.steamid, 10);
                else if (typeof object.steamid === "number")
                    message.steamid = object.steamid;
                else if (typeof object.steamid === "object")
                    message.steamid = new $util.LongBits(object.steamid.low >>> 0, object.steamid.high >>> 0).toNumber();
            if (object.fakeplayer != null)
                message.fakeplayer = Boolean(object.fakeplayer);
            if (object.ishltv != null)
                message.ishltv = Boolean(object.ishltv);
            return message;
        };
    
        /**
         * Creates a plain object from a CMsgPlayerInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CMsgPlayerInfo
         * @static
         * @param {CMsgPlayerInfo} message CMsgPlayerInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CMsgPlayerInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.name = "";
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.xuid = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.xuid = options.longs === String ? "0" : 0;
                object.userid = 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.steamid = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.steamid = options.longs === String ? "0" : 0;
                object.fakeplayer = false;
                object.ishltv = false;
            }
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
            if (message.xuid != null && message.hasOwnProperty("xuid"))
                if (typeof message.xuid === "number")
                    object.xuid = options.longs === String ? String(message.xuid) : message.xuid;
                else
                    object.xuid = options.longs === String ? $util.Long.prototype.toString.call(message.xuid) : options.longs === Number ? new $util.LongBits(message.xuid.low >>> 0, message.xuid.high >>> 0).toNumber() : message.xuid;
            if (message.userid != null && message.hasOwnProperty("userid"))
                object.userid = message.userid;
            if (message.steamid != null && message.hasOwnProperty("steamid"))
                if (typeof message.steamid === "number")
                    object.steamid = options.longs === String ? String(message.steamid) : message.steamid;
                else
                    object.steamid = options.longs === String ? $util.Long.prototype.toString.call(message.steamid) : options.longs === Number ? new $util.LongBits(message.steamid.low >>> 0, message.steamid.high >>> 0).toNumber() : message.steamid;
            if (message.fakeplayer != null && message.hasOwnProperty("fakeplayer"))
                object.fakeplayer = message.fakeplayer;
            if (message.ishltv != null && message.hasOwnProperty("ishltv"))
                object.ishltv = message.ishltv;
            return object;
        };
    
        /**
         * Converts this CMsgPlayerInfo to JSON.
         * @function toJSON
         * @memberof CMsgPlayerInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CMsgPlayerInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * Gets the default type url for CMsgPlayerInfo
         * @function getTypeUrl
         * @memberof CMsgPlayerInfo
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        CMsgPlayerInfo.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/CMsgPlayerInfo";
        };
    
        return CMsgPlayerInfo;
    })();
    
    $root.CEntityMsg = (function() {
    
        /**
         * Properties of a CEntityMsg.
         * @exports ICEntityMsg
         * @interface ICEntityMsg
         * @property {number|null} [targetEntity] CEntityMsg targetEntity
         */
    
        /**
         * Constructs a new CEntityMsg.
         * @exports CEntityMsg
         * @classdesc Represents a CEntityMsg.
         * @implements ICEntityMsg
         * @constructor
         * @param {ICEntityMsg=} [properties] Properties to set
         */
        function CEntityMsg(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CEntityMsg targetEntity.
         * @member {number} targetEntity
         * @memberof CEntityMsg
         * @instance
         */
        CEntityMsg.prototype.targetEntity = 16777215;
    
        /**
         * Creates a new CEntityMsg instance using the specified properties.
         * @function create
         * @memberof CEntityMsg
         * @static
         * @param {ICEntityMsg=} [properties] Properties to set
         * @returns {CEntityMsg} CEntityMsg instance
         */
        CEntityMsg.create = function create(properties) {
            return new CEntityMsg(properties);
        };
    
        /**
         * Encodes the specified CEntityMsg message. Does not implicitly {@link CEntityMsg.verify|verify} messages.
         * @function encode
         * @memberof CEntityMsg
         * @static
         * @param {ICEntityMsg} message CEntityMsg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CEntityMsg.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.targetEntity != null && Object.hasOwnProperty.call(message, "targetEntity"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.targetEntity);
            return writer;
        };
    
        /**
         * Encodes the specified CEntityMsg message, length delimited. Does not implicitly {@link CEntityMsg.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CEntityMsg
         * @static
         * @param {ICEntityMsg} message CEntityMsg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CEntityMsg.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CEntityMsg message from the specified reader or buffer.
         * @function decode
         * @memberof CEntityMsg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CEntityMsg} CEntityMsg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CEntityMsg.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CEntityMsg();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.targetEntity = reader.uint32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CEntityMsg message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CEntityMsg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CEntityMsg} CEntityMsg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CEntityMsg.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CEntityMsg message.
         * @function verify
         * @memberof CEntityMsg
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CEntityMsg.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.targetEntity != null && message.hasOwnProperty("targetEntity"))
                if (!$util.isInteger(message.targetEntity))
                    return "targetEntity: integer expected";
            return null;
        };
    
        /**
         * Creates a CEntityMsg message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CEntityMsg
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CEntityMsg} CEntityMsg
         */
        CEntityMsg.fromObject = function fromObject(object) {
            if (object instanceof $root.CEntityMsg)
                return object;
            var message = new $root.CEntityMsg();
            if (object.targetEntity != null)
                message.targetEntity = object.targetEntity >>> 0;
            return message;
        };
    
        /**
         * Creates a plain object from a CEntityMsg message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CEntityMsg
         * @static
         * @param {CEntityMsg} message CEntityMsg
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CEntityMsg.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.targetEntity = 16777215;
            if (message.targetEntity != null && message.hasOwnProperty("targetEntity"))
                object.targetEntity = message.targetEntity;
            return object;
        };
    
        /**
         * Converts this CEntityMsg to JSON.
         * @function toJSON
         * @memberof CEntityMsg
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CEntityMsg.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * Gets the default type url for CEntityMsg
         * @function getTypeUrl
         * @memberof CEntityMsg
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        CEntityMsg.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/CEntityMsg";
        };
    
        return CEntityMsg;
    })();
    
    $root.CMsg_CVars = (function() {
    
        /**
         * Properties of a CMsg_CVars.
         * @exports ICMsg_CVars
         * @interface ICMsg_CVars
         * @property {Array.<CMsg_CVars.ICVar>|null} [cvars] CMsg_CVars cvars
         */
    
        /**
         * Constructs a new CMsg_CVars.
         * @exports CMsg_CVars
         * @classdesc Represents a CMsg_CVars.
         * @implements ICMsg_CVars
         * @constructor
         * @param {ICMsg_CVars=} [properties] Properties to set
         */
        function CMsg_CVars(properties) {
            this.cvars = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CMsg_CVars cvars.
         * @member {Array.<CMsg_CVars.ICVar>} cvars
         * @memberof CMsg_CVars
         * @instance
         */
        CMsg_CVars.prototype.cvars = $util.emptyArray;
    
        /**
         * Creates a new CMsg_CVars instance using the specified properties.
         * @function create
         * @memberof CMsg_CVars
         * @static
         * @param {ICMsg_CVars=} [properties] Properties to set
         * @returns {CMsg_CVars} CMsg_CVars instance
         */
        CMsg_CVars.create = function create(properties) {
            return new CMsg_CVars(properties);
        };
    
        /**
         * Encodes the specified CMsg_CVars message. Does not implicitly {@link CMsg_CVars.verify|verify} messages.
         * @function encode
         * @memberof CMsg_CVars
         * @static
         * @param {ICMsg_CVars} message CMsg_CVars message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CMsg_CVars.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.cvars != null && message.cvars.length)
                for (var i = 0; i < message.cvars.length; ++i)
                    $root.CMsg_CVars.CVar.encode(message.cvars[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };
    
        /**
         * Encodes the specified CMsg_CVars message, length delimited. Does not implicitly {@link CMsg_CVars.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CMsg_CVars
         * @static
         * @param {ICMsg_CVars} message CMsg_CVars message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CMsg_CVars.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CMsg_CVars message from the specified reader or buffer.
         * @function decode
         * @memberof CMsg_CVars
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CMsg_CVars} CMsg_CVars
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CMsg_CVars.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsg_CVars();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        if (!(message.cvars && message.cvars.length))
                            message.cvars = [];
                        message.cvars.push($root.CMsg_CVars.CVar.decode(reader, reader.uint32()));
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CMsg_CVars message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CMsg_CVars
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CMsg_CVars} CMsg_CVars
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CMsg_CVars.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CMsg_CVars message.
         * @function verify
         * @memberof CMsg_CVars
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CMsg_CVars.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.cvars != null && message.hasOwnProperty("cvars")) {
                if (!Array.isArray(message.cvars))
                    return "cvars: array expected";
                for (var i = 0; i < message.cvars.length; ++i) {
                    var error = $root.CMsg_CVars.CVar.verify(message.cvars[i]);
                    if (error)
                        return "cvars." + error;
                }
            }
            return null;
        };
    
        /**
         * Creates a CMsg_CVars message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CMsg_CVars
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CMsg_CVars} CMsg_CVars
         */
        CMsg_CVars.fromObject = function fromObject(object) {
            if (object instanceof $root.CMsg_CVars)
                return object;
            var message = new $root.CMsg_CVars();
            if (object.cvars) {
                if (!Array.isArray(object.cvars))
                    throw TypeError(".CMsg_CVars.cvars: array expected");
                message.cvars = [];
                for (var i = 0; i < object.cvars.length; ++i) {
                    if (typeof object.cvars[i] !== "object")
                        throw TypeError(".CMsg_CVars.cvars: object expected");
                    message.cvars[i] = $root.CMsg_CVars.CVar.fromObject(object.cvars[i]);
                }
            }
            return message;
        };
    
        /**
         * Creates a plain object from a CMsg_CVars message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CMsg_CVars
         * @static
         * @param {CMsg_CVars} message CMsg_CVars
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CMsg_CVars.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.cvars = [];
            if (message.cvars && message.cvars.length) {
                object.cvars = [];
                for (var j = 0; j < message.cvars.length; ++j)
                    object.cvars[j] = $root.CMsg_CVars.CVar.toObject(message.cvars[j], options);
            }
            return object;
        };
    
        /**
         * Converts this CMsg_CVars to JSON.
         * @function toJSON
         * @memberof CMsg_CVars
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CMsg_CVars.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * Gets the default type url for CMsg_CVars
         * @function getTypeUrl
         * @memberof CMsg_CVars
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        CMsg_CVars.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/CMsg_CVars";
        };
    
        CMsg_CVars.CVar = (function() {
    
            /**
             * Properties of a CVar.
             * @memberof CMsg_CVars
             * @interface ICVar
             * @property {string|null} [name] CVar name
             * @property {string|null} [value] CVar value
             */
    
            /**
             * Constructs a new CVar.
             * @memberof CMsg_CVars
             * @classdesc Represents a CVar.
             * @implements ICVar
             * @constructor
             * @param {CMsg_CVars.ICVar=} [properties] Properties to set
             */
            function CVar(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * CVar name.
             * @member {string} name
             * @memberof CMsg_CVars.CVar
             * @instance
             */
            CVar.prototype.name = "";
    
            /**
             * CVar value.
             * @member {string} value
             * @memberof CMsg_CVars.CVar
             * @instance
             */
            CVar.prototype.value = "";
    
            /**
             * Creates a new CVar instance using the specified properties.
             * @function create
             * @memberof CMsg_CVars.CVar
             * @static
             * @param {CMsg_CVars.ICVar=} [properties] Properties to set
             * @returns {CMsg_CVars.CVar} CVar instance
             */
            CVar.create = function create(properties) {
                return new CVar(properties);
            };
    
            /**
             * Encodes the specified CVar message. Does not implicitly {@link CMsg_CVars.CVar.verify|verify} messages.
             * @function encode
             * @memberof CMsg_CVars.CVar
             * @static
             * @param {CMsg_CVars.ICVar} message CVar message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CVar.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                if (message.value != null && Object.hasOwnProperty.call(message, "value"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.value);
                return writer;
            };
    
            /**
             * Encodes the specified CVar message, length delimited. Does not implicitly {@link CMsg_CVars.CVar.verify|verify} messages.
             * @function encodeDelimited
             * @memberof CMsg_CVars.CVar
             * @static
             * @param {CMsg_CVars.ICVar} message CVar message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CVar.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a CVar message from the specified reader or buffer.
             * @function decode
             * @memberof CMsg_CVars.CVar
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {CMsg_CVars.CVar} CVar
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CVar.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsg_CVars.CVar();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.name = reader.string();
                            break;
                        }
                    case 2: {
                            message.value = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a CVar message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof CMsg_CVars.CVar
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {CMsg_CVars.CVar} CVar
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CVar.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a CVar message.
             * @function verify
             * @memberof CMsg_CVars.CVar
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            CVar.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                if (message.value != null && message.hasOwnProperty("value"))
                    if (!$util.isString(message.value))
                        return "value: string expected";
                return null;
            };
    
            /**
             * Creates a CVar message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof CMsg_CVars.CVar
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {CMsg_CVars.CVar} CVar
             */
            CVar.fromObject = function fromObject(object) {
                if (object instanceof $root.CMsg_CVars.CVar)
                    return object;
                var message = new $root.CMsg_CVars.CVar();
                if (object.name != null)
                    message.name = String(object.name);
                if (object.value != null)
                    message.value = String(object.value);
                return message;
            };
    
            /**
             * Creates a plain object from a CVar message. Also converts values to other types if specified.
             * @function toObject
             * @memberof CMsg_CVars.CVar
             * @static
             * @param {CMsg_CVars.CVar} message CVar
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            CVar.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.name = "";
                    object.value = "";
                }
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                if (message.value != null && message.hasOwnProperty("value"))
                    object.value = message.value;
                return object;
            };
    
            /**
             * Converts this CVar to JSON.
             * @function toJSON
             * @memberof CMsg_CVars.CVar
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            CVar.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            /**
             * Gets the default type url for CVar
             * @function getTypeUrl
             * @memberof CMsg_CVars.CVar
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            CVar.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/CMsg_CVars.CVar";
            };
    
            return CVar;
        })();
    
        return CMsg_CVars;
    })();
    
    $root.CNETMsg_NOP = (function() {
    
        /**
         * Properties of a CNETMsg_NOP.
         * @exports ICNETMsg_NOP
         * @interface ICNETMsg_NOP
         */
    
        /**
         * Constructs a new CNETMsg_NOP.
         * @exports CNETMsg_NOP
         * @classdesc Represents a CNETMsg_NOP.
         * @implements ICNETMsg_NOP
         * @constructor
         * @param {ICNETMsg_NOP=} [properties] Properties to set
         */
        function CNETMsg_NOP(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * Creates a new CNETMsg_NOP instance using the specified properties.
         * @function create
         * @memberof CNETMsg_NOP
         * @static
         * @param {ICNETMsg_NOP=} [properties] Properties to set
         * @returns {CNETMsg_NOP} CNETMsg_NOP instance
         */
        CNETMsg_NOP.create = function create(properties) {
            return new CNETMsg_NOP(properties);
        };
    
        /**
         * Encodes the specified CNETMsg_NOP message. Does not implicitly {@link CNETMsg_NOP.verify|verify} messages.
         * @function encode
         * @memberof CNETMsg_NOP
         * @static
         * @param {ICNETMsg_NOP} message CNETMsg_NOP message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CNETMsg_NOP.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };
    
        /**
         * Encodes the specified CNETMsg_NOP message, length delimited. Does not implicitly {@link CNETMsg_NOP.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CNETMsg_NOP
         * @static
         * @param {ICNETMsg_NOP} message CNETMsg_NOP message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CNETMsg_NOP.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CNETMsg_NOP message from the specified reader or buffer.
         * @function decode
         * @memberof CNETMsg_NOP
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CNETMsg_NOP} CNETMsg_NOP
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CNETMsg_NOP.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CNETMsg_NOP();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CNETMsg_NOP message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CNETMsg_NOP
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CNETMsg_NOP} CNETMsg_NOP
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CNETMsg_NOP.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CNETMsg_NOP message.
         * @function verify
         * @memberof CNETMsg_NOP
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CNETMsg_NOP.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };
    
        /**
         * Creates a CNETMsg_NOP message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CNETMsg_NOP
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CNETMsg_NOP} CNETMsg_NOP
         */
        CNETMsg_NOP.fromObject = function fromObject(object) {
            if (object instanceof $root.CNETMsg_NOP)
                return object;
            return new $root.CNETMsg_NOP();
        };
    
        /**
         * Creates a plain object from a CNETMsg_NOP message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CNETMsg_NOP
         * @static
         * @param {CNETMsg_NOP} message CNETMsg_NOP
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CNETMsg_NOP.toObject = function toObject() {
            return {};
        };
    
        /**
         * Converts this CNETMsg_NOP to JSON.
         * @function toJSON
         * @memberof CNETMsg_NOP
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CNETMsg_NOP.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * Gets the default type url for CNETMsg_NOP
         * @function getTypeUrl
         * @memberof CNETMsg_NOP
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        CNETMsg_NOP.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/CNETMsg_NOP";
        };
    
        return CNETMsg_NOP;
    })();
    
    $root.CNETMsg_SplitScreenUser = (function() {
    
        /**
         * Properties of a CNETMsg_SplitScreenUser.
         * @exports ICNETMsg_SplitScreenUser
         * @interface ICNETMsg_SplitScreenUser
         * @property {number|null} [slot] CNETMsg_SplitScreenUser slot
         */
    
        /**
         * Constructs a new CNETMsg_SplitScreenUser.
         * @exports CNETMsg_SplitScreenUser
         * @classdesc Represents a CNETMsg_SplitScreenUser.
         * @implements ICNETMsg_SplitScreenUser
         * @constructor
         * @param {ICNETMsg_SplitScreenUser=} [properties] Properties to set
         */
        function CNETMsg_SplitScreenUser(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CNETMsg_SplitScreenUser slot.
         * @member {number} slot
         * @memberof CNETMsg_SplitScreenUser
         * @instance
         */
        CNETMsg_SplitScreenUser.prototype.slot = 0;
    
        /**
         * Creates a new CNETMsg_SplitScreenUser instance using the specified properties.
         * @function create
         * @memberof CNETMsg_SplitScreenUser
         * @static
         * @param {ICNETMsg_SplitScreenUser=} [properties] Properties to set
         * @returns {CNETMsg_SplitScreenUser} CNETMsg_SplitScreenUser instance
         */
        CNETMsg_SplitScreenUser.create = function create(properties) {
            return new CNETMsg_SplitScreenUser(properties);
        };
    
        /**
         * Encodes the specified CNETMsg_SplitScreenUser message. Does not implicitly {@link CNETMsg_SplitScreenUser.verify|verify} messages.
         * @function encode
         * @memberof CNETMsg_SplitScreenUser
         * @static
         * @param {ICNETMsg_SplitScreenUser} message CNETMsg_SplitScreenUser message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CNETMsg_SplitScreenUser.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.slot != null && Object.hasOwnProperty.call(message, "slot"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.slot);
            return writer;
        };
    
        /**
         * Encodes the specified CNETMsg_SplitScreenUser message, length delimited. Does not implicitly {@link CNETMsg_SplitScreenUser.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CNETMsg_SplitScreenUser
         * @static
         * @param {ICNETMsg_SplitScreenUser} message CNETMsg_SplitScreenUser message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CNETMsg_SplitScreenUser.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CNETMsg_SplitScreenUser message from the specified reader or buffer.
         * @function decode
         * @memberof CNETMsg_SplitScreenUser
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CNETMsg_SplitScreenUser} CNETMsg_SplitScreenUser
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CNETMsg_SplitScreenUser.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CNETMsg_SplitScreenUser();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.slot = reader.int32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CNETMsg_SplitScreenUser message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CNETMsg_SplitScreenUser
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CNETMsg_SplitScreenUser} CNETMsg_SplitScreenUser
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CNETMsg_SplitScreenUser.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CNETMsg_SplitScreenUser message.
         * @function verify
         * @memberof CNETMsg_SplitScreenUser
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CNETMsg_SplitScreenUser.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.slot != null && message.hasOwnProperty("slot"))
                if (!$util.isInteger(message.slot))
                    return "slot: integer expected";
            return null;
        };
    
        /**
         * Creates a CNETMsg_SplitScreenUser message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CNETMsg_SplitScreenUser
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CNETMsg_SplitScreenUser} CNETMsg_SplitScreenUser
         */
        CNETMsg_SplitScreenUser.fromObject = function fromObject(object) {
            if (object instanceof $root.CNETMsg_SplitScreenUser)
                return object;
            var message = new $root.CNETMsg_SplitScreenUser();
            if (object.slot != null)
                message.slot = object.slot | 0;
            return message;
        };
    
        /**
         * Creates a plain object from a CNETMsg_SplitScreenUser message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CNETMsg_SplitScreenUser
         * @static
         * @param {CNETMsg_SplitScreenUser} message CNETMsg_SplitScreenUser
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CNETMsg_SplitScreenUser.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.slot = 0;
            if (message.slot != null && message.hasOwnProperty("slot"))
                object.slot = message.slot;
            return object;
        };
    
        /**
         * Converts this CNETMsg_SplitScreenUser to JSON.
         * @function toJSON
         * @memberof CNETMsg_SplitScreenUser
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CNETMsg_SplitScreenUser.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * Gets the default type url for CNETMsg_SplitScreenUser
         * @function getTypeUrl
         * @memberof CNETMsg_SplitScreenUser
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        CNETMsg_SplitScreenUser.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/CNETMsg_SplitScreenUser";
        };
    
        return CNETMsg_SplitScreenUser;
    })();
    
    $root.CNETMsg_Disconnect = (function() {
    
        /**
         * Properties of a CNETMsg_Disconnect.
         * @exports ICNETMsg_Disconnect
         * @interface ICNETMsg_Disconnect
         * @property {ENetworkDisconnectionReason|null} [reason] CNETMsg_Disconnect reason
         */
    
        /**
         * Constructs a new CNETMsg_Disconnect.
         * @exports CNETMsg_Disconnect
         * @classdesc Represents a CNETMsg_Disconnect.
         * @implements ICNETMsg_Disconnect
         * @constructor
         * @param {ICNETMsg_Disconnect=} [properties] Properties to set
         */
        function CNETMsg_Disconnect(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CNETMsg_Disconnect reason.
         * @member {ENetworkDisconnectionReason} reason
         * @memberof CNETMsg_Disconnect
         * @instance
         */
        CNETMsg_Disconnect.prototype.reason = 0;
    
        /**
         * Creates a new CNETMsg_Disconnect instance using the specified properties.
         * @function create
         * @memberof CNETMsg_Disconnect
         * @static
         * @param {ICNETMsg_Disconnect=} [properties] Properties to set
         * @returns {CNETMsg_Disconnect} CNETMsg_Disconnect instance
         */
        CNETMsg_Disconnect.create = function create(properties) {
            return new CNETMsg_Disconnect(properties);
        };
    
        /**
         * Encodes the specified CNETMsg_Disconnect message. Does not implicitly {@link CNETMsg_Disconnect.verify|verify} messages.
         * @function encode
         * @memberof CNETMsg_Disconnect
         * @static
         * @param {ICNETMsg_Disconnect} message CNETMsg_Disconnect message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CNETMsg_Disconnect.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.reason != null && Object.hasOwnProperty.call(message, "reason"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.reason);
            return writer;
        };
    
        /**
         * Encodes the specified CNETMsg_Disconnect message, length delimited. Does not implicitly {@link CNETMsg_Disconnect.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CNETMsg_Disconnect
         * @static
         * @param {ICNETMsg_Disconnect} message CNETMsg_Disconnect message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CNETMsg_Disconnect.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CNETMsg_Disconnect message from the specified reader or buffer.
         * @function decode
         * @memberof CNETMsg_Disconnect
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CNETMsg_Disconnect} CNETMsg_Disconnect
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CNETMsg_Disconnect.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CNETMsg_Disconnect();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 2: {
                        message.reason = reader.int32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CNETMsg_Disconnect message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CNETMsg_Disconnect
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CNETMsg_Disconnect} CNETMsg_Disconnect
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CNETMsg_Disconnect.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CNETMsg_Disconnect message.
         * @function verify
         * @memberof CNETMsg_Disconnect
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CNETMsg_Disconnect.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.reason != null && message.hasOwnProperty("reason"))
                switch (message.reason) {
                default:
                    return "reason: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                case 7:
                case 8:
                case 9:
                case 10:
                case 11:
                case 12:
                case 13:
                case 14:
                case 15:
                case 16:
                case 17:
                case 18:
                case 19:
                case 20:
                case 21:
                case 22:
                case 23:
                case 24:
                case 25:
                case 26:
                case 27:
                case 28:
                case 29:
                case 30:
                case 31:
                case 32:
                case 33:
                case 34:
                case 35:
                case 36:
                case 37:
                case 38:
                case 39:
                case 40:
                case 41:
                case 42:
                case 43:
                case 44:
                case 45:
                case 46:
                case 47:
                case 48:
                case 49:
                case 50:
                case 51:
                case 52:
                case 53:
                case 54:
                case 55:
                case 56:
                case 57:
                case 58:
                case 59:
                case 60:
                case 61:
                case 62:
                case 63:
                case 64:
                case 65:
                case 66:
                case 67:
                case 68:
                case 69:
                case 71:
                case 72:
                case 73:
                case 74:
                case 75:
                case 76:
                case 77:
                case 79:
                case 80:
                case 81:
                case 82:
                case 83:
                case 84:
                case 85:
                case 128:
                case 129:
                case 130:
                case 131:
                case 132:
                case 133:
                case 134:
                case 135:
                case 136:
                case 137:
                case 138:
                case 139:
                case 140:
                case 141:
                case 142:
                case 143:
                case 144:
                case 145:
                case 146:
                case 147:
                case 148:
                case 149:
                case 150:
                case 151:
                case 152:
                case 153:
                case 154:
                case 155:
                case 156:
                case 157:
                case 158:
                case 159:
                case 160:
                case 161:
                    break;
                }
            return null;
        };
    
        /**
         * Creates a CNETMsg_Disconnect message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CNETMsg_Disconnect
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CNETMsg_Disconnect} CNETMsg_Disconnect
         */
        CNETMsg_Disconnect.fromObject = function fromObject(object) {
            if (object instanceof $root.CNETMsg_Disconnect)
                return object;
            var message = new $root.CNETMsg_Disconnect();
            switch (object.reason) {
            default:
                if (typeof object.reason === "number") {
                    message.reason = object.reason;
                    break;
                }
                break;
            case "NETWORK_DISCONNECT_INVALID":
            case 0:
                message.reason = 0;
                break;
            case "NETWORK_DISCONNECT_SHUTDOWN":
            case 1:
                message.reason = 1;
                break;
            case "NETWORK_DISCONNECT_DISCONNECT_BY_USER":
            case 2:
                message.reason = 2;
                break;
            case "NETWORK_DISCONNECT_DISCONNECT_BY_SERVER":
            case 3:
                message.reason = 3;
                break;
            case "NETWORK_DISCONNECT_LOST":
            case 4:
                message.reason = 4;
                break;
            case "NETWORK_DISCONNECT_OVERFLOW":
            case 5:
                message.reason = 5;
                break;
            case "NETWORK_DISCONNECT_STEAM_BANNED":
            case 6:
                message.reason = 6;
                break;
            case "NETWORK_DISCONNECT_STEAM_INUSE":
            case 7:
                message.reason = 7;
                break;
            case "NETWORK_DISCONNECT_STEAM_TICKET":
            case 8:
                message.reason = 8;
                break;
            case "NETWORK_DISCONNECT_STEAM_LOGON":
            case 9:
                message.reason = 9;
                break;
            case "NETWORK_DISCONNECT_STEAM_AUTHCANCELLED":
            case 10:
                message.reason = 10;
                break;
            case "NETWORK_DISCONNECT_STEAM_AUTHALREADYUSED":
            case 11:
                message.reason = 11;
                break;
            case "NETWORK_DISCONNECT_STEAM_AUTHINVALID":
            case 12:
                message.reason = 12;
                break;
            case "NETWORK_DISCONNECT_STEAM_VACBANSTATE":
            case 13:
                message.reason = 13;
                break;
            case "NETWORK_DISCONNECT_STEAM_LOGGED_IN_ELSEWHERE":
            case 14:
                message.reason = 14;
                break;
            case "NETWORK_DISCONNECT_STEAM_VAC_CHECK_TIMEDOUT":
            case 15:
                message.reason = 15;
                break;
            case "NETWORK_DISCONNECT_STEAM_DROPPED":
            case 16:
                message.reason = 16;
                break;
            case "NETWORK_DISCONNECT_STEAM_OWNERSHIP":
            case 17:
                message.reason = 17;
                break;
            case "NETWORK_DISCONNECT_SERVERINFO_OVERFLOW":
            case 18:
                message.reason = 18;
                break;
            case "NETWORK_DISCONNECT_TICKMSG_OVERFLOW":
            case 19:
                message.reason = 19;
                break;
            case "NETWORK_DISCONNECT_STRINGTABLEMSG_OVERFLOW":
            case 20:
                message.reason = 20;
                break;
            case "NETWORK_DISCONNECT_DELTAENTMSG_OVERFLOW":
            case 21:
                message.reason = 21;
                break;
            case "NETWORK_DISCONNECT_TEMPENTMSG_OVERFLOW":
            case 22:
                message.reason = 22;
                break;
            case "NETWORK_DISCONNECT_SOUNDSMSG_OVERFLOW":
            case 23:
                message.reason = 23;
                break;
            case "NETWORK_DISCONNECT_SNAPSHOTOVERFLOW":
            case 24:
                message.reason = 24;
                break;
            case "NETWORK_DISCONNECT_SNAPSHOTERROR":
            case 25:
                message.reason = 25;
                break;
            case "NETWORK_DISCONNECT_RELIABLEOVERFLOW":
            case 26:
                message.reason = 26;
                break;
            case "NETWORK_DISCONNECT_BADDELTATICK":
            case 27:
                message.reason = 27;
                break;
            case "NETWORK_DISCONNECT_NOMORESPLITS":
            case 28:
                message.reason = 28;
                break;
            case "NETWORK_DISCONNECT_TIMEDOUT":
            case 29:
                message.reason = 29;
                break;
            case "NETWORK_DISCONNECT_DISCONNECTED":
            case 30:
                message.reason = 30;
                break;
            case "NETWORK_DISCONNECT_LEAVINGSPLIT":
            case 31:
                message.reason = 31;
                break;
            case "NETWORK_DISCONNECT_DIFFERENTCLASSTABLES":
            case 32:
                message.reason = 32;
                break;
            case "NETWORK_DISCONNECT_BADRELAYPASSWORD":
            case 33:
                message.reason = 33;
                break;
            case "NETWORK_DISCONNECT_BADSPECTATORPASSWORD":
            case 34:
                message.reason = 34;
                break;
            case "NETWORK_DISCONNECT_HLTVRESTRICTED":
            case 35:
                message.reason = 35;
                break;
            case "NETWORK_DISCONNECT_NOSPECTATORS":
            case 36:
                message.reason = 36;
                break;
            case "NETWORK_DISCONNECT_HLTVUNAVAILABLE":
            case 37:
                message.reason = 37;
                break;
            case "NETWORK_DISCONNECT_HLTVSTOP":
            case 38:
                message.reason = 38;
                break;
            case "NETWORK_DISCONNECT_KICKED":
            case 39:
                message.reason = 39;
                break;
            case "NETWORK_DISCONNECT_BANADDED":
            case 40:
                message.reason = 40;
                break;
            case "NETWORK_DISCONNECT_KICKBANADDED":
            case 41:
                message.reason = 41;
                break;
            case "NETWORK_DISCONNECT_HLTVDIRECT":
            case 42:
                message.reason = 42;
                break;
            case "NETWORK_DISCONNECT_PURESERVER_CLIENTEXTRA":
            case 43:
                message.reason = 43;
                break;
            case "NETWORK_DISCONNECT_PURESERVER_MISMATCH":
            case 44:
                message.reason = 44;
                break;
            case "NETWORK_DISCONNECT_USERCMD":
            case 45:
                message.reason = 45;
                break;
            case "NETWORK_DISCONNECT_REJECTED_BY_GAME":
            case 46:
                message.reason = 46;
                break;
            case "NETWORK_DISCONNECT_MESSAGE_PARSE_ERROR":
            case 47:
                message.reason = 47;
                break;
            case "NETWORK_DISCONNECT_INVALID_MESSAGE_ERROR":
            case 48:
                message.reason = 48;
                break;
            case "NETWORK_DISCONNECT_BAD_SERVER_PASSWORD":
            case 49:
                message.reason = 49;
                break;
            case "NETWORK_DISCONNECT_DIRECT_CONNECT_RESERVATION":
            case 50:
                message.reason = 50;
                break;
            case "NETWORK_DISCONNECT_CONNECTION_FAILURE":
            case 51:
                message.reason = 51;
                break;
            case "NETWORK_DISCONNECT_NO_PEER_GROUP_HANDLERS":
            case 52:
                message.reason = 52;
                break;
            case "NETWORK_DISCONNECT_RECONNECTION":
            case 53:
                message.reason = 53;
                break;
            case "NETWORK_DISCONNECT_LOOPSHUTDOWN":
            case 54:
                message.reason = 54;
                break;
            case "NETWORK_DISCONNECT_LOOPDEACTIVATE":
            case 55:
                message.reason = 55;
                break;
            case "NETWORK_DISCONNECT_HOST_ENDGAME":
            case 56:
                message.reason = 56;
                break;
            case "NETWORK_DISCONNECT_LOOP_LEVELLOAD_ACTIVATE":
            case 57:
                message.reason = 57;
                break;
            case "NETWORK_DISCONNECT_CREATE_SERVER_FAILED":
            case 58:
                message.reason = 58;
                break;
            case "NETWORK_DISCONNECT_EXITING":
            case 59:
                message.reason = 59;
                break;
            case "NETWORK_DISCONNECT_REQUEST_HOSTSTATE_IDLE":
            case 60:
                message.reason = 60;
                break;
            case "NETWORK_DISCONNECT_REQUEST_HOSTSTATE_HLTVRELAY":
            case 61:
                message.reason = 61;
                break;
            case "NETWORK_DISCONNECT_CLIENT_CONSISTENCY_FAIL":
            case 62:
                message.reason = 62;
                break;
            case "NETWORK_DISCONNECT_CLIENT_UNABLE_TO_CRC_MAP":
            case 63:
                message.reason = 63;
                break;
            case "NETWORK_DISCONNECT_CLIENT_NO_MAP":
            case 64:
                message.reason = 64;
                break;
            case "NETWORK_DISCONNECT_CLIENT_DIFFERENT_MAP":
            case 65:
                message.reason = 65;
                break;
            case "NETWORK_DISCONNECT_SERVER_REQUIRES_STEAM":
            case 66:
                message.reason = 66;
                break;
            case "NETWORK_DISCONNECT_STEAM_DENY_MISC":
            case 67:
                message.reason = 67;
                break;
            case "NETWORK_DISCONNECT_STEAM_DENY_BAD_ANTI_CHEAT":
            case 68:
                message.reason = 68;
                break;
            case "NETWORK_DISCONNECT_SERVER_SHUTDOWN":
            case 69:
                message.reason = 69;
                break;
            case "NETWORK_DISCONNECT_REPLAY_INCOMPATIBLE":
            case 71:
                message.reason = 71;
                break;
            case "NETWORK_DISCONNECT_CONNECT_REQUEST_TIMEDOUT":
            case 72:
                message.reason = 72;
                break;
            case "NETWORK_DISCONNECT_SERVER_INCOMPATIBLE":
            case 73:
                message.reason = 73;
                break;
            case "NETWORK_DISCONNECT_LOCALPROBLEM_MANYRELAYS":
            case 74:
                message.reason = 74;
                break;
            case "NETWORK_DISCONNECT_LOCALPROBLEM_HOSTEDSERVERPRIMARYRELAY":
            case 75:
                message.reason = 75;
                break;
            case "NETWORK_DISCONNECT_LOCALPROBLEM_NETWORKCONFIG":
            case 76:
                message.reason = 76;
                break;
            case "NETWORK_DISCONNECT_LOCALPROBLEM_OTHER":
            case 77:
                message.reason = 77;
                break;
            case "NETWORK_DISCONNECT_REMOTE_TIMEOUT":
            case 79:
                message.reason = 79;
                break;
            case "NETWORK_DISCONNECT_REMOTE_TIMEOUT_CONNECTING":
            case 80:
                message.reason = 80;
                break;
            case "NETWORK_DISCONNECT_REMOTE_OTHER":
            case 81:
                message.reason = 81;
                break;
            case "NETWORK_DISCONNECT_REMOTE_BADCRYPT":
            case 82:
                message.reason = 82;
                break;
            case "NETWORK_DISCONNECT_REMOTE_CERTNOTTRUSTED":
            case 83:
                message.reason = 83;
                break;
            case "NETWORK_DISCONNECT_UNUSUAL":
            case 84:
                message.reason = 84;
                break;
            case "NETWORK_DISCONNECT_INTERNAL_ERROR":
            case 85:
                message.reason = 85;
                break;
            case "NETWORK_DISCONNECT_REJECT_BADCHALLENGE":
            case 128:
                message.reason = 128;
                break;
            case "NETWORK_DISCONNECT_REJECT_NOLOBBY":
            case 129:
                message.reason = 129;
                break;
            case "NETWORK_DISCONNECT_REJECT_BACKGROUND_MAP":
            case 130:
                message.reason = 130;
                break;
            case "NETWORK_DISCONNECT_REJECT_SINGLE_PLAYER":
            case 131:
                message.reason = 131;
                break;
            case "NETWORK_DISCONNECT_REJECT_HIDDEN_GAME":
            case 132:
                message.reason = 132;
                break;
            case "NETWORK_DISCONNECT_REJECT_LANRESTRICT":
            case 133:
                message.reason = 133;
                break;
            case "NETWORK_DISCONNECT_REJECT_BADPASSWORD":
            case 134:
                message.reason = 134;
                break;
            case "NETWORK_DISCONNECT_REJECT_SERVERFULL":
            case 135:
                message.reason = 135;
                break;
            case "NETWORK_DISCONNECT_REJECT_INVALIDRESERVATION":
            case 136:
                message.reason = 136;
                break;
            case "NETWORK_DISCONNECT_REJECT_FAILEDCHANNEL":
            case 137:
                message.reason = 137;
                break;
            case "NETWORK_DISCONNECT_REJECT_CONNECT_FROM_LOBBY":
            case 138:
                message.reason = 138;
                break;
            case "NETWORK_DISCONNECT_REJECT_RESERVED_FOR_LOBBY":
            case 139:
                message.reason = 139;
                break;
            case "NETWORK_DISCONNECT_REJECT_INVALIDKEYLENGTH":
            case 140:
                message.reason = 140;
                break;
            case "NETWORK_DISCONNECT_REJECT_OLDPROTOCOL":
            case 141:
                message.reason = 141;
                break;
            case "NETWORK_DISCONNECT_REJECT_NEWPROTOCOL":
            case 142:
                message.reason = 142;
                break;
            case "NETWORK_DISCONNECT_REJECT_INVALIDCONNECTION":
            case 143:
                message.reason = 143;
                break;
            case "NETWORK_DISCONNECT_REJECT_INVALIDCERTLEN":
            case 144:
                message.reason = 144;
                break;
            case "NETWORK_DISCONNECT_REJECT_INVALIDSTEAMCERTLEN":
            case 145:
                message.reason = 145;
                break;
            case "NETWORK_DISCONNECT_REJECT_STEAM":
            case 146:
                message.reason = 146;
                break;
            case "NETWORK_DISCONNECT_REJECT_SERVERAUTHDISABLED":
            case 147:
                message.reason = 147;
                break;
            case "NETWORK_DISCONNECT_REJECT_SERVERCDKEYAUTHINVALID":
            case 148:
                message.reason = 148;
                break;
            case "NETWORK_DISCONNECT_REJECT_BANNED":
            case 149:
                message.reason = 149;
                break;
            case "NETWORK_DISCONNECT_KICKED_TEAMKILLING":
            case 150:
                message.reason = 150;
                break;
            case "NETWORK_DISCONNECT_KICKED_TK_START":
            case 151:
                message.reason = 151;
                break;
            case "NETWORK_DISCONNECT_KICKED_UNTRUSTEDACCOUNT":
            case 152:
                message.reason = 152;
                break;
            case "NETWORK_DISCONNECT_KICKED_CONVICTEDACCOUNT":
            case 153:
                message.reason = 153;
                break;
            case "NETWORK_DISCONNECT_KICKED_COMPETITIVECOOLDOWN":
            case 154:
                message.reason = 154;
                break;
            case "NETWORK_DISCONNECT_KICKED_TEAMHURTING":
            case 155:
                message.reason = 155;
                break;
            case "NETWORK_DISCONNECT_KICKED_HOSTAGEKILLING":
            case 156:
                message.reason = 156;
                break;
            case "NETWORK_DISCONNECT_KICKED_VOTEDOFF":
            case 157:
                message.reason = 157;
                break;
            case "NETWORK_DISCONNECT_KICKED_IDLE":
            case 158:
                message.reason = 158;
                break;
            case "NETWORK_DISCONNECT_KICKED_SUICIDE":
            case 159:
                message.reason = 159;
                break;
            case "NETWORK_DISCONNECT_KICKED_NOSTEAMLOGIN":
            case 160:
                message.reason = 160;
                break;
            case "NETWORK_DISCONNECT_KICKED_NOSTEAMTICKET":
            case 161:
                message.reason = 161;
                break;
            }
            return message;
        };
    
        /**
         * Creates a plain object from a CNETMsg_Disconnect message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CNETMsg_Disconnect
         * @static
         * @param {CNETMsg_Disconnect} message CNETMsg_Disconnect
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CNETMsg_Disconnect.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.reason = options.enums === String ? "NETWORK_DISCONNECT_INVALID" : 0;
            if (message.reason != null && message.hasOwnProperty("reason"))
                object.reason = options.enums === String ? $root.ENetworkDisconnectionReason[message.reason] === undefined ? message.reason : $root.ENetworkDisconnectionReason[message.reason] : message.reason;
            return object;
        };
    
        /**
         * Converts this CNETMsg_Disconnect to JSON.
         * @function toJSON
         * @memberof CNETMsg_Disconnect
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CNETMsg_Disconnect.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * Gets the default type url for CNETMsg_Disconnect
         * @function getTypeUrl
         * @memberof CNETMsg_Disconnect
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        CNETMsg_Disconnect.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/CNETMsg_Disconnect";
        };
    
        return CNETMsg_Disconnect;
    })();
    
    $root.CNETMsg_Tick = (function() {
    
        /**
         * Properties of a CNETMsg_Tick.
         * @exports ICNETMsg_Tick
         * @interface ICNETMsg_Tick
         * @property {number|null} [tick] CNETMsg_Tick tick
         * @property {number|null} [hostFrametime] CNETMsg_Tick hostFrametime
         * @property {number|null} [hostFrametimeStdDeviation] CNETMsg_Tick hostFrametimeStdDeviation
         * @property {number|null} [hostComputationtime] CNETMsg_Tick hostComputationtime
         * @property {number|null} [hostComputationtimeStdDeviation] CNETMsg_Tick hostComputationtimeStdDeviation
         * @property {number|null} [hostFramestarttimeStdDeviation] CNETMsg_Tick hostFramestarttimeStdDeviation
         * @property {number|null} [hostLoss] CNETMsg_Tick hostLoss
         * @property {number|null} [hostUnfilteredFrametime] CNETMsg_Tick hostUnfilteredFrametime
         * @property {number|null} [hltvReplayFlags] CNETMsg_Tick hltvReplayFlags
         */
    
        /**
         * Constructs a new CNETMsg_Tick.
         * @exports CNETMsg_Tick
         * @classdesc Represents a CNETMsg_Tick.
         * @implements ICNETMsg_Tick
         * @constructor
         * @param {ICNETMsg_Tick=} [properties] Properties to set
         */
        function CNETMsg_Tick(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CNETMsg_Tick tick.
         * @member {number} tick
         * @memberof CNETMsg_Tick
         * @instance
         */
        CNETMsg_Tick.prototype.tick = 0;
    
        /**
         * CNETMsg_Tick hostFrametime.
         * @member {number} hostFrametime
         * @memberof CNETMsg_Tick
         * @instance
         */
        CNETMsg_Tick.prototype.hostFrametime = 0;
    
        /**
         * CNETMsg_Tick hostFrametimeStdDeviation.
         * @member {number} hostFrametimeStdDeviation
         * @memberof CNETMsg_Tick
         * @instance
         */
        CNETMsg_Tick.prototype.hostFrametimeStdDeviation = 0;
    
        /**
         * CNETMsg_Tick hostComputationtime.
         * @member {number} hostComputationtime
         * @memberof CNETMsg_Tick
         * @instance
         */
        CNETMsg_Tick.prototype.hostComputationtime = 0;
    
        /**
         * CNETMsg_Tick hostComputationtimeStdDeviation.
         * @member {number} hostComputationtimeStdDeviation
         * @memberof CNETMsg_Tick
         * @instance
         */
        CNETMsg_Tick.prototype.hostComputationtimeStdDeviation = 0;
    
        /**
         * CNETMsg_Tick hostFramestarttimeStdDeviation.
         * @member {number} hostFramestarttimeStdDeviation
         * @memberof CNETMsg_Tick
         * @instance
         */
        CNETMsg_Tick.prototype.hostFramestarttimeStdDeviation = 0;
    
        /**
         * CNETMsg_Tick hostLoss.
         * @member {number} hostLoss
         * @memberof CNETMsg_Tick
         * @instance
         */
        CNETMsg_Tick.prototype.hostLoss = 0;
    
        /**
         * CNETMsg_Tick hostUnfilteredFrametime.
         * @member {number} hostUnfilteredFrametime
         * @memberof CNETMsg_Tick
         * @instance
         */
        CNETMsg_Tick.prototype.hostUnfilteredFrametime = 0;
    
        /**
         * CNETMsg_Tick hltvReplayFlags.
         * @member {number} hltvReplayFlags
         * @memberof CNETMsg_Tick
         * @instance
         */
        CNETMsg_Tick.prototype.hltvReplayFlags = 0;
    
        /**
         * Creates a new CNETMsg_Tick instance using the specified properties.
         * @function create
         * @memberof CNETMsg_Tick
         * @static
         * @param {ICNETMsg_Tick=} [properties] Properties to set
         * @returns {CNETMsg_Tick} CNETMsg_Tick instance
         */
        CNETMsg_Tick.create = function create(properties) {
            return new CNETMsg_Tick(properties);
        };
    
        /**
         * Encodes the specified CNETMsg_Tick message. Does not implicitly {@link CNETMsg_Tick.verify|verify} messages.
         * @function encode
         * @memberof CNETMsg_Tick
         * @static
         * @param {ICNETMsg_Tick} message CNETMsg_Tick message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CNETMsg_Tick.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.tick != null && Object.hasOwnProperty.call(message, "tick"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.tick);
            if (message.hostFrametime != null && Object.hasOwnProperty.call(message, "hostFrametime"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.hostFrametime);
            if (message.hostFrametimeStdDeviation != null && Object.hasOwnProperty.call(message, "hostFrametimeStdDeviation"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.hostFrametimeStdDeviation);
            if (message.hostComputationtime != null && Object.hasOwnProperty.call(message, "hostComputationtime"))
                writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.hostComputationtime);
            if (message.hostComputationtimeStdDeviation != null && Object.hasOwnProperty.call(message, "hostComputationtimeStdDeviation"))
                writer.uint32(/* id 5, wireType 0 =*/40).uint32(message.hostComputationtimeStdDeviation);
            if (message.hostFramestarttimeStdDeviation != null && Object.hasOwnProperty.call(message, "hostFramestarttimeStdDeviation"))
                writer.uint32(/* id 6, wireType 0 =*/48).uint32(message.hostFramestarttimeStdDeviation);
            if (message.hostLoss != null && Object.hasOwnProperty.call(message, "hostLoss"))
                writer.uint32(/* id 7, wireType 0 =*/56).uint32(message.hostLoss);
            if (message.hostUnfilteredFrametime != null && Object.hasOwnProperty.call(message, "hostUnfilteredFrametime"))
                writer.uint32(/* id 8, wireType 0 =*/64).uint32(message.hostUnfilteredFrametime);
            if (message.hltvReplayFlags != null && Object.hasOwnProperty.call(message, "hltvReplayFlags"))
                writer.uint32(/* id 9, wireType 0 =*/72).uint32(message.hltvReplayFlags);
            return writer;
        };
    
        /**
         * Encodes the specified CNETMsg_Tick message, length delimited. Does not implicitly {@link CNETMsg_Tick.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CNETMsg_Tick
         * @static
         * @param {ICNETMsg_Tick} message CNETMsg_Tick message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CNETMsg_Tick.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CNETMsg_Tick message from the specified reader or buffer.
         * @function decode
         * @memberof CNETMsg_Tick
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CNETMsg_Tick} CNETMsg_Tick
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CNETMsg_Tick.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CNETMsg_Tick();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.tick = reader.uint32();
                        break;
                    }
                case 2: {
                        message.hostFrametime = reader.uint32();
                        break;
                    }
                case 3: {
                        message.hostFrametimeStdDeviation = reader.uint32();
                        break;
                    }
                case 4: {
                        message.hostComputationtime = reader.uint32();
                        break;
                    }
                case 5: {
                        message.hostComputationtimeStdDeviation = reader.uint32();
                        break;
                    }
                case 6: {
                        message.hostFramestarttimeStdDeviation = reader.uint32();
                        break;
                    }
                case 7: {
                        message.hostLoss = reader.uint32();
                        break;
                    }
                case 8: {
                        message.hostUnfilteredFrametime = reader.uint32();
                        break;
                    }
                case 9: {
                        message.hltvReplayFlags = reader.uint32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CNETMsg_Tick message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CNETMsg_Tick
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CNETMsg_Tick} CNETMsg_Tick
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CNETMsg_Tick.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CNETMsg_Tick message.
         * @function verify
         * @memberof CNETMsg_Tick
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CNETMsg_Tick.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.tick != null && message.hasOwnProperty("tick"))
                if (!$util.isInteger(message.tick))
                    return "tick: integer expected";
            if (message.hostFrametime != null && message.hasOwnProperty("hostFrametime"))
                if (!$util.isInteger(message.hostFrametime))
                    return "hostFrametime: integer expected";
            if (message.hostFrametimeStdDeviation != null && message.hasOwnProperty("hostFrametimeStdDeviation"))
                if (!$util.isInteger(message.hostFrametimeStdDeviation))
                    return "hostFrametimeStdDeviation: integer expected";
            if (message.hostComputationtime != null && message.hasOwnProperty("hostComputationtime"))
                if (!$util.isInteger(message.hostComputationtime))
                    return "hostComputationtime: integer expected";
            if (message.hostComputationtimeStdDeviation != null && message.hasOwnProperty("hostComputationtimeStdDeviation"))
                if (!$util.isInteger(message.hostComputationtimeStdDeviation))
                    return "hostComputationtimeStdDeviation: integer expected";
            if (message.hostFramestarttimeStdDeviation != null && message.hasOwnProperty("hostFramestarttimeStdDeviation"))
                if (!$util.isInteger(message.hostFramestarttimeStdDeviation))
                    return "hostFramestarttimeStdDeviation: integer expected";
            if (message.hostLoss != null && message.hasOwnProperty("hostLoss"))
                if (!$util.isInteger(message.hostLoss))
                    return "hostLoss: integer expected";
            if (message.hostUnfilteredFrametime != null && message.hasOwnProperty("hostUnfilteredFrametime"))
                if (!$util.isInteger(message.hostUnfilteredFrametime))
                    return "hostUnfilteredFrametime: integer expected";
            if (message.hltvReplayFlags != null && message.hasOwnProperty("hltvReplayFlags"))
                if (!$util.isInteger(message.hltvReplayFlags))
                    return "hltvReplayFlags: integer expected";
            return null;
        };
    
        /**
         * Creates a CNETMsg_Tick message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CNETMsg_Tick
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CNETMsg_Tick} CNETMsg_Tick
         */
        CNETMsg_Tick.fromObject = function fromObject(object) {
            if (object instanceof $root.CNETMsg_Tick)
                return object;
            var message = new $root.CNETMsg_Tick();
            if (object.tick != null)
                message.tick = object.tick >>> 0;
            if (object.hostFrametime != null)
                message.hostFrametime = object.hostFrametime >>> 0;
            if (object.hostFrametimeStdDeviation != null)
                message.hostFrametimeStdDeviation = object.hostFrametimeStdDeviation >>> 0;
            if (object.hostComputationtime != null)
                message.hostComputationtime = object.hostComputationtime >>> 0;
            if (object.hostComputationtimeStdDeviation != null)
                message.hostComputationtimeStdDeviation = object.hostComputationtimeStdDeviation >>> 0;
            if (object.hostFramestarttimeStdDeviation != null)
                message.hostFramestarttimeStdDeviation = object.hostFramestarttimeStdDeviation >>> 0;
            if (object.hostLoss != null)
                message.hostLoss = object.hostLoss >>> 0;
            if (object.hostUnfilteredFrametime != null)
                message.hostUnfilteredFrametime = object.hostUnfilteredFrametime >>> 0;
            if (object.hltvReplayFlags != null)
                message.hltvReplayFlags = object.hltvReplayFlags >>> 0;
            return message;
        };
    
        /**
         * Creates a plain object from a CNETMsg_Tick message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CNETMsg_Tick
         * @static
         * @param {CNETMsg_Tick} message CNETMsg_Tick
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CNETMsg_Tick.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.tick = 0;
                object.hostFrametime = 0;
                object.hostFrametimeStdDeviation = 0;
                object.hostComputationtime = 0;
                object.hostComputationtimeStdDeviation = 0;
                object.hostFramestarttimeStdDeviation = 0;
                object.hostLoss = 0;
                object.hostUnfilteredFrametime = 0;
                object.hltvReplayFlags = 0;
            }
            if (message.tick != null && message.hasOwnProperty("tick"))
                object.tick = message.tick;
            if (message.hostFrametime != null && message.hasOwnProperty("hostFrametime"))
                object.hostFrametime = message.hostFrametime;
            if (message.hostFrametimeStdDeviation != null && message.hasOwnProperty("hostFrametimeStdDeviation"))
                object.hostFrametimeStdDeviation = message.hostFrametimeStdDeviation;
            if (message.hostComputationtime != null && message.hasOwnProperty("hostComputationtime"))
                object.hostComputationtime = message.hostComputationtime;
            if (message.hostComputationtimeStdDeviation != null && message.hasOwnProperty("hostComputationtimeStdDeviation"))
                object.hostComputationtimeStdDeviation = message.hostComputationtimeStdDeviation;
            if (message.hostFramestarttimeStdDeviation != null && message.hasOwnProperty("hostFramestarttimeStdDeviation"))
                object.hostFramestarttimeStdDeviation = message.hostFramestarttimeStdDeviation;
            if (message.hostLoss != null && message.hasOwnProperty("hostLoss"))
                object.hostLoss = message.hostLoss;
            if (message.hostUnfilteredFrametime != null && message.hasOwnProperty("hostUnfilteredFrametime"))
                object.hostUnfilteredFrametime = message.hostUnfilteredFrametime;
            if (message.hltvReplayFlags != null && message.hasOwnProperty("hltvReplayFlags"))
                object.hltvReplayFlags = message.hltvReplayFlags;
            return object;
        };
    
        /**
         * Converts this CNETMsg_Tick to JSON.
         * @function toJSON
         * @memberof CNETMsg_Tick
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CNETMsg_Tick.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * Gets the default type url for CNETMsg_Tick
         * @function getTypeUrl
         * @memberof CNETMsg_Tick
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        CNETMsg_Tick.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/CNETMsg_Tick";
        };
    
        return CNETMsg_Tick;
    })();
    
    $root.CNETMsg_StringCmd = (function() {
    
        /**
         * Properties of a CNETMsg_StringCmd.
         * @exports ICNETMsg_StringCmd
         * @interface ICNETMsg_StringCmd
         * @property {string|null} [command] CNETMsg_StringCmd command
         * @property {number|null} [predictionSync] CNETMsg_StringCmd predictionSync
         */
    
        /**
         * Constructs a new CNETMsg_StringCmd.
         * @exports CNETMsg_StringCmd
         * @classdesc Represents a CNETMsg_StringCmd.
         * @implements ICNETMsg_StringCmd
         * @constructor
         * @param {ICNETMsg_StringCmd=} [properties] Properties to set
         */
        function CNETMsg_StringCmd(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CNETMsg_StringCmd command.
         * @member {string} command
         * @memberof CNETMsg_StringCmd
         * @instance
         */
        CNETMsg_StringCmd.prototype.command = "";
    
        /**
         * CNETMsg_StringCmd predictionSync.
         * @member {number} predictionSync
         * @memberof CNETMsg_StringCmd
         * @instance
         */
        CNETMsg_StringCmd.prototype.predictionSync = 0;
    
        /**
         * Creates a new CNETMsg_StringCmd instance using the specified properties.
         * @function create
         * @memberof CNETMsg_StringCmd
         * @static
         * @param {ICNETMsg_StringCmd=} [properties] Properties to set
         * @returns {CNETMsg_StringCmd} CNETMsg_StringCmd instance
         */
        CNETMsg_StringCmd.create = function create(properties) {
            return new CNETMsg_StringCmd(properties);
        };
    
        /**
         * Encodes the specified CNETMsg_StringCmd message. Does not implicitly {@link CNETMsg_StringCmd.verify|verify} messages.
         * @function encode
         * @memberof CNETMsg_StringCmd
         * @static
         * @param {ICNETMsg_StringCmd} message CNETMsg_StringCmd message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CNETMsg_StringCmd.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.command != null && Object.hasOwnProperty.call(message, "command"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.command);
            if (message.predictionSync != null && Object.hasOwnProperty.call(message, "predictionSync"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.predictionSync);
            return writer;
        };
    
        /**
         * Encodes the specified CNETMsg_StringCmd message, length delimited. Does not implicitly {@link CNETMsg_StringCmd.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CNETMsg_StringCmd
         * @static
         * @param {ICNETMsg_StringCmd} message CNETMsg_StringCmd message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CNETMsg_StringCmd.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CNETMsg_StringCmd message from the specified reader or buffer.
         * @function decode
         * @memberof CNETMsg_StringCmd
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CNETMsg_StringCmd} CNETMsg_StringCmd
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CNETMsg_StringCmd.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CNETMsg_StringCmd();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.command = reader.string();
                        break;
                    }
                case 2: {
                        message.predictionSync = reader.uint32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CNETMsg_StringCmd message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CNETMsg_StringCmd
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CNETMsg_StringCmd} CNETMsg_StringCmd
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CNETMsg_StringCmd.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CNETMsg_StringCmd message.
         * @function verify
         * @memberof CNETMsg_StringCmd
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CNETMsg_StringCmd.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.command != null && message.hasOwnProperty("command"))
                if (!$util.isString(message.command))
                    return "command: string expected";
            if (message.predictionSync != null && message.hasOwnProperty("predictionSync"))
                if (!$util.isInteger(message.predictionSync))
                    return "predictionSync: integer expected";
            return null;
        };
    
        /**
         * Creates a CNETMsg_StringCmd message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CNETMsg_StringCmd
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CNETMsg_StringCmd} CNETMsg_StringCmd
         */
        CNETMsg_StringCmd.fromObject = function fromObject(object) {
            if (object instanceof $root.CNETMsg_StringCmd)
                return object;
            var message = new $root.CNETMsg_StringCmd();
            if (object.command != null)
                message.command = String(object.command);
            if (object.predictionSync != null)
                message.predictionSync = object.predictionSync >>> 0;
            return message;
        };
    
        /**
         * Creates a plain object from a CNETMsg_StringCmd message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CNETMsg_StringCmd
         * @static
         * @param {CNETMsg_StringCmd} message CNETMsg_StringCmd
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CNETMsg_StringCmd.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.command = "";
                object.predictionSync = 0;
            }
            if (message.command != null && message.hasOwnProperty("command"))
                object.command = message.command;
            if (message.predictionSync != null && message.hasOwnProperty("predictionSync"))
                object.predictionSync = message.predictionSync;
            return object;
        };
    
        /**
         * Converts this CNETMsg_StringCmd to JSON.
         * @function toJSON
         * @memberof CNETMsg_StringCmd
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CNETMsg_StringCmd.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * Gets the default type url for CNETMsg_StringCmd
         * @function getTypeUrl
         * @memberof CNETMsg_StringCmd
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        CNETMsg_StringCmd.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/CNETMsg_StringCmd";
        };
    
        return CNETMsg_StringCmd;
    })();
    
    $root.CNETMsg_SetConVar = (function() {
    
        /**
         * Properties of a CNETMsg_SetConVar.
         * @exports ICNETMsg_SetConVar
         * @interface ICNETMsg_SetConVar
         * @property {ICMsg_CVars|null} [convars] CNETMsg_SetConVar convars
         */
    
        /**
         * Constructs a new CNETMsg_SetConVar.
         * @exports CNETMsg_SetConVar
         * @classdesc Represents a CNETMsg_SetConVar.
         * @implements ICNETMsg_SetConVar
         * @constructor
         * @param {ICNETMsg_SetConVar=} [properties] Properties to set
         */
        function CNETMsg_SetConVar(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CNETMsg_SetConVar convars.
         * @member {ICMsg_CVars|null|undefined} convars
         * @memberof CNETMsg_SetConVar
         * @instance
         */
        CNETMsg_SetConVar.prototype.convars = null;
    
        /**
         * Creates a new CNETMsg_SetConVar instance using the specified properties.
         * @function create
         * @memberof CNETMsg_SetConVar
         * @static
         * @param {ICNETMsg_SetConVar=} [properties] Properties to set
         * @returns {CNETMsg_SetConVar} CNETMsg_SetConVar instance
         */
        CNETMsg_SetConVar.create = function create(properties) {
            return new CNETMsg_SetConVar(properties);
        };
    
        /**
         * Encodes the specified CNETMsg_SetConVar message. Does not implicitly {@link CNETMsg_SetConVar.verify|verify} messages.
         * @function encode
         * @memberof CNETMsg_SetConVar
         * @static
         * @param {ICNETMsg_SetConVar} message CNETMsg_SetConVar message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CNETMsg_SetConVar.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.convars != null && Object.hasOwnProperty.call(message, "convars"))
                $root.CMsg_CVars.encode(message.convars, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };
    
        /**
         * Encodes the specified CNETMsg_SetConVar message, length delimited. Does not implicitly {@link CNETMsg_SetConVar.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CNETMsg_SetConVar
         * @static
         * @param {ICNETMsg_SetConVar} message CNETMsg_SetConVar message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CNETMsg_SetConVar.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CNETMsg_SetConVar message from the specified reader or buffer.
         * @function decode
         * @memberof CNETMsg_SetConVar
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CNETMsg_SetConVar} CNETMsg_SetConVar
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CNETMsg_SetConVar.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CNETMsg_SetConVar();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.convars = $root.CMsg_CVars.decode(reader, reader.uint32());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CNETMsg_SetConVar message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CNETMsg_SetConVar
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CNETMsg_SetConVar} CNETMsg_SetConVar
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CNETMsg_SetConVar.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CNETMsg_SetConVar message.
         * @function verify
         * @memberof CNETMsg_SetConVar
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CNETMsg_SetConVar.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.convars != null && message.hasOwnProperty("convars")) {
                var error = $root.CMsg_CVars.verify(message.convars);
                if (error)
                    return "convars." + error;
            }
            return null;
        };
    
        /**
         * Creates a CNETMsg_SetConVar message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CNETMsg_SetConVar
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CNETMsg_SetConVar} CNETMsg_SetConVar
         */
        CNETMsg_SetConVar.fromObject = function fromObject(object) {
            if (object instanceof $root.CNETMsg_SetConVar)
                return object;
            var message = new $root.CNETMsg_SetConVar();
            if (object.convars != null) {
                if (typeof object.convars !== "object")
                    throw TypeError(".CNETMsg_SetConVar.convars: object expected");
                message.convars = $root.CMsg_CVars.fromObject(object.convars);
            }
            return message;
        };
    
        /**
         * Creates a plain object from a CNETMsg_SetConVar message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CNETMsg_SetConVar
         * @static
         * @param {CNETMsg_SetConVar} message CNETMsg_SetConVar
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CNETMsg_SetConVar.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.convars = null;
            if (message.convars != null && message.hasOwnProperty("convars"))
                object.convars = $root.CMsg_CVars.toObject(message.convars, options);
            return object;
        };
    
        /**
         * Converts this CNETMsg_SetConVar to JSON.
         * @function toJSON
         * @memberof CNETMsg_SetConVar
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CNETMsg_SetConVar.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * Gets the default type url for CNETMsg_SetConVar
         * @function getTypeUrl
         * @memberof CNETMsg_SetConVar
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        CNETMsg_SetConVar.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/CNETMsg_SetConVar";
        };
    
        return CNETMsg_SetConVar;
    })();
    
    $root.CNETMsg_SignonState = (function() {
    
        /**
         * Properties of a CNETMsg_SignonState.
         * @exports ICNETMsg_SignonState
         * @interface ICNETMsg_SignonState
         * @property {SignonState_t|null} [signonState] CNETMsg_SignonState signonState
         * @property {number|null} [spawnCount] CNETMsg_SignonState spawnCount
         * @property {number|null} [numServerPlayers] CNETMsg_SignonState numServerPlayers
         * @property {Array.<string>|null} [playersNetworkids] CNETMsg_SignonState playersNetworkids
         * @property {string|null} [mapName] CNETMsg_SignonState mapName
         * @property {string|null} [addons] CNETMsg_SignonState addons
         */
    
        /**
         * Constructs a new CNETMsg_SignonState.
         * @exports CNETMsg_SignonState
         * @classdesc Represents a CNETMsg_SignonState.
         * @implements ICNETMsg_SignonState
         * @constructor
         * @param {ICNETMsg_SignonState=} [properties] Properties to set
         */
        function CNETMsg_SignonState(properties) {
            this.playersNetworkids = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CNETMsg_SignonState signonState.
         * @member {SignonState_t} signonState
         * @memberof CNETMsg_SignonState
         * @instance
         */
        CNETMsg_SignonState.prototype.signonState = 0;
    
        /**
         * CNETMsg_SignonState spawnCount.
         * @member {number} spawnCount
         * @memberof CNETMsg_SignonState
         * @instance
         */
        CNETMsg_SignonState.prototype.spawnCount = 0;
    
        /**
         * CNETMsg_SignonState numServerPlayers.
         * @member {number} numServerPlayers
         * @memberof CNETMsg_SignonState
         * @instance
         */
        CNETMsg_SignonState.prototype.numServerPlayers = 0;
    
        /**
         * CNETMsg_SignonState playersNetworkids.
         * @member {Array.<string>} playersNetworkids
         * @memberof CNETMsg_SignonState
         * @instance
         */
        CNETMsg_SignonState.prototype.playersNetworkids = $util.emptyArray;
    
        /**
         * CNETMsg_SignonState mapName.
         * @member {string} mapName
         * @memberof CNETMsg_SignonState
         * @instance
         */
        CNETMsg_SignonState.prototype.mapName = "";
    
        /**
         * CNETMsg_SignonState addons.
         * @member {string} addons
         * @memberof CNETMsg_SignonState
         * @instance
         */
        CNETMsg_SignonState.prototype.addons = "";
    
        /**
         * Creates a new CNETMsg_SignonState instance using the specified properties.
         * @function create
         * @memberof CNETMsg_SignonState
         * @static
         * @param {ICNETMsg_SignonState=} [properties] Properties to set
         * @returns {CNETMsg_SignonState} CNETMsg_SignonState instance
         */
        CNETMsg_SignonState.create = function create(properties) {
            return new CNETMsg_SignonState(properties);
        };
    
        /**
         * Encodes the specified CNETMsg_SignonState message. Does not implicitly {@link CNETMsg_SignonState.verify|verify} messages.
         * @function encode
         * @memberof CNETMsg_SignonState
         * @static
         * @param {ICNETMsg_SignonState} message CNETMsg_SignonState message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CNETMsg_SignonState.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.signonState != null && Object.hasOwnProperty.call(message, "signonState"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.signonState);
            if (message.spawnCount != null && Object.hasOwnProperty.call(message, "spawnCount"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.spawnCount);
            if (message.numServerPlayers != null && Object.hasOwnProperty.call(message, "numServerPlayers"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.numServerPlayers);
            if (message.playersNetworkids != null && message.playersNetworkids.length)
                for (var i = 0; i < message.playersNetworkids.length; ++i)
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.playersNetworkids[i]);
            if (message.mapName != null && Object.hasOwnProperty.call(message, "mapName"))
                writer.uint32(/* id 5, wireType 2 =*/42).string(message.mapName);
            if (message.addons != null && Object.hasOwnProperty.call(message, "addons"))
                writer.uint32(/* id 6, wireType 2 =*/50).string(message.addons);
            return writer;
        };
    
        /**
         * Encodes the specified CNETMsg_SignonState message, length delimited. Does not implicitly {@link CNETMsg_SignonState.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CNETMsg_SignonState
         * @static
         * @param {ICNETMsg_SignonState} message CNETMsg_SignonState message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CNETMsg_SignonState.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CNETMsg_SignonState message from the specified reader or buffer.
         * @function decode
         * @memberof CNETMsg_SignonState
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CNETMsg_SignonState} CNETMsg_SignonState
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CNETMsg_SignonState.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CNETMsg_SignonState();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.signonState = reader.int32();
                        break;
                    }
                case 2: {
                        message.spawnCount = reader.uint32();
                        break;
                    }
                case 3: {
                        message.numServerPlayers = reader.uint32();
                        break;
                    }
                case 4: {
                        if (!(message.playersNetworkids && message.playersNetworkids.length))
                            message.playersNetworkids = [];
                        message.playersNetworkids.push(reader.string());
                        break;
                    }
                case 5: {
                        message.mapName = reader.string();
                        break;
                    }
                case 6: {
                        message.addons = reader.string();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CNETMsg_SignonState message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CNETMsg_SignonState
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CNETMsg_SignonState} CNETMsg_SignonState
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CNETMsg_SignonState.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CNETMsg_SignonState message.
         * @function verify
         * @memberof CNETMsg_SignonState
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CNETMsg_SignonState.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.signonState != null && message.hasOwnProperty("signonState"))
                switch (message.signonState) {
                default:
                    return "signonState: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                case 7:
                    break;
                }
            if (message.spawnCount != null && message.hasOwnProperty("spawnCount"))
                if (!$util.isInteger(message.spawnCount))
                    return "spawnCount: integer expected";
            if (message.numServerPlayers != null && message.hasOwnProperty("numServerPlayers"))
                if (!$util.isInteger(message.numServerPlayers))
                    return "numServerPlayers: integer expected";
            if (message.playersNetworkids != null && message.hasOwnProperty("playersNetworkids")) {
                if (!Array.isArray(message.playersNetworkids))
                    return "playersNetworkids: array expected";
                for (var i = 0; i < message.playersNetworkids.length; ++i)
                    if (!$util.isString(message.playersNetworkids[i]))
                        return "playersNetworkids: string[] expected";
            }
            if (message.mapName != null && message.hasOwnProperty("mapName"))
                if (!$util.isString(message.mapName))
                    return "mapName: string expected";
            if (message.addons != null && message.hasOwnProperty("addons"))
                if (!$util.isString(message.addons))
                    return "addons: string expected";
            return null;
        };
    
        /**
         * Creates a CNETMsg_SignonState message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CNETMsg_SignonState
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CNETMsg_SignonState} CNETMsg_SignonState
         */
        CNETMsg_SignonState.fromObject = function fromObject(object) {
            if (object instanceof $root.CNETMsg_SignonState)
                return object;
            var message = new $root.CNETMsg_SignonState();
            switch (object.signonState) {
            default:
                if (typeof object.signonState === "number") {
                    message.signonState = object.signonState;
                    break;
                }
                break;
            case "SIGNONSTATE_NONE":
            case 0:
                message.signonState = 0;
                break;
            case "SIGNONSTATE_CHALLENGE":
            case 1:
                message.signonState = 1;
                break;
            case "SIGNONSTATE_CONNECTED":
            case 2:
                message.signonState = 2;
                break;
            case "SIGNONSTATE_NEW":
            case 3:
                message.signonState = 3;
                break;
            case "SIGNONSTATE_PRESPAWN":
            case 4:
                message.signonState = 4;
                break;
            case "SIGNONSTATE_SPAWN":
            case 5:
                message.signonState = 5;
                break;
            case "SIGNONSTATE_FULL":
            case 6:
                message.signonState = 6;
                break;
            case "SIGNONSTATE_CHANGELEVEL":
            case 7:
                message.signonState = 7;
                break;
            }
            if (object.spawnCount != null)
                message.spawnCount = object.spawnCount >>> 0;
            if (object.numServerPlayers != null)
                message.numServerPlayers = object.numServerPlayers >>> 0;
            if (object.playersNetworkids) {
                if (!Array.isArray(object.playersNetworkids))
                    throw TypeError(".CNETMsg_SignonState.playersNetworkids: array expected");
                message.playersNetworkids = [];
                for (var i = 0; i < object.playersNetworkids.length; ++i)
                    message.playersNetworkids[i] = String(object.playersNetworkids[i]);
            }
            if (object.mapName != null)
                message.mapName = String(object.mapName);
            if (object.addons != null)
                message.addons = String(object.addons);
            return message;
        };
    
        /**
         * Creates a plain object from a CNETMsg_SignonState message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CNETMsg_SignonState
         * @static
         * @param {CNETMsg_SignonState} message CNETMsg_SignonState
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CNETMsg_SignonState.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.playersNetworkids = [];
            if (options.defaults) {
                object.signonState = options.enums === String ? "SIGNONSTATE_NONE" : 0;
                object.spawnCount = 0;
                object.numServerPlayers = 0;
                object.mapName = "";
                object.addons = "";
            }
            if (message.signonState != null && message.hasOwnProperty("signonState"))
                object.signonState = options.enums === String ? $root.SignonState_t[message.signonState] === undefined ? message.signonState : $root.SignonState_t[message.signonState] : message.signonState;
            if (message.spawnCount != null && message.hasOwnProperty("spawnCount"))
                object.spawnCount = message.spawnCount;
            if (message.numServerPlayers != null && message.hasOwnProperty("numServerPlayers"))
                object.numServerPlayers = message.numServerPlayers;
            if (message.playersNetworkids && message.playersNetworkids.length) {
                object.playersNetworkids = [];
                for (var j = 0; j < message.playersNetworkids.length; ++j)
                    object.playersNetworkids[j] = message.playersNetworkids[j];
            }
            if (message.mapName != null && message.hasOwnProperty("mapName"))
                object.mapName = message.mapName;
            if (message.addons != null && message.hasOwnProperty("addons"))
                object.addons = message.addons;
            return object;
        };
    
        /**
         * Converts this CNETMsg_SignonState to JSON.
         * @function toJSON
         * @memberof CNETMsg_SignonState
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CNETMsg_SignonState.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * Gets the default type url for CNETMsg_SignonState
         * @function getTypeUrl
         * @memberof CNETMsg_SignonState
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        CNETMsg_SignonState.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/CNETMsg_SignonState";
        };
    
        return CNETMsg_SignonState;
    })();
    
    $root.CSVCMsg_GameEvent = (function() {
    
        /**
         * Properties of a CSVCMsg_GameEvent.
         * @exports ICSVCMsg_GameEvent
         * @interface ICSVCMsg_GameEvent
         * @property {string|null} [eventName] CSVCMsg_GameEvent eventName
         * @property {number|null} [eventid] CSVCMsg_GameEvent eventid
         * @property {Array.<CSVCMsg_GameEvent.Ikey_t>|null} [keys] CSVCMsg_GameEvent keys
         */
    
        /**
         * Constructs a new CSVCMsg_GameEvent.
         * @exports CSVCMsg_GameEvent
         * @classdesc Represents a CSVCMsg_GameEvent.
         * @implements ICSVCMsg_GameEvent
         * @constructor
         * @param {ICSVCMsg_GameEvent=} [properties] Properties to set
         */
        function CSVCMsg_GameEvent(properties) {
            this.keys = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CSVCMsg_GameEvent eventName.
         * @member {string} eventName
         * @memberof CSVCMsg_GameEvent
         * @instance
         */
        CSVCMsg_GameEvent.prototype.eventName = "";
    
        /**
         * CSVCMsg_GameEvent eventid.
         * @member {number} eventid
         * @memberof CSVCMsg_GameEvent
         * @instance
         */
        CSVCMsg_GameEvent.prototype.eventid = 0;
    
        /**
         * CSVCMsg_GameEvent keys.
         * @member {Array.<CSVCMsg_GameEvent.Ikey_t>} keys
         * @memberof CSVCMsg_GameEvent
         * @instance
         */
        CSVCMsg_GameEvent.prototype.keys = $util.emptyArray;
    
        /**
         * Creates a new CSVCMsg_GameEvent instance using the specified properties.
         * @function create
         * @memberof CSVCMsg_GameEvent
         * @static
         * @param {ICSVCMsg_GameEvent=} [properties] Properties to set
         * @returns {CSVCMsg_GameEvent} CSVCMsg_GameEvent instance
         */
        CSVCMsg_GameEvent.create = function create(properties) {
            return new CSVCMsg_GameEvent(properties);
        };
    
        /**
         * Encodes the specified CSVCMsg_GameEvent message. Does not implicitly {@link CSVCMsg_GameEvent.verify|verify} messages.
         * @function encode
         * @memberof CSVCMsg_GameEvent
         * @static
         * @param {ICSVCMsg_GameEvent} message CSVCMsg_GameEvent message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CSVCMsg_GameEvent.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.eventName != null && Object.hasOwnProperty.call(message, "eventName"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.eventName);
            if (message.eventid != null && Object.hasOwnProperty.call(message, "eventid"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.eventid);
            if (message.keys != null && message.keys.length)
                for (var i = 0; i < message.keys.length; ++i)
                    $root.CSVCMsg_GameEvent.key_t.encode(message.keys[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            return writer;
        };
    
        /**
         * Encodes the specified CSVCMsg_GameEvent message, length delimited. Does not implicitly {@link CSVCMsg_GameEvent.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CSVCMsg_GameEvent
         * @static
         * @param {ICSVCMsg_GameEvent} message CSVCMsg_GameEvent message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CSVCMsg_GameEvent.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CSVCMsg_GameEvent message from the specified reader or buffer.
         * @function decode
         * @memberof CSVCMsg_GameEvent
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CSVCMsg_GameEvent} CSVCMsg_GameEvent
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CSVCMsg_GameEvent.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CSVCMsg_GameEvent();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.eventName = reader.string();
                        break;
                    }
                case 2: {
                        message.eventid = reader.int32();
                        break;
                    }
                case 3: {
                        if (!(message.keys && message.keys.length))
                            message.keys = [];
                        message.keys.push($root.CSVCMsg_GameEvent.key_t.decode(reader, reader.uint32()));
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CSVCMsg_GameEvent message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CSVCMsg_GameEvent
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CSVCMsg_GameEvent} CSVCMsg_GameEvent
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CSVCMsg_GameEvent.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CSVCMsg_GameEvent message.
         * @function verify
         * @memberof CSVCMsg_GameEvent
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CSVCMsg_GameEvent.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.eventName != null && message.hasOwnProperty("eventName"))
                if (!$util.isString(message.eventName))
                    return "eventName: string expected";
            if (message.eventid != null && message.hasOwnProperty("eventid"))
                if (!$util.isInteger(message.eventid))
                    return "eventid: integer expected";
            if (message.keys != null && message.hasOwnProperty("keys")) {
                if (!Array.isArray(message.keys))
                    return "keys: array expected";
                for (var i = 0; i < message.keys.length; ++i) {
                    var error = $root.CSVCMsg_GameEvent.key_t.verify(message.keys[i]);
                    if (error)
                        return "keys." + error;
                }
            }
            return null;
        };
    
        /**
         * Creates a CSVCMsg_GameEvent message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CSVCMsg_GameEvent
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CSVCMsg_GameEvent} CSVCMsg_GameEvent
         */
        CSVCMsg_GameEvent.fromObject = function fromObject(object) {
            if (object instanceof $root.CSVCMsg_GameEvent)
                return object;
            var message = new $root.CSVCMsg_GameEvent();
            if (object.eventName != null)
                message.eventName = String(object.eventName);
            if (object.eventid != null)
                message.eventid = object.eventid | 0;
            if (object.keys) {
                if (!Array.isArray(object.keys))
                    throw TypeError(".CSVCMsg_GameEvent.keys: array expected");
                message.keys = [];
                for (var i = 0; i < object.keys.length; ++i) {
                    if (typeof object.keys[i] !== "object")
                        throw TypeError(".CSVCMsg_GameEvent.keys: object expected");
                    message.keys[i] = $root.CSVCMsg_GameEvent.key_t.fromObject(object.keys[i]);
                }
            }
            return message;
        };
    
        /**
         * Creates a plain object from a CSVCMsg_GameEvent message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CSVCMsg_GameEvent
         * @static
         * @param {CSVCMsg_GameEvent} message CSVCMsg_GameEvent
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CSVCMsg_GameEvent.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.keys = [];
            if (options.defaults) {
                object.eventName = "";
                object.eventid = 0;
            }
            if (message.eventName != null && message.hasOwnProperty("eventName"))
                object.eventName = message.eventName;
            if (message.eventid != null && message.hasOwnProperty("eventid"))
                object.eventid = message.eventid;
            if (message.keys && message.keys.length) {
                object.keys = [];
                for (var j = 0; j < message.keys.length; ++j)
                    object.keys[j] = $root.CSVCMsg_GameEvent.key_t.toObject(message.keys[j], options);
            }
            return object;
        };
    
        /**
         * Converts this CSVCMsg_GameEvent to JSON.
         * @function toJSON
         * @memberof CSVCMsg_GameEvent
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CSVCMsg_GameEvent.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * Gets the default type url for CSVCMsg_GameEvent
         * @function getTypeUrl
         * @memberof CSVCMsg_GameEvent
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        CSVCMsg_GameEvent.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/CSVCMsg_GameEvent";
        };
    
        CSVCMsg_GameEvent.key_t = (function() {
    
            /**
             * Properties of a key_t.
             * @memberof CSVCMsg_GameEvent
             * @interface Ikey_t
             * @property {number|null} [type] key_t type
             * @property {string|null} [valString] key_t valString
             * @property {number|null} [valFloat] key_t valFloat
             * @property {number|null} [valLong] key_t valLong
             * @property {number|null} [valShort] key_t valShort
             * @property {number|null} [valByte] key_t valByte
             * @property {boolean|null} [valBool] key_t valBool
             * @property {number|Long|null} [valUint64] key_t valUint64
             */
    
            /**
             * Constructs a new key_t.
             * @memberof CSVCMsg_GameEvent
             * @classdesc Represents a key_t.
             * @implements Ikey_t
             * @constructor
             * @param {CSVCMsg_GameEvent.Ikey_t=} [properties] Properties to set
             */
            function key_t(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * key_t type.
             * @member {number} type
             * @memberof CSVCMsg_GameEvent.key_t
             * @instance
             */
            key_t.prototype.type = 0;
    
            /**
             * key_t valString.
             * @member {string} valString
             * @memberof CSVCMsg_GameEvent.key_t
             * @instance
             */
            key_t.prototype.valString = "";
    
            /**
             * key_t valFloat.
             * @member {number} valFloat
             * @memberof CSVCMsg_GameEvent.key_t
             * @instance
             */
            key_t.prototype.valFloat = 0;
    
            /**
             * key_t valLong.
             * @member {number} valLong
             * @memberof CSVCMsg_GameEvent.key_t
             * @instance
             */
            key_t.prototype.valLong = 0;
    
            /**
             * key_t valShort.
             * @member {number} valShort
             * @memberof CSVCMsg_GameEvent.key_t
             * @instance
             */
            key_t.prototype.valShort = 0;
    
            /**
             * key_t valByte.
             * @member {number} valByte
             * @memberof CSVCMsg_GameEvent.key_t
             * @instance
             */
            key_t.prototype.valByte = 0;
    
            /**
             * key_t valBool.
             * @member {boolean} valBool
             * @memberof CSVCMsg_GameEvent.key_t
             * @instance
             */
            key_t.prototype.valBool = false;
    
            /**
             * key_t valUint64.
             * @member {number|Long} valUint64
             * @memberof CSVCMsg_GameEvent.key_t
             * @instance
             */
            key_t.prototype.valUint64 = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
            /**
             * Creates a new key_t instance using the specified properties.
             * @function create
             * @memberof CSVCMsg_GameEvent.key_t
             * @static
             * @param {CSVCMsg_GameEvent.Ikey_t=} [properties] Properties to set
             * @returns {CSVCMsg_GameEvent.key_t} key_t instance
             */
            key_t.create = function create(properties) {
                return new key_t(properties);
            };
    
            /**
             * Encodes the specified key_t message. Does not implicitly {@link CSVCMsg_GameEvent.key_t.verify|verify} messages.
             * @function encode
             * @memberof CSVCMsg_GameEvent.key_t
             * @static
             * @param {CSVCMsg_GameEvent.Ikey_t} message key_t message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            key_t.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
                if (message.valString != null && Object.hasOwnProperty.call(message, "valString"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.valString);
                if (message.valFloat != null && Object.hasOwnProperty.call(message, "valFloat"))
                    writer.uint32(/* id 3, wireType 5 =*/29).float(message.valFloat);
                if (message.valLong != null && Object.hasOwnProperty.call(message, "valLong"))
                    writer.uint32(/* id 4, wireType 0 =*/32).int32(message.valLong);
                if (message.valShort != null && Object.hasOwnProperty.call(message, "valShort"))
                    writer.uint32(/* id 5, wireType 0 =*/40).int32(message.valShort);
                if (message.valByte != null && Object.hasOwnProperty.call(message, "valByte"))
                    writer.uint32(/* id 6, wireType 0 =*/48).int32(message.valByte);
                if (message.valBool != null && Object.hasOwnProperty.call(message, "valBool"))
                    writer.uint32(/* id 7, wireType 0 =*/56).bool(message.valBool);
                if (message.valUint64 != null && Object.hasOwnProperty.call(message, "valUint64"))
                    writer.uint32(/* id 8, wireType 0 =*/64).uint64(message.valUint64);
                return writer;
            };
    
            /**
             * Encodes the specified key_t message, length delimited. Does not implicitly {@link CSVCMsg_GameEvent.key_t.verify|verify} messages.
             * @function encodeDelimited
             * @memberof CSVCMsg_GameEvent.key_t
             * @static
             * @param {CSVCMsg_GameEvent.Ikey_t} message key_t message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            key_t.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a key_t message from the specified reader or buffer.
             * @function decode
             * @memberof CSVCMsg_GameEvent.key_t
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {CSVCMsg_GameEvent.key_t} key_t
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            key_t.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CSVCMsg_GameEvent.key_t();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.type = reader.int32();
                            break;
                        }
                    case 2: {
                            message.valString = reader.string();
                            break;
                        }
                    case 3: {
                            message.valFloat = reader.float();
                            break;
                        }
                    case 4: {
                            message.valLong = reader.int32();
                            break;
                        }
                    case 5: {
                            message.valShort = reader.int32();
                            break;
                        }
                    case 6: {
                            message.valByte = reader.int32();
                            break;
                        }
                    case 7: {
                            message.valBool = reader.bool();
                            break;
                        }
                    case 8: {
                            message.valUint64 = reader.uint64();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a key_t message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof CSVCMsg_GameEvent.key_t
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {CSVCMsg_GameEvent.key_t} key_t
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            key_t.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a key_t message.
             * @function verify
             * @memberof CSVCMsg_GameEvent.key_t
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            key_t.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.type != null && message.hasOwnProperty("type"))
                    if (!$util.isInteger(message.type))
                        return "type: integer expected";
                if (message.valString != null && message.hasOwnProperty("valString"))
                    if (!$util.isString(message.valString))
                        return "valString: string expected";
                if (message.valFloat != null && message.hasOwnProperty("valFloat"))
                    if (typeof message.valFloat !== "number")
                        return "valFloat: number expected";
                if (message.valLong != null && message.hasOwnProperty("valLong"))
                    if (!$util.isInteger(message.valLong))
                        return "valLong: integer expected";
                if (message.valShort != null && message.hasOwnProperty("valShort"))
                    if (!$util.isInteger(message.valShort))
                        return "valShort: integer expected";
                if (message.valByte != null && message.hasOwnProperty("valByte"))
                    if (!$util.isInteger(message.valByte))
                        return "valByte: integer expected";
                if (message.valBool != null && message.hasOwnProperty("valBool"))
                    if (typeof message.valBool !== "boolean")
                        return "valBool: boolean expected";
                if (message.valUint64 != null && message.hasOwnProperty("valUint64"))
                    if (!$util.isInteger(message.valUint64) && !(message.valUint64 && $util.isInteger(message.valUint64.low) && $util.isInteger(message.valUint64.high)))
                        return "valUint64: integer|Long expected";
                return null;
            };
    
            /**
             * Creates a key_t message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof CSVCMsg_GameEvent.key_t
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {CSVCMsg_GameEvent.key_t} key_t
             */
            key_t.fromObject = function fromObject(object) {
                if (object instanceof $root.CSVCMsg_GameEvent.key_t)
                    return object;
                var message = new $root.CSVCMsg_GameEvent.key_t();
                if (object.type != null)
                    message.type = object.type | 0;
                if (object.valString != null)
                    message.valString = String(object.valString);
                if (object.valFloat != null)
                    message.valFloat = Number(object.valFloat);
                if (object.valLong != null)
                    message.valLong = object.valLong | 0;
                if (object.valShort != null)
                    message.valShort = object.valShort | 0;
                if (object.valByte != null)
                    message.valByte = object.valByte | 0;
                if (object.valBool != null)
                    message.valBool = Boolean(object.valBool);
                if (object.valUint64 != null)
                    if ($util.Long)
                        (message.valUint64 = $util.Long.fromValue(object.valUint64)).unsigned = true;
                    else if (typeof object.valUint64 === "string")
                        message.valUint64 = parseInt(object.valUint64, 10);
                    else if (typeof object.valUint64 === "number")
                        message.valUint64 = object.valUint64;
                    else if (typeof object.valUint64 === "object")
                        message.valUint64 = new $util.LongBits(object.valUint64.low >>> 0, object.valUint64.high >>> 0).toNumber(true);
                return message;
            };
    
            /**
             * Creates a plain object from a key_t message. Also converts values to other types if specified.
             * @function toObject
             * @memberof CSVCMsg_GameEvent.key_t
             * @static
             * @param {CSVCMsg_GameEvent.key_t} message key_t
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            key_t.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.type = 0;
                    object.valString = "";
                    object.valFloat = 0;
                    object.valLong = 0;
                    object.valShort = 0;
                    object.valByte = 0;
                    object.valBool = false;
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, true);
                        object.valUint64 = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.valUint64 = options.longs === String ? "0" : 0;
                }
                if (message.type != null && message.hasOwnProperty("type"))
                    object.type = message.type;
                if (message.valString != null && message.hasOwnProperty("valString"))
                    object.valString = message.valString;
                if (message.valFloat != null && message.hasOwnProperty("valFloat"))
                    object.valFloat = options.json && !isFinite(message.valFloat) ? String(message.valFloat) : message.valFloat;
                if (message.valLong != null && message.hasOwnProperty("valLong"))
                    object.valLong = message.valLong;
                if (message.valShort != null && message.hasOwnProperty("valShort"))
                    object.valShort = message.valShort;
                if (message.valByte != null && message.hasOwnProperty("valByte"))
                    object.valByte = message.valByte;
                if (message.valBool != null && message.hasOwnProperty("valBool"))
                    object.valBool = message.valBool;
                if (message.valUint64 != null && message.hasOwnProperty("valUint64"))
                    if (typeof message.valUint64 === "number")
                        object.valUint64 = options.longs === String ? String(message.valUint64) : message.valUint64;
                    else
                        object.valUint64 = options.longs === String ? $util.Long.prototype.toString.call(message.valUint64) : options.longs === Number ? new $util.LongBits(message.valUint64.low >>> 0, message.valUint64.high >>> 0).toNumber(true) : message.valUint64;
                return object;
            };
    
            /**
             * Converts this key_t to JSON.
             * @function toJSON
             * @memberof CSVCMsg_GameEvent.key_t
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            key_t.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            /**
             * Gets the default type url for key_t
             * @function getTypeUrl
             * @memberof CSVCMsg_GameEvent.key_t
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            key_t.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/CSVCMsg_GameEvent.key_t";
            };
    
            return key_t;
        })();
    
        return CSVCMsg_GameEvent;
    })();
    
    $root.CSVCMsgList_GameEvents = (function() {
    
        /**
         * Properties of a CSVCMsgList_GameEvents.
         * @exports ICSVCMsgList_GameEvents
         * @interface ICSVCMsgList_GameEvents
         * @property {Array.<CSVCMsgList_GameEvents.Ievent_t>|null} [events] CSVCMsgList_GameEvents events
         */
    
        /**
         * Constructs a new CSVCMsgList_GameEvents.
         * @exports CSVCMsgList_GameEvents
         * @classdesc Represents a CSVCMsgList_GameEvents.
         * @implements ICSVCMsgList_GameEvents
         * @constructor
         * @param {ICSVCMsgList_GameEvents=} [properties] Properties to set
         */
        function CSVCMsgList_GameEvents(properties) {
            this.events = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CSVCMsgList_GameEvents events.
         * @member {Array.<CSVCMsgList_GameEvents.Ievent_t>} events
         * @memberof CSVCMsgList_GameEvents
         * @instance
         */
        CSVCMsgList_GameEvents.prototype.events = $util.emptyArray;
    
        /**
         * Creates a new CSVCMsgList_GameEvents instance using the specified properties.
         * @function create
         * @memberof CSVCMsgList_GameEvents
         * @static
         * @param {ICSVCMsgList_GameEvents=} [properties] Properties to set
         * @returns {CSVCMsgList_GameEvents} CSVCMsgList_GameEvents instance
         */
        CSVCMsgList_GameEvents.create = function create(properties) {
            return new CSVCMsgList_GameEvents(properties);
        };
    
        /**
         * Encodes the specified CSVCMsgList_GameEvents message. Does not implicitly {@link CSVCMsgList_GameEvents.verify|verify} messages.
         * @function encode
         * @memberof CSVCMsgList_GameEvents
         * @static
         * @param {ICSVCMsgList_GameEvents} message CSVCMsgList_GameEvents message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CSVCMsgList_GameEvents.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.events != null && message.events.length)
                for (var i = 0; i < message.events.length; ++i)
                    $root.CSVCMsgList_GameEvents.event_t.encode(message.events[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };
    
        /**
         * Encodes the specified CSVCMsgList_GameEvents message, length delimited. Does not implicitly {@link CSVCMsgList_GameEvents.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CSVCMsgList_GameEvents
         * @static
         * @param {ICSVCMsgList_GameEvents} message CSVCMsgList_GameEvents message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CSVCMsgList_GameEvents.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CSVCMsgList_GameEvents message from the specified reader or buffer.
         * @function decode
         * @memberof CSVCMsgList_GameEvents
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CSVCMsgList_GameEvents} CSVCMsgList_GameEvents
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CSVCMsgList_GameEvents.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CSVCMsgList_GameEvents();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        if (!(message.events && message.events.length))
                            message.events = [];
                        message.events.push($root.CSVCMsgList_GameEvents.event_t.decode(reader, reader.uint32()));
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CSVCMsgList_GameEvents message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CSVCMsgList_GameEvents
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CSVCMsgList_GameEvents} CSVCMsgList_GameEvents
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CSVCMsgList_GameEvents.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CSVCMsgList_GameEvents message.
         * @function verify
         * @memberof CSVCMsgList_GameEvents
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CSVCMsgList_GameEvents.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.events != null && message.hasOwnProperty("events")) {
                if (!Array.isArray(message.events))
                    return "events: array expected";
                for (var i = 0; i < message.events.length; ++i) {
                    var error = $root.CSVCMsgList_GameEvents.event_t.verify(message.events[i]);
                    if (error)
                        return "events." + error;
                }
            }
            return null;
        };
    
        /**
         * Creates a CSVCMsgList_GameEvents message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CSVCMsgList_GameEvents
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CSVCMsgList_GameEvents} CSVCMsgList_GameEvents
         */
        CSVCMsgList_GameEvents.fromObject = function fromObject(object) {
            if (object instanceof $root.CSVCMsgList_GameEvents)
                return object;
            var message = new $root.CSVCMsgList_GameEvents();
            if (object.events) {
                if (!Array.isArray(object.events))
                    throw TypeError(".CSVCMsgList_GameEvents.events: array expected");
                message.events = [];
                for (var i = 0; i < object.events.length; ++i) {
                    if (typeof object.events[i] !== "object")
                        throw TypeError(".CSVCMsgList_GameEvents.events: object expected");
                    message.events[i] = $root.CSVCMsgList_GameEvents.event_t.fromObject(object.events[i]);
                }
            }
            return message;
        };
    
        /**
         * Creates a plain object from a CSVCMsgList_GameEvents message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CSVCMsgList_GameEvents
         * @static
         * @param {CSVCMsgList_GameEvents} message CSVCMsgList_GameEvents
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CSVCMsgList_GameEvents.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.events = [];
            if (message.events && message.events.length) {
                object.events = [];
                for (var j = 0; j < message.events.length; ++j)
                    object.events[j] = $root.CSVCMsgList_GameEvents.event_t.toObject(message.events[j], options);
            }
            return object;
        };
    
        /**
         * Converts this CSVCMsgList_GameEvents to JSON.
         * @function toJSON
         * @memberof CSVCMsgList_GameEvents
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CSVCMsgList_GameEvents.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * Gets the default type url for CSVCMsgList_GameEvents
         * @function getTypeUrl
         * @memberof CSVCMsgList_GameEvents
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        CSVCMsgList_GameEvents.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/CSVCMsgList_GameEvents";
        };
    
        CSVCMsgList_GameEvents.event_t = (function() {
    
            /**
             * Properties of an event_t.
             * @memberof CSVCMsgList_GameEvents
             * @interface Ievent_t
             * @property {number|null} [tick] event_t tick
             * @property {ICSVCMsg_GameEvent|null} [event] event_t event
             */
    
            /**
             * Constructs a new event_t.
             * @memberof CSVCMsgList_GameEvents
             * @classdesc Represents an event_t.
             * @implements Ievent_t
             * @constructor
             * @param {CSVCMsgList_GameEvents.Ievent_t=} [properties] Properties to set
             */
            function event_t(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * event_t tick.
             * @member {number} tick
             * @memberof CSVCMsgList_GameEvents.event_t
             * @instance
             */
            event_t.prototype.tick = 0;
    
            /**
             * event_t event.
             * @member {ICSVCMsg_GameEvent|null|undefined} event
             * @memberof CSVCMsgList_GameEvents.event_t
             * @instance
             */
            event_t.prototype.event = null;
    
            /**
             * Creates a new event_t instance using the specified properties.
             * @function create
             * @memberof CSVCMsgList_GameEvents.event_t
             * @static
             * @param {CSVCMsgList_GameEvents.Ievent_t=} [properties] Properties to set
             * @returns {CSVCMsgList_GameEvents.event_t} event_t instance
             */
            event_t.create = function create(properties) {
                return new event_t(properties);
            };
    
            /**
             * Encodes the specified event_t message. Does not implicitly {@link CSVCMsgList_GameEvents.event_t.verify|verify} messages.
             * @function encode
             * @memberof CSVCMsgList_GameEvents.event_t
             * @static
             * @param {CSVCMsgList_GameEvents.Ievent_t} message event_t message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            event_t.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.tick != null && Object.hasOwnProperty.call(message, "tick"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.tick);
                if (message.event != null && Object.hasOwnProperty.call(message, "event"))
                    $root.CSVCMsg_GameEvent.encode(message.event, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };
    
            /**
             * Encodes the specified event_t message, length delimited. Does not implicitly {@link CSVCMsgList_GameEvents.event_t.verify|verify} messages.
             * @function encodeDelimited
             * @memberof CSVCMsgList_GameEvents.event_t
             * @static
             * @param {CSVCMsgList_GameEvents.Ievent_t} message event_t message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            event_t.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes an event_t message from the specified reader or buffer.
             * @function decode
             * @memberof CSVCMsgList_GameEvents.event_t
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {CSVCMsgList_GameEvents.event_t} event_t
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            event_t.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CSVCMsgList_GameEvents.event_t();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.tick = reader.int32();
                            break;
                        }
                    case 2: {
                            message.event = $root.CSVCMsg_GameEvent.decode(reader, reader.uint32());
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes an event_t message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof CSVCMsgList_GameEvents.event_t
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {CSVCMsgList_GameEvents.event_t} event_t
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            event_t.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies an event_t message.
             * @function verify
             * @memberof CSVCMsgList_GameEvents.event_t
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            event_t.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.tick != null && message.hasOwnProperty("tick"))
                    if (!$util.isInteger(message.tick))
                        return "tick: integer expected";
                if (message.event != null && message.hasOwnProperty("event")) {
                    var error = $root.CSVCMsg_GameEvent.verify(message.event);
                    if (error)
                        return "event." + error;
                }
                return null;
            };
    
            /**
             * Creates an event_t message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof CSVCMsgList_GameEvents.event_t
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {CSVCMsgList_GameEvents.event_t} event_t
             */
            event_t.fromObject = function fromObject(object) {
                if (object instanceof $root.CSVCMsgList_GameEvents.event_t)
                    return object;
                var message = new $root.CSVCMsgList_GameEvents.event_t();
                if (object.tick != null)
                    message.tick = object.tick | 0;
                if (object.event != null) {
                    if (typeof object.event !== "object")
                        throw TypeError(".CSVCMsgList_GameEvents.event_t.event: object expected");
                    message.event = $root.CSVCMsg_GameEvent.fromObject(object.event);
                }
                return message;
            };
    
            /**
             * Creates a plain object from an event_t message. Also converts values to other types if specified.
             * @function toObject
             * @memberof CSVCMsgList_GameEvents.event_t
             * @static
             * @param {CSVCMsgList_GameEvents.event_t} message event_t
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            event_t.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.tick = 0;
                    object.event = null;
                }
                if (message.tick != null && message.hasOwnProperty("tick"))
                    object.tick = message.tick;
                if (message.event != null && message.hasOwnProperty("event"))
                    object.event = $root.CSVCMsg_GameEvent.toObject(message.event, options);
                return object;
            };
    
            /**
             * Converts this event_t to JSON.
             * @function toJSON
             * @memberof CSVCMsgList_GameEvents.event_t
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            event_t.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            /**
             * Gets the default type url for event_t
             * @function getTypeUrl
             * @memberof CSVCMsgList_GameEvents.event_t
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            event_t.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/CSVCMsgList_GameEvents.event_t";
            };
    
            return event_t;
        })();
    
        return CSVCMsgList_GameEvents;
    })();
    
    $root.CNETMsg_SpawnGroup_Load = (function() {
    
        /**
         * Properties of a CNETMsg_SpawnGroup_Load.
         * @exports ICNETMsg_SpawnGroup_Load
         * @interface ICNETMsg_SpawnGroup_Load
         * @property {string|null} [worldname] CNETMsg_SpawnGroup_Load worldname
         * @property {string|null} [entitylumpname] CNETMsg_SpawnGroup_Load entitylumpname
         * @property {string|null} [entityfiltername] CNETMsg_SpawnGroup_Load entityfiltername
         * @property {number|null} [spawngrouphandle] CNETMsg_SpawnGroup_Load spawngrouphandle
         * @property {number|null} [spawngroupownerhandle] CNETMsg_SpawnGroup_Load spawngroupownerhandle
         * @property {ICMsgVector|null} [worldOffsetPos] CNETMsg_SpawnGroup_Load worldOffsetPos
         * @property {ICMsgQAngle|null} [worldOffsetAngle] CNETMsg_SpawnGroup_Load worldOffsetAngle
         * @property {Uint8Array|null} [spawngroupmanifest] CNETMsg_SpawnGroup_Load spawngroupmanifest
         * @property {number|null} [flags] CNETMsg_SpawnGroup_Load flags
         * @property {number|null} [tickcount] CNETMsg_SpawnGroup_Load tickcount
         * @property {boolean|null} [manifestincomplete] CNETMsg_SpawnGroup_Load manifestincomplete
         * @property {string|null} [localnamefixup] CNETMsg_SpawnGroup_Load localnamefixup
         * @property {string|null} [parentnamefixup] CNETMsg_SpawnGroup_Load parentnamefixup
         * @property {number|null} [manifestloadpriority] CNETMsg_SpawnGroup_Load manifestloadpriority
         * @property {number|null} [worldgroupid] CNETMsg_SpawnGroup_Load worldgroupid
         * @property {number|null} [creationsequence] CNETMsg_SpawnGroup_Load creationsequence
         * @property {string|null} [savegamefilename] CNETMsg_SpawnGroup_Load savegamefilename
         * @property {number|null} [spawngroupparenthandle] CNETMsg_SpawnGroup_Load spawngroupparenthandle
         * @property {boolean|null} [leveltransition] CNETMsg_SpawnGroup_Load leveltransition
         * @property {string|null} [worldgroupname] CNETMsg_SpawnGroup_Load worldgroupname
         */
    
        /**
         * Constructs a new CNETMsg_SpawnGroup_Load.
         * @exports CNETMsg_SpawnGroup_Load
         * @classdesc Represents a CNETMsg_SpawnGroup_Load.
         * @implements ICNETMsg_SpawnGroup_Load
         * @constructor
         * @param {ICNETMsg_SpawnGroup_Load=} [properties] Properties to set
         */
        function CNETMsg_SpawnGroup_Load(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CNETMsg_SpawnGroup_Load worldname.
         * @member {string} worldname
         * @memberof CNETMsg_SpawnGroup_Load
         * @instance
         */
        CNETMsg_SpawnGroup_Load.prototype.worldname = "";
    
        /**
         * CNETMsg_SpawnGroup_Load entitylumpname.
         * @member {string} entitylumpname
         * @memberof CNETMsg_SpawnGroup_Load
         * @instance
         */
        CNETMsg_SpawnGroup_Load.prototype.entitylumpname = "";
    
        /**
         * CNETMsg_SpawnGroup_Load entityfiltername.
         * @member {string} entityfiltername
         * @memberof CNETMsg_SpawnGroup_Load
         * @instance
         */
        CNETMsg_SpawnGroup_Load.prototype.entityfiltername = "";
    
        /**
         * CNETMsg_SpawnGroup_Load spawngrouphandle.
         * @member {number} spawngrouphandle
         * @memberof CNETMsg_SpawnGroup_Load
         * @instance
         */
        CNETMsg_SpawnGroup_Load.prototype.spawngrouphandle = 0;
    
        /**
         * CNETMsg_SpawnGroup_Load spawngroupownerhandle.
         * @member {number} spawngroupownerhandle
         * @memberof CNETMsg_SpawnGroup_Load
         * @instance
         */
        CNETMsg_SpawnGroup_Load.prototype.spawngroupownerhandle = 0;
    
        /**
         * CNETMsg_SpawnGroup_Load worldOffsetPos.
         * @member {ICMsgVector|null|undefined} worldOffsetPos
         * @memberof CNETMsg_SpawnGroup_Load
         * @instance
         */
        CNETMsg_SpawnGroup_Load.prototype.worldOffsetPos = null;
    
        /**
         * CNETMsg_SpawnGroup_Load worldOffsetAngle.
         * @member {ICMsgQAngle|null|undefined} worldOffsetAngle
         * @memberof CNETMsg_SpawnGroup_Load
         * @instance
         */
        CNETMsg_SpawnGroup_Load.prototype.worldOffsetAngle = null;
    
        /**
         * CNETMsg_SpawnGroup_Load spawngroupmanifest.
         * @member {Uint8Array} spawngroupmanifest
         * @memberof CNETMsg_SpawnGroup_Load
         * @instance
         */
        CNETMsg_SpawnGroup_Load.prototype.spawngroupmanifest = $util.newBuffer([]);
    
        /**
         * CNETMsg_SpawnGroup_Load flags.
         * @member {number} flags
         * @memberof CNETMsg_SpawnGroup_Load
         * @instance
         */
        CNETMsg_SpawnGroup_Load.prototype.flags = 0;
    
        /**
         * CNETMsg_SpawnGroup_Load tickcount.
         * @member {number} tickcount
         * @memberof CNETMsg_SpawnGroup_Load
         * @instance
         */
        CNETMsg_SpawnGroup_Load.prototype.tickcount = 0;
    
        /**
         * CNETMsg_SpawnGroup_Load manifestincomplete.
         * @member {boolean} manifestincomplete
         * @memberof CNETMsg_SpawnGroup_Load
         * @instance
         */
        CNETMsg_SpawnGroup_Load.prototype.manifestincomplete = false;
    
        /**
         * CNETMsg_SpawnGroup_Load localnamefixup.
         * @member {string} localnamefixup
         * @memberof CNETMsg_SpawnGroup_Load
         * @instance
         */
        CNETMsg_SpawnGroup_Load.prototype.localnamefixup = "";
    
        /**
         * CNETMsg_SpawnGroup_Load parentnamefixup.
         * @member {string} parentnamefixup
         * @memberof CNETMsg_SpawnGroup_Load
         * @instance
         */
        CNETMsg_SpawnGroup_Load.prototype.parentnamefixup = "";
    
        /**
         * CNETMsg_SpawnGroup_Load manifestloadpriority.
         * @member {number} manifestloadpriority
         * @memberof CNETMsg_SpawnGroup_Load
         * @instance
         */
        CNETMsg_SpawnGroup_Load.prototype.manifestloadpriority = 0;
    
        /**
         * CNETMsg_SpawnGroup_Load worldgroupid.
         * @member {number} worldgroupid
         * @memberof CNETMsg_SpawnGroup_Load
         * @instance
         */
        CNETMsg_SpawnGroup_Load.prototype.worldgroupid = 0;
    
        /**
         * CNETMsg_SpawnGroup_Load creationsequence.
         * @member {number} creationsequence
         * @memberof CNETMsg_SpawnGroup_Load
         * @instance
         */
        CNETMsg_SpawnGroup_Load.prototype.creationsequence = 0;
    
        /**
         * CNETMsg_SpawnGroup_Load savegamefilename.
         * @member {string} savegamefilename
         * @memberof CNETMsg_SpawnGroup_Load
         * @instance
         */
        CNETMsg_SpawnGroup_Load.prototype.savegamefilename = "";
    
        /**
         * CNETMsg_SpawnGroup_Load spawngroupparenthandle.
         * @member {number} spawngroupparenthandle
         * @memberof CNETMsg_SpawnGroup_Load
         * @instance
         */
        CNETMsg_SpawnGroup_Load.prototype.spawngroupparenthandle = 0;
    
        /**
         * CNETMsg_SpawnGroup_Load leveltransition.
         * @member {boolean} leveltransition
         * @memberof CNETMsg_SpawnGroup_Load
         * @instance
         */
        CNETMsg_SpawnGroup_Load.prototype.leveltransition = false;
    
        /**
         * CNETMsg_SpawnGroup_Load worldgroupname.
         * @member {string} worldgroupname
         * @memberof CNETMsg_SpawnGroup_Load
         * @instance
         */
        CNETMsg_SpawnGroup_Load.prototype.worldgroupname = "";
    
        /**
         * Creates a new CNETMsg_SpawnGroup_Load instance using the specified properties.
         * @function create
         * @memberof CNETMsg_SpawnGroup_Load
         * @static
         * @param {ICNETMsg_SpawnGroup_Load=} [properties] Properties to set
         * @returns {CNETMsg_SpawnGroup_Load} CNETMsg_SpawnGroup_Load instance
         */
        CNETMsg_SpawnGroup_Load.create = function create(properties) {
            return new CNETMsg_SpawnGroup_Load(properties);
        };
    
        /**
         * Encodes the specified CNETMsg_SpawnGroup_Load message. Does not implicitly {@link CNETMsg_SpawnGroup_Load.verify|verify} messages.
         * @function encode
         * @memberof CNETMsg_SpawnGroup_Load
         * @static
         * @param {ICNETMsg_SpawnGroup_Load} message CNETMsg_SpawnGroup_Load message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CNETMsg_SpawnGroup_Load.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.worldname != null && Object.hasOwnProperty.call(message, "worldname"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.worldname);
            if (message.entitylumpname != null && Object.hasOwnProperty.call(message, "entitylumpname"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.entitylumpname);
            if (message.entityfiltername != null && Object.hasOwnProperty.call(message, "entityfiltername"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.entityfiltername);
            if (message.spawngrouphandle != null && Object.hasOwnProperty.call(message, "spawngrouphandle"))
                writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.spawngrouphandle);
            if (message.spawngroupownerhandle != null && Object.hasOwnProperty.call(message, "spawngroupownerhandle"))
                writer.uint32(/* id 5, wireType 0 =*/40).uint32(message.spawngroupownerhandle);
            if (message.worldOffsetPos != null && Object.hasOwnProperty.call(message, "worldOffsetPos"))
                $root.CMsgVector.encode(message.worldOffsetPos, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
            if (message.worldOffsetAngle != null && Object.hasOwnProperty.call(message, "worldOffsetAngle"))
                $root.CMsgQAngle.encode(message.worldOffsetAngle, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
            if (message.spawngroupmanifest != null && Object.hasOwnProperty.call(message, "spawngroupmanifest"))
                writer.uint32(/* id 8, wireType 2 =*/66).bytes(message.spawngroupmanifest);
            if (message.flags != null && Object.hasOwnProperty.call(message, "flags"))
                writer.uint32(/* id 9, wireType 0 =*/72).uint32(message.flags);
            if (message.tickcount != null && Object.hasOwnProperty.call(message, "tickcount"))
                writer.uint32(/* id 10, wireType 0 =*/80).int32(message.tickcount);
            if (message.manifestincomplete != null && Object.hasOwnProperty.call(message, "manifestincomplete"))
                writer.uint32(/* id 11, wireType 0 =*/88).bool(message.manifestincomplete);
            if (message.localnamefixup != null && Object.hasOwnProperty.call(message, "localnamefixup"))
                writer.uint32(/* id 12, wireType 2 =*/98).string(message.localnamefixup);
            if (message.parentnamefixup != null && Object.hasOwnProperty.call(message, "parentnamefixup"))
                writer.uint32(/* id 13, wireType 2 =*/106).string(message.parentnamefixup);
            if (message.manifestloadpriority != null && Object.hasOwnProperty.call(message, "manifestloadpriority"))
                writer.uint32(/* id 14, wireType 0 =*/112).int32(message.manifestloadpriority);
            if (message.worldgroupid != null && Object.hasOwnProperty.call(message, "worldgroupid"))
                writer.uint32(/* id 15, wireType 0 =*/120).uint32(message.worldgroupid);
            if (message.creationsequence != null && Object.hasOwnProperty.call(message, "creationsequence"))
                writer.uint32(/* id 16, wireType 0 =*/128).uint32(message.creationsequence);
            if (message.savegamefilename != null && Object.hasOwnProperty.call(message, "savegamefilename"))
                writer.uint32(/* id 17, wireType 2 =*/138).string(message.savegamefilename);
            if (message.spawngroupparenthandle != null && Object.hasOwnProperty.call(message, "spawngroupparenthandle"))
                writer.uint32(/* id 18, wireType 0 =*/144).uint32(message.spawngroupparenthandle);
            if (message.leveltransition != null && Object.hasOwnProperty.call(message, "leveltransition"))
                writer.uint32(/* id 19, wireType 0 =*/152).bool(message.leveltransition);
            if (message.worldgroupname != null && Object.hasOwnProperty.call(message, "worldgroupname"))
                writer.uint32(/* id 20, wireType 2 =*/162).string(message.worldgroupname);
            return writer;
        };
    
        /**
         * Encodes the specified CNETMsg_SpawnGroup_Load message, length delimited. Does not implicitly {@link CNETMsg_SpawnGroup_Load.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CNETMsg_SpawnGroup_Load
         * @static
         * @param {ICNETMsg_SpawnGroup_Load} message CNETMsg_SpawnGroup_Load message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CNETMsg_SpawnGroup_Load.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CNETMsg_SpawnGroup_Load message from the specified reader or buffer.
         * @function decode
         * @memberof CNETMsg_SpawnGroup_Load
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CNETMsg_SpawnGroup_Load} CNETMsg_SpawnGroup_Load
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CNETMsg_SpawnGroup_Load.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CNETMsg_SpawnGroup_Load();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.worldname = reader.string();
                        break;
                    }
                case 2: {
                        message.entitylumpname = reader.string();
                        break;
                    }
                case 3: {
                        message.entityfiltername = reader.string();
                        break;
                    }
                case 4: {
                        message.spawngrouphandle = reader.uint32();
                        break;
                    }
                case 5: {
                        message.spawngroupownerhandle = reader.uint32();
                        break;
                    }
                case 6: {
                        message.worldOffsetPos = $root.CMsgVector.decode(reader, reader.uint32());
                        break;
                    }
                case 7: {
                        message.worldOffsetAngle = $root.CMsgQAngle.decode(reader, reader.uint32());
                        break;
                    }
                case 8: {
                        message.spawngroupmanifest = reader.bytes();
                        break;
                    }
                case 9: {
                        message.flags = reader.uint32();
                        break;
                    }
                case 10: {
                        message.tickcount = reader.int32();
                        break;
                    }
                case 11: {
                        message.manifestincomplete = reader.bool();
                        break;
                    }
                case 12: {
                        message.localnamefixup = reader.string();
                        break;
                    }
                case 13: {
                        message.parentnamefixup = reader.string();
                        break;
                    }
                case 14: {
                        message.manifestloadpriority = reader.int32();
                        break;
                    }
                case 15: {
                        message.worldgroupid = reader.uint32();
                        break;
                    }
                case 16: {
                        message.creationsequence = reader.uint32();
                        break;
                    }
                case 17: {
                        message.savegamefilename = reader.string();
                        break;
                    }
                case 18: {
                        message.spawngroupparenthandle = reader.uint32();
                        break;
                    }
                case 19: {
                        message.leveltransition = reader.bool();
                        break;
                    }
                case 20: {
                        message.worldgroupname = reader.string();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CNETMsg_SpawnGroup_Load message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CNETMsg_SpawnGroup_Load
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CNETMsg_SpawnGroup_Load} CNETMsg_SpawnGroup_Load
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CNETMsg_SpawnGroup_Load.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CNETMsg_SpawnGroup_Load message.
         * @function verify
         * @memberof CNETMsg_SpawnGroup_Load
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CNETMsg_SpawnGroup_Load.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.worldname != null && message.hasOwnProperty("worldname"))
                if (!$util.isString(message.worldname))
                    return "worldname: string expected";
            if (message.entitylumpname != null && message.hasOwnProperty("entitylumpname"))
                if (!$util.isString(message.entitylumpname))
                    return "entitylumpname: string expected";
            if (message.entityfiltername != null && message.hasOwnProperty("entityfiltername"))
                if (!$util.isString(message.entityfiltername))
                    return "entityfiltername: string expected";
            if (message.spawngrouphandle != null && message.hasOwnProperty("spawngrouphandle"))
                if (!$util.isInteger(message.spawngrouphandle))
                    return "spawngrouphandle: integer expected";
            if (message.spawngroupownerhandle != null && message.hasOwnProperty("spawngroupownerhandle"))
                if (!$util.isInteger(message.spawngroupownerhandle))
                    return "spawngroupownerhandle: integer expected";
            if (message.worldOffsetPos != null && message.hasOwnProperty("worldOffsetPos")) {
                var error = $root.CMsgVector.verify(message.worldOffsetPos);
                if (error)
                    return "worldOffsetPos." + error;
            }
            if (message.worldOffsetAngle != null && message.hasOwnProperty("worldOffsetAngle")) {
                var error = $root.CMsgQAngle.verify(message.worldOffsetAngle);
                if (error)
                    return "worldOffsetAngle." + error;
            }
            if (message.spawngroupmanifest != null && message.hasOwnProperty("spawngroupmanifest"))
                if (!(message.spawngroupmanifest && typeof message.spawngroupmanifest.length === "number" || $util.isString(message.spawngroupmanifest)))
                    return "spawngroupmanifest: buffer expected";
            if (message.flags != null && message.hasOwnProperty("flags"))
                if (!$util.isInteger(message.flags))
                    return "flags: integer expected";
            if (message.tickcount != null && message.hasOwnProperty("tickcount"))
                if (!$util.isInteger(message.tickcount))
                    return "tickcount: integer expected";
            if (message.manifestincomplete != null && message.hasOwnProperty("manifestincomplete"))
                if (typeof message.manifestincomplete !== "boolean")
                    return "manifestincomplete: boolean expected";
            if (message.localnamefixup != null && message.hasOwnProperty("localnamefixup"))
                if (!$util.isString(message.localnamefixup))
                    return "localnamefixup: string expected";
            if (message.parentnamefixup != null && message.hasOwnProperty("parentnamefixup"))
                if (!$util.isString(message.parentnamefixup))
                    return "parentnamefixup: string expected";
            if (message.manifestloadpriority != null && message.hasOwnProperty("manifestloadpriority"))
                if (!$util.isInteger(message.manifestloadpriority))
                    return "manifestloadpriority: integer expected";
            if (message.worldgroupid != null && message.hasOwnProperty("worldgroupid"))
                if (!$util.isInteger(message.worldgroupid))
                    return "worldgroupid: integer expected";
            if (message.creationsequence != null && message.hasOwnProperty("creationsequence"))
                if (!$util.isInteger(message.creationsequence))
                    return "creationsequence: integer expected";
            if (message.savegamefilename != null && message.hasOwnProperty("savegamefilename"))
                if (!$util.isString(message.savegamefilename))
                    return "savegamefilename: string expected";
            if (message.spawngroupparenthandle != null && message.hasOwnProperty("spawngroupparenthandle"))
                if (!$util.isInteger(message.spawngroupparenthandle))
                    return "spawngroupparenthandle: integer expected";
            if (message.leveltransition != null && message.hasOwnProperty("leveltransition"))
                if (typeof message.leveltransition !== "boolean")
                    return "leveltransition: boolean expected";
            if (message.worldgroupname != null && message.hasOwnProperty("worldgroupname"))
                if (!$util.isString(message.worldgroupname))
                    return "worldgroupname: string expected";
            return null;
        };
    
        /**
         * Creates a CNETMsg_SpawnGroup_Load message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CNETMsg_SpawnGroup_Load
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CNETMsg_SpawnGroup_Load} CNETMsg_SpawnGroup_Load
         */
        CNETMsg_SpawnGroup_Load.fromObject = function fromObject(object) {
            if (object instanceof $root.CNETMsg_SpawnGroup_Load)
                return object;
            var message = new $root.CNETMsg_SpawnGroup_Load();
            if (object.worldname != null)
                message.worldname = String(object.worldname);
            if (object.entitylumpname != null)
                message.entitylumpname = String(object.entitylumpname);
            if (object.entityfiltername != null)
                message.entityfiltername = String(object.entityfiltername);
            if (object.spawngrouphandle != null)
                message.spawngrouphandle = object.spawngrouphandle >>> 0;
            if (object.spawngroupownerhandle != null)
                message.spawngroupownerhandle = object.spawngroupownerhandle >>> 0;
            if (object.worldOffsetPos != null) {
                if (typeof object.worldOffsetPos !== "object")
                    throw TypeError(".CNETMsg_SpawnGroup_Load.worldOffsetPos: object expected");
                message.worldOffsetPos = $root.CMsgVector.fromObject(object.worldOffsetPos);
            }
            if (object.worldOffsetAngle != null) {
                if (typeof object.worldOffsetAngle !== "object")
                    throw TypeError(".CNETMsg_SpawnGroup_Load.worldOffsetAngle: object expected");
                message.worldOffsetAngle = $root.CMsgQAngle.fromObject(object.worldOffsetAngle);
            }
            if (object.spawngroupmanifest != null)
                if (typeof object.spawngroupmanifest === "string")
                    $util.base64.decode(object.spawngroupmanifest, message.spawngroupmanifest = $util.newBuffer($util.base64.length(object.spawngroupmanifest)), 0);
                else if (object.spawngroupmanifest.length >= 0)
                    message.spawngroupmanifest = object.spawngroupmanifest;
            if (object.flags != null)
                message.flags = object.flags >>> 0;
            if (object.tickcount != null)
                message.tickcount = object.tickcount | 0;
            if (object.manifestincomplete != null)
                message.manifestincomplete = Boolean(object.manifestincomplete);
            if (object.localnamefixup != null)
                message.localnamefixup = String(object.localnamefixup);
            if (object.parentnamefixup != null)
                message.parentnamefixup = String(object.parentnamefixup);
            if (object.manifestloadpriority != null)
                message.manifestloadpriority = object.manifestloadpriority | 0;
            if (object.worldgroupid != null)
                message.worldgroupid = object.worldgroupid >>> 0;
            if (object.creationsequence != null)
                message.creationsequence = object.creationsequence >>> 0;
            if (object.savegamefilename != null)
                message.savegamefilename = String(object.savegamefilename);
            if (object.spawngroupparenthandle != null)
                message.spawngroupparenthandle = object.spawngroupparenthandle >>> 0;
            if (object.leveltransition != null)
                message.leveltransition = Boolean(object.leveltransition);
            if (object.worldgroupname != null)
                message.worldgroupname = String(object.worldgroupname);
            return message;
        };
    
        /**
         * Creates a plain object from a CNETMsg_SpawnGroup_Load message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CNETMsg_SpawnGroup_Load
         * @static
         * @param {CNETMsg_SpawnGroup_Load} message CNETMsg_SpawnGroup_Load
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CNETMsg_SpawnGroup_Load.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.worldname = "";
                object.entitylumpname = "";
                object.entityfiltername = "";
                object.spawngrouphandle = 0;
                object.spawngroupownerhandle = 0;
                object.worldOffsetPos = null;
                object.worldOffsetAngle = null;
                if (options.bytes === String)
                    object.spawngroupmanifest = "";
                else {
                    object.spawngroupmanifest = [];
                    if (options.bytes !== Array)
                        object.spawngroupmanifest = $util.newBuffer(object.spawngroupmanifest);
                }
                object.flags = 0;
                object.tickcount = 0;
                object.manifestincomplete = false;
                object.localnamefixup = "";
                object.parentnamefixup = "";
                object.manifestloadpriority = 0;
                object.worldgroupid = 0;
                object.creationsequence = 0;
                object.savegamefilename = "";
                object.spawngroupparenthandle = 0;
                object.leveltransition = false;
                object.worldgroupname = "";
            }
            if (message.worldname != null && message.hasOwnProperty("worldname"))
                object.worldname = message.worldname;
            if (message.entitylumpname != null && message.hasOwnProperty("entitylumpname"))
                object.entitylumpname = message.entitylumpname;
            if (message.entityfiltername != null && message.hasOwnProperty("entityfiltername"))
                object.entityfiltername = message.entityfiltername;
            if (message.spawngrouphandle != null && message.hasOwnProperty("spawngrouphandle"))
                object.spawngrouphandle = message.spawngrouphandle;
            if (message.spawngroupownerhandle != null && message.hasOwnProperty("spawngroupownerhandle"))
                object.spawngroupownerhandle = message.spawngroupownerhandle;
            if (message.worldOffsetPos != null && message.hasOwnProperty("worldOffsetPos"))
                object.worldOffsetPos = $root.CMsgVector.toObject(message.worldOffsetPos, options);
            if (message.worldOffsetAngle != null && message.hasOwnProperty("worldOffsetAngle"))
                object.worldOffsetAngle = $root.CMsgQAngle.toObject(message.worldOffsetAngle, options);
            if (message.spawngroupmanifest != null && message.hasOwnProperty("spawngroupmanifest"))
                object.spawngroupmanifest = options.bytes === String ? $util.base64.encode(message.spawngroupmanifest, 0, message.spawngroupmanifest.length) : options.bytes === Array ? Array.prototype.slice.call(message.spawngroupmanifest) : message.spawngroupmanifest;
            if (message.flags != null && message.hasOwnProperty("flags"))
                object.flags = message.flags;
            if (message.tickcount != null && message.hasOwnProperty("tickcount"))
                object.tickcount = message.tickcount;
            if (message.manifestincomplete != null && message.hasOwnProperty("manifestincomplete"))
                object.manifestincomplete = message.manifestincomplete;
            if (message.localnamefixup != null && message.hasOwnProperty("localnamefixup"))
                object.localnamefixup = message.localnamefixup;
            if (message.parentnamefixup != null && message.hasOwnProperty("parentnamefixup"))
                object.parentnamefixup = message.parentnamefixup;
            if (message.manifestloadpriority != null && message.hasOwnProperty("manifestloadpriority"))
                object.manifestloadpriority = message.manifestloadpriority;
            if (message.worldgroupid != null && message.hasOwnProperty("worldgroupid"))
                object.worldgroupid = message.worldgroupid;
            if (message.creationsequence != null && message.hasOwnProperty("creationsequence"))
                object.creationsequence = message.creationsequence;
            if (message.savegamefilename != null && message.hasOwnProperty("savegamefilename"))
                object.savegamefilename = message.savegamefilename;
            if (message.spawngroupparenthandle != null && message.hasOwnProperty("spawngroupparenthandle"))
                object.spawngroupparenthandle = message.spawngroupparenthandle;
            if (message.leveltransition != null && message.hasOwnProperty("leveltransition"))
                object.leveltransition = message.leveltransition;
            if (message.worldgroupname != null && message.hasOwnProperty("worldgroupname"))
                object.worldgroupname = message.worldgroupname;
            return object;
        };
    
        /**
         * Converts this CNETMsg_SpawnGroup_Load to JSON.
         * @function toJSON
         * @memberof CNETMsg_SpawnGroup_Load
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CNETMsg_SpawnGroup_Load.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * Gets the default type url for CNETMsg_SpawnGroup_Load
         * @function getTypeUrl
         * @memberof CNETMsg_SpawnGroup_Load
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        CNETMsg_SpawnGroup_Load.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/CNETMsg_SpawnGroup_Load";
        };
    
        return CNETMsg_SpawnGroup_Load;
    })();
    
    $root.CNETMsg_SpawnGroup_ManifestUpdate = (function() {
    
        /**
         * Properties of a CNETMsg_SpawnGroup_ManifestUpdate.
         * @exports ICNETMsg_SpawnGroup_ManifestUpdate
         * @interface ICNETMsg_SpawnGroup_ManifestUpdate
         * @property {number|null} [spawngrouphandle] CNETMsg_SpawnGroup_ManifestUpdate spawngrouphandle
         * @property {Uint8Array|null} [spawngroupmanifest] CNETMsg_SpawnGroup_ManifestUpdate spawngroupmanifest
         * @property {boolean|null} [manifestincomplete] CNETMsg_SpawnGroup_ManifestUpdate manifestincomplete
         */
    
        /**
         * Constructs a new CNETMsg_SpawnGroup_ManifestUpdate.
         * @exports CNETMsg_SpawnGroup_ManifestUpdate
         * @classdesc Represents a CNETMsg_SpawnGroup_ManifestUpdate.
         * @implements ICNETMsg_SpawnGroup_ManifestUpdate
         * @constructor
         * @param {ICNETMsg_SpawnGroup_ManifestUpdate=} [properties] Properties to set
         */
        function CNETMsg_SpawnGroup_ManifestUpdate(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CNETMsg_SpawnGroup_ManifestUpdate spawngrouphandle.
         * @member {number} spawngrouphandle
         * @memberof CNETMsg_SpawnGroup_ManifestUpdate
         * @instance
         */
        CNETMsg_SpawnGroup_ManifestUpdate.prototype.spawngrouphandle = 0;
    
        /**
         * CNETMsg_SpawnGroup_ManifestUpdate spawngroupmanifest.
         * @member {Uint8Array} spawngroupmanifest
         * @memberof CNETMsg_SpawnGroup_ManifestUpdate
         * @instance
         */
        CNETMsg_SpawnGroup_ManifestUpdate.prototype.spawngroupmanifest = $util.newBuffer([]);
    
        /**
         * CNETMsg_SpawnGroup_ManifestUpdate manifestincomplete.
         * @member {boolean} manifestincomplete
         * @memberof CNETMsg_SpawnGroup_ManifestUpdate
         * @instance
         */
        CNETMsg_SpawnGroup_ManifestUpdate.prototype.manifestincomplete = false;
    
        /**
         * Creates a new CNETMsg_SpawnGroup_ManifestUpdate instance using the specified properties.
         * @function create
         * @memberof CNETMsg_SpawnGroup_ManifestUpdate
         * @static
         * @param {ICNETMsg_SpawnGroup_ManifestUpdate=} [properties] Properties to set
         * @returns {CNETMsg_SpawnGroup_ManifestUpdate} CNETMsg_SpawnGroup_ManifestUpdate instance
         */
        CNETMsg_SpawnGroup_ManifestUpdate.create = function create(properties) {
            return new CNETMsg_SpawnGroup_ManifestUpdate(properties);
        };
    
        /**
         * Encodes the specified CNETMsg_SpawnGroup_ManifestUpdate message. Does not implicitly {@link CNETMsg_SpawnGroup_ManifestUpdate.verify|verify} messages.
         * @function encode
         * @memberof CNETMsg_SpawnGroup_ManifestUpdate
         * @static
         * @param {ICNETMsg_SpawnGroup_ManifestUpdate} message CNETMsg_SpawnGroup_ManifestUpdate message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CNETMsg_SpawnGroup_ManifestUpdate.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.spawngrouphandle != null && Object.hasOwnProperty.call(message, "spawngrouphandle"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.spawngrouphandle);
            if (message.spawngroupmanifest != null && Object.hasOwnProperty.call(message, "spawngroupmanifest"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.spawngroupmanifest);
            if (message.manifestincomplete != null && Object.hasOwnProperty.call(message, "manifestincomplete"))
                writer.uint32(/* id 3, wireType 0 =*/24).bool(message.manifestincomplete);
            return writer;
        };
    
        /**
         * Encodes the specified CNETMsg_SpawnGroup_ManifestUpdate message, length delimited. Does not implicitly {@link CNETMsg_SpawnGroup_ManifestUpdate.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CNETMsg_SpawnGroup_ManifestUpdate
         * @static
         * @param {ICNETMsg_SpawnGroup_ManifestUpdate} message CNETMsg_SpawnGroup_ManifestUpdate message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CNETMsg_SpawnGroup_ManifestUpdate.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CNETMsg_SpawnGroup_ManifestUpdate message from the specified reader or buffer.
         * @function decode
         * @memberof CNETMsg_SpawnGroup_ManifestUpdate
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CNETMsg_SpawnGroup_ManifestUpdate} CNETMsg_SpawnGroup_ManifestUpdate
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CNETMsg_SpawnGroup_ManifestUpdate.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CNETMsg_SpawnGroup_ManifestUpdate();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.spawngrouphandle = reader.uint32();
                        break;
                    }
                case 2: {
                        message.spawngroupmanifest = reader.bytes();
                        break;
                    }
                case 3: {
                        message.manifestincomplete = reader.bool();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CNETMsg_SpawnGroup_ManifestUpdate message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CNETMsg_SpawnGroup_ManifestUpdate
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CNETMsg_SpawnGroup_ManifestUpdate} CNETMsg_SpawnGroup_ManifestUpdate
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CNETMsg_SpawnGroup_ManifestUpdate.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CNETMsg_SpawnGroup_ManifestUpdate message.
         * @function verify
         * @memberof CNETMsg_SpawnGroup_ManifestUpdate
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CNETMsg_SpawnGroup_ManifestUpdate.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.spawngrouphandle != null && message.hasOwnProperty("spawngrouphandle"))
                if (!$util.isInteger(message.spawngrouphandle))
                    return "spawngrouphandle: integer expected";
            if (message.spawngroupmanifest != null && message.hasOwnProperty("spawngroupmanifest"))
                if (!(message.spawngroupmanifest && typeof message.spawngroupmanifest.length === "number" || $util.isString(message.spawngroupmanifest)))
                    return "spawngroupmanifest: buffer expected";
            if (message.manifestincomplete != null && message.hasOwnProperty("manifestincomplete"))
                if (typeof message.manifestincomplete !== "boolean")
                    return "manifestincomplete: boolean expected";
            return null;
        };
    
        /**
         * Creates a CNETMsg_SpawnGroup_ManifestUpdate message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CNETMsg_SpawnGroup_ManifestUpdate
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CNETMsg_SpawnGroup_ManifestUpdate} CNETMsg_SpawnGroup_ManifestUpdate
         */
        CNETMsg_SpawnGroup_ManifestUpdate.fromObject = function fromObject(object) {
            if (object instanceof $root.CNETMsg_SpawnGroup_ManifestUpdate)
                return object;
            var message = new $root.CNETMsg_SpawnGroup_ManifestUpdate();
            if (object.spawngrouphandle != null)
                message.spawngrouphandle = object.spawngrouphandle >>> 0;
            if (object.spawngroupmanifest != null)
                if (typeof object.spawngroupmanifest === "string")
                    $util.base64.decode(object.spawngroupmanifest, message.spawngroupmanifest = $util.newBuffer($util.base64.length(object.spawngroupmanifest)), 0);
                else if (object.spawngroupmanifest.length >= 0)
                    message.spawngroupmanifest = object.spawngroupmanifest;
            if (object.manifestincomplete != null)
                message.manifestincomplete = Boolean(object.manifestincomplete);
            return message;
        };
    
        /**
         * Creates a plain object from a CNETMsg_SpawnGroup_ManifestUpdate message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CNETMsg_SpawnGroup_ManifestUpdate
         * @static
         * @param {CNETMsg_SpawnGroup_ManifestUpdate} message CNETMsg_SpawnGroup_ManifestUpdate
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CNETMsg_SpawnGroup_ManifestUpdate.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.spawngrouphandle = 0;
                if (options.bytes === String)
                    object.spawngroupmanifest = "";
                else {
                    object.spawngroupmanifest = [];
                    if (options.bytes !== Array)
                        object.spawngroupmanifest = $util.newBuffer(object.spawngroupmanifest);
                }
                object.manifestincomplete = false;
            }
            if (message.spawngrouphandle != null && message.hasOwnProperty("spawngrouphandle"))
                object.spawngrouphandle = message.spawngrouphandle;
            if (message.spawngroupmanifest != null && message.hasOwnProperty("spawngroupmanifest"))
                object.spawngroupmanifest = options.bytes === String ? $util.base64.encode(message.spawngroupmanifest, 0, message.spawngroupmanifest.length) : options.bytes === Array ? Array.prototype.slice.call(message.spawngroupmanifest) : message.spawngroupmanifest;
            if (message.manifestincomplete != null && message.hasOwnProperty("manifestincomplete"))
                object.manifestincomplete = message.manifestincomplete;
            return object;
        };
    
        /**
         * Converts this CNETMsg_SpawnGroup_ManifestUpdate to JSON.
         * @function toJSON
         * @memberof CNETMsg_SpawnGroup_ManifestUpdate
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CNETMsg_SpawnGroup_ManifestUpdate.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * Gets the default type url for CNETMsg_SpawnGroup_ManifestUpdate
         * @function getTypeUrl
         * @memberof CNETMsg_SpawnGroup_ManifestUpdate
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        CNETMsg_SpawnGroup_ManifestUpdate.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/CNETMsg_SpawnGroup_ManifestUpdate";
        };
    
        return CNETMsg_SpawnGroup_ManifestUpdate;
    })();
    
    $root.CNETMsg_SpawnGroup_SetCreationTick = (function() {
    
        /**
         * Properties of a CNETMsg_SpawnGroup_SetCreationTick.
         * @exports ICNETMsg_SpawnGroup_SetCreationTick
         * @interface ICNETMsg_SpawnGroup_SetCreationTick
         * @property {number|null} [spawngrouphandle] CNETMsg_SpawnGroup_SetCreationTick spawngrouphandle
         * @property {number|null} [tickcount] CNETMsg_SpawnGroup_SetCreationTick tickcount
         * @property {number|null} [creationsequence] CNETMsg_SpawnGroup_SetCreationTick creationsequence
         */
    
        /**
         * Constructs a new CNETMsg_SpawnGroup_SetCreationTick.
         * @exports CNETMsg_SpawnGroup_SetCreationTick
         * @classdesc Represents a CNETMsg_SpawnGroup_SetCreationTick.
         * @implements ICNETMsg_SpawnGroup_SetCreationTick
         * @constructor
         * @param {ICNETMsg_SpawnGroup_SetCreationTick=} [properties] Properties to set
         */
        function CNETMsg_SpawnGroup_SetCreationTick(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CNETMsg_SpawnGroup_SetCreationTick spawngrouphandle.
         * @member {number} spawngrouphandle
         * @memberof CNETMsg_SpawnGroup_SetCreationTick
         * @instance
         */
        CNETMsg_SpawnGroup_SetCreationTick.prototype.spawngrouphandle = 0;
    
        /**
         * CNETMsg_SpawnGroup_SetCreationTick tickcount.
         * @member {number} tickcount
         * @memberof CNETMsg_SpawnGroup_SetCreationTick
         * @instance
         */
        CNETMsg_SpawnGroup_SetCreationTick.prototype.tickcount = 0;
    
        /**
         * CNETMsg_SpawnGroup_SetCreationTick creationsequence.
         * @member {number} creationsequence
         * @memberof CNETMsg_SpawnGroup_SetCreationTick
         * @instance
         */
        CNETMsg_SpawnGroup_SetCreationTick.prototype.creationsequence = 0;
    
        /**
         * Creates a new CNETMsg_SpawnGroup_SetCreationTick instance using the specified properties.
         * @function create
         * @memberof CNETMsg_SpawnGroup_SetCreationTick
         * @static
         * @param {ICNETMsg_SpawnGroup_SetCreationTick=} [properties] Properties to set
         * @returns {CNETMsg_SpawnGroup_SetCreationTick} CNETMsg_SpawnGroup_SetCreationTick instance
         */
        CNETMsg_SpawnGroup_SetCreationTick.create = function create(properties) {
            return new CNETMsg_SpawnGroup_SetCreationTick(properties);
        };
    
        /**
         * Encodes the specified CNETMsg_SpawnGroup_SetCreationTick message. Does not implicitly {@link CNETMsg_SpawnGroup_SetCreationTick.verify|verify} messages.
         * @function encode
         * @memberof CNETMsg_SpawnGroup_SetCreationTick
         * @static
         * @param {ICNETMsg_SpawnGroup_SetCreationTick} message CNETMsg_SpawnGroup_SetCreationTick message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CNETMsg_SpawnGroup_SetCreationTick.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.spawngrouphandle != null && Object.hasOwnProperty.call(message, "spawngrouphandle"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.spawngrouphandle);
            if (message.tickcount != null && Object.hasOwnProperty.call(message, "tickcount"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.tickcount);
            if (message.creationsequence != null && Object.hasOwnProperty.call(message, "creationsequence"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.creationsequence);
            return writer;
        };
    
        /**
         * Encodes the specified CNETMsg_SpawnGroup_SetCreationTick message, length delimited. Does not implicitly {@link CNETMsg_SpawnGroup_SetCreationTick.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CNETMsg_SpawnGroup_SetCreationTick
         * @static
         * @param {ICNETMsg_SpawnGroup_SetCreationTick} message CNETMsg_SpawnGroup_SetCreationTick message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CNETMsg_SpawnGroup_SetCreationTick.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CNETMsg_SpawnGroup_SetCreationTick message from the specified reader or buffer.
         * @function decode
         * @memberof CNETMsg_SpawnGroup_SetCreationTick
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CNETMsg_SpawnGroup_SetCreationTick} CNETMsg_SpawnGroup_SetCreationTick
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CNETMsg_SpawnGroup_SetCreationTick.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CNETMsg_SpawnGroup_SetCreationTick();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.spawngrouphandle = reader.uint32();
                        break;
                    }
                case 2: {
                        message.tickcount = reader.int32();
                        break;
                    }
                case 3: {
                        message.creationsequence = reader.uint32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CNETMsg_SpawnGroup_SetCreationTick message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CNETMsg_SpawnGroup_SetCreationTick
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CNETMsg_SpawnGroup_SetCreationTick} CNETMsg_SpawnGroup_SetCreationTick
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CNETMsg_SpawnGroup_SetCreationTick.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CNETMsg_SpawnGroup_SetCreationTick message.
         * @function verify
         * @memberof CNETMsg_SpawnGroup_SetCreationTick
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CNETMsg_SpawnGroup_SetCreationTick.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.spawngrouphandle != null && message.hasOwnProperty("spawngrouphandle"))
                if (!$util.isInteger(message.spawngrouphandle))
                    return "spawngrouphandle: integer expected";
            if (message.tickcount != null && message.hasOwnProperty("tickcount"))
                if (!$util.isInteger(message.tickcount))
                    return "tickcount: integer expected";
            if (message.creationsequence != null && message.hasOwnProperty("creationsequence"))
                if (!$util.isInteger(message.creationsequence))
                    return "creationsequence: integer expected";
            return null;
        };
    
        /**
         * Creates a CNETMsg_SpawnGroup_SetCreationTick message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CNETMsg_SpawnGroup_SetCreationTick
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CNETMsg_SpawnGroup_SetCreationTick} CNETMsg_SpawnGroup_SetCreationTick
         */
        CNETMsg_SpawnGroup_SetCreationTick.fromObject = function fromObject(object) {
            if (object instanceof $root.CNETMsg_SpawnGroup_SetCreationTick)
                return object;
            var message = new $root.CNETMsg_SpawnGroup_SetCreationTick();
            if (object.spawngrouphandle != null)
                message.spawngrouphandle = object.spawngrouphandle >>> 0;
            if (object.tickcount != null)
                message.tickcount = object.tickcount | 0;
            if (object.creationsequence != null)
                message.creationsequence = object.creationsequence >>> 0;
            return message;
        };
    
        /**
         * Creates a plain object from a CNETMsg_SpawnGroup_SetCreationTick message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CNETMsg_SpawnGroup_SetCreationTick
         * @static
         * @param {CNETMsg_SpawnGroup_SetCreationTick} message CNETMsg_SpawnGroup_SetCreationTick
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CNETMsg_SpawnGroup_SetCreationTick.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.spawngrouphandle = 0;
                object.tickcount = 0;
                object.creationsequence = 0;
            }
            if (message.spawngrouphandle != null && message.hasOwnProperty("spawngrouphandle"))
                object.spawngrouphandle = message.spawngrouphandle;
            if (message.tickcount != null && message.hasOwnProperty("tickcount"))
                object.tickcount = message.tickcount;
            if (message.creationsequence != null && message.hasOwnProperty("creationsequence"))
                object.creationsequence = message.creationsequence;
            return object;
        };
    
        /**
         * Converts this CNETMsg_SpawnGroup_SetCreationTick to JSON.
         * @function toJSON
         * @memberof CNETMsg_SpawnGroup_SetCreationTick
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CNETMsg_SpawnGroup_SetCreationTick.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * Gets the default type url for CNETMsg_SpawnGroup_SetCreationTick
         * @function getTypeUrl
         * @memberof CNETMsg_SpawnGroup_SetCreationTick
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        CNETMsg_SpawnGroup_SetCreationTick.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/CNETMsg_SpawnGroup_SetCreationTick";
        };
    
        return CNETMsg_SpawnGroup_SetCreationTick;
    })();
    
    $root.CNETMsg_SpawnGroup_Unload = (function() {
    
        /**
         * Properties of a CNETMsg_SpawnGroup_Unload.
         * @exports ICNETMsg_SpawnGroup_Unload
         * @interface ICNETMsg_SpawnGroup_Unload
         * @property {number|null} [spawngrouphandle] CNETMsg_SpawnGroup_Unload spawngrouphandle
         * @property {number|null} [flags] CNETMsg_SpawnGroup_Unload flags
         * @property {number|null} [tickcount] CNETMsg_SpawnGroup_Unload tickcount
         */
    
        /**
         * Constructs a new CNETMsg_SpawnGroup_Unload.
         * @exports CNETMsg_SpawnGroup_Unload
         * @classdesc Represents a CNETMsg_SpawnGroup_Unload.
         * @implements ICNETMsg_SpawnGroup_Unload
         * @constructor
         * @param {ICNETMsg_SpawnGroup_Unload=} [properties] Properties to set
         */
        function CNETMsg_SpawnGroup_Unload(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CNETMsg_SpawnGroup_Unload spawngrouphandle.
         * @member {number} spawngrouphandle
         * @memberof CNETMsg_SpawnGroup_Unload
         * @instance
         */
        CNETMsg_SpawnGroup_Unload.prototype.spawngrouphandle = 0;
    
        /**
         * CNETMsg_SpawnGroup_Unload flags.
         * @member {number} flags
         * @memberof CNETMsg_SpawnGroup_Unload
         * @instance
         */
        CNETMsg_SpawnGroup_Unload.prototype.flags = 0;
    
        /**
         * CNETMsg_SpawnGroup_Unload tickcount.
         * @member {number} tickcount
         * @memberof CNETMsg_SpawnGroup_Unload
         * @instance
         */
        CNETMsg_SpawnGroup_Unload.prototype.tickcount = 0;
    
        /**
         * Creates a new CNETMsg_SpawnGroup_Unload instance using the specified properties.
         * @function create
         * @memberof CNETMsg_SpawnGroup_Unload
         * @static
         * @param {ICNETMsg_SpawnGroup_Unload=} [properties] Properties to set
         * @returns {CNETMsg_SpawnGroup_Unload} CNETMsg_SpawnGroup_Unload instance
         */
        CNETMsg_SpawnGroup_Unload.create = function create(properties) {
            return new CNETMsg_SpawnGroup_Unload(properties);
        };
    
        /**
         * Encodes the specified CNETMsg_SpawnGroup_Unload message. Does not implicitly {@link CNETMsg_SpawnGroup_Unload.verify|verify} messages.
         * @function encode
         * @memberof CNETMsg_SpawnGroup_Unload
         * @static
         * @param {ICNETMsg_SpawnGroup_Unload} message CNETMsg_SpawnGroup_Unload message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CNETMsg_SpawnGroup_Unload.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.spawngrouphandle != null && Object.hasOwnProperty.call(message, "spawngrouphandle"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.spawngrouphandle);
            if (message.flags != null && Object.hasOwnProperty.call(message, "flags"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.flags);
            if (message.tickcount != null && Object.hasOwnProperty.call(message, "tickcount"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.tickcount);
            return writer;
        };
    
        /**
         * Encodes the specified CNETMsg_SpawnGroup_Unload message, length delimited. Does not implicitly {@link CNETMsg_SpawnGroup_Unload.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CNETMsg_SpawnGroup_Unload
         * @static
         * @param {ICNETMsg_SpawnGroup_Unload} message CNETMsg_SpawnGroup_Unload message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CNETMsg_SpawnGroup_Unload.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CNETMsg_SpawnGroup_Unload message from the specified reader or buffer.
         * @function decode
         * @memberof CNETMsg_SpawnGroup_Unload
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CNETMsg_SpawnGroup_Unload} CNETMsg_SpawnGroup_Unload
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CNETMsg_SpawnGroup_Unload.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CNETMsg_SpawnGroup_Unload();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.spawngrouphandle = reader.uint32();
                        break;
                    }
                case 2: {
                        message.flags = reader.uint32();
                        break;
                    }
                case 3: {
                        message.tickcount = reader.int32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CNETMsg_SpawnGroup_Unload message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CNETMsg_SpawnGroup_Unload
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CNETMsg_SpawnGroup_Unload} CNETMsg_SpawnGroup_Unload
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CNETMsg_SpawnGroup_Unload.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CNETMsg_SpawnGroup_Unload message.
         * @function verify
         * @memberof CNETMsg_SpawnGroup_Unload
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CNETMsg_SpawnGroup_Unload.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.spawngrouphandle != null && message.hasOwnProperty("spawngrouphandle"))
                if (!$util.isInteger(message.spawngrouphandle))
                    return "spawngrouphandle: integer expected";
            if (message.flags != null && message.hasOwnProperty("flags"))
                if (!$util.isInteger(message.flags))
                    return "flags: integer expected";
            if (message.tickcount != null && message.hasOwnProperty("tickcount"))
                if (!$util.isInteger(message.tickcount))
                    return "tickcount: integer expected";
            return null;
        };
    
        /**
         * Creates a CNETMsg_SpawnGroup_Unload message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CNETMsg_SpawnGroup_Unload
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CNETMsg_SpawnGroup_Unload} CNETMsg_SpawnGroup_Unload
         */
        CNETMsg_SpawnGroup_Unload.fromObject = function fromObject(object) {
            if (object instanceof $root.CNETMsg_SpawnGroup_Unload)
                return object;
            var message = new $root.CNETMsg_SpawnGroup_Unload();
            if (object.spawngrouphandle != null)
                message.spawngrouphandle = object.spawngrouphandle >>> 0;
            if (object.flags != null)
                message.flags = object.flags >>> 0;
            if (object.tickcount != null)
                message.tickcount = object.tickcount | 0;
            return message;
        };
    
        /**
         * Creates a plain object from a CNETMsg_SpawnGroup_Unload message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CNETMsg_SpawnGroup_Unload
         * @static
         * @param {CNETMsg_SpawnGroup_Unload} message CNETMsg_SpawnGroup_Unload
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CNETMsg_SpawnGroup_Unload.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.spawngrouphandle = 0;
                object.flags = 0;
                object.tickcount = 0;
            }
            if (message.spawngrouphandle != null && message.hasOwnProperty("spawngrouphandle"))
                object.spawngrouphandle = message.spawngrouphandle;
            if (message.flags != null && message.hasOwnProperty("flags"))
                object.flags = message.flags;
            if (message.tickcount != null && message.hasOwnProperty("tickcount"))
                object.tickcount = message.tickcount;
            return object;
        };
    
        /**
         * Converts this CNETMsg_SpawnGroup_Unload to JSON.
         * @function toJSON
         * @memberof CNETMsg_SpawnGroup_Unload
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CNETMsg_SpawnGroup_Unload.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * Gets the default type url for CNETMsg_SpawnGroup_Unload
         * @function getTypeUrl
         * @memberof CNETMsg_SpawnGroup_Unload
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        CNETMsg_SpawnGroup_Unload.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/CNETMsg_SpawnGroup_Unload";
        };
    
        return CNETMsg_SpawnGroup_Unload;
    })();
    
    $root.CNETMsg_SpawnGroup_LoadCompleted = (function() {
    
        /**
         * Properties of a CNETMsg_SpawnGroup_LoadCompleted.
         * @exports ICNETMsg_SpawnGroup_LoadCompleted
         * @interface ICNETMsg_SpawnGroup_LoadCompleted
         * @property {number|null} [spawngrouphandle] CNETMsg_SpawnGroup_LoadCompleted spawngrouphandle
         */
    
        /**
         * Constructs a new CNETMsg_SpawnGroup_LoadCompleted.
         * @exports CNETMsg_SpawnGroup_LoadCompleted
         * @classdesc Represents a CNETMsg_SpawnGroup_LoadCompleted.
         * @implements ICNETMsg_SpawnGroup_LoadCompleted
         * @constructor
         * @param {ICNETMsg_SpawnGroup_LoadCompleted=} [properties] Properties to set
         */
        function CNETMsg_SpawnGroup_LoadCompleted(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CNETMsg_SpawnGroup_LoadCompleted spawngrouphandle.
         * @member {number} spawngrouphandle
         * @memberof CNETMsg_SpawnGroup_LoadCompleted
         * @instance
         */
        CNETMsg_SpawnGroup_LoadCompleted.prototype.spawngrouphandle = 0;
    
        /**
         * Creates a new CNETMsg_SpawnGroup_LoadCompleted instance using the specified properties.
         * @function create
         * @memberof CNETMsg_SpawnGroup_LoadCompleted
         * @static
         * @param {ICNETMsg_SpawnGroup_LoadCompleted=} [properties] Properties to set
         * @returns {CNETMsg_SpawnGroup_LoadCompleted} CNETMsg_SpawnGroup_LoadCompleted instance
         */
        CNETMsg_SpawnGroup_LoadCompleted.create = function create(properties) {
            return new CNETMsg_SpawnGroup_LoadCompleted(properties);
        };
    
        /**
         * Encodes the specified CNETMsg_SpawnGroup_LoadCompleted message. Does not implicitly {@link CNETMsg_SpawnGroup_LoadCompleted.verify|verify} messages.
         * @function encode
         * @memberof CNETMsg_SpawnGroup_LoadCompleted
         * @static
         * @param {ICNETMsg_SpawnGroup_LoadCompleted} message CNETMsg_SpawnGroup_LoadCompleted message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CNETMsg_SpawnGroup_LoadCompleted.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.spawngrouphandle != null && Object.hasOwnProperty.call(message, "spawngrouphandle"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.spawngrouphandle);
            return writer;
        };
    
        /**
         * Encodes the specified CNETMsg_SpawnGroup_LoadCompleted message, length delimited. Does not implicitly {@link CNETMsg_SpawnGroup_LoadCompleted.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CNETMsg_SpawnGroup_LoadCompleted
         * @static
         * @param {ICNETMsg_SpawnGroup_LoadCompleted} message CNETMsg_SpawnGroup_LoadCompleted message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CNETMsg_SpawnGroup_LoadCompleted.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CNETMsg_SpawnGroup_LoadCompleted message from the specified reader or buffer.
         * @function decode
         * @memberof CNETMsg_SpawnGroup_LoadCompleted
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CNETMsg_SpawnGroup_LoadCompleted} CNETMsg_SpawnGroup_LoadCompleted
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CNETMsg_SpawnGroup_LoadCompleted.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CNETMsg_SpawnGroup_LoadCompleted();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.spawngrouphandle = reader.uint32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CNETMsg_SpawnGroup_LoadCompleted message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CNETMsg_SpawnGroup_LoadCompleted
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CNETMsg_SpawnGroup_LoadCompleted} CNETMsg_SpawnGroup_LoadCompleted
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CNETMsg_SpawnGroup_LoadCompleted.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CNETMsg_SpawnGroup_LoadCompleted message.
         * @function verify
         * @memberof CNETMsg_SpawnGroup_LoadCompleted
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CNETMsg_SpawnGroup_LoadCompleted.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.spawngrouphandle != null && message.hasOwnProperty("spawngrouphandle"))
                if (!$util.isInteger(message.spawngrouphandle))
                    return "spawngrouphandle: integer expected";
            return null;
        };
    
        /**
         * Creates a CNETMsg_SpawnGroup_LoadCompleted message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CNETMsg_SpawnGroup_LoadCompleted
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CNETMsg_SpawnGroup_LoadCompleted} CNETMsg_SpawnGroup_LoadCompleted
         */
        CNETMsg_SpawnGroup_LoadCompleted.fromObject = function fromObject(object) {
            if (object instanceof $root.CNETMsg_SpawnGroup_LoadCompleted)
                return object;
            var message = new $root.CNETMsg_SpawnGroup_LoadCompleted();
            if (object.spawngrouphandle != null)
                message.spawngrouphandle = object.spawngrouphandle >>> 0;
            return message;
        };
    
        /**
         * Creates a plain object from a CNETMsg_SpawnGroup_LoadCompleted message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CNETMsg_SpawnGroup_LoadCompleted
         * @static
         * @param {CNETMsg_SpawnGroup_LoadCompleted} message CNETMsg_SpawnGroup_LoadCompleted
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CNETMsg_SpawnGroup_LoadCompleted.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.spawngrouphandle = 0;
            if (message.spawngrouphandle != null && message.hasOwnProperty("spawngrouphandle"))
                object.spawngrouphandle = message.spawngrouphandle;
            return object;
        };
    
        /**
         * Converts this CNETMsg_SpawnGroup_LoadCompleted to JSON.
         * @function toJSON
         * @memberof CNETMsg_SpawnGroup_LoadCompleted
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CNETMsg_SpawnGroup_LoadCompleted.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * Gets the default type url for CNETMsg_SpawnGroup_LoadCompleted
         * @function getTypeUrl
         * @memberof CNETMsg_SpawnGroup_LoadCompleted
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        CNETMsg_SpawnGroup_LoadCompleted.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/CNETMsg_SpawnGroup_LoadCompleted";
        };
    
        return CNETMsg_SpawnGroup_LoadCompleted;
    })();
    
    $root.CSVCMsg_GameSessionConfiguration = (function() {
    
        /**
         * Properties of a CSVCMsg_GameSessionConfiguration.
         * @exports ICSVCMsg_GameSessionConfiguration
         * @interface ICSVCMsg_GameSessionConfiguration
         * @property {boolean|null} [isMultiplayer] CSVCMsg_GameSessionConfiguration isMultiplayer
         * @property {boolean|null} [isLoadsavegame] CSVCMsg_GameSessionConfiguration isLoadsavegame
         * @property {boolean|null} [isBackgroundMap] CSVCMsg_GameSessionConfiguration isBackgroundMap
         * @property {boolean|null} [isHeadless] CSVCMsg_GameSessionConfiguration isHeadless
         * @property {number|null} [minClientLimit] CSVCMsg_GameSessionConfiguration minClientLimit
         * @property {number|null} [maxClientLimit] CSVCMsg_GameSessionConfiguration maxClientLimit
         * @property {number|null} [maxClients] CSVCMsg_GameSessionConfiguration maxClients
         * @property {number|null} [tickInterval] CSVCMsg_GameSessionConfiguration tickInterval
         * @property {string|null} [hostname] CSVCMsg_GameSessionConfiguration hostname
         * @property {string|null} [savegamename] CSVCMsg_GameSessionConfiguration savegamename
         * @property {string|null} [s1Mapname] CSVCMsg_GameSessionConfiguration s1Mapname
         * @property {string|null} [gamemode] CSVCMsg_GameSessionConfiguration gamemode
         * @property {string|null} [serverIpAddress] CSVCMsg_GameSessionConfiguration serverIpAddress
         * @property {Uint8Array|null} [data] CSVCMsg_GameSessionConfiguration data
         * @property {boolean|null} [isLocalonly] CSVCMsg_GameSessionConfiguration isLocalonly
         * @property {boolean|null} [noSteamServer] CSVCMsg_GameSessionConfiguration noSteamServer
         * @property {boolean|null} [isTransition] CSVCMsg_GameSessionConfiguration isTransition
         * @property {string|null} [previouslevel] CSVCMsg_GameSessionConfiguration previouslevel
         * @property {string|null} [landmarkname] CSVCMsg_GameSessionConfiguration landmarkname
         */
    
        /**
         * Constructs a new CSVCMsg_GameSessionConfiguration.
         * @exports CSVCMsg_GameSessionConfiguration
         * @classdesc Represents a CSVCMsg_GameSessionConfiguration.
         * @implements ICSVCMsg_GameSessionConfiguration
         * @constructor
         * @param {ICSVCMsg_GameSessionConfiguration=} [properties] Properties to set
         */
        function CSVCMsg_GameSessionConfiguration(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CSVCMsg_GameSessionConfiguration isMultiplayer.
         * @member {boolean} isMultiplayer
         * @memberof CSVCMsg_GameSessionConfiguration
         * @instance
         */
        CSVCMsg_GameSessionConfiguration.prototype.isMultiplayer = false;
    
        /**
         * CSVCMsg_GameSessionConfiguration isLoadsavegame.
         * @member {boolean} isLoadsavegame
         * @memberof CSVCMsg_GameSessionConfiguration
         * @instance
         */
        CSVCMsg_GameSessionConfiguration.prototype.isLoadsavegame = false;
    
        /**
         * CSVCMsg_GameSessionConfiguration isBackgroundMap.
         * @member {boolean} isBackgroundMap
         * @memberof CSVCMsg_GameSessionConfiguration
         * @instance
         */
        CSVCMsg_GameSessionConfiguration.prototype.isBackgroundMap = false;
    
        /**
         * CSVCMsg_GameSessionConfiguration isHeadless.
         * @member {boolean} isHeadless
         * @memberof CSVCMsg_GameSessionConfiguration
         * @instance
         */
        CSVCMsg_GameSessionConfiguration.prototype.isHeadless = false;
    
        /**
         * CSVCMsg_GameSessionConfiguration minClientLimit.
         * @member {number} minClientLimit
         * @memberof CSVCMsg_GameSessionConfiguration
         * @instance
         */
        CSVCMsg_GameSessionConfiguration.prototype.minClientLimit = 0;
    
        /**
         * CSVCMsg_GameSessionConfiguration maxClientLimit.
         * @member {number} maxClientLimit
         * @memberof CSVCMsg_GameSessionConfiguration
         * @instance
         */
        CSVCMsg_GameSessionConfiguration.prototype.maxClientLimit = 0;
    
        /**
         * CSVCMsg_GameSessionConfiguration maxClients.
         * @member {number} maxClients
         * @memberof CSVCMsg_GameSessionConfiguration
         * @instance
         */
        CSVCMsg_GameSessionConfiguration.prototype.maxClients = 0;
    
        /**
         * CSVCMsg_GameSessionConfiguration tickInterval.
         * @member {number} tickInterval
         * @memberof CSVCMsg_GameSessionConfiguration
         * @instance
         */
        CSVCMsg_GameSessionConfiguration.prototype.tickInterval = 0;
    
        /**
         * CSVCMsg_GameSessionConfiguration hostname.
         * @member {string} hostname
         * @memberof CSVCMsg_GameSessionConfiguration
         * @instance
         */
        CSVCMsg_GameSessionConfiguration.prototype.hostname = "";
    
        /**
         * CSVCMsg_GameSessionConfiguration savegamename.
         * @member {string} savegamename
         * @memberof CSVCMsg_GameSessionConfiguration
         * @instance
         */
        CSVCMsg_GameSessionConfiguration.prototype.savegamename = "";
    
        /**
         * CSVCMsg_GameSessionConfiguration s1Mapname.
         * @member {string} s1Mapname
         * @memberof CSVCMsg_GameSessionConfiguration
         * @instance
         */
        CSVCMsg_GameSessionConfiguration.prototype.s1Mapname = "";
    
        /**
         * CSVCMsg_GameSessionConfiguration gamemode.
         * @member {string} gamemode
         * @memberof CSVCMsg_GameSessionConfiguration
         * @instance
         */
        CSVCMsg_GameSessionConfiguration.prototype.gamemode = "";
    
        /**
         * CSVCMsg_GameSessionConfiguration serverIpAddress.
         * @member {string} serverIpAddress
         * @memberof CSVCMsg_GameSessionConfiguration
         * @instance
         */
        CSVCMsg_GameSessionConfiguration.prototype.serverIpAddress = "";
    
        /**
         * CSVCMsg_GameSessionConfiguration data.
         * @member {Uint8Array} data
         * @memberof CSVCMsg_GameSessionConfiguration
         * @instance
         */
        CSVCMsg_GameSessionConfiguration.prototype.data = $util.newBuffer([]);
    
        /**
         * CSVCMsg_GameSessionConfiguration isLocalonly.
         * @member {boolean} isLocalonly
         * @memberof CSVCMsg_GameSessionConfiguration
         * @instance
         */
        CSVCMsg_GameSessionConfiguration.prototype.isLocalonly = false;
    
        /**
         * CSVCMsg_GameSessionConfiguration noSteamServer.
         * @member {boolean} noSteamServer
         * @memberof CSVCMsg_GameSessionConfiguration
         * @instance
         */
        CSVCMsg_GameSessionConfiguration.prototype.noSteamServer = false;
    
        /**
         * CSVCMsg_GameSessionConfiguration isTransition.
         * @member {boolean} isTransition
         * @memberof CSVCMsg_GameSessionConfiguration
         * @instance
         */
        CSVCMsg_GameSessionConfiguration.prototype.isTransition = false;
    
        /**
         * CSVCMsg_GameSessionConfiguration previouslevel.
         * @member {string} previouslevel
         * @memberof CSVCMsg_GameSessionConfiguration
         * @instance
         */
        CSVCMsg_GameSessionConfiguration.prototype.previouslevel = "";
    
        /**
         * CSVCMsg_GameSessionConfiguration landmarkname.
         * @member {string} landmarkname
         * @memberof CSVCMsg_GameSessionConfiguration
         * @instance
         */
        CSVCMsg_GameSessionConfiguration.prototype.landmarkname = "";
    
        /**
         * Creates a new CSVCMsg_GameSessionConfiguration instance using the specified properties.
         * @function create
         * @memberof CSVCMsg_GameSessionConfiguration
         * @static
         * @param {ICSVCMsg_GameSessionConfiguration=} [properties] Properties to set
         * @returns {CSVCMsg_GameSessionConfiguration} CSVCMsg_GameSessionConfiguration instance
         */
        CSVCMsg_GameSessionConfiguration.create = function create(properties) {
            return new CSVCMsg_GameSessionConfiguration(properties);
        };
    
        /**
         * Encodes the specified CSVCMsg_GameSessionConfiguration message. Does not implicitly {@link CSVCMsg_GameSessionConfiguration.verify|verify} messages.
         * @function encode
         * @memberof CSVCMsg_GameSessionConfiguration
         * @static
         * @param {ICSVCMsg_GameSessionConfiguration} message CSVCMsg_GameSessionConfiguration message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CSVCMsg_GameSessionConfiguration.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.isMultiplayer != null && Object.hasOwnProperty.call(message, "isMultiplayer"))
                writer.uint32(/* id 1, wireType 0 =*/8).bool(message.isMultiplayer);
            if (message.isLoadsavegame != null && Object.hasOwnProperty.call(message, "isLoadsavegame"))
                writer.uint32(/* id 2, wireType 0 =*/16).bool(message.isLoadsavegame);
            if (message.isBackgroundMap != null && Object.hasOwnProperty.call(message, "isBackgroundMap"))
                writer.uint32(/* id 3, wireType 0 =*/24).bool(message.isBackgroundMap);
            if (message.isHeadless != null && Object.hasOwnProperty.call(message, "isHeadless"))
                writer.uint32(/* id 4, wireType 0 =*/32).bool(message.isHeadless);
            if (message.minClientLimit != null && Object.hasOwnProperty.call(message, "minClientLimit"))
                writer.uint32(/* id 5, wireType 0 =*/40).uint32(message.minClientLimit);
            if (message.maxClientLimit != null && Object.hasOwnProperty.call(message, "maxClientLimit"))
                writer.uint32(/* id 6, wireType 0 =*/48).uint32(message.maxClientLimit);
            if (message.maxClients != null && Object.hasOwnProperty.call(message, "maxClients"))
                writer.uint32(/* id 7, wireType 0 =*/56).uint32(message.maxClients);
            if (message.tickInterval != null && Object.hasOwnProperty.call(message, "tickInterval"))
                writer.uint32(/* id 8, wireType 5 =*/69).fixed32(message.tickInterval);
            if (message.hostname != null && Object.hasOwnProperty.call(message, "hostname"))
                writer.uint32(/* id 9, wireType 2 =*/74).string(message.hostname);
            if (message.savegamename != null && Object.hasOwnProperty.call(message, "savegamename"))
                writer.uint32(/* id 10, wireType 2 =*/82).string(message.savegamename);
            if (message.s1Mapname != null && Object.hasOwnProperty.call(message, "s1Mapname"))
                writer.uint32(/* id 11, wireType 2 =*/90).string(message.s1Mapname);
            if (message.gamemode != null && Object.hasOwnProperty.call(message, "gamemode"))
                writer.uint32(/* id 12, wireType 2 =*/98).string(message.gamemode);
            if (message.serverIpAddress != null && Object.hasOwnProperty.call(message, "serverIpAddress"))
                writer.uint32(/* id 13, wireType 2 =*/106).string(message.serverIpAddress);
            if (message.data != null && Object.hasOwnProperty.call(message, "data"))
                writer.uint32(/* id 14, wireType 2 =*/114).bytes(message.data);
            if (message.isLocalonly != null && Object.hasOwnProperty.call(message, "isLocalonly"))
                writer.uint32(/* id 15, wireType 0 =*/120).bool(message.isLocalonly);
            if (message.isTransition != null && Object.hasOwnProperty.call(message, "isTransition"))
                writer.uint32(/* id 16, wireType 0 =*/128).bool(message.isTransition);
            if (message.previouslevel != null && Object.hasOwnProperty.call(message, "previouslevel"))
                writer.uint32(/* id 17, wireType 2 =*/138).string(message.previouslevel);
            if (message.landmarkname != null && Object.hasOwnProperty.call(message, "landmarkname"))
                writer.uint32(/* id 18, wireType 2 =*/146).string(message.landmarkname);
            if (message.noSteamServer != null && Object.hasOwnProperty.call(message, "noSteamServer"))
                writer.uint32(/* id 19, wireType 0 =*/152).bool(message.noSteamServer);
            return writer;
        };
    
        /**
         * Encodes the specified CSVCMsg_GameSessionConfiguration message, length delimited. Does not implicitly {@link CSVCMsg_GameSessionConfiguration.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CSVCMsg_GameSessionConfiguration
         * @static
         * @param {ICSVCMsg_GameSessionConfiguration} message CSVCMsg_GameSessionConfiguration message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CSVCMsg_GameSessionConfiguration.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CSVCMsg_GameSessionConfiguration message from the specified reader or buffer.
         * @function decode
         * @memberof CSVCMsg_GameSessionConfiguration
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CSVCMsg_GameSessionConfiguration} CSVCMsg_GameSessionConfiguration
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CSVCMsg_GameSessionConfiguration.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CSVCMsg_GameSessionConfiguration();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.isMultiplayer = reader.bool();
                        break;
                    }
                case 2: {
                        message.isLoadsavegame = reader.bool();
                        break;
                    }
                case 3: {
                        message.isBackgroundMap = reader.bool();
                        break;
                    }
                case 4: {
                        message.isHeadless = reader.bool();
                        break;
                    }
                case 5: {
                        message.minClientLimit = reader.uint32();
                        break;
                    }
                case 6: {
                        message.maxClientLimit = reader.uint32();
                        break;
                    }
                case 7: {
                        message.maxClients = reader.uint32();
                        break;
                    }
                case 8: {
                        message.tickInterval = reader.fixed32();
                        break;
                    }
                case 9: {
                        message.hostname = reader.string();
                        break;
                    }
                case 10: {
                        message.savegamename = reader.string();
                        break;
                    }
                case 11: {
                        message.s1Mapname = reader.string();
                        break;
                    }
                case 12: {
                        message.gamemode = reader.string();
                        break;
                    }
                case 13: {
                        message.serverIpAddress = reader.string();
                        break;
                    }
                case 14: {
                        message.data = reader.bytes();
                        break;
                    }
                case 15: {
                        message.isLocalonly = reader.bool();
                        break;
                    }
                case 19: {
                        message.noSteamServer = reader.bool();
                        break;
                    }
                case 16: {
                        message.isTransition = reader.bool();
                        break;
                    }
                case 17: {
                        message.previouslevel = reader.string();
                        break;
                    }
                case 18: {
                        message.landmarkname = reader.string();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CSVCMsg_GameSessionConfiguration message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CSVCMsg_GameSessionConfiguration
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CSVCMsg_GameSessionConfiguration} CSVCMsg_GameSessionConfiguration
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CSVCMsg_GameSessionConfiguration.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CSVCMsg_GameSessionConfiguration message.
         * @function verify
         * @memberof CSVCMsg_GameSessionConfiguration
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CSVCMsg_GameSessionConfiguration.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.isMultiplayer != null && message.hasOwnProperty("isMultiplayer"))
                if (typeof message.isMultiplayer !== "boolean")
                    return "isMultiplayer: boolean expected";
            if (message.isLoadsavegame != null && message.hasOwnProperty("isLoadsavegame"))
                if (typeof message.isLoadsavegame !== "boolean")
                    return "isLoadsavegame: boolean expected";
            if (message.isBackgroundMap != null && message.hasOwnProperty("isBackgroundMap"))
                if (typeof message.isBackgroundMap !== "boolean")
                    return "isBackgroundMap: boolean expected";
            if (message.isHeadless != null && message.hasOwnProperty("isHeadless"))
                if (typeof message.isHeadless !== "boolean")
                    return "isHeadless: boolean expected";
            if (message.minClientLimit != null && message.hasOwnProperty("minClientLimit"))
                if (!$util.isInteger(message.minClientLimit))
                    return "minClientLimit: integer expected";
            if (message.maxClientLimit != null && message.hasOwnProperty("maxClientLimit"))
                if (!$util.isInteger(message.maxClientLimit))
                    return "maxClientLimit: integer expected";
            if (message.maxClients != null && message.hasOwnProperty("maxClients"))
                if (!$util.isInteger(message.maxClients))
                    return "maxClients: integer expected";
            if (message.tickInterval != null && message.hasOwnProperty("tickInterval"))
                if (!$util.isInteger(message.tickInterval))
                    return "tickInterval: integer expected";
            if (message.hostname != null && message.hasOwnProperty("hostname"))
                if (!$util.isString(message.hostname))
                    return "hostname: string expected";
            if (message.savegamename != null && message.hasOwnProperty("savegamename"))
                if (!$util.isString(message.savegamename))
                    return "savegamename: string expected";
            if (message.s1Mapname != null && message.hasOwnProperty("s1Mapname"))
                if (!$util.isString(message.s1Mapname))
                    return "s1Mapname: string expected";
            if (message.gamemode != null && message.hasOwnProperty("gamemode"))
                if (!$util.isString(message.gamemode))
                    return "gamemode: string expected";
            if (message.serverIpAddress != null && message.hasOwnProperty("serverIpAddress"))
                if (!$util.isString(message.serverIpAddress))
                    return "serverIpAddress: string expected";
            if (message.data != null && message.hasOwnProperty("data"))
                if (!(message.data && typeof message.data.length === "number" || $util.isString(message.data)))
                    return "data: buffer expected";
            if (message.isLocalonly != null && message.hasOwnProperty("isLocalonly"))
                if (typeof message.isLocalonly !== "boolean")
                    return "isLocalonly: boolean expected";
            if (message.noSteamServer != null && message.hasOwnProperty("noSteamServer"))
                if (typeof message.noSteamServer !== "boolean")
                    return "noSteamServer: boolean expected";
            if (message.isTransition != null && message.hasOwnProperty("isTransition"))
                if (typeof message.isTransition !== "boolean")
                    return "isTransition: boolean expected";
            if (message.previouslevel != null && message.hasOwnProperty("previouslevel"))
                if (!$util.isString(message.previouslevel))
                    return "previouslevel: string expected";
            if (message.landmarkname != null && message.hasOwnProperty("landmarkname"))
                if (!$util.isString(message.landmarkname))
                    return "landmarkname: string expected";
            return null;
        };
    
        /**
         * Creates a CSVCMsg_GameSessionConfiguration message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CSVCMsg_GameSessionConfiguration
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CSVCMsg_GameSessionConfiguration} CSVCMsg_GameSessionConfiguration
         */
        CSVCMsg_GameSessionConfiguration.fromObject = function fromObject(object) {
            if (object instanceof $root.CSVCMsg_GameSessionConfiguration)
                return object;
            var message = new $root.CSVCMsg_GameSessionConfiguration();
            if (object.isMultiplayer != null)
                message.isMultiplayer = Boolean(object.isMultiplayer);
            if (object.isLoadsavegame != null)
                message.isLoadsavegame = Boolean(object.isLoadsavegame);
            if (object.isBackgroundMap != null)
                message.isBackgroundMap = Boolean(object.isBackgroundMap);
            if (object.isHeadless != null)
                message.isHeadless = Boolean(object.isHeadless);
            if (object.minClientLimit != null)
                message.minClientLimit = object.minClientLimit >>> 0;
            if (object.maxClientLimit != null)
                message.maxClientLimit = object.maxClientLimit >>> 0;
            if (object.maxClients != null)
                message.maxClients = object.maxClients >>> 0;
            if (object.tickInterval != null)
                message.tickInterval = object.tickInterval >>> 0;
            if (object.hostname != null)
                message.hostname = String(object.hostname);
            if (object.savegamename != null)
                message.savegamename = String(object.savegamename);
            if (object.s1Mapname != null)
                message.s1Mapname = String(object.s1Mapname);
            if (object.gamemode != null)
                message.gamemode = String(object.gamemode);
            if (object.serverIpAddress != null)
                message.serverIpAddress = String(object.serverIpAddress);
            if (object.data != null)
                if (typeof object.data === "string")
                    $util.base64.decode(object.data, message.data = $util.newBuffer($util.base64.length(object.data)), 0);
                else if (object.data.length >= 0)
                    message.data = object.data;
            if (object.isLocalonly != null)
                message.isLocalonly = Boolean(object.isLocalonly);
            if (object.noSteamServer != null)
                message.noSteamServer = Boolean(object.noSteamServer);
            if (object.isTransition != null)
                message.isTransition = Boolean(object.isTransition);
            if (object.previouslevel != null)
                message.previouslevel = String(object.previouslevel);
            if (object.landmarkname != null)
                message.landmarkname = String(object.landmarkname);
            return message;
        };
    
        /**
         * Creates a plain object from a CSVCMsg_GameSessionConfiguration message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CSVCMsg_GameSessionConfiguration
         * @static
         * @param {CSVCMsg_GameSessionConfiguration} message CSVCMsg_GameSessionConfiguration
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CSVCMsg_GameSessionConfiguration.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.isMultiplayer = false;
                object.isLoadsavegame = false;
                object.isBackgroundMap = false;
                object.isHeadless = false;
                object.minClientLimit = 0;
                object.maxClientLimit = 0;
                object.maxClients = 0;
                object.tickInterval = 0;
                object.hostname = "";
                object.savegamename = "";
                object.s1Mapname = "";
                object.gamemode = "";
                object.serverIpAddress = "";
                if (options.bytes === String)
                    object.data = "";
                else {
                    object.data = [];
                    if (options.bytes !== Array)
                        object.data = $util.newBuffer(object.data);
                }
                object.isLocalonly = false;
                object.isTransition = false;
                object.previouslevel = "";
                object.landmarkname = "";
                object.noSteamServer = false;
            }
            if (message.isMultiplayer != null && message.hasOwnProperty("isMultiplayer"))
                object.isMultiplayer = message.isMultiplayer;
            if (message.isLoadsavegame != null && message.hasOwnProperty("isLoadsavegame"))
                object.isLoadsavegame = message.isLoadsavegame;
            if (message.isBackgroundMap != null && message.hasOwnProperty("isBackgroundMap"))
                object.isBackgroundMap = message.isBackgroundMap;
            if (message.isHeadless != null && message.hasOwnProperty("isHeadless"))
                object.isHeadless = message.isHeadless;
            if (message.minClientLimit != null && message.hasOwnProperty("minClientLimit"))
                object.minClientLimit = message.minClientLimit;
            if (message.maxClientLimit != null && message.hasOwnProperty("maxClientLimit"))
                object.maxClientLimit = message.maxClientLimit;
            if (message.maxClients != null && message.hasOwnProperty("maxClients"))
                object.maxClients = message.maxClients;
            if (message.tickInterval != null && message.hasOwnProperty("tickInterval"))
                object.tickInterval = message.tickInterval;
            if (message.hostname != null && message.hasOwnProperty("hostname"))
                object.hostname = message.hostname;
            if (message.savegamename != null && message.hasOwnProperty("savegamename"))
                object.savegamename = message.savegamename;
            if (message.s1Mapname != null && message.hasOwnProperty("s1Mapname"))
                object.s1Mapname = message.s1Mapname;
            if (message.gamemode != null && message.hasOwnProperty("gamemode"))
                object.gamemode = message.gamemode;
            if (message.serverIpAddress != null && message.hasOwnProperty("serverIpAddress"))
                object.serverIpAddress = message.serverIpAddress;
            if (message.data != null && message.hasOwnProperty("data"))
                object.data = options.bytes === String ? $util.base64.encode(message.data, 0, message.data.length) : options.bytes === Array ? Array.prototype.slice.call(message.data) : message.data;
            if (message.isLocalonly != null && message.hasOwnProperty("isLocalonly"))
                object.isLocalonly = message.isLocalonly;
            if (message.isTransition != null && message.hasOwnProperty("isTransition"))
                object.isTransition = message.isTransition;
            if (message.previouslevel != null && message.hasOwnProperty("previouslevel"))
                object.previouslevel = message.previouslevel;
            if (message.landmarkname != null && message.hasOwnProperty("landmarkname"))
                object.landmarkname = message.landmarkname;
            if (message.noSteamServer != null && message.hasOwnProperty("noSteamServer"))
                object.noSteamServer = message.noSteamServer;
            return object;
        };
    
        /**
         * Converts this CSVCMsg_GameSessionConfiguration to JSON.
         * @function toJSON
         * @memberof CSVCMsg_GameSessionConfiguration
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CSVCMsg_GameSessionConfiguration.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * Gets the default type url for CSVCMsg_GameSessionConfiguration
         * @function getTypeUrl
         * @memberof CSVCMsg_GameSessionConfiguration
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        CSVCMsg_GameSessionConfiguration.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/CSVCMsg_GameSessionConfiguration";
        };
    
        return CSVCMsg_GameSessionConfiguration;
    })();
    
    $root.CNETMsg_DebugOverlay = (function() {
    
        /**
         * Properties of a CNETMsg_DebugOverlay.
         * @exports ICNETMsg_DebugOverlay
         * @interface ICNETMsg_DebugOverlay
         * @property {number|null} [etype] CNETMsg_DebugOverlay etype
         * @property {Array.<ICMsgVector>|null} [vectors] CNETMsg_DebugOverlay vectors
         * @property {Array.<ICMsgRGBA>|null} [colors] CNETMsg_DebugOverlay colors
         * @property {Array.<number>|null} [dimensions] CNETMsg_DebugOverlay dimensions
         * @property {Array.<number>|null} [times] CNETMsg_DebugOverlay times
         * @property {Array.<boolean>|null} [bools] CNETMsg_DebugOverlay bools
         * @property {Array.<number|Long>|null} [uint64s] CNETMsg_DebugOverlay uint64s
         * @property {Array.<string>|null} [strings] CNETMsg_DebugOverlay strings
         */
    
        /**
         * Constructs a new CNETMsg_DebugOverlay.
         * @exports CNETMsg_DebugOverlay
         * @classdesc Represents a CNETMsg_DebugOverlay.
         * @implements ICNETMsg_DebugOverlay
         * @constructor
         * @param {ICNETMsg_DebugOverlay=} [properties] Properties to set
         */
        function CNETMsg_DebugOverlay(properties) {
            this.vectors = [];
            this.colors = [];
            this.dimensions = [];
            this.times = [];
            this.bools = [];
            this.uint64s = [];
            this.strings = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CNETMsg_DebugOverlay etype.
         * @member {number} etype
         * @memberof CNETMsg_DebugOverlay
         * @instance
         */
        CNETMsg_DebugOverlay.prototype.etype = 0;
    
        /**
         * CNETMsg_DebugOverlay vectors.
         * @member {Array.<ICMsgVector>} vectors
         * @memberof CNETMsg_DebugOverlay
         * @instance
         */
        CNETMsg_DebugOverlay.prototype.vectors = $util.emptyArray;
    
        /**
         * CNETMsg_DebugOverlay colors.
         * @member {Array.<ICMsgRGBA>} colors
         * @memberof CNETMsg_DebugOverlay
         * @instance
         */
        CNETMsg_DebugOverlay.prototype.colors = $util.emptyArray;
    
        /**
         * CNETMsg_DebugOverlay dimensions.
         * @member {Array.<number>} dimensions
         * @memberof CNETMsg_DebugOverlay
         * @instance
         */
        CNETMsg_DebugOverlay.prototype.dimensions = $util.emptyArray;
    
        /**
         * CNETMsg_DebugOverlay times.
         * @member {Array.<number>} times
         * @memberof CNETMsg_DebugOverlay
         * @instance
         */
        CNETMsg_DebugOverlay.prototype.times = $util.emptyArray;
    
        /**
         * CNETMsg_DebugOverlay bools.
         * @member {Array.<boolean>} bools
         * @memberof CNETMsg_DebugOverlay
         * @instance
         */
        CNETMsg_DebugOverlay.prototype.bools = $util.emptyArray;
    
        /**
         * CNETMsg_DebugOverlay uint64s.
         * @member {Array.<number|Long>} uint64s
         * @memberof CNETMsg_DebugOverlay
         * @instance
         */
        CNETMsg_DebugOverlay.prototype.uint64s = $util.emptyArray;
    
        /**
         * CNETMsg_DebugOverlay strings.
         * @member {Array.<string>} strings
         * @memberof CNETMsg_DebugOverlay
         * @instance
         */
        CNETMsg_DebugOverlay.prototype.strings = $util.emptyArray;
    
        /**
         * Creates a new CNETMsg_DebugOverlay instance using the specified properties.
         * @function create
         * @memberof CNETMsg_DebugOverlay
         * @static
         * @param {ICNETMsg_DebugOverlay=} [properties] Properties to set
         * @returns {CNETMsg_DebugOverlay} CNETMsg_DebugOverlay instance
         */
        CNETMsg_DebugOverlay.create = function create(properties) {
            return new CNETMsg_DebugOverlay(properties);
        };
    
        /**
         * Encodes the specified CNETMsg_DebugOverlay message. Does not implicitly {@link CNETMsg_DebugOverlay.verify|verify} messages.
         * @function encode
         * @memberof CNETMsg_DebugOverlay
         * @static
         * @param {ICNETMsg_DebugOverlay} message CNETMsg_DebugOverlay message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CNETMsg_DebugOverlay.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.etype != null && Object.hasOwnProperty.call(message, "etype"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.etype);
            if (message.vectors != null && message.vectors.length)
                for (var i = 0; i < message.vectors.length; ++i)
                    $root.CMsgVector.encode(message.vectors[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.colors != null && message.colors.length)
                for (var i = 0; i < message.colors.length; ++i)
                    $root.CMsgRGBA.encode(message.colors[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.dimensions != null && message.dimensions.length)
                for (var i = 0; i < message.dimensions.length; ++i)
                    writer.uint32(/* id 4, wireType 5 =*/37).float(message.dimensions[i]);
            if (message.times != null && message.times.length)
                for (var i = 0; i < message.times.length; ++i)
                    writer.uint32(/* id 5, wireType 5 =*/45).float(message.times[i]);
            if (message.bools != null && message.bools.length)
                for (var i = 0; i < message.bools.length; ++i)
                    writer.uint32(/* id 6, wireType 0 =*/48).bool(message.bools[i]);
            if (message.uint64s != null && message.uint64s.length)
                for (var i = 0; i < message.uint64s.length; ++i)
                    writer.uint32(/* id 7, wireType 0 =*/56).uint64(message.uint64s[i]);
            if (message.strings != null && message.strings.length)
                for (var i = 0; i < message.strings.length; ++i)
                    writer.uint32(/* id 8, wireType 2 =*/66).string(message.strings[i]);
            return writer;
        };
    
        /**
         * Encodes the specified CNETMsg_DebugOverlay message, length delimited. Does not implicitly {@link CNETMsg_DebugOverlay.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CNETMsg_DebugOverlay
         * @static
         * @param {ICNETMsg_DebugOverlay} message CNETMsg_DebugOverlay message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CNETMsg_DebugOverlay.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CNETMsg_DebugOverlay message from the specified reader or buffer.
         * @function decode
         * @memberof CNETMsg_DebugOverlay
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CNETMsg_DebugOverlay} CNETMsg_DebugOverlay
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CNETMsg_DebugOverlay.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CNETMsg_DebugOverlay();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.etype = reader.int32();
                        break;
                    }
                case 2: {
                        if (!(message.vectors && message.vectors.length))
                            message.vectors = [];
                        message.vectors.push($root.CMsgVector.decode(reader, reader.uint32()));
                        break;
                    }
                case 3: {
                        if (!(message.colors && message.colors.length))
                            message.colors = [];
                        message.colors.push($root.CMsgRGBA.decode(reader, reader.uint32()));
                        break;
                    }
                case 4: {
                        if (!(message.dimensions && message.dimensions.length))
                            message.dimensions = [];
                        if ((tag & 7) === 2) {
                            var end2 = reader.uint32() + reader.pos;
                            while (reader.pos < end2)
                                message.dimensions.push(reader.float());
                        } else
                            message.dimensions.push(reader.float());
                        break;
                    }
                case 5: {
                        if (!(message.times && message.times.length))
                            message.times = [];
                        if ((tag & 7) === 2) {
                            var end2 = reader.uint32() + reader.pos;
                            while (reader.pos < end2)
                                message.times.push(reader.float());
                        } else
                            message.times.push(reader.float());
                        break;
                    }
                case 6: {
                        if (!(message.bools && message.bools.length))
                            message.bools = [];
                        if ((tag & 7) === 2) {
                            var end2 = reader.uint32() + reader.pos;
                            while (reader.pos < end2)
                                message.bools.push(reader.bool());
                        } else
                            message.bools.push(reader.bool());
                        break;
                    }
                case 7: {
                        if (!(message.uint64s && message.uint64s.length))
                            message.uint64s = [];
                        if ((tag & 7) === 2) {
                            var end2 = reader.uint32() + reader.pos;
                            while (reader.pos < end2)
                                message.uint64s.push(reader.uint64());
                        } else
                            message.uint64s.push(reader.uint64());
                        break;
                    }
                case 8: {
                        if (!(message.strings && message.strings.length))
                            message.strings = [];
                        message.strings.push(reader.string());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CNETMsg_DebugOverlay message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CNETMsg_DebugOverlay
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CNETMsg_DebugOverlay} CNETMsg_DebugOverlay
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CNETMsg_DebugOverlay.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CNETMsg_DebugOverlay message.
         * @function verify
         * @memberof CNETMsg_DebugOverlay
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CNETMsg_DebugOverlay.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.etype != null && message.hasOwnProperty("etype"))
                if (!$util.isInteger(message.etype))
                    return "etype: integer expected";
            if (message.vectors != null && message.hasOwnProperty("vectors")) {
                if (!Array.isArray(message.vectors))
                    return "vectors: array expected";
                for (var i = 0; i < message.vectors.length; ++i) {
                    var error = $root.CMsgVector.verify(message.vectors[i]);
                    if (error)
                        return "vectors." + error;
                }
            }
            if (message.colors != null && message.hasOwnProperty("colors")) {
                if (!Array.isArray(message.colors))
                    return "colors: array expected";
                for (var i = 0; i < message.colors.length; ++i) {
                    var error = $root.CMsgRGBA.verify(message.colors[i]);
                    if (error)
                        return "colors." + error;
                }
            }
            if (message.dimensions != null && message.hasOwnProperty("dimensions")) {
                if (!Array.isArray(message.dimensions))
                    return "dimensions: array expected";
                for (var i = 0; i < message.dimensions.length; ++i)
                    if (typeof message.dimensions[i] !== "number")
                        return "dimensions: number[] expected";
            }
            if (message.times != null && message.hasOwnProperty("times")) {
                if (!Array.isArray(message.times))
                    return "times: array expected";
                for (var i = 0; i < message.times.length; ++i)
                    if (typeof message.times[i] !== "number")
                        return "times: number[] expected";
            }
            if (message.bools != null && message.hasOwnProperty("bools")) {
                if (!Array.isArray(message.bools))
                    return "bools: array expected";
                for (var i = 0; i < message.bools.length; ++i)
                    if (typeof message.bools[i] !== "boolean")
                        return "bools: boolean[] expected";
            }
            if (message.uint64s != null && message.hasOwnProperty("uint64s")) {
                if (!Array.isArray(message.uint64s))
                    return "uint64s: array expected";
                for (var i = 0; i < message.uint64s.length; ++i)
                    if (!$util.isInteger(message.uint64s[i]) && !(message.uint64s[i] && $util.isInteger(message.uint64s[i].low) && $util.isInteger(message.uint64s[i].high)))
                        return "uint64s: integer|Long[] expected";
            }
            if (message.strings != null && message.hasOwnProperty("strings")) {
                if (!Array.isArray(message.strings))
                    return "strings: array expected";
                for (var i = 0; i < message.strings.length; ++i)
                    if (!$util.isString(message.strings[i]))
                        return "strings: string[] expected";
            }
            return null;
        };
    
        /**
         * Creates a CNETMsg_DebugOverlay message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CNETMsg_DebugOverlay
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CNETMsg_DebugOverlay} CNETMsg_DebugOverlay
         */
        CNETMsg_DebugOverlay.fromObject = function fromObject(object) {
            if (object instanceof $root.CNETMsg_DebugOverlay)
                return object;
            var message = new $root.CNETMsg_DebugOverlay();
            if (object.etype != null)
                message.etype = object.etype | 0;
            if (object.vectors) {
                if (!Array.isArray(object.vectors))
                    throw TypeError(".CNETMsg_DebugOverlay.vectors: array expected");
                message.vectors = [];
                for (var i = 0; i < object.vectors.length; ++i) {
                    if (typeof object.vectors[i] !== "object")
                        throw TypeError(".CNETMsg_DebugOverlay.vectors: object expected");
                    message.vectors[i] = $root.CMsgVector.fromObject(object.vectors[i]);
                }
            }
            if (object.colors) {
                if (!Array.isArray(object.colors))
                    throw TypeError(".CNETMsg_DebugOverlay.colors: array expected");
                message.colors = [];
                for (var i = 0; i < object.colors.length; ++i) {
                    if (typeof object.colors[i] !== "object")
                        throw TypeError(".CNETMsg_DebugOverlay.colors: object expected");
                    message.colors[i] = $root.CMsgRGBA.fromObject(object.colors[i]);
                }
            }
            if (object.dimensions) {
                if (!Array.isArray(object.dimensions))
                    throw TypeError(".CNETMsg_DebugOverlay.dimensions: array expected");
                message.dimensions = [];
                for (var i = 0; i < object.dimensions.length; ++i)
                    message.dimensions[i] = Number(object.dimensions[i]);
            }
            if (object.times) {
                if (!Array.isArray(object.times))
                    throw TypeError(".CNETMsg_DebugOverlay.times: array expected");
                message.times = [];
                for (var i = 0; i < object.times.length; ++i)
                    message.times[i] = Number(object.times[i]);
            }
            if (object.bools) {
                if (!Array.isArray(object.bools))
                    throw TypeError(".CNETMsg_DebugOverlay.bools: array expected");
                message.bools = [];
                for (var i = 0; i < object.bools.length; ++i)
                    message.bools[i] = Boolean(object.bools[i]);
            }
            if (object.uint64s) {
                if (!Array.isArray(object.uint64s))
                    throw TypeError(".CNETMsg_DebugOverlay.uint64s: array expected");
                message.uint64s = [];
                for (var i = 0; i < object.uint64s.length; ++i)
                    if ($util.Long)
                        (message.uint64s[i] = $util.Long.fromValue(object.uint64s[i])).unsigned = true;
                    else if (typeof object.uint64s[i] === "string")
                        message.uint64s[i] = parseInt(object.uint64s[i], 10);
                    else if (typeof object.uint64s[i] === "number")
                        message.uint64s[i] = object.uint64s[i];
                    else if (typeof object.uint64s[i] === "object")
                        message.uint64s[i] = new $util.LongBits(object.uint64s[i].low >>> 0, object.uint64s[i].high >>> 0).toNumber(true);
            }
            if (object.strings) {
                if (!Array.isArray(object.strings))
                    throw TypeError(".CNETMsg_DebugOverlay.strings: array expected");
                message.strings = [];
                for (var i = 0; i < object.strings.length; ++i)
                    message.strings[i] = String(object.strings[i]);
            }
            return message;
        };
    
        /**
         * Creates a plain object from a CNETMsg_DebugOverlay message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CNETMsg_DebugOverlay
         * @static
         * @param {CNETMsg_DebugOverlay} message CNETMsg_DebugOverlay
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CNETMsg_DebugOverlay.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults) {
                object.vectors = [];
                object.colors = [];
                object.dimensions = [];
                object.times = [];
                object.bools = [];
                object.uint64s = [];
                object.strings = [];
            }
            if (options.defaults)
                object.etype = 0;
            if (message.etype != null && message.hasOwnProperty("etype"))
                object.etype = message.etype;
            if (message.vectors && message.vectors.length) {
                object.vectors = [];
                for (var j = 0; j < message.vectors.length; ++j)
                    object.vectors[j] = $root.CMsgVector.toObject(message.vectors[j], options);
            }
            if (message.colors && message.colors.length) {
                object.colors = [];
                for (var j = 0; j < message.colors.length; ++j)
                    object.colors[j] = $root.CMsgRGBA.toObject(message.colors[j], options);
            }
            if (message.dimensions && message.dimensions.length) {
                object.dimensions = [];
                for (var j = 0; j < message.dimensions.length; ++j)
                    object.dimensions[j] = options.json && !isFinite(message.dimensions[j]) ? String(message.dimensions[j]) : message.dimensions[j];
            }
            if (message.times && message.times.length) {
                object.times = [];
                for (var j = 0; j < message.times.length; ++j)
                    object.times[j] = options.json && !isFinite(message.times[j]) ? String(message.times[j]) : message.times[j];
            }
            if (message.bools && message.bools.length) {
                object.bools = [];
                for (var j = 0; j < message.bools.length; ++j)
                    object.bools[j] = message.bools[j];
            }
            if (message.uint64s && message.uint64s.length) {
                object.uint64s = [];
                for (var j = 0; j < message.uint64s.length; ++j)
                    if (typeof message.uint64s[j] === "number")
                        object.uint64s[j] = options.longs === String ? String(message.uint64s[j]) : message.uint64s[j];
                    else
                        object.uint64s[j] = options.longs === String ? $util.Long.prototype.toString.call(message.uint64s[j]) : options.longs === Number ? new $util.LongBits(message.uint64s[j].low >>> 0, message.uint64s[j].high >>> 0).toNumber(true) : message.uint64s[j];
            }
            if (message.strings && message.strings.length) {
                object.strings = [];
                for (var j = 0; j < message.strings.length; ++j)
                    object.strings[j] = message.strings[j];
            }
            return object;
        };
    
        /**
         * Converts this CNETMsg_DebugOverlay to JSON.
         * @function toJSON
         * @memberof CNETMsg_DebugOverlay
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CNETMsg_DebugOverlay.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * Gets the default type url for CNETMsg_DebugOverlay
         * @function getTypeUrl
         * @memberof CNETMsg_DebugOverlay
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        CNETMsg_DebugOverlay.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/CNETMsg_DebugOverlay";
        };
    
        return CNETMsg_DebugOverlay;
    })();
    
    /**
     * ENetworkDisconnectionReason enum.
     * @exports ENetworkDisconnectionReason
     * @enum {number}
     * @property {number} NETWORK_DISCONNECT_INVALID=0 NETWORK_DISCONNECT_INVALID value
     * @property {number} NETWORK_DISCONNECT_SHUTDOWN=1 NETWORK_DISCONNECT_SHUTDOWN value
     * @property {number} NETWORK_DISCONNECT_DISCONNECT_BY_USER=2 NETWORK_DISCONNECT_DISCONNECT_BY_USER value
     * @property {number} NETWORK_DISCONNECT_DISCONNECT_BY_SERVER=3 NETWORK_DISCONNECT_DISCONNECT_BY_SERVER value
     * @property {number} NETWORK_DISCONNECT_LOST=4 NETWORK_DISCONNECT_LOST value
     * @property {number} NETWORK_DISCONNECT_OVERFLOW=5 NETWORK_DISCONNECT_OVERFLOW value
     * @property {number} NETWORK_DISCONNECT_STEAM_BANNED=6 NETWORK_DISCONNECT_STEAM_BANNED value
     * @property {number} NETWORK_DISCONNECT_STEAM_INUSE=7 NETWORK_DISCONNECT_STEAM_INUSE value
     * @property {number} NETWORK_DISCONNECT_STEAM_TICKET=8 NETWORK_DISCONNECT_STEAM_TICKET value
     * @property {number} NETWORK_DISCONNECT_STEAM_LOGON=9 NETWORK_DISCONNECT_STEAM_LOGON value
     * @property {number} NETWORK_DISCONNECT_STEAM_AUTHCANCELLED=10 NETWORK_DISCONNECT_STEAM_AUTHCANCELLED value
     * @property {number} NETWORK_DISCONNECT_STEAM_AUTHALREADYUSED=11 NETWORK_DISCONNECT_STEAM_AUTHALREADYUSED value
     * @property {number} NETWORK_DISCONNECT_STEAM_AUTHINVALID=12 NETWORK_DISCONNECT_STEAM_AUTHINVALID value
     * @property {number} NETWORK_DISCONNECT_STEAM_VACBANSTATE=13 NETWORK_DISCONNECT_STEAM_VACBANSTATE value
     * @property {number} NETWORK_DISCONNECT_STEAM_LOGGED_IN_ELSEWHERE=14 NETWORK_DISCONNECT_STEAM_LOGGED_IN_ELSEWHERE value
     * @property {number} NETWORK_DISCONNECT_STEAM_VAC_CHECK_TIMEDOUT=15 NETWORK_DISCONNECT_STEAM_VAC_CHECK_TIMEDOUT value
     * @property {number} NETWORK_DISCONNECT_STEAM_DROPPED=16 NETWORK_DISCONNECT_STEAM_DROPPED value
     * @property {number} NETWORK_DISCONNECT_STEAM_OWNERSHIP=17 NETWORK_DISCONNECT_STEAM_OWNERSHIP value
     * @property {number} NETWORK_DISCONNECT_SERVERINFO_OVERFLOW=18 NETWORK_DISCONNECT_SERVERINFO_OVERFLOW value
     * @property {number} NETWORK_DISCONNECT_TICKMSG_OVERFLOW=19 NETWORK_DISCONNECT_TICKMSG_OVERFLOW value
     * @property {number} NETWORK_DISCONNECT_STRINGTABLEMSG_OVERFLOW=20 NETWORK_DISCONNECT_STRINGTABLEMSG_OVERFLOW value
     * @property {number} NETWORK_DISCONNECT_DELTAENTMSG_OVERFLOW=21 NETWORK_DISCONNECT_DELTAENTMSG_OVERFLOW value
     * @property {number} NETWORK_DISCONNECT_TEMPENTMSG_OVERFLOW=22 NETWORK_DISCONNECT_TEMPENTMSG_OVERFLOW value
     * @property {number} NETWORK_DISCONNECT_SOUNDSMSG_OVERFLOW=23 NETWORK_DISCONNECT_SOUNDSMSG_OVERFLOW value
     * @property {number} NETWORK_DISCONNECT_SNAPSHOTOVERFLOW=24 NETWORK_DISCONNECT_SNAPSHOTOVERFLOW value
     * @property {number} NETWORK_DISCONNECT_SNAPSHOTERROR=25 NETWORK_DISCONNECT_SNAPSHOTERROR value
     * @property {number} NETWORK_DISCONNECT_RELIABLEOVERFLOW=26 NETWORK_DISCONNECT_RELIABLEOVERFLOW value
     * @property {number} NETWORK_DISCONNECT_BADDELTATICK=27 NETWORK_DISCONNECT_BADDELTATICK value
     * @property {number} NETWORK_DISCONNECT_NOMORESPLITS=28 NETWORK_DISCONNECT_NOMORESPLITS value
     * @property {number} NETWORK_DISCONNECT_TIMEDOUT=29 NETWORK_DISCONNECT_TIMEDOUT value
     * @property {number} NETWORK_DISCONNECT_DISCONNECTED=30 NETWORK_DISCONNECT_DISCONNECTED value
     * @property {number} NETWORK_DISCONNECT_LEAVINGSPLIT=31 NETWORK_DISCONNECT_LEAVINGSPLIT value
     * @property {number} NETWORK_DISCONNECT_DIFFERENTCLASSTABLES=32 NETWORK_DISCONNECT_DIFFERENTCLASSTABLES value
     * @property {number} NETWORK_DISCONNECT_BADRELAYPASSWORD=33 NETWORK_DISCONNECT_BADRELAYPASSWORD value
     * @property {number} NETWORK_DISCONNECT_BADSPECTATORPASSWORD=34 NETWORK_DISCONNECT_BADSPECTATORPASSWORD value
     * @property {number} NETWORK_DISCONNECT_HLTVRESTRICTED=35 NETWORK_DISCONNECT_HLTVRESTRICTED value
     * @property {number} NETWORK_DISCONNECT_NOSPECTATORS=36 NETWORK_DISCONNECT_NOSPECTATORS value
     * @property {number} NETWORK_DISCONNECT_HLTVUNAVAILABLE=37 NETWORK_DISCONNECT_HLTVUNAVAILABLE value
     * @property {number} NETWORK_DISCONNECT_HLTVSTOP=38 NETWORK_DISCONNECT_HLTVSTOP value
     * @property {number} NETWORK_DISCONNECT_KICKED=39 NETWORK_DISCONNECT_KICKED value
     * @property {number} NETWORK_DISCONNECT_BANADDED=40 NETWORK_DISCONNECT_BANADDED value
     * @property {number} NETWORK_DISCONNECT_KICKBANADDED=41 NETWORK_DISCONNECT_KICKBANADDED value
     * @property {number} NETWORK_DISCONNECT_HLTVDIRECT=42 NETWORK_DISCONNECT_HLTVDIRECT value
     * @property {number} NETWORK_DISCONNECT_PURESERVER_CLIENTEXTRA=43 NETWORK_DISCONNECT_PURESERVER_CLIENTEXTRA value
     * @property {number} NETWORK_DISCONNECT_PURESERVER_MISMATCH=44 NETWORK_DISCONNECT_PURESERVER_MISMATCH value
     * @property {number} NETWORK_DISCONNECT_USERCMD=45 NETWORK_DISCONNECT_USERCMD value
     * @property {number} NETWORK_DISCONNECT_REJECTED_BY_GAME=46 NETWORK_DISCONNECT_REJECTED_BY_GAME value
     * @property {number} NETWORK_DISCONNECT_MESSAGE_PARSE_ERROR=47 NETWORK_DISCONNECT_MESSAGE_PARSE_ERROR value
     * @property {number} NETWORK_DISCONNECT_INVALID_MESSAGE_ERROR=48 NETWORK_DISCONNECT_INVALID_MESSAGE_ERROR value
     * @property {number} NETWORK_DISCONNECT_BAD_SERVER_PASSWORD=49 NETWORK_DISCONNECT_BAD_SERVER_PASSWORD value
     * @property {number} NETWORK_DISCONNECT_DIRECT_CONNECT_RESERVATION=50 NETWORK_DISCONNECT_DIRECT_CONNECT_RESERVATION value
     * @property {number} NETWORK_DISCONNECT_CONNECTION_FAILURE=51 NETWORK_DISCONNECT_CONNECTION_FAILURE value
     * @property {number} NETWORK_DISCONNECT_NO_PEER_GROUP_HANDLERS=52 NETWORK_DISCONNECT_NO_PEER_GROUP_HANDLERS value
     * @property {number} NETWORK_DISCONNECT_RECONNECTION=53 NETWORK_DISCONNECT_RECONNECTION value
     * @property {number} NETWORK_DISCONNECT_LOOPSHUTDOWN=54 NETWORK_DISCONNECT_LOOPSHUTDOWN value
     * @property {number} NETWORK_DISCONNECT_LOOPDEACTIVATE=55 NETWORK_DISCONNECT_LOOPDEACTIVATE value
     * @property {number} NETWORK_DISCONNECT_HOST_ENDGAME=56 NETWORK_DISCONNECT_HOST_ENDGAME value
     * @property {number} NETWORK_DISCONNECT_LOOP_LEVELLOAD_ACTIVATE=57 NETWORK_DISCONNECT_LOOP_LEVELLOAD_ACTIVATE value
     * @property {number} NETWORK_DISCONNECT_CREATE_SERVER_FAILED=58 NETWORK_DISCONNECT_CREATE_SERVER_FAILED value
     * @property {number} NETWORK_DISCONNECT_EXITING=59 NETWORK_DISCONNECT_EXITING value
     * @property {number} NETWORK_DISCONNECT_REQUEST_HOSTSTATE_IDLE=60 NETWORK_DISCONNECT_REQUEST_HOSTSTATE_IDLE value
     * @property {number} NETWORK_DISCONNECT_REQUEST_HOSTSTATE_HLTVRELAY=61 NETWORK_DISCONNECT_REQUEST_HOSTSTATE_HLTVRELAY value
     * @property {number} NETWORK_DISCONNECT_CLIENT_CONSISTENCY_FAIL=62 NETWORK_DISCONNECT_CLIENT_CONSISTENCY_FAIL value
     * @property {number} NETWORK_DISCONNECT_CLIENT_UNABLE_TO_CRC_MAP=63 NETWORK_DISCONNECT_CLIENT_UNABLE_TO_CRC_MAP value
     * @property {number} NETWORK_DISCONNECT_CLIENT_NO_MAP=64 NETWORK_DISCONNECT_CLIENT_NO_MAP value
     * @property {number} NETWORK_DISCONNECT_CLIENT_DIFFERENT_MAP=65 NETWORK_DISCONNECT_CLIENT_DIFFERENT_MAP value
     * @property {number} NETWORK_DISCONNECT_SERVER_REQUIRES_STEAM=66 NETWORK_DISCONNECT_SERVER_REQUIRES_STEAM value
     * @property {number} NETWORK_DISCONNECT_STEAM_DENY_MISC=67 NETWORK_DISCONNECT_STEAM_DENY_MISC value
     * @property {number} NETWORK_DISCONNECT_STEAM_DENY_BAD_ANTI_CHEAT=68 NETWORK_DISCONNECT_STEAM_DENY_BAD_ANTI_CHEAT value
     * @property {number} NETWORK_DISCONNECT_SERVER_SHUTDOWN=69 NETWORK_DISCONNECT_SERVER_SHUTDOWN value
     * @property {number} NETWORK_DISCONNECT_REPLAY_INCOMPATIBLE=71 NETWORK_DISCONNECT_REPLAY_INCOMPATIBLE value
     * @property {number} NETWORK_DISCONNECT_CONNECT_REQUEST_TIMEDOUT=72 NETWORK_DISCONNECT_CONNECT_REQUEST_TIMEDOUT value
     * @property {number} NETWORK_DISCONNECT_SERVER_INCOMPATIBLE=73 NETWORK_DISCONNECT_SERVER_INCOMPATIBLE value
     * @property {number} NETWORK_DISCONNECT_LOCALPROBLEM_MANYRELAYS=74 NETWORK_DISCONNECT_LOCALPROBLEM_MANYRELAYS value
     * @property {number} NETWORK_DISCONNECT_LOCALPROBLEM_HOSTEDSERVERPRIMARYRELAY=75 NETWORK_DISCONNECT_LOCALPROBLEM_HOSTEDSERVERPRIMARYRELAY value
     * @property {number} NETWORK_DISCONNECT_LOCALPROBLEM_NETWORKCONFIG=76 NETWORK_DISCONNECT_LOCALPROBLEM_NETWORKCONFIG value
     * @property {number} NETWORK_DISCONNECT_LOCALPROBLEM_OTHER=77 NETWORK_DISCONNECT_LOCALPROBLEM_OTHER value
     * @property {number} NETWORK_DISCONNECT_REMOTE_TIMEOUT=79 NETWORK_DISCONNECT_REMOTE_TIMEOUT value
     * @property {number} NETWORK_DISCONNECT_REMOTE_TIMEOUT_CONNECTING=80 NETWORK_DISCONNECT_REMOTE_TIMEOUT_CONNECTING value
     * @property {number} NETWORK_DISCONNECT_REMOTE_OTHER=81 NETWORK_DISCONNECT_REMOTE_OTHER value
     * @property {number} NETWORK_DISCONNECT_REMOTE_BADCRYPT=82 NETWORK_DISCONNECT_REMOTE_BADCRYPT value
     * @property {number} NETWORK_DISCONNECT_REMOTE_CERTNOTTRUSTED=83 NETWORK_DISCONNECT_REMOTE_CERTNOTTRUSTED value
     * @property {number} NETWORK_DISCONNECT_UNUSUAL=84 NETWORK_DISCONNECT_UNUSUAL value
     * @property {number} NETWORK_DISCONNECT_INTERNAL_ERROR=85 NETWORK_DISCONNECT_INTERNAL_ERROR value
     * @property {number} NETWORK_DISCONNECT_REJECT_BADCHALLENGE=128 NETWORK_DISCONNECT_REJECT_BADCHALLENGE value
     * @property {number} NETWORK_DISCONNECT_REJECT_NOLOBBY=129 NETWORK_DISCONNECT_REJECT_NOLOBBY value
     * @property {number} NETWORK_DISCONNECT_REJECT_BACKGROUND_MAP=130 NETWORK_DISCONNECT_REJECT_BACKGROUND_MAP value
     * @property {number} NETWORK_DISCONNECT_REJECT_SINGLE_PLAYER=131 NETWORK_DISCONNECT_REJECT_SINGLE_PLAYER value
     * @property {number} NETWORK_DISCONNECT_REJECT_HIDDEN_GAME=132 NETWORK_DISCONNECT_REJECT_HIDDEN_GAME value
     * @property {number} NETWORK_DISCONNECT_REJECT_LANRESTRICT=133 NETWORK_DISCONNECT_REJECT_LANRESTRICT value
     * @property {number} NETWORK_DISCONNECT_REJECT_BADPASSWORD=134 NETWORK_DISCONNECT_REJECT_BADPASSWORD value
     * @property {number} NETWORK_DISCONNECT_REJECT_SERVERFULL=135 NETWORK_DISCONNECT_REJECT_SERVERFULL value
     * @property {number} NETWORK_DISCONNECT_REJECT_INVALIDRESERVATION=136 NETWORK_DISCONNECT_REJECT_INVALIDRESERVATION value
     * @property {number} NETWORK_DISCONNECT_REJECT_FAILEDCHANNEL=137 NETWORK_DISCONNECT_REJECT_FAILEDCHANNEL value
     * @property {number} NETWORK_DISCONNECT_REJECT_CONNECT_FROM_LOBBY=138 NETWORK_DISCONNECT_REJECT_CONNECT_FROM_LOBBY value
     * @property {number} NETWORK_DISCONNECT_REJECT_RESERVED_FOR_LOBBY=139 NETWORK_DISCONNECT_REJECT_RESERVED_FOR_LOBBY value
     * @property {number} NETWORK_DISCONNECT_REJECT_INVALIDKEYLENGTH=140 NETWORK_DISCONNECT_REJECT_INVALIDKEYLENGTH value
     * @property {number} NETWORK_DISCONNECT_REJECT_OLDPROTOCOL=141 NETWORK_DISCONNECT_REJECT_OLDPROTOCOL value
     * @property {number} NETWORK_DISCONNECT_REJECT_NEWPROTOCOL=142 NETWORK_DISCONNECT_REJECT_NEWPROTOCOL value
     * @property {number} NETWORK_DISCONNECT_REJECT_INVALIDCONNECTION=143 NETWORK_DISCONNECT_REJECT_INVALIDCONNECTION value
     * @property {number} NETWORK_DISCONNECT_REJECT_INVALIDCERTLEN=144 NETWORK_DISCONNECT_REJECT_INVALIDCERTLEN value
     * @property {number} NETWORK_DISCONNECT_REJECT_INVALIDSTEAMCERTLEN=145 NETWORK_DISCONNECT_REJECT_INVALIDSTEAMCERTLEN value
     * @property {number} NETWORK_DISCONNECT_REJECT_STEAM=146 NETWORK_DISCONNECT_REJECT_STEAM value
     * @property {number} NETWORK_DISCONNECT_REJECT_SERVERAUTHDISABLED=147 NETWORK_DISCONNECT_REJECT_SERVERAUTHDISABLED value
     * @property {number} NETWORK_DISCONNECT_REJECT_SERVERCDKEYAUTHINVALID=148 NETWORK_DISCONNECT_REJECT_SERVERCDKEYAUTHINVALID value
     * @property {number} NETWORK_DISCONNECT_REJECT_BANNED=149 NETWORK_DISCONNECT_REJECT_BANNED value
     * @property {number} NETWORK_DISCONNECT_KICKED_TEAMKILLING=150 NETWORK_DISCONNECT_KICKED_TEAMKILLING value
     * @property {number} NETWORK_DISCONNECT_KICKED_TK_START=151 NETWORK_DISCONNECT_KICKED_TK_START value
     * @property {number} NETWORK_DISCONNECT_KICKED_UNTRUSTEDACCOUNT=152 NETWORK_DISCONNECT_KICKED_UNTRUSTEDACCOUNT value
     * @property {number} NETWORK_DISCONNECT_KICKED_CONVICTEDACCOUNT=153 NETWORK_DISCONNECT_KICKED_CONVICTEDACCOUNT value
     * @property {number} NETWORK_DISCONNECT_KICKED_COMPETITIVECOOLDOWN=154 NETWORK_DISCONNECT_KICKED_COMPETITIVECOOLDOWN value
     * @property {number} NETWORK_DISCONNECT_KICKED_TEAMHURTING=155 NETWORK_DISCONNECT_KICKED_TEAMHURTING value
     * @property {number} NETWORK_DISCONNECT_KICKED_HOSTAGEKILLING=156 NETWORK_DISCONNECT_KICKED_HOSTAGEKILLING value
     * @property {number} NETWORK_DISCONNECT_KICKED_VOTEDOFF=157 NETWORK_DISCONNECT_KICKED_VOTEDOFF value
     * @property {number} NETWORK_DISCONNECT_KICKED_IDLE=158 NETWORK_DISCONNECT_KICKED_IDLE value
     * @property {number} NETWORK_DISCONNECT_KICKED_SUICIDE=159 NETWORK_DISCONNECT_KICKED_SUICIDE value
     * @property {number} NETWORK_DISCONNECT_KICKED_NOSTEAMLOGIN=160 NETWORK_DISCONNECT_KICKED_NOSTEAMLOGIN value
     * @property {number} NETWORK_DISCONNECT_KICKED_NOSTEAMTICKET=161 NETWORK_DISCONNECT_KICKED_NOSTEAMTICKET value
     */
    $root.ENetworkDisconnectionReason = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "NETWORK_DISCONNECT_INVALID"] = 0;
        values[valuesById[1] = "NETWORK_DISCONNECT_SHUTDOWN"] = 1;
        values[valuesById[2] = "NETWORK_DISCONNECT_DISCONNECT_BY_USER"] = 2;
        values[valuesById[3] = "NETWORK_DISCONNECT_DISCONNECT_BY_SERVER"] = 3;
        values[valuesById[4] = "NETWORK_DISCONNECT_LOST"] = 4;
        values[valuesById[5] = "NETWORK_DISCONNECT_OVERFLOW"] = 5;
        values[valuesById[6] = "NETWORK_DISCONNECT_STEAM_BANNED"] = 6;
        values[valuesById[7] = "NETWORK_DISCONNECT_STEAM_INUSE"] = 7;
        values[valuesById[8] = "NETWORK_DISCONNECT_STEAM_TICKET"] = 8;
        values[valuesById[9] = "NETWORK_DISCONNECT_STEAM_LOGON"] = 9;
        values[valuesById[10] = "NETWORK_DISCONNECT_STEAM_AUTHCANCELLED"] = 10;
        values[valuesById[11] = "NETWORK_DISCONNECT_STEAM_AUTHALREADYUSED"] = 11;
        values[valuesById[12] = "NETWORK_DISCONNECT_STEAM_AUTHINVALID"] = 12;
        values[valuesById[13] = "NETWORK_DISCONNECT_STEAM_VACBANSTATE"] = 13;
        values[valuesById[14] = "NETWORK_DISCONNECT_STEAM_LOGGED_IN_ELSEWHERE"] = 14;
        values[valuesById[15] = "NETWORK_DISCONNECT_STEAM_VAC_CHECK_TIMEDOUT"] = 15;
        values[valuesById[16] = "NETWORK_DISCONNECT_STEAM_DROPPED"] = 16;
        values[valuesById[17] = "NETWORK_DISCONNECT_STEAM_OWNERSHIP"] = 17;
        values[valuesById[18] = "NETWORK_DISCONNECT_SERVERINFO_OVERFLOW"] = 18;
        values[valuesById[19] = "NETWORK_DISCONNECT_TICKMSG_OVERFLOW"] = 19;
        values[valuesById[20] = "NETWORK_DISCONNECT_STRINGTABLEMSG_OVERFLOW"] = 20;
        values[valuesById[21] = "NETWORK_DISCONNECT_DELTAENTMSG_OVERFLOW"] = 21;
        values[valuesById[22] = "NETWORK_DISCONNECT_TEMPENTMSG_OVERFLOW"] = 22;
        values[valuesById[23] = "NETWORK_DISCONNECT_SOUNDSMSG_OVERFLOW"] = 23;
        values[valuesById[24] = "NETWORK_DISCONNECT_SNAPSHOTOVERFLOW"] = 24;
        values[valuesById[25] = "NETWORK_DISCONNECT_SNAPSHOTERROR"] = 25;
        values[valuesById[26] = "NETWORK_DISCONNECT_RELIABLEOVERFLOW"] = 26;
        values[valuesById[27] = "NETWORK_DISCONNECT_BADDELTATICK"] = 27;
        values[valuesById[28] = "NETWORK_DISCONNECT_NOMORESPLITS"] = 28;
        values[valuesById[29] = "NETWORK_DISCONNECT_TIMEDOUT"] = 29;
        values[valuesById[30] = "NETWORK_DISCONNECT_DISCONNECTED"] = 30;
        values[valuesById[31] = "NETWORK_DISCONNECT_LEAVINGSPLIT"] = 31;
        values[valuesById[32] = "NETWORK_DISCONNECT_DIFFERENTCLASSTABLES"] = 32;
        values[valuesById[33] = "NETWORK_DISCONNECT_BADRELAYPASSWORD"] = 33;
        values[valuesById[34] = "NETWORK_DISCONNECT_BADSPECTATORPASSWORD"] = 34;
        values[valuesById[35] = "NETWORK_DISCONNECT_HLTVRESTRICTED"] = 35;
        values[valuesById[36] = "NETWORK_DISCONNECT_NOSPECTATORS"] = 36;
        values[valuesById[37] = "NETWORK_DISCONNECT_HLTVUNAVAILABLE"] = 37;
        values[valuesById[38] = "NETWORK_DISCONNECT_HLTVSTOP"] = 38;
        values[valuesById[39] = "NETWORK_DISCONNECT_KICKED"] = 39;
        values[valuesById[40] = "NETWORK_DISCONNECT_BANADDED"] = 40;
        values[valuesById[41] = "NETWORK_DISCONNECT_KICKBANADDED"] = 41;
        values[valuesById[42] = "NETWORK_DISCONNECT_HLTVDIRECT"] = 42;
        values[valuesById[43] = "NETWORK_DISCONNECT_PURESERVER_CLIENTEXTRA"] = 43;
        values[valuesById[44] = "NETWORK_DISCONNECT_PURESERVER_MISMATCH"] = 44;
        values[valuesById[45] = "NETWORK_DISCONNECT_USERCMD"] = 45;
        values[valuesById[46] = "NETWORK_DISCONNECT_REJECTED_BY_GAME"] = 46;
        values[valuesById[47] = "NETWORK_DISCONNECT_MESSAGE_PARSE_ERROR"] = 47;
        values[valuesById[48] = "NETWORK_DISCONNECT_INVALID_MESSAGE_ERROR"] = 48;
        values[valuesById[49] = "NETWORK_DISCONNECT_BAD_SERVER_PASSWORD"] = 49;
        values[valuesById[50] = "NETWORK_DISCONNECT_DIRECT_CONNECT_RESERVATION"] = 50;
        values[valuesById[51] = "NETWORK_DISCONNECT_CONNECTION_FAILURE"] = 51;
        values[valuesById[52] = "NETWORK_DISCONNECT_NO_PEER_GROUP_HANDLERS"] = 52;
        values[valuesById[53] = "NETWORK_DISCONNECT_RECONNECTION"] = 53;
        values[valuesById[54] = "NETWORK_DISCONNECT_LOOPSHUTDOWN"] = 54;
        values[valuesById[55] = "NETWORK_DISCONNECT_LOOPDEACTIVATE"] = 55;
        values[valuesById[56] = "NETWORK_DISCONNECT_HOST_ENDGAME"] = 56;
        values[valuesById[57] = "NETWORK_DISCONNECT_LOOP_LEVELLOAD_ACTIVATE"] = 57;
        values[valuesById[58] = "NETWORK_DISCONNECT_CREATE_SERVER_FAILED"] = 58;
        values[valuesById[59] = "NETWORK_DISCONNECT_EXITING"] = 59;
        values[valuesById[60] = "NETWORK_DISCONNECT_REQUEST_HOSTSTATE_IDLE"] = 60;
        values[valuesById[61] = "NETWORK_DISCONNECT_REQUEST_HOSTSTATE_HLTVRELAY"] = 61;
        values[valuesById[62] = "NETWORK_DISCONNECT_CLIENT_CONSISTENCY_FAIL"] = 62;
        values[valuesById[63] = "NETWORK_DISCONNECT_CLIENT_UNABLE_TO_CRC_MAP"] = 63;
        values[valuesById[64] = "NETWORK_DISCONNECT_CLIENT_NO_MAP"] = 64;
        values[valuesById[65] = "NETWORK_DISCONNECT_CLIENT_DIFFERENT_MAP"] = 65;
        values[valuesById[66] = "NETWORK_DISCONNECT_SERVER_REQUIRES_STEAM"] = 66;
        values[valuesById[67] = "NETWORK_DISCONNECT_STEAM_DENY_MISC"] = 67;
        values[valuesById[68] = "NETWORK_DISCONNECT_STEAM_DENY_BAD_ANTI_CHEAT"] = 68;
        values[valuesById[69] = "NETWORK_DISCONNECT_SERVER_SHUTDOWN"] = 69;
        values[valuesById[71] = "NETWORK_DISCONNECT_REPLAY_INCOMPATIBLE"] = 71;
        values[valuesById[72] = "NETWORK_DISCONNECT_CONNECT_REQUEST_TIMEDOUT"] = 72;
        values[valuesById[73] = "NETWORK_DISCONNECT_SERVER_INCOMPATIBLE"] = 73;
        values[valuesById[74] = "NETWORK_DISCONNECT_LOCALPROBLEM_MANYRELAYS"] = 74;
        values[valuesById[75] = "NETWORK_DISCONNECT_LOCALPROBLEM_HOSTEDSERVERPRIMARYRELAY"] = 75;
        values[valuesById[76] = "NETWORK_DISCONNECT_LOCALPROBLEM_NETWORKCONFIG"] = 76;
        values[valuesById[77] = "NETWORK_DISCONNECT_LOCALPROBLEM_OTHER"] = 77;
        values[valuesById[79] = "NETWORK_DISCONNECT_REMOTE_TIMEOUT"] = 79;
        values[valuesById[80] = "NETWORK_DISCONNECT_REMOTE_TIMEOUT_CONNECTING"] = 80;
        values[valuesById[81] = "NETWORK_DISCONNECT_REMOTE_OTHER"] = 81;
        values[valuesById[82] = "NETWORK_DISCONNECT_REMOTE_BADCRYPT"] = 82;
        values[valuesById[83] = "NETWORK_DISCONNECT_REMOTE_CERTNOTTRUSTED"] = 83;
        values[valuesById[84] = "NETWORK_DISCONNECT_UNUSUAL"] = 84;
        values[valuesById[85] = "NETWORK_DISCONNECT_INTERNAL_ERROR"] = 85;
        values[valuesById[128] = "NETWORK_DISCONNECT_REJECT_BADCHALLENGE"] = 128;
        values[valuesById[129] = "NETWORK_DISCONNECT_REJECT_NOLOBBY"] = 129;
        values[valuesById[130] = "NETWORK_DISCONNECT_REJECT_BACKGROUND_MAP"] = 130;
        values[valuesById[131] = "NETWORK_DISCONNECT_REJECT_SINGLE_PLAYER"] = 131;
        values[valuesById[132] = "NETWORK_DISCONNECT_REJECT_HIDDEN_GAME"] = 132;
        values[valuesById[133] = "NETWORK_DISCONNECT_REJECT_LANRESTRICT"] = 133;
        values[valuesById[134] = "NETWORK_DISCONNECT_REJECT_BADPASSWORD"] = 134;
        values[valuesById[135] = "NETWORK_DISCONNECT_REJECT_SERVERFULL"] = 135;
        values[valuesById[136] = "NETWORK_DISCONNECT_REJECT_INVALIDRESERVATION"] = 136;
        values[valuesById[137] = "NETWORK_DISCONNECT_REJECT_FAILEDCHANNEL"] = 137;
        values[valuesById[138] = "NETWORK_DISCONNECT_REJECT_CONNECT_FROM_LOBBY"] = 138;
        values[valuesById[139] = "NETWORK_DISCONNECT_REJECT_RESERVED_FOR_LOBBY"] = 139;
        values[valuesById[140] = "NETWORK_DISCONNECT_REJECT_INVALIDKEYLENGTH"] = 140;
        values[valuesById[141] = "NETWORK_DISCONNECT_REJECT_OLDPROTOCOL"] = 141;
        values[valuesById[142] = "NETWORK_DISCONNECT_REJECT_NEWPROTOCOL"] = 142;
        values[valuesById[143] = "NETWORK_DISCONNECT_REJECT_INVALIDCONNECTION"] = 143;
        values[valuesById[144] = "NETWORK_DISCONNECT_REJECT_INVALIDCERTLEN"] = 144;
        values[valuesById[145] = "NETWORK_DISCONNECT_REJECT_INVALIDSTEAMCERTLEN"] = 145;
        values[valuesById[146] = "NETWORK_DISCONNECT_REJECT_STEAM"] = 146;
        values[valuesById[147] = "NETWORK_DISCONNECT_REJECT_SERVERAUTHDISABLED"] = 147;
        values[valuesById[148] = "NETWORK_DISCONNECT_REJECT_SERVERCDKEYAUTHINVALID"] = 148;
        values[valuesById[149] = "NETWORK_DISCONNECT_REJECT_BANNED"] = 149;
        values[valuesById[150] = "NETWORK_DISCONNECT_KICKED_TEAMKILLING"] = 150;
        values[valuesById[151] = "NETWORK_DISCONNECT_KICKED_TK_START"] = 151;
        values[valuesById[152] = "NETWORK_DISCONNECT_KICKED_UNTRUSTEDACCOUNT"] = 152;
        values[valuesById[153] = "NETWORK_DISCONNECT_KICKED_CONVICTEDACCOUNT"] = 153;
        values[valuesById[154] = "NETWORK_DISCONNECT_KICKED_COMPETITIVECOOLDOWN"] = 154;
        values[valuesById[155] = "NETWORK_DISCONNECT_KICKED_TEAMHURTING"] = 155;
        values[valuesById[156] = "NETWORK_DISCONNECT_KICKED_HOSTAGEKILLING"] = 156;
        values[valuesById[157] = "NETWORK_DISCONNECT_KICKED_VOTEDOFF"] = 157;
        values[valuesById[158] = "NETWORK_DISCONNECT_KICKED_IDLE"] = 158;
        values[valuesById[159] = "NETWORK_DISCONNECT_KICKED_SUICIDE"] = 159;
        values[valuesById[160] = "NETWORK_DISCONNECT_KICKED_NOSTEAMLOGIN"] = 160;
        values[valuesById[161] = "NETWORK_DISCONNECT_KICKED_NOSTEAMTICKET"] = 161;
        return values;
    })();
    
    $root.google = (function() {
    
        /**
         * Namespace google.
         * @exports google
         * @namespace
         */
        var google = {};
    
        google.protobuf = (function() {
    
            /**
             * Namespace protobuf.
             * @memberof google
             * @namespace
             */
            var protobuf = {};
    
            protobuf.FileDescriptorSet = (function() {
    
                /**
                 * Properties of a FileDescriptorSet.
                 * @memberof google.protobuf
                 * @interface IFileDescriptorSet
                 * @property {Array.<google.protobuf.IFileDescriptorProto>|null} [file] FileDescriptorSet file
                 */
    
                /**
                 * Constructs a new FileDescriptorSet.
                 * @memberof google.protobuf
                 * @classdesc Represents a FileDescriptorSet.
                 * @implements IFileDescriptorSet
                 * @constructor
                 * @param {google.protobuf.IFileDescriptorSet=} [properties] Properties to set
                 */
                function FileDescriptorSet(properties) {
                    this.file = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * FileDescriptorSet file.
                 * @member {Array.<google.protobuf.IFileDescriptorProto>} file
                 * @memberof google.protobuf.FileDescriptorSet
                 * @instance
                 */
                FileDescriptorSet.prototype.file = $util.emptyArray;
    
                /**
                 * Creates a new FileDescriptorSet instance using the specified properties.
                 * @function create
                 * @memberof google.protobuf.FileDescriptorSet
                 * @static
                 * @param {google.protobuf.IFileDescriptorSet=} [properties] Properties to set
                 * @returns {google.protobuf.FileDescriptorSet} FileDescriptorSet instance
                 */
                FileDescriptorSet.create = function create(properties) {
                    return new FileDescriptorSet(properties);
                };
    
                /**
                 * Encodes the specified FileDescriptorSet message. Does not implicitly {@link google.protobuf.FileDescriptorSet.verify|verify} messages.
                 * @function encode
                 * @memberof google.protobuf.FileDescriptorSet
                 * @static
                 * @param {google.protobuf.IFileDescriptorSet} message FileDescriptorSet message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                FileDescriptorSet.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.file != null && message.file.length)
                        for (var i = 0; i < message.file.length; ++i)
                            $root.google.protobuf.FileDescriptorProto.encode(message.file[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified FileDescriptorSet message, length delimited. Does not implicitly {@link google.protobuf.FileDescriptorSet.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof google.protobuf.FileDescriptorSet
                 * @static
                 * @param {google.protobuf.IFileDescriptorSet} message FileDescriptorSet message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                FileDescriptorSet.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a FileDescriptorSet message from the specified reader or buffer.
                 * @function decode
                 * @memberof google.protobuf.FileDescriptorSet
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {google.protobuf.FileDescriptorSet} FileDescriptorSet
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                FileDescriptorSet.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.FileDescriptorSet();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1: {
                                if (!(message.file && message.file.length))
                                    message.file = [];
                                message.file.push($root.google.protobuf.FileDescriptorProto.decode(reader, reader.uint32()));
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a FileDescriptorSet message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof google.protobuf.FileDescriptorSet
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {google.protobuf.FileDescriptorSet} FileDescriptorSet
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                FileDescriptorSet.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a FileDescriptorSet message.
                 * @function verify
                 * @memberof google.protobuf.FileDescriptorSet
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                FileDescriptorSet.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.file != null && message.hasOwnProperty("file")) {
                        if (!Array.isArray(message.file))
                            return "file: array expected";
                        for (var i = 0; i < message.file.length; ++i) {
                            var error = $root.google.protobuf.FileDescriptorProto.verify(message.file[i]);
                            if (error)
                                return "file." + error;
                        }
                    }
                    return null;
                };
    
                /**
                 * Creates a FileDescriptorSet message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof google.protobuf.FileDescriptorSet
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {google.protobuf.FileDescriptorSet} FileDescriptorSet
                 */
                FileDescriptorSet.fromObject = function fromObject(object) {
                    if (object instanceof $root.google.protobuf.FileDescriptorSet)
                        return object;
                    var message = new $root.google.protobuf.FileDescriptorSet();
                    if (object.file) {
                        if (!Array.isArray(object.file))
                            throw TypeError(".google.protobuf.FileDescriptorSet.file: array expected");
                        message.file = [];
                        for (var i = 0; i < object.file.length; ++i) {
                            if (typeof object.file[i] !== "object")
                                throw TypeError(".google.protobuf.FileDescriptorSet.file: object expected");
                            message.file[i] = $root.google.protobuf.FileDescriptorProto.fromObject(object.file[i]);
                        }
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a FileDescriptorSet message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof google.protobuf.FileDescriptorSet
                 * @static
                 * @param {google.protobuf.FileDescriptorSet} message FileDescriptorSet
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                FileDescriptorSet.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.file = [];
                    if (message.file && message.file.length) {
                        object.file = [];
                        for (var j = 0; j < message.file.length; ++j)
                            object.file[j] = $root.google.protobuf.FileDescriptorProto.toObject(message.file[j], options);
                    }
                    return object;
                };
    
                /**
                 * Converts this FileDescriptorSet to JSON.
                 * @function toJSON
                 * @memberof google.protobuf.FileDescriptorSet
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                FileDescriptorSet.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                /**
                 * Gets the default type url for FileDescriptorSet
                 * @function getTypeUrl
                 * @memberof google.protobuf.FileDescriptorSet
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                FileDescriptorSet.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/google.protobuf.FileDescriptorSet";
                };
    
                return FileDescriptorSet;
            })();
    
            protobuf.FileDescriptorProto = (function() {
    
                /**
                 * Properties of a FileDescriptorProto.
                 * @memberof google.protobuf
                 * @interface IFileDescriptorProto
                 * @property {string|null} [name] FileDescriptorProto name
                 * @property {string|null} ["package"] FileDescriptorProto package
                 * @property {Array.<string>|null} [dependency] FileDescriptorProto dependency
                 * @property {Array.<number>|null} [publicDependency] FileDescriptorProto publicDependency
                 * @property {Array.<number>|null} [weakDependency] FileDescriptorProto weakDependency
                 * @property {Array.<google.protobuf.IDescriptorProto>|null} [messageType] FileDescriptorProto messageType
                 * @property {Array.<google.protobuf.IEnumDescriptorProto>|null} [enumType] FileDescriptorProto enumType
                 * @property {Array.<google.protobuf.IServiceDescriptorProto>|null} [service] FileDescriptorProto service
                 * @property {Array.<google.protobuf.IFieldDescriptorProto>|null} [extension] FileDescriptorProto extension
                 * @property {google.protobuf.IFileOptions|null} [options] FileDescriptorProto options
                 * @property {google.protobuf.ISourceCodeInfo|null} [sourceCodeInfo] FileDescriptorProto sourceCodeInfo
                 * @property {string|null} [syntax] FileDescriptorProto syntax
                 */
    
                /**
                 * Constructs a new FileDescriptorProto.
                 * @memberof google.protobuf
                 * @classdesc Represents a FileDescriptorProto.
                 * @implements IFileDescriptorProto
                 * @constructor
                 * @param {google.protobuf.IFileDescriptorProto=} [properties] Properties to set
                 */
                function FileDescriptorProto(properties) {
                    this.dependency = [];
                    this.publicDependency = [];
                    this.weakDependency = [];
                    this.messageType = [];
                    this.enumType = [];
                    this.service = [];
                    this.extension = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * FileDescriptorProto name.
                 * @member {string} name
                 * @memberof google.protobuf.FileDescriptorProto
                 * @instance
                 */
                FileDescriptorProto.prototype.name = "";
    
                /**
                 * FileDescriptorProto package.
                 * @member {string} package
                 * @memberof google.protobuf.FileDescriptorProto
                 * @instance
                 */
                FileDescriptorProto.prototype["package"] = "";
    
                /**
                 * FileDescriptorProto dependency.
                 * @member {Array.<string>} dependency
                 * @memberof google.protobuf.FileDescriptorProto
                 * @instance
                 */
                FileDescriptorProto.prototype.dependency = $util.emptyArray;
    
                /**
                 * FileDescriptorProto publicDependency.
                 * @member {Array.<number>} publicDependency
                 * @memberof google.protobuf.FileDescriptorProto
                 * @instance
                 */
                FileDescriptorProto.prototype.publicDependency = $util.emptyArray;
    
                /**
                 * FileDescriptorProto weakDependency.
                 * @member {Array.<number>} weakDependency
                 * @memberof google.protobuf.FileDescriptorProto
                 * @instance
                 */
                FileDescriptorProto.prototype.weakDependency = $util.emptyArray;
    
                /**
                 * FileDescriptorProto messageType.
                 * @member {Array.<google.protobuf.IDescriptorProto>} messageType
                 * @memberof google.protobuf.FileDescriptorProto
                 * @instance
                 */
                FileDescriptorProto.prototype.messageType = $util.emptyArray;
    
                /**
                 * FileDescriptorProto enumType.
                 * @member {Array.<google.protobuf.IEnumDescriptorProto>} enumType
                 * @memberof google.protobuf.FileDescriptorProto
                 * @instance
                 */
                FileDescriptorProto.prototype.enumType = $util.emptyArray;
    
                /**
                 * FileDescriptorProto service.
                 * @member {Array.<google.protobuf.IServiceDescriptorProto>} service
                 * @memberof google.protobuf.FileDescriptorProto
                 * @instance
                 */
                FileDescriptorProto.prototype.service = $util.emptyArray;
    
                /**
                 * FileDescriptorProto extension.
                 * @member {Array.<google.protobuf.IFieldDescriptorProto>} extension
                 * @memberof google.protobuf.FileDescriptorProto
                 * @instance
                 */
                FileDescriptorProto.prototype.extension = $util.emptyArray;
    
                /**
                 * FileDescriptorProto options.
                 * @member {google.protobuf.IFileOptions|null|undefined} options
                 * @memberof google.protobuf.FileDescriptorProto
                 * @instance
                 */
                FileDescriptorProto.prototype.options = null;
    
                /**
                 * FileDescriptorProto sourceCodeInfo.
                 * @member {google.protobuf.ISourceCodeInfo|null|undefined} sourceCodeInfo
                 * @memberof google.protobuf.FileDescriptorProto
                 * @instance
                 */
                FileDescriptorProto.prototype.sourceCodeInfo = null;
    
                /**
                 * FileDescriptorProto syntax.
                 * @member {string} syntax
                 * @memberof google.protobuf.FileDescriptorProto
                 * @instance
                 */
                FileDescriptorProto.prototype.syntax = "";
    
                /**
                 * Creates a new FileDescriptorProto instance using the specified properties.
                 * @function create
                 * @memberof google.protobuf.FileDescriptorProto
                 * @static
                 * @param {google.protobuf.IFileDescriptorProto=} [properties] Properties to set
                 * @returns {google.protobuf.FileDescriptorProto} FileDescriptorProto instance
                 */
                FileDescriptorProto.create = function create(properties) {
                    return new FileDescriptorProto(properties);
                };
    
                /**
                 * Encodes the specified FileDescriptorProto message. Does not implicitly {@link google.protobuf.FileDescriptorProto.verify|verify} messages.
                 * @function encode
                 * @memberof google.protobuf.FileDescriptorProto
                 * @static
                 * @param {google.protobuf.IFileDescriptorProto} message FileDescriptorProto message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                FileDescriptorProto.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                    if (message["package"] != null && Object.hasOwnProperty.call(message, "package"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message["package"]);
                    if (message.dependency != null && message.dependency.length)
                        for (var i = 0; i < message.dependency.length; ++i)
                            writer.uint32(/* id 3, wireType 2 =*/26).string(message.dependency[i]);
                    if (message.messageType != null && message.messageType.length)
                        for (var i = 0; i < message.messageType.length; ++i)
                            $root.google.protobuf.DescriptorProto.encode(message.messageType[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                    if (message.enumType != null && message.enumType.length)
                        for (var i = 0; i < message.enumType.length; ++i)
                            $root.google.protobuf.EnumDescriptorProto.encode(message.enumType[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                    if (message.service != null && message.service.length)
                        for (var i = 0; i < message.service.length; ++i)
                            $root.google.protobuf.ServiceDescriptorProto.encode(message.service[i], writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                    if (message.extension != null && message.extension.length)
                        for (var i = 0; i < message.extension.length; ++i)
                            $root.google.protobuf.FieldDescriptorProto.encode(message.extension[i], writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
                    if (message.options != null && Object.hasOwnProperty.call(message, "options"))
                        $root.google.protobuf.FileOptions.encode(message.options, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
                    if (message.sourceCodeInfo != null && Object.hasOwnProperty.call(message, "sourceCodeInfo"))
                        $root.google.protobuf.SourceCodeInfo.encode(message.sourceCodeInfo, writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
                    if (message.publicDependency != null && message.publicDependency.length)
                        for (var i = 0; i < message.publicDependency.length; ++i)
                            writer.uint32(/* id 10, wireType 0 =*/80).int32(message.publicDependency[i]);
                    if (message.weakDependency != null && message.weakDependency.length)
                        for (var i = 0; i < message.weakDependency.length; ++i)
                            writer.uint32(/* id 11, wireType 0 =*/88).int32(message.weakDependency[i]);
                    if (message.syntax != null && Object.hasOwnProperty.call(message, "syntax"))
                        writer.uint32(/* id 12, wireType 2 =*/98).string(message.syntax);
                    return writer;
                };
    
                /**
                 * Encodes the specified FileDescriptorProto message, length delimited. Does not implicitly {@link google.protobuf.FileDescriptorProto.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof google.protobuf.FileDescriptorProto
                 * @static
                 * @param {google.protobuf.IFileDescriptorProto} message FileDescriptorProto message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                FileDescriptorProto.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a FileDescriptorProto message from the specified reader or buffer.
                 * @function decode
                 * @memberof google.protobuf.FileDescriptorProto
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {google.protobuf.FileDescriptorProto} FileDescriptorProto
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                FileDescriptorProto.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.FileDescriptorProto();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1: {
                                message.name = reader.string();
                                break;
                            }
                        case 2: {
                                message["package"] = reader.string();
                                break;
                            }
                        case 3: {
                                if (!(message.dependency && message.dependency.length))
                                    message.dependency = [];
                                message.dependency.push(reader.string());
                                break;
                            }
                        case 10: {
                                if (!(message.publicDependency && message.publicDependency.length))
                                    message.publicDependency = [];
                                if ((tag & 7) === 2) {
                                    var end2 = reader.uint32() + reader.pos;
                                    while (reader.pos < end2)
                                        message.publicDependency.push(reader.int32());
                                } else
                                    message.publicDependency.push(reader.int32());
                                break;
                            }
                        case 11: {
                                if (!(message.weakDependency && message.weakDependency.length))
                                    message.weakDependency = [];
                                if ((tag & 7) === 2) {
                                    var end2 = reader.uint32() + reader.pos;
                                    while (reader.pos < end2)
                                        message.weakDependency.push(reader.int32());
                                } else
                                    message.weakDependency.push(reader.int32());
                                break;
                            }
                        case 4: {
                                if (!(message.messageType && message.messageType.length))
                                    message.messageType = [];
                                message.messageType.push($root.google.protobuf.DescriptorProto.decode(reader, reader.uint32()));
                                break;
                            }
                        case 5: {
                                if (!(message.enumType && message.enumType.length))
                                    message.enumType = [];
                                message.enumType.push($root.google.protobuf.EnumDescriptorProto.decode(reader, reader.uint32()));
                                break;
                            }
                        case 6: {
                                if (!(message.service && message.service.length))
                                    message.service = [];
                                message.service.push($root.google.protobuf.ServiceDescriptorProto.decode(reader, reader.uint32()));
                                break;
                            }
                        case 7: {
                                if (!(message.extension && message.extension.length))
                                    message.extension = [];
                                message.extension.push($root.google.protobuf.FieldDescriptorProto.decode(reader, reader.uint32()));
                                break;
                            }
                        case 8: {
                                message.options = $root.google.protobuf.FileOptions.decode(reader, reader.uint32());
                                break;
                            }
                        case 9: {
                                message.sourceCodeInfo = $root.google.protobuf.SourceCodeInfo.decode(reader, reader.uint32());
                                break;
                            }
                        case 12: {
                                message.syntax = reader.string();
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a FileDescriptorProto message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof google.protobuf.FileDescriptorProto
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {google.protobuf.FileDescriptorProto} FileDescriptorProto
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                FileDescriptorProto.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a FileDescriptorProto message.
                 * @function verify
                 * @memberof google.protobuf.FileDescriptorProto
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                FileDescriptorProto.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.name != null && message.hasOwnProperty("name"))
                        if (!$util.isString(message.name))
                            return "name: string expected";
                    if (message["package"] != null && message.hasOwnProperty("package"))
                        if (!$util.isString(message["package"]))
                            return "package: string expected";
                    if (message.dependency != null && message.hasOwnProperty("dependency")) {
                        if (!Array.isArray(message.dependency))
                            return "dependency: array expected";
                        for (var i = 0; i < message.dependency.length; ++i)
                            if (!$util.isString(message.dependency[i]))
                                return "dependency: string[] expected";
                    }
                    if (message.publicDependency != null && message.hasOwnProperty("publicDependency")) {
                        if (!Array.isArray(message.publicDependency))
                            return "publicDependency: array expected";
                        for (var i = 0; i < message.publicDependency.length; ++i)
                            if (!$util.isInteger(message.publicDependency[i]))
                                return "publicDependency: integer[] expected";
                    }
                    if (message.weakDependency != null && message.hasOwnProperty("weakDependency")) {
                        if (!Array.isArray(message.weakDependency))
                            return "weakDependency: array expected";
                        for (var i = 0; i < message.weakDependency.length; ++i)
                            if (!$util.isInteger(message.weakDependency[i]))
                                return "weakDependency: integer[] expected";
                    }
                    if (message.messageType != null && message.hasOwnProperty("messageType")) {
                        if (!Array.isArray(message.messageType))
                            return "messageType: array expected";
                        for (var i = 0; i < message.messageType.length; ++i) {
                            var error = $root.google.protobuf.DescriptorProto.verify(message.messageType[i]);
                            if (error)
                                return "messageType." + error;
                        }
                    }
                    if (message.enumType != null && message.hasOwnProperty("enumType")) {
                        if (!Array.isArray(message.enumType))
                            return "enumType: array expected";
                        for (var i = 0; i < message.enumType.length; ++i) {
                            var error = $root.google.protobuf.EnumDescriptorProto.verify(message.enumType[i]);
                            if (error)
                                return "enumType." + error;
                        }
                    }
                    if (message.service != null && message.hasOwnProperty("service")) {
                        if (!Array.isArray(message.service))
                            return "service: array expected";
                        for (var i = 0; i < message.service.length; ++i) {
                            var error = $root.google.protobuf.ServiceDescriptorProto.verify(message.service[i]);
                            if (error)
                                return "service." + error;
                        }
                    }
                    if (message.extension != null && message.hasOwnProperty("extension")) {
                        if (!Array.isArray(message.extension))
                            return "extension: array expected";
                        for (var i = 0; i < message.extension.length; ++i) {
                            var error = $root.google.protobuf.FieldDescriptorProto.verify(message.extension[i]);
                            if (error)
                                return "extension." + error;
                        }
                    }
                    if (message.options != null && message.hasOwnProperty("options")) {
                        var error = $root.google.protobuf.FileOptions.verify(message.options);
                        if (error)
                            return "options." + error;
                    }
                    if (message.sourceCodeInfo != null && message.hasOwnProperty("sourceCodeInfo")) {
                        var error = $root.google.protobuf.SourceCodeInfo.verify(message.sourceCodeInfo);
                        if (error)
                            return "sourceCodeInfo." + error;
                    }
                    if (message.syntax != null && message.hasOwnProperty("syntax"))
                        if (!$util.isString(message.syntax))
                            return "syntax: string expected";
                    return null;
                };
    
                /**
                 * Creates a FileDescriptorProto message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof google.protobuf.FileDescriptorProto
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {google.protobuf.FileDescriptorProto} FileDescriptorProto
                 */
                FileDescriptorProto.fromObject = function fromObject(object) {
                    if (object instanceof $root.google.protobuf.FileDescriptorProto)
                        return object;
                    var message = new $root.google.protobuf.FileDescriptorProto();
                    if (object.name != null)
                        message.name = String(object.name);
                    if (object["package"] != null)
                        message["package"] = String(object["package"]);
                    if (object.dependency) {
                        if (!Array.isArray(object.dependency))
                            throw TypeError(".google.protobuf.FileDescriptorProto.dependency: array expected");
                        message.dependency = [];
                        for (var i = 0; i < object.dependency.length; ++i)
                            message.dependency[i] = String(object.dependency[i]);
                    }
                    if (object.publicDependency) {
                        if (!Array.isArray(object.publicDependency))
                            throw TypeError(".google.protobuf.FileDescriptorProto.publicDependency: array expected");
                        message.publicDependency = [];
                        for (var i = 0; i < object.publicDependency.length; ++i)
                            message.publicDependency[i] = object.publicDependency[i] | 0;
                    }
                    if (object.weakDependency) {
                        if (!Array.isArray(object.weakDependency))
                            throw TypeError(".google.protobuf.FileDescriptorProto.weakDependency: array expected");
                        message.weakDependency = [];
                        for (var i = 0; i < object.weakDependency.length; ++i)
                            message.weakDependency[i] = object.weakDependency[i] | 0;
                    }
                    if (object.messageType) {
                        if (!Array.isArray(object.messageType))
                            throw TypeError(".google.protobuf.FileDescriptorProto.messageType: array expected");
                        message.messageType = [];
                        for (var i = 0; i < object.messageType.length; ++i) {
                            if (typeof object.messageType[i] !== "object")
                                throw TypeError(".google.protobuf.FileDescriptorProto.messageType: object expected");
                            message.messageType[i] = $root.google.protobuf.DescriptorProto.fromObject(object.messageType[i]);
                        }
                    }
                    if (object.enumType) {
                        if (!Array.isArray(object.enumType))
                            throw TypeError(".google.protobuf.FileDescriptorProto.enumType: array expected");
                        message.enumType = [];
                        for (var i = 0; i < object.enumType.length; ++i) {
                            if (typeof object.enumType[i] !== "object")
                                throw TypeError(".google.protobuf.FileDescriptorProto.enumType: object expected");
                            message.enumType[i] = $root.google.protobuf.EnumDescriptorProto.fromObject(object.enumType[i]);
                        }
                    }
                    if (object.service) {
                        if (!Array.isArray(object.service))
                            throw TypeError(".google.protobuf.FileDescriptorProto.service: array expected");
                        message.service = [];
                        for (var i = 0; i < object.service.length; ++i) {
                            if (typeof object.service[i] !== "object")
                                throw TypeError(".google.protobuf.FileDescriptorProto.service: object expected");
                            message.service[i] = $root.google.protobuf.ServiceDescriptorProto.fromObject(object.service[i]);
                        }
                    }
                    if (object.extension) {
                        if (!Array.isArray(object.extension))
                            throw TypeError(".google.protobuf.FileDescriptorProto.extension: array expected");
                        message.extension = [];
                        for (var i = 0; i < object.extension.length; ++i) {
                            if (typeof object.extension[i] !== "object")
                                throw TypeError(".google.protobuf.FileDescriptorProto.extension: object expected");
                            message.extension[i] = $root.google.protobuf.FieldDescriptorProto.fromObject(object.extension[i]);
                        }
                    }
                    if (object.options != null) {
                        if (typeof object.options !== "object")
                            throw TypeError(".google.protobuf.FileDescriptorProto.options: object expected");
                        message.options = $root.google.protobuf.FileOptions.fromObject(object.options);
                    }
                    if (object.sourceCodeInfo != null) {
                        if (typeof object.sourceCodeInfo !== "object")
                            throw TypeError(".google.protobuf.FileDescriptorProto.sourceCodeInfo: object expected");
                        message.sourceCodeInfo = $root.google.protobuf.SourceCodeInfo.fromObject(object.sourceCodeInfo);
                    }
                    if (object.syntax != null)
                        message.syntax = String(object.syntax);
                    return message;
                };
    
                /**
                 * Creates a plain object from a FileDescriptorProto message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof google.protobuf.FileDescriptorProto
                 * @static
                 * @param {google.protobuf.FileDescriptorProto} message FileDescriptorProto
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                FileDescriptorProto.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults) {
                        object.dependency = [];
                        object.messageType = [];
                        object.enumType = [];
                        object.service = [];
                        object.extension = [];
                        object.publicDependency = [];
                        object.weakDependency = [];
                    }
                    if (options.defaults) {
                        object.name = "";
                        object["package"] = "";
                        object.options = null;
                        object.sourceCodeInfo = null;
                        object.syntax = "";
                    }
                    if (message.name != null && message.hasOwnProperty("name"))
                        object.name = message.name;
                    if (message["package"] != null && message.hasOwnProperty("package"))
                        object["package"] = message["package"];
                    if (message.dependency && message.dependency.length) {
                        object.dependency = [];
                        for (var j = 0; j < message.dependency.length; ++j)
                            object.dependency[j] = message.dependency[j];
                    }
                    if (message.messageType && message.messageType.length) {
                        object.messageType = [];
                        for (var j = 0; j < message.messageType.length; ++j)
                            object.messageType[j] = $root.google.protobuf.DescriptorProto.toObject(message.messageType[j], options);
                    }
                    if (message.enumType && message.enumType.length) {
                        object.enumType = [];
                        for (var j = 0; j < message.enumType.length; ++j)
                            object.enumType[j] = $root.google.protobuf.EnumDescriptorProto.toObject(message.enumType[j], options);
                    }
                    if (message.service && message.service.length) {
                        object.service = [];
                        for (var j = 0; j < message.service.length; ++j)
                            object.service[j] = $root.google.protobuf.ServiceDescriptorProto.toObject(message.service[j], options);
                    }
                    if (message.extension && message.extension.length) {
                        object.extension = [];
                        for (var j = 0; j < message.extension.length; ++j)
                            object.extension[j] = $root.google.protobuf.FieldDescriptorProto.toObject(message.extension[j], options);
                    }
                    if (message.options != null && message.hasOwnProperty("options"))
                        object.options = $root.google.protobuf.FileOptions.toObject(message.options, options);
                    if (message.sourceCodeInfo != null && message.hasOwnProperty("sourceCodeInfo"))
                        object.sourceCodeInfo = $root.google.protobuf.SourceCodeInfo.toObject(message.sourceCodeInfo, options);
                    if (message.publicDependency && message.publicDependency.length) {
                        object.publicDependency = [];
                        for (var j = 0; j < message.publicDependency.length; ++j)
                            object.publicDependency[j] = message.publicDependency[j];
                    }
                    if (message.weakDependency && message.weakDependency.length) {
                        object.weakDependency = [];
                        for (var j = 0; j < message.weakDependency.length; ++j)
                            object.weakDependency[j] = message.weakDependency[j];
                    }
                    if (message.syntax != null && message.hasOwnProperty("syntax"))
                        object.syntax = message.syntax;
                    return object;
                };
    
                /**
                 * Converts this FileDescriptorProto to JSON.
                 * @function toJSON
                 * @memberof google.protobuf.FileDescriptorProto
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                FileDescriptorProto.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                /**
                 * Gets the default type url for FileDescriptorProto
                 * @function getTypeUrl
                 * @memberof google.protobuf.FileDescriptorProto
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                FileDescriptorProto.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/google.protobuf.FileDescriptorProto";
                };
    
                return FileDescriptorProto;
            })();
    
            protobuf.DescriptorProto = (function() {
    
                /**
                 * Properties of a DescriptorProto.
                 * @memberof google.protobuf
                 * @interface IDescriptorProto
                 * @property {string|null} [name] DescriptorProto name
                 * @property {Array.<google.protobuf.IFieldDescriptorProto>|null} [field] DescriptorProto field
                 * @property {Array.<google.protobuf.IFieldDescriptorProto>|null} [extension] DescriptorProto extension
                 * @property {Array.<google.protobuf.IDescriptorProto>|null} [nestedType] DescriptorProto nestedType
                 * @property {Array.<google.protobuf.IEnumDescriptorProto>|null} [enumType] DescriptorProto enumType
                 * @property {Array.<google.protobuf.DescriptorProto.IExtensionRange>|null} [extensionRange] DescriptorProto extensionRange
                 * @property {Array.<google.protobuf.IOneofDescriptorProto>|null} [oneofDecl] DescriptorProto oneofDecl
                 * @property {google.protobuf.IMessageOptions|null} [options] DescriptorProto options
                 * @property {Array.<google.protobuf.DescriptorProto.IReservedRange>|null} [reservedRange] DescriptorProto reservedRange
                 * @property {Array.<string>|null} [reservedName] DescriptorProto reservedName
                 */
    
                /**
                 * Constructs a new DescriptorProto.
                 * @memberof google.protobuf
                 * @classdesc Represents a DescriptorProto.
                 * @implements IDescriptorProto
                 * @constructor
                 * @param {google.protobuf.IDescriptorProto=} [properties] Properties to set
                 */
                function DescriptorProto(properties) {
                    this.field = [];
                    this.extension = [];
                    this.nestedType = [];
                    this.enumType = [];
                    this.extensionRange = [];
                    this.oneofDecl = [];
                    this.reservedRange = [];
                    this.reservedName = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * DescriptorProto name.
                 * @member {string} name
                 * @memberof google.protobuf.DescriptorProto
                 * @instance
                 */
                DescriptorProto.prototype.name = "";
    
                /**
                 * DescriptorProto field.
                 * @member {Array.<google.protobuf.IFieldDescriptorProto>} field
                 * @memberof google.protobuf.DescriptorProto
                 * @instance
                 */
                DescriptorProto.prototype.field = $util.emptyArray;
    
                /**
                 * DescriptorProto extension.
                 * @member {Array.<google.protobuf.IFieldDescriptorProto>} extension
                 * @memberof google.protobuf.DescriptorProto
                 * @instance
                 */
                DescriptorProto.prototype.extension = $util.emptyArray;
    
                /**
                 * DescriptorProto nestedType.
                 * @member {Array.<google.protobuf.IDescriptorProto>} nestedType
                 * @memberof google.protobuf.DescriptorProto
                 * @instance
                 */
                DescriptorProto.prototype.nestedType = $util.emptyArray;
    
                /**
                 * DescriptorProto enumType.
                 * @member {Array.<google.protobuf.IEnumDescriptorProto>} enumType
                 * @memberof google.protobuf.DescriptorProto
                 * @instance
                 */
                DescriptorProto.prototype.enumType = $util.emptyArray;
    
                /**
                 * DescriptorProto extensionRange.
                 * @member {Array.<google.protobuf.DescriptorProto.IExtensionRange>} extensionRange
                 * @memberof google.protobuf.DescriptorProto
                 * @instance
                 */
                DescriptorProto.prototype.extensionRange = $util.emptyArray;
    
                /**
                 * DescriptorProto oneofDecl.
                 * @member {Array.<google.protobuf.IOneofDescriptorProto>} oneofDecl
                 * @memberof google.protobuf.DescriptorProto
                 * @instance
                 */
                DescriptorProto.prototype.oneofDecl = $util.emptyArray;
    
                /**
                 * DescriptorProto options.
                 * @member {google.protobuf.IMessageOptions|null|undefined} options
                 * @memberof google.protobuf.DescriptorProto
                 * @instance
                 */
                DescriptorProto.prototype.options = null;
    
                /**
                 * DescriptorProto reservedRange.
                 * @member {Array.<google.protobuf.DescriptorProto.IReservedRange>} reservedRange
                 * @memberof google.protobuf.DescriptorProto
                 * @instance
                 */
                DescriptorProto.prototype.reservedRange = $util.emptyArray;
    
                /**
                 * DescriptorProto reservedName.
                 * @member {Array.<string>} reservedName
                 * @memberof google.protobuf.DescriptorProto
                 * @instance
                 */
                DescriptorProto.prototype.reservedName = $util.emptyArray;
    
                /**
                 * Creates a new DescriptorProto instance using the specified properties.
                 * @function create
                 * @memberof google.protobuf.DescriptorProto
                 * @static
                 * @param {google.protobuf.IDescriptorProto=} [properties] Properties to set
                 * @returns {google.protobuf.DescriptorProto} DescriptorProto instance
                 */
                DescriptorProto.create = function create(properties) {
                    return new DescriptorProto(properties);
                };
    
                /**
                 * Encodes the specified DescriptorProto message. Does not implicitly {@link google.protobuf.DescriptorProto.verify|verify} messages.
                 * @function encode
                 * @memberof google.protobuf.DescriptorProto
                 * @static
                 * @param {google.protobuf.IDescriptorProto} message DescriptorProto message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                DescriptorProto.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                    if (message.field != null && message.field.length)
                        for (var i = 0; i < message.field.length; ++i)
                            $root.google.protobuf.FieldDescriptorProto.encode(message.field[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    if (message.nestedType != null && message.nestedType.length)
                        for (var i = 0; i < message.nestedType.length; ++i)
                            $root.google.protobuf.DescriptorProto.encode(message.nestedType[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    if (message.enumType != null && message.enumType.length)
                        for (var i = 0; i < message.enumType.length; ++i)
                            $root.google.protobuf.EnumDescriptorProto.encode(message.enumType[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                    if (message.extensionRange != null && message.extensionRange.length)
                        for (var i = 0; i < message.extensionRange.length; ++i)
                            $root.google.protobuf.DescriptorProto.ExtensionRange.encode(message.extensionRange[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                    if (message.extension != null && message.extension.length)
                        for (var i = 0; i < message.extension.length; ++i)
                            $root.google.protobuf.FieldDescriptorProto.encode(message.extension[i], writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                    if (message.options != null && Object.hasOwnProperty.call(message, "options"))
                        $root.google.protobuf.MessageOptions.encode(message.options, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
                    if (message.oneofDecl != null && message.oneofDecl.length)
                        for (var i = 0; i < message.oneofDecl.length; ++i)
                            $root.google.protobuf.OneofDescriptorProto.encode(message.oneofDecl[i], writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
                    if (message.reservedRange != null && message.reservedRange.length)
                        for (var i = 0; i < message.reservedRange.length; ++i)
                            $root.google.protobuf.DescriptorProto.ReservedRange.encode(message.reservedRange[i], writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
                    if (message.reservedName != null && message.reservedName.length)
                        for (var i = 0; i < message.reservedName.length; ++i)
                            writer.uint32(/* id 10, wireType 2 =*/82).string(message.reservedName[i]);
                    return writer;
                };
    
                /**
                 * Encodes the specified DescriptorProto message, length delimited. Does not implicitly {@link google.protobuf.DescriptorProto.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof google.protobuf.DescriptorProto
                 * @static
                 * @param {google.protobuf.IDescriptorProto} message DescriptorProto message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                DescriptorProto.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a DescriptorProto message from the specified reader or buffer.
                 * @function decode
                 * @memberof google.protobuf.DescriptorProto
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {google.protobuf.DescriptorProto} DescriptorProto
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                DescriptorProto.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.DescriptorProto();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1: {
                                message.name = reader.string();
                                break;
                            }
                        case 2: {
                                if (!(message.field && message.field.length))
                                    message.field = [];
                                message.field.push($root.google.protobuf.FieldDescriptorProto.decode(reader, reader.uint32()));
                                break;
                            }
                        case 6: {
                                if (!(message.extension && message.extension.length))
                                    message.extension = [];
                                message.extension.push($root.google.protobuf.FieldDescriptorProto.decode(reader, reader.uint32()));
                                break;
                            }
                        case 3: {
                                if (!(message.nestedType && message.nestedType.length))
                                    message.nestedType = [];
                                message.nestedType.push($root.google.protobuf.DescriptorProto.decode(reader, reader.uint32()));
                                break;
                            }
                        case 4: {
                                if (!(message.enumType && message.enumType.length))
                                    message.enumType = [];
                                message.enumType.push($root.google.protobuf.EnumDescriptorProto.decode(reader, reader.uint32()));
                                break;
                            }
                        case 5: {
                                if (!(message.extensionRange && message.extensionRange.length))
                                    message.extensionRange = [];
                                message.extensionRange.push($root.google.protobuf.DescriptorProto.ExtensionRange.decode(reader, reader.uint32()));
                                break;
                            }
                        case 8: {
                                if (!(message.oneofDecl && message.oneofDecl.length))
                                    message.oneofDecl = [];
                                message.oneofDecl.push($root.google.protobuf.OneofDescriptorProto.decode(reader, reader.uint32()));
                                break;
                            }
                        case 7: {
                                message.options = $root.google.protobuf.MessageOptions.decode(reader, reader.uint32());
                                break;
                            }
                        case 9: {
                                if (!(message.reservedRange && message.reservedRange.length))
                                    message.reservedRange = [];
                                message.reservedRange.push($root.google.protobuf.DescriptorProto.ReservedRange.decode(reader, reader.uint32()));
                                break;
                            }
                        case 10: {
                                if (!(message.reservedName && message.reservedName.length))
                                    message.reservedName = [];
                                message.reservedName.push(reader.string());
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a DescriptorProto message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof google.protobuf.DescriptorProto
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {google.protobuf.DescriptorProto} DescriptorProto
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                DescriptorProto.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a DescriptorProto message.
                 * @function verify
                 * @memberof google.protobuf.DescriptorProto
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                DescriptorProto.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.name != null && message.hasOwnProperty("name"))
                        if (!$util.isString(message.name))
                            return "name: string expected";
                    if (message.field != null && message.hasOwnProperty("field")) {
                        if (!Array.isArray(message.field))
                            return "field: array expected";
                        for (var i = 0; i < message.field.length; ++i) {
                            var error = $root.google.protobuf.FieldDescriptorProto.verify(message.field[i]);
                            if (error)
                                return "field." + error;
                        }
                    }
                    if (message.extension != null && message.hasOwnProperty("extension")) {
                        if (!Array.isArray(message.extension))
                            return "extension: array expected";
                        for (var i = 0; i < message.extension.length; ++i) {
                            var error = $root.google.protobuf.FieldDescriptorProto.verify(message.extension[i]);
                            if (error)
                                return "extension." + error;
                        }
                    }
                    if (message.nestedType != null && message.hasOwnProperty("nestedType")) {
                        if (!Array.isArray(message.nestedType))
                            return "nestedType: array expected";
                        for (var i = 0; i < message.nestedType.length; ++i) {
                            var error = $root.google.protobuf.DescriptorProto.verify(message.nestedType[i]);
                            if (error)
                                return "nestedType." + error;
                        }
                    }
                    if (message.enumType != null && message.hasOwnProperty("enumType")) {
                        if (!Array.isArray(message.enumType))
                            return "enumType: array expected";
                        for (var i = 0; i < message.enumType.length; ++i) {
                            var error = $root.google.protobuf.EnumDescriptorProto.verify(message.enumType[i]);
                            if (error)
                                return "enumType." + error;
                        }
                    }
                    if (message.extensionRange != null && message.hasOwnProperty("extensionRange")) {
                        if (!Array.isArray(message.extensionRange))
                            return "extensionRange: array expected";
                        for (var i = 0; i < message.extensionRange.length; ++i) {
                            var error = $root.google.protobuf.DescriptorProto.ExtensionRange.verify(message.extensionRange[i]);
                            if (error)
                                return "extensionRange." + error;
                        }
                    }
                    if (message.oneofDecl != null && message.hasOwnProperty("oneofDecl")) {
                        if (!Array.isArray(message.oneofDecl))
                            return "oneofDecl: array expected";
                        for (var i = 0; i < message.oneofDecl.length; ++i) {
                            var error = $root.google.protobuf.OneofDescriptorProto.verify(message.oneofDecl[i]);
                            if (error)
                                return "oneofDecl." + error;
                        }
                    }
                    if (message.options != null && message.hasOwnProperty("options")) {
                        var error = $root.google.protobuf.MessageOptions.verify(message.options);
                        if (error)
                            return "options." + error;
                    }
                    if (message.reservedRange != null && message.hasOwnProperty("reservedRange")) {
                        if (!Array.isArray(message.reservedRange))
                            return "reservedRange: array expected";
                        for (var i = 0; i < message.reservedRange.length; ++i) {
                            var error = $root.google.protobuf.DescriptorProto.ReservedRange.verify(message.reservedRange[i]);
                            if (error)
                                return "reservedRange." + error;
                        }
                    }
                    if (message.reservedName != null && message.hasOwnProperty("reservedName")) {
                        if (!Array.isArray(message.reservedName))
                            return "reservedName: array expected";
                        for (var i = 0; i < message.reservedName.length; ++i)
                            if (!$util.isString(message.reservedName[i]))
                                return "reservedName: string[] expected";
                    }
                    return null;
                };
    
                /**
                 * Creates a DescriptorProto message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof google.protobuf.DescriptorProto
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {google.protobuf.DescriptorProto} DescriptorProto
                 */
                DescriptorProto.fromObject = function fromObject(object) {
                    if (object instanceof $root.google.protobuf.DescriptorProto)
                        return object;
                    var message = new $root.google.protobuf.DescriptorProto();
                    if (object.name != null)
                        message.name = String(object.name);
                    if (object.field) {
                        if (!Array.isArray(object.field))
                            throw TypeError(".google.protobuf.DescriptorProto.field: array expected");
                        message.field = [];
                        for (var i = 0; i < object.field.length; ++i) {
                            if (typeof object.field[i] !== "object")
                                throw TypeError(".google.protobuf.DescriptorProto.field: object expected");
                            message.field[i] = $root.google.protobuf.FieldDescriptorProto.fromObject(object.field[i]);
                        }
                    }
                    if (object.extension) {
                        if (!Array.isArray(object.extension))
                            throw TypeError(".google.protobuf.DescriptorProto.extension: array expected");
                        message.extension = [];
                        for (var i = 0; i < object.extension.length; ++i) {
                            if (typeof object.extension[i] !== "object")
                                throw TypeError(".google.protobuf.DescriptorProto.extension: object expected");
                            message.extension[i] = $root.google.protobuf.FieldDescriptorProto.fromObject(object.extension[i]);
                        }
                    }
                    if (object.nestedType) {
                        if (!Array.isArray(object.nestedType))
                            throw TypeError(".google.protobuf.DescriptorProto.nestedType: array expected");
                        message.nestedType = [];
                        for (var i = 0; i < object.nestedType.length; ++i) {
                            if (typeof object.nestedType[i] !== "object")
                                throw TypeError(".google.protobuf.DescriptorProto.nestedType: object expected");
                            message.nestedType[i] = $root.google.protobuf.DescriptorProto.fromObject(object.nestedType[i]);
                        }
                    }
                    if (object.enumType) {
                        if (!Array.isArray(object.enumType))
                            throw TypeError(".google.protobuf.DescriptorProto.enumType: array expected");
                        message.enumType = [];
                        for (var i = 0; i < object.enumType.length; ++i) {
                            if (typeof object.enumType[i] !== "object")
                                throw TypeError(".google.protobuf.DescriptorProto.enumType: object expected");
                            message.enumType[i] = $root.google.protobuf.EnumDescriptorProto.fromObject(object.enumType[i]);
                        }
                    }
                    if (object.extensionRange) {
                        if (!Array.isArray(object.extensionRange))
                            throw TypeError(".google.protobuf.DescriptorProto.extensionRange: array expected");
                        message.extensionRange = [];
                        for (var i = 0; i < object.extensionRange.length; ++i) {
                            if (typeof object.extensionRange[i] !== "object")
                                throw TypeError(".google.protobuf.DescriptorProto.extensionRange: object expected");
                            message.extensionRange[i] = $root.google.protobuf.DescriptorProto.ExtensionRange.fromObject(object.extensionRange[i]);
                        }
                    }
                    if (object.oneofDecl) {
                        if (!Array.isArray(object.oneofDecl))
                            throw TypeError(".google.protobuf.DescriptorProto.oneofDecl: array expected");
                        message.oneofDecl = [];
                        for (var i = 0; i < object.oneofDecl.length; ++i) {
                            if (typeof object.oneofDecl[i] !== "object")
                                throw TypeError(".google.protobuf.DescriptorProto.oneofDecl: object expected");
                            message.oneofDecl[i] = $root.google.protobuf.OneofDescriptorProto.fromObject(object.oneofDecl[i]);
                        }
                    }
                    if (object.options != null) {
                        if (typeof object.options !== "object")
                            throw TypeError(".google.protobuf.DescriptorProto.options: object expected");
                        message.options = $root.google.protobuf.MessageOptions.fromObject(object.options);
                    }
                    if (object.reservedRange) {
                        if (!Array.isArray(object.reservedRange))
                            throw TypeError(".google.protobuf.DescriptorProto.reservedRange: array expected");
                        message.reservedRange = [];
                        for (var i = 0; i < object.reservedRange.length; ++i) {
                            if (typeof object.reservedRange[i] !== "object")
                                throw TypeError(".google.protobuf.DescriptorProto.reservedRange: object expected");
                            message.reservedRange[i] = $root.google.protobuf.DescriptorProto.ReservedRange.fromObject(object.reservedRange[i]);
                        }
                    }
                    if (object.reservedName) {
                        if (!Array.isArray(object.reservedName))
                            throw TypeError(".google.protobuf.DescriptorProto.reservedName: array expected");
                        message.reservedName = [];
                        for (var i = 0; i < object.reservedName.length; ++i)
                            message.reservedName[i] = String(object.reservedName[i]);
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a DescriptorProto message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof google.protobuf.DescriptorProto
                 * @static
                 * @param {google.protobuf.DescriptorProto} message DescriptorProto
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                DescriptorProto.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults) {
                        object.field = [];
                        object.nestedType = [];
                        object.enumType = [];
                        object.extensionRange = [];
                        object.extension = [];
                        object.oneofDecl = [];
                        object.reservedRange = [];
                        object.reservedName = [];
                    }
                    if (options.defaults) {
                        object.name = "";
                        object.options = null;
                    }
                    if (message.name != null && message.hasOwnProperty("name"))
                        object.name = message.name;
                    if (message.field && message.field.length) {
                        object.field = [];
                        for (var j = 0; j < message.field.length; ++j)
                            object.field[j] = $root.google.protobuf.FieldDescriptorProto.toObject(message.field[j], options);
                    }
                    if (message.nestedType && message.nestedType.length) {
                        object.nestedType = [];
                        for (var j = 0; j < message.nestedType.length; ++j)
                            object.nestedType[j] = $root.google.protobuf.DescriptorProto.toObject(message.nestedType[j], options);
                    }
                    if (message.enumType && message.enumType.length) {
                        object.enumType = [];
                        for (var j = 0; j < message.enumType.length; ++j)
                            object.enumType[j] = $root.google.protobuf.EnumDescriptorProto.toObject(message.enumType[j], options);
                    }
                    if (message.extensionRange && message.extensionRange.length) {
                        object.extensionRange = [];
                        for (var j = 0; j < message.extensionRange.length; ++j)
                            object.extensionRange[j] = $root.google.protobuf.DescriptorProto.ExtensionRange.toObject(message.extensionRange[j], options);
                    }
                    if (message.extension && message.extension.length) {
                        object.extension = [];
                        for (var j = 0; j < message.extension.length; ++j)
                            object.extension[j] = $root.google.protobuf.FieldDescriptorProto.toObject(message.extension[j], options);
                    }
                    if (message.options != null && message.hasOwnProperty("options"))
                        object.options = $root.google.protobuf.MessageOptions.toObject(message.options, options);
                    if (message.oneofDecl && message.oneofDecl.length) {
                        object.oneofDecl = [];
                        for (var j = 0; j < message.oneofDecl.length; ++j)
                            object.oneofDecl[j] = $root.google.protobuf.OneofDescriptorProto.toObject(message.oneofDecl[j], options);
                    }
                    if (message.reservedRange && message.reservedRange.length) {
                        object.reservedRange = [];
                        for (var j = 0; j < message.reservedRange.length; ++j)
                            object.reservedRange[j] = $root.google.protobuf.DescriptorProto.ReservedRange.toObject(message.reservedRange[j], options);
                    }
                    if (message.reservedName && message.reservedName.length) {
                        object.reservedName = [];
                        for (var j = 0; j < message.reservedName.length; ++j)
                            object.reservedName[j] = message.reservedName[j];
                    }
                    return object;
                };
    
                /**
                 * Converts this DescriptorProto to JSON.
                 * @function toJSON
                 * @memberof google.protobuf.DescriptorProto
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                DescriptorProto.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                /**
                 * Gets the default type url for DescriptorProto
                 * @function getTypeUrl
                 * @memberof google.protobuf.DescriptorProto
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                DescriptorProto.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/google.protobuf.DescriptorProto";
                };
    
                DescriptorProto.ExtensionRange = (function() {
    
                    /**
                     * Properties of an ExtensionRange.
                     * @memberof google.protobuf.DescriptorProto
                     * @interface IExtensionRange
                     * @property {number|null} [start] ExtensionRange start
                     * @property {number|null} [end] ExtensionRange end
                     */
    
                    /**
                     * Constructs a new ExtensionRange.
                     * @memberof google.protobuf.DescriptorProto
                     * @classdesc Represents an ExtensionRange.
                     * @implements IExtensionRange
                     * @constructor
                     * @param {google.protobuf.DescriptorProto.IExtensionRange=} [properties] Properties to set
                     */
                    function ExtensionRange(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * ExtensionRange start.
                     * @member {number} start
                     * @memberof google.protobuf.DescriptorProto.ExtensionRange
                     * @instance
                     */
                    ExtensionRange.prototype.start = 0;
    
                    /**
                     * ExtensionRange end.
                     * @member {number} end
                     * @memberof google.protobuf.DescriptorProto.ExtensionRange
                     * @instance
                     */
                    ExtensionRange.prototype.end = 0;
    
                    /**
                     * Creates a new ExtensionRange instance using the specified properties.
                     * @function create
                     * @memberof google.protobuf.DescriptorProto.ExtensionRange
                     * @static
                     * @param {google.protobuf.DescriptorProto.IExtensionRange=} [properties] Properties to set
                     * @returns {google.protobuf.DescriptorProto.ExtensionRange} ExtensionRange instance
                     */
                    ExtensionRange.create = function create(properties) {
                        return new ExtensionRange(properties);
                    };
    
                    /**
                     * Encodes the specified ExtensionRange message. Does not implicitly {@link google.protobuf.DescriptorProto.ExtensionRange.verify|verify} messages.
                     * @function encode
                     * @memberof google.protobuf.DescriptorProto.ExtensionRange
                     * @static
                     * @param {google.protobuf.DescriptorProto.IExtensionRange} message ExtensionRange message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    ExtensionRange.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.start != null && Object.hasOwnProperty.call(message, "start"))
                            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.start);
                        if (message.end != null && Object.hasOwnProperty.call(message, "end"))
                            writer.uint32(/* id 2, wireType 0 =*/16).int32(message.end);
                        return writer;
                    };
    
                    /**
                     * Encodes the specified ExtensionRange message, length delimited. Does not implicitly {@link google.protobuf.DescriptorProto.ExtensionRange.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof google.protobuf.DescriptorProto.ExtensionRange
                     * @static
                     * @param {google.protobuf.DescriptorProto.IExtensionRange} message ExtensionRange message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    ExtensionRange.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };
    
                    /**
                     * Decodes an ExtensionRange message from the specified reader or buffer.
                     * @function decode
                     * @memberof google.protobuf.DescriptorProto.ExtensionRange
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {google.protobuf.DescriptorProto.ExtensionRange} ExtensionRange
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    ExtensionRange.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.DescriptorProto.ExtensionRange();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1: {
                                    message.start = reader.int32();
                                    break;
                                }
                            case 2: {
                                    message.end = reader.int32();
                                    break;
                                }
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Decodes an ExtensionRange message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof google.protobuf.DescriptorProto.ExtensionRange
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {google.protobuf.DescriptorProto.ExtensionRange} ExtensionRange
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    ExtensionRange.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };
    
                    /**
                     * Verifies an ExtensionRange message.
                     * @function verify
                     * @memberof google.protobuf.DescriptorProto.ExtensionRange
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    ExtensionRange.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.start != null && message.hasOwnProperty("start"))
                            if (!$util.isInteger(message.start))
                                return "start: integer expected";
                        if (message.end != null && message.hasOwnProperty("end"))
                            if (!$util.isInteger(message.end))
                                return "end: integer expected";
                        return null;
                    };
    
                    /**
                     * Creates an ExtensionRange message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof google.protobuf.DescriptorProto.ExtensionRange
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {google.protobuf.DescriptorProto.ExtensionRange} ExtensionRange
                     */
                    ExtensionRange.fromObject = function fromObject(object) {
                        if (object instanceof $root.google.protobuf.DescriptorProto.ExtensionRange)
                            return object;
                        var message = new $root.google.protobuf.DescriptorProto.ExtensionRange();
                        if (object.start != null)
                            message.start = object.start | 0;
                        if (object.end != null)
                            message.end = object.end | 0;
                        return message;
                    };
    
                    /**
                     * Creates a plain object from an ExtensionRange message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof google.protobuf.DescriptorProto.ExtensionRange
                     * @static
                     * @param {google.protobuf.DescriptorProto.ExtensionRange} message ExtensionRange
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    ExtensionRange.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            object.start = 0;
                            object.end = 0;
                        }
                        if (message.start != null && message.hasOwnProperty("start"))
                            object.start = message.start;
                        if (message.end != null && message.hasOwnProperty("end"))
                            object.end = message.end;
                        return object;
                    };
    
                    /**
                     * Converts this ExtensionRange to JSON.
                     * @function toJSON
                     * @memberof google.protobuf.DescriptorProto.ExtensionRange
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    ExtensionRange.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    /**
                     * Gets the default type url for ExtensionRange
                     * @function getTypeUrl
                     * @memberof google.protobuf.DescriptorProto.ExtensionRange
                     * @static
                     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                     * @returns {string} The default type url
                     */
                    ExtensionRange.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                        if (typeUrlPrefix === undefined) {
                            typeUrlPrefix = "type.googleapis.com";
                        }
                        return typeUrlPrefix + "/google.protobuf.DescriptorProto.ExtensionRange";
                    };
    
                    return ExtensionRange;
                })();
    
                DescriptorProto.ReservedRange = (function() {
    
                    /**
                     * Properties of a ReservedRange.
                     * @memberof google.protobuf.DescriptorProto
                     * @interface IReservedRange
                     * @property {number|null} [start] ReservedRange start
                     * @property {number|null} [end] ReservedRange end
                     */
    
                    /**
                     * Constructs a new ReservedRange.
                     * @memberof google.protobuf.DescriptorProto
                     * @classdesc Represents a ReservedRange.
                     * @implements IReservedRange
                     * @constructor
                     * @param {google.protobuf.DescriptorProto.IReservedRange=} [properties] Properties to set
                     */
                    function ReservedRange(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * ReservedRange start.
                     * @member {number} start
                     * @memberof google.protobuf.DescriptorProto.ReservedRange
                     * @instance
                     */
                    ReservedRange.prototype.start = 0;
    
                    /**
                     * ReservedRange end.
                     * @member {number} end
                     * @memberof google.protobuf.DescriptorProto.ReservedRange
                     * @instance
                     */
                    ReservedRange.prototype.end = 0;
    
                    /**
                     * Creates a new ReservedRange instance using the specified properties.
                     * @function create
                     * @memberof google.protobuf.DescriptorProto.ReservedRange
                     * @static
                     * @param {google.protobuf.DescriptorProto.IReservedRange=} [properties] Properties to set
                     * @returns {google.protobuf.DescriptorProto.ReservedRange} ReservedRange instance
                     */
                    ReservedRange.create = function create(properties) {
                        return new ReservedRange(properties);
                    };
    
                    /**
                     * Encodes the specified ReservedRange message. Does not implicitly {@link google.protobuf.DescriptorProto.ReservedRange.verify|verify} messages.
                     * @function encode
                     * @memberof google.protobuf.DescriptorProto.ReservedRange
                     * @static
                     * @param {google.protobuf.DescriptorProto.IReservedRange} message ReservedRange message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    ReservedRange.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.start != null && Object.hasOwnProperty.call(message, "start"))
                            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.start);
                        if (message.end != null && Object.hasOwnProperty.call(message, "end"))
                            writer.uint32(/* id 2, wireType 0 =*/16).int32(message.end);
                        return writer;
                    };
    
                    /**
                     * Encodes the specified ReservedRange message, length delimited. Does not implicitly {@link google.protobuf.DescriptorProto.ReservedRange.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof google.protobuf.DescriptorProto.ReservedRange
                     * @static
                     * @param {google.protobuf.DescriptorProto.IReservedRange} message ReservedRange message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    ReservedRange.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };
    
                    /**
                     * Decodes a ReservedRange message from the specified reader or buffer.
                     * @function decode
                     * @memberof google.protobuf.DescriptorProto.ReservedRange
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {google.protobuf.DescriptorProto.ReservedRange} ReservedRange
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    ReservedRange.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.DescriptorProto.ReservedRange();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1: {
                                    message.start = reader.int32();
                                    break;
                                }
                            case 2: {
                                    message.end = reader.int32();
                                    break;
                                }
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Decodes a ReservedRange message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof google.protobuf.DescriptorProto.ReservedRange
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {google.protobuf.DescriptorProto.ReservedRange} ReservedRange
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    ReservedRange.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };
    
                    /**
                     * Verifies a ReservedRange message.
                     * @function verify
                     * @memberof google.protobuf.DescriptorProto.ReservedRange
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    ReservedRange.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.start != null && message.hasOwnProperty("start"))
                            if (!$util.isInteger(message.start))
                                return "start: integer expected";
                        if (message.end != null && message.hasOwnProperty("end"))
                            if (!$util.isInteger(message.end))
                                return "end: integer expected";
                        return null;
                    };
    
                    /**
                     * Creates a ReservedRange message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof google.protobuf.DescriptorProto.ReservedRange
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {google.protobuf.DescriptorProto.ReservedRange} ReservedRange
                     */
                    ReservedRange.fromObject = function fromObject(object) {
                        if (object instanceof $root.google.protobuf.DescriptorProto.ReservedRange)
                            return object;
                        var message = new $root.google.protobuf.DescriptorProto.ReservedRange();
                        if (object.start != null)
                            message.start = object.start | 0;
                        if (object.end != null)
                            message.end = object.end | 0;
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a ReservedRange message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof google.protobuf.DescriptorProto.ReservedRange
                     * @static
                     * @param {google.protobuf.DescriptorProto.ReservedRange} message ReservedRange
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    ReservedRange.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            object.start = 0;
                            object.end = 0;
                        }
                        if (message.start != null && message.hasOwnProperty("start"))
                            object.start = message.start;
                        if (message.end != null && message.hasOwnProperty("end"))
                            object.end = message.end;
                        return object;
                    };
    
                    /**
                     * Converts this ReservedRange to JSON.
                     * @function toJSON
                     * @memberof google.protobuf.DescriptorProto.ReservedRange
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    ReservedRange.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    /**
                     * Gets the default type url for ReservedRange
                     * @function getTypeUrl
                     * @memberof google.protobuf.DescriptorProto.ReservedRange
                     * @static
                     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                     * @returns {string} The default type url
                     */
                    ReservedRange.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                        if (typeUrlPrefix === undefined) {
                            typeUrlPrefix = "type.googleapis.com";
                        }
                        return typeUrlPrefix + "/google.protobuf.DescriptorProto.ReservedRange";
                    };
    
                    return ReservedRange;
                })();
    
                return DescriptorProto;
            })();
    
            protobuf.FieldDescriptorProto = (function() {
    
                /**
                 * Properties of a FieldDescriptorProto.
                 * @memberof google.protobuf
                 * @interface IFieldDescriptorProto
                 * @property {string|null} [name] FieldDescriptorProto name
                 * @property {number|null} [number] FieldDescriptorProto number
                 * @property {google.protobuf.FieldDescriptorProto.Label|null} [label] FieldDescriptorProto label
                 * @property {google.protobuf.FieldDescriptorProto.Type|null} [type] FieldDescriptorProto type
                 * @property {string|null} [typeName] FieldDescriptorProto typeName
                 * @property {string|null} [extendee] FieldDescriptorProto extendee
                 * @property {string|null} [defaultValue] FieldDescriptorProto defaultValue
                 * @property {number|null} [oneofIndex] FieldDescriptorProto oneofIndex
                 * @property {string|null} [jsonName] FieldDescriptorProto jsonName
                 * @property {google.protobuf.IFieldOptions|null} [options] FieldDescriptorProto options
                 */
    
                /**
                 * Constructs a new FieldDescriptorProto.
                 * @memberof google.protobuf
                 * @classdesc Represents a FieldDescriptorProto.
                 * @implements IFieldDescriptorProto
                 * @constructor
                 * @param {google.protobuf.IFieldDescriptorProto=} [properties] Properties to set
                 */
                function FieldDescriptorProto(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * FieldDescriptorProto name.
                 * @member {string} name
                 * @memberof google.protobuf.FieldDescriptorProto
                 * @instance
                 */
                FieldDescriptorProto.prototype.name = "";
    
                /**
                 * FieldDescriptorProto number.
                 * @member {number} number
                 * @memberof google.protobuf.FieldDescriptorProto
                 * @instance
                 */
                FieldDescriptorProto.prototype.number = 0;
    
                /**
                 * FieldDescriptorProto label.
                 * @member {google.protobuf.FieldDescriptorProto.Label} label
                 * @memberof google.protobuf.FieldDescriptorProto
                 * @instance
                 */
                FieldDescriptorProto.prototype.label = 1;
    
                /**
                 * FieldDescriptorProto type.
                 * @member {google.protobuf.FieldDescriptorProto.Type} type
                 * @memberof google.protobuf.FieldDescriptorProto
                 * @instance
                 */
                FieldDescriptorProto.prototype.type = 1;
    
                /**
                 * FieldDescriptorProto typeName.
                 * @member {string} typeName
                 * @memberof google.protobuf.FieldDescriptorProto
                 * @instance
                 */
                FieldDescriptorProto.prototype.typeName = "";
    
                /**
                 * FieldDescriptorProto extendee.
                 * @member {string} extendee
                 * @memberof google.protobuf.FieldDescriptorProto
                 * @instance
                 */
                FieldDescriptorProto.prototype.extendee = "";
    
                /**
                 * FieldDescriptorProto defaultValue.
                 * @member {string} defaultValue
                 * @memberof google.protobuf.FieldDescriptorProto
                 * @instance
                 */
                FieldDescriptorProto.prototype.defaultValue = "";
    
                /**
                 * FieldDescriptorProto oneofIndex.
                 * @member {number} oneofIndex
                 * @memberof google.protobuf.FieldDescriptorProto
                 * @instance
                 */
                FieldDescriptorProto.prototype.oneofIndex = 0;
    
                /**
                 * FieldDescriptorProto jsonName.
                 * @member {string} jsonName
                 * @memberof google.protobuf.FieldDescriptorProto
                 * @instance
                 */
                FieldDescriptorProto.prototype.jsonName = "";
    
                /**
                 * FieldDescriptorProto options.
                 * @member {google.protobuf.IFieldOptions|null|undefined} options
                 * @memberof google.protobuf.FieldDescriptorProto
                 * @instance
                 */
                FieldDescriptorProto.prototype.options = null;
    
                /**
                 * Creates a new FieldDescriptorProto instance using the specified properties.
                 * @function create
                 * @memberof google.protobuf.FieldDescriptorProto
                 * @static
                 * @param {google.protobuf.IFieldDescriptorProto=} [properties] Properties to set
                 * @returns {google.protobuf.FieldDescriptorProto} FieldDescriptorProto instance
                 */
                FieldDescriptorProto.create = function create(properties) {
                    return new FieldDescriptorProto(properties);
                };
    
                /**
                 * Encodes the specified FieldDescriptorProto message. Does not implicitly {@link google.protobuf.FieldDescriptorProto.verify|verify} messages.
                 * @function encode
                 * @memberof google.protobuf.FieldDescriptorProto
                 * @static
                 * @param {google.protobuf.IFieldDescriptorProto} message FieldDescriptorProto message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                FieldDescriptorProto.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                    if (message.extendee != null && Object.hasOwnProperty.call(message, "extendee"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.extendee);
                    if (message.number != null && Object.hasOwnProperty.call(message, "number"))
                        writer.uint32(/* id 3, wireType 0 =*/24).int32(message.number);
                    if (message.label != null && Object.hasOwnProperty.call(message, "label"))
                        writer.uint32(/* id 4, wireType 0 =*/32).int32(message.label);
                    if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                        writer.uint32(/* id 5, wireType 0 =*/40).int32(message.type);
                    if (message.typeName != null && Object.hasOwnProperty.call(message, "typeName"))
                        writer.uint32(/* id 6, wireType 2 =*/50).string(message.typeName);
                    if (message.defaultValue != null && Object.hasOwnProperty.call(message, "defaultValue"))
                        writer.uint32(/* id 7, wireType 2 =*/58).string(message.defaultValue);
                    if (message.options != null && Object.hasOwnProperty.call(message, "options"))
                        $root.google.protobuf.FieldOptions.encode(message.options, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
                    if (message.oneofIndex != null && Object.hasOwnProperty.call(message, "oneofIndex"))
                        writer.uint32(/* id 9, wireType 0 =*/72).int32(message.oneofIndex);
                    if (message.jsonName != null && Object.hasOwnProperty.call(message, "jsonName"))
                        writer.uint32(/* id 10, wireType 2 =*/82).string(message.jsonName);
                    return writer;
                };
    
                /**
                 * Encodes the specified FieldDescriptorProto message, length delimited. Does not implicitly {@link google.protobuf.FieldDescriptorProto.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof google.protobuf.FieldDescriptorProto
                 * @static
                 * @param {google.protobuf.IFieldDescriptorProto} message FieldDescriptorProto message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                FieldDescriptorProto.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a FieldDescriptorProto message from the specified reader or buffer.
                 * @function decode
                 * @memberof google.protobuf.FieldDescriptorProto
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {google.protobuf.FieldDescriptorProto} FieldDescriptorProto
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                FieldDescriptorProto.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.FieldDescriptorProto();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1: {
                                message.name = reader.string();
                                break;
                            }
                        case 3: {
                                message.number = reader.int32();
                                break;
                            }
                        case 4: {
                                message.label = reader.int32();
                                break;
                            }
                        case 5: {
                                message.type = reader.int32();
                                break;
                            }
                        case 6: {
                                message.typeName = reader.string();
                                break;
                            }
                        case 2: {
                                message.extendee = reader.string();
                                break;
                            }
                        case 7: {
                                message.defaultValue = reader.string();
                                break;
                            }
                        case 9: {
                                message.oneofIndex = reader.int32();
                                break;
                            }
                        case 10: {
                                message.jsonName = reader.string();
                                break;
                            }
                        case 8: {
                                message.options = $root.google.protobuf.FieldOptions.decode(reader, reader.uint32());
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a FieldDescriptorProto message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof google.protobuf.FieldDescriptorProto
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {google.protobuf.FieldDescriptorProto} FieldDescriptorProto
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                FieldDescriptorProto.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a FieldDescriptorProto message.
                 * @function verify
                 * @memberof google.protobuf.FieldDescriptorProto
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                FieldDescriptorProto.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.name != null && message.hasOwnProperty("name"))
                        if (!$util.isString(message.name))
                            return "name: string expected";
                    if (message.number != null && message.hasOwnProperty("number"))
                        if (!$util.isInteger(message.number))
                            return "number: integer expected";
                    if (message.label != null && message.hasOwnProperty("label"))
                        switch (message.label) {
                        default:
                            return "label: enum value expected";
                        case 1:
                        case 2:
                        case 3:
                            break;
                        }
                    if (message.type != null && message.hasOwnProperty("type"))
                        switch (message.type) {
                        default:
                            return "type: enum value expected";
                        case 1:
                        case 2:
                        case 3:
                        case 4:
                        case 5:
                        case 6:
                        case 7:
                        case 8:
                        case 9:
                        case 10:
                        case 11:
                        case 12:
                        case 13:
                        case 14:
                        case 15:
                        case 16:
                        case 17:
                        case 18:
                            break;
                        }
                    if (message.typeName != null && message.hasOwnProperty("typeName"))
                        if (!$util.isString(message.typeName))
                            return "typeName: string expected";
                    if (message.extendee != null && message.hasOwnProperty("extendee"))
                        if (!$util.isString(message.extendee))
                            return "extendee: string expected";
                    if (message.defaultValue != null && message.hasOwnProperty("defaultValue"))
                        if (!$util.isString(message.defaultValue))
                            return "defaultValue: string expected";
                    if (message.oneofIndex != null && message.hasOwnProperty("oneofIndex"))
                        if (!$util.isInteger(message.oneofIndex))
                            return "oneofIndex: integer expected";
                    if (message.jsonName != null && message.hasOwnProperty("jsonName"))
                        if (!$util.isString(message.jsonName))
                            return "jsonName: string expected";
                    if (message.options != null && message.hasOwnProperty("options")) {
                        var error = $root.google.protobuf.FieldOptions.verify(message.options);
                        if (error)
                            return "options." + error;
                    }
                    return null;
                };
    
                /**
                 * Creates a FieldDescriptorProto message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof google.protobuf.FieldDescriptorProto
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {google.protobuf.FieldDescriptorProto} FieldDescriptorProto
                 */
                FieldDescriptorProto.fromObject = function fromObject(object) {
                    if (object instanceof $root.google.protobuf.FieldDescriptorProto)
                        return object;
                    var message = new $root.google.protobuf.FieldDescriptorProto();
                    if (object.name != null)
                        message.name = String(object.name);
                    if (object.number != null)
                        message.number = object.number | 0;
                    switch (object.label) {
                    default:
                        if (typeof object.label === "number") {
                            message.label = object.label;
                            break;
                        }
                        break;
                    case "LABEL_OPTIONAL":
                    case 1:
                        message.label = 1;
                        break;
                    case "LABEL_REQUIRED":
                    case 2:
                        message.label = 2;
                        break;
                    case "LABEL_REPEATED":
                    case 3:
                        message.label = 3;
                        break;
                    }
                    switch (object.type) {
                    default:
                        if (typeof object.type === "number") {
                            message.type = object.type;
                            break;
                        }
                        break;
                    case "TYPE_DOUBLE":
                    case 1:
                        message.type = 1;
                        break;
                    case "TYPE_FLOAT":
                    case 2:
                        message.type = 2;
                        break;
                    case "TYPE_INT64":
                    case 3:
                        message.type = 3;
                        break;
                    case "TYPE_UINT64":
                    case 4:
                        message.type = 4;
                        break;
                    case "TYPE_INT32":
                    case 5:
                        message.type = 5;
                        break;
                    case "TYPE_FIXED64":
                    case 6:
                        message.type = 6;
                        break;
                    case "TYPE_FIXED32":
                    case 7:
                        message.type = 7;
                        break;
                    case "TYPE_BOOL":
                    case 8:
                        message.type = 8;
                        break;
                    case "TYPE_STRING":
                    case 9:
                        message.type = 9;
                        break;
                    case "TYPE_GROUP":
                    case 10:
                        message.type = 10;
                        break;
                    case "TYPE_MESSAGE":
                    case 11:
                        message.type = 11;
                        break;
                    case "TYPE_BYTES":
                    case 12:
                        message.type = 12;
                        break;
                    case "TYPE_UINT32":
                    case 13:
                        message.type = 13;
                        break;
                    case "TYPE_ENUM":
                    case 14:
                        message.type = 14;
                        break;
                    case "TYPE_SFIXED32":
                    case 15:
                        message.type = 15;
                        break;
                    case "TYPE_SFIXED64":
                    case 16:
                        message.type = 16;
                        break;
                    case "TYPE_SINT32":
                    case 17:
                        message.type = 17;
                        break;
                    case "TYPE_SINT64":
                    case 18:
                        message.type = 18;
                        break;
                    }
                    if (object.typeName != null)
                        message.typeName = String(object.typeName);
                    if (object.extendee != null)
                        message.extendee = String(object.extendee);
                    if (object.defaultValue != null)
                        message.defaultValue = String(object.defaultValue);
                    if (object.oneofIndex != null)
                        message.oneofIndex = object.oneofIndex | 0;
                    if (object.jsonName != null)
                        message.jsonName = String(object.jsonName);
                    if (object.options != null) {
                        if (typeof object.options !== "object")
                            throw TypeError(".google.protobuf.FieldDescriptorProto.options: object expected");
                        message.options = $root.google.protobuf.FieldOptions.fromObject(object.options);
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a FieldDescriptorProto message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof google.protobuf.FieldDescriptorProto
                 * @static
                 * @param {google.protobuf.FieldDescriptorProto} message FieldDescriptorProto
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                FieldDescriptorProto.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.name = "";
                        object.extendee = "";
                        object.number = 0;
                        object.label = options.enums === String ? "LABEL_OPTIONAL" : 1;
                        object.type = options.enums === String ? "TYPE_DOUBLE" : 1;
                        object.typeName = "";
                        object.defaultValue = "";
                        object.options = null;
                        object.oneofIndex = 0;
                        object.jsonName = "";
                    }
                    if (message.name != null && message.hasOwnProperty("name"))
                        object.name = message.name;
                    if (message.extendee != null && message.hasOwnProperty("extendee"))
                        object.extendee = message.extendee;
                    if (message.number != null && message.hasOwnProperty("number"))
                        object.number = message.number;
                    if (message.label != null && message.hasOwnProperty("label"))
                        object.label = options.enums === String ? $root.google.protobuf.FieldDescriptorProto.Label[message.label] === undefined ? message.label : $root.google.protobuf.FieldDescriptorProto.Label[message.label] : message.label;
                    if (message.type != null && message.hasOwnProperty("type"))
                        object.type = options.enums === String ? $root.google.protobuf.FieldDescriptorProto.Type[message.type] === undefined ? message.type : $root.google.protobuf.FieldDescriptorProto.Type[message.type] : message.type;
                    if (message.typeName != null && message.hasOwnProperty("typeName"))
                        object.typeName = message.typeName;
                    if (message.defaultValue != null && message.hasOwnProperty("defaultValue"))
                        object.defaultValue = message.defaultValue;
                    if (message.options != null && message.hasOwnProperty("options"))
                        object.options = $root.google.protobuf.FieldOptions.toObject(message.options, options);
                    if (message.oneofIndex != null && message.hasOwnProperty("oneofIndex"))
                        object.oneofIndex = message.oneofIndex;
                    if (message.jsonName != null && message.hasOwnProperty("jsonName"))
                        object.jsonName = message.jsonName;
                    return object;
                };
    
                /**
                 * Converts this FieldDescriptorProto to JSON.
                 * @function toJSON
                 * @memberof google.protobuf.FieldDescriptorProto
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                FieldDescriptorProto.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                /**
                 * Gets the default type url for FieldDescriptorProto
                 * @function getTypeUrl
                 * @memberof google.protobuf.FieldDescriptorProto
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                FieldDescriptorProto.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/google.protobuf.FieldDescriptorProto";
                };
    
                /**
                 * Type enum.
                 * @name google.protobuf.FieldDescriptorProto.Type
                 * @enum {number}
                 * @property {number} TYPE_DOUBLE=1 TYPE_DOUBLE value
                 * @property {number} TYPE_FLOAT=2 TYPE_FLOAT value
                 * @property {number} TYPE_INT64=3 TYPE_INT64 value
                 * @property {number} TYPE_UINT64=4 TYPE_UINT64 value
                 * @property {number} TYPE_INT32=5 TYPE_INT32 value
                 * @property {number} TYPE_FIXED64=6 TYPE_FIXED64 value
                 * @property {number} TYPE_FIXED32=7 TYPE_FIXED32 value
                 * @property {number} TYPE_BOOL=8 TYPE_BOOL value
                 * @property {number} TYPE_STRING=9 TYPE_STRING value
                 * @property {number} TYPE_GROUP=10 TYPE_GROUP value
                 * @property {number} TYPE_MESSAGE=11 TYPE_MESSAGE value
                 * @property {number} TYPE_BYTES=12 TYPE_BYTES value
                 * @property {number} TYPE_UINT32=13 TYPE_UINT32 value
                 * @property {number} TYPE_ENUM=14 TYPE_ENUM value
                 * @property {number} TYPE_SFIXED32=15 TYPE_SFIXED32 value
                 * @property {number} TYPE_SFIXED64=16 TYPE_SFIXED64 value
                 * @property {number} TYPE_SINT32=17 TYPE_SINT32 value
                 * @property {number} TYPE_SINT64=18 TYPE_SINT64 value
                 */
                FieldDescriptorProto.Type = (function() {
                    var valuesById = {}, values = Object.create(valuesById);
                    values[valuesById[1] = "TYPE_DOUBLE"] = 1;
                    values[valuesById[2] = "TYPE_FLOAT"] = 2;
                    values[valuesById[3] = "TYPE_INT64"] = 3;
                    values[valuesById[4] = "TYPE_UINT64"] = 4;
                    values[valuesById[5] = "TYPE_INT32"] = 5;
                    values[valuesById[6] = "TYPE_FIXED64"] = 6;
                    values[valuesById[7] = "TYPE_FIXED32"] = 7;
                    values[valuesById[8] = "TYPE_BOOL"] = 8;
                    values[valuesById[9] = "TYPE_STRING"] = 9;
                    values[valuesById[10] = "TYPE_GROUP"] = 10;
                    values[valuesById[11] = "TYPE_MESSAGE"] = 11;
                    values[valuesById[12] = "TYPE_BYTES"] = 12;
                    values[valuesById[13] = "TYPE_UINT32"] = 13;
                    values[valuesById[14] = "TYPE_ENUM"] = 14;
                    values[valuesById[15] = "TYPE_SFIXED32"] = 15;
                    values[valuesById[16] = "TYPE_SFIXED64"] = 16;
                    values[valuesById[17] = "TYPE_SINT32"] = 17;
                    values[valuesById[18] = "TYPE_SINT64"] = 18;
                    return values;
                })();
    
                /**
                 * Label enum.
                 * @name google.protobuf.FieldDescriptorProto.Label
                 * @enum {number}
                 * @property {number} LABEL_OPTIONAL=1 LABEL_OPTIONAL value
                 * @property {number} LABEL_REQUIRED=2 LABEL_REQUIRED value
                 * @property {number} LABEL_REPEATED=3 LABEL_REPEATED value
                 */
                FieldDescriptorProto.Label = (function() {
                    var valuesById = {}, values = Object.create(valuesById);
                    values[valuesById[1] = "LABEL_OPTIONAL"] = 1;
                    values[valuesById[2] = "LABEL_REQUIRED"] = 2;
                    values[valuesById[3] = "LABEL_REPEATED"] = 3;
                    return values;
                })();
    
                return FieldDescriptorProto;
            })();
    
            protobuf.OneofDescriptorProto = (function() {
    
                /**
                 * Properties of an OneofDescriptorProto.
                 * @memberof google.protobuf
                 * @interface IOneofDescriptorProto
                 * @property {string|null} [name] OneofDescriptorProto name
                 * @property {google.protobuf.IOneofOptions|null} [options] OneofDescriptorProto options
                 */
    
                /**
                 * Constructs a new OneofDescriptorProto.
                 * @memberof google.protobuf
                 * @classdesc Represents an OneofDescriptorProto.
                 * @implements IOneofDescriptorProto
                 * @constructor
                 * @param {google.protobuf.IOneofDescriptorProto=} [properties] Properties to set
                 */
                function OneofDescriptorProto(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * OneofDescriptorProto name.
                 * @member {string} name
                 * @memberof google.protobuf.OneofDescriptorProto
                 * @instance
                 */
                OneofDescriptorProto.prototype.name = "";
    
                /**
                 * OneofDescriptorProto options.
                 * @member {google.protobuf.IOneofOptions|null|undefined} options
                 * @memberof google.protobuf.OneofDescriptorProto
                 * @instance
                 */
                OneofDescriptorProto.prototype.options = null;
    
                /**
                 * Creates a new OneofDescriptorProto instance using the specified properties.
                 * @function create
                 * @memberof google.protobuf.OneofDescriptorProto
                 * @static
                 * @param {google.protobuf.IOneofDescriptorProto=} [properties] Properties to set
                 * @returns {google.protobuf.OneofDescriptorProto} OneofDescriptorProto instance
                 */
                OneofDescriptorProto.create = function create(properties) {
                    return new OneofDescriptorProto(properties);
                };
    
                /**
                 * Encodes the specified OneofDescriptorProto message. Does not implicitly {@link google.protobuf.OneofDescriptorProto.verify|verify} messages.
                 * @function encode
                 * @memberof google.protobuf.OneofDescriptorProto
                 * @static
                 * @param {google.protobuf.IOneofDescriptorProto} message OneofDescriptorProto message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                OneofDescriptorProto.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                    if (message.options != null && Object.hasOwnProperty.call(message, "options"))
                        $root.google.protobuf.OneofOptions.encode(message.options, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified OneofDescriptorProto message, length delimited. Does not implicitly {@link google.protobuf.OneofDescriptorProto.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof google.protobuf.OneofDescriptorProto
                 * @static
                 * @param {google.protobuf.IOneofDescriptorProto} message OneofDescriptorProto message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                OneofDescriptorProto.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes an OneofDescriptorProto message from the specified reader or buffer.
                 * @function decode
                 * @memberof google.protobuf.OneofDescriptorProto
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {google.protobuf.OneofDescriptorProto} OneofDescriptorProto
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                OneofDescriptorProto.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.OneofDescriptorProto();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1: {
                                message.name = reader.string();
                                break;
                            }
                        case 2: {
                                message.options = $root.google.protobuf.OneofOptions.decode(reader, reader.uint32());
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes an OneofDescriptorProto message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof google.protobuf.OneofDescriptorProto
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {google.protobuf.OneofDescriptorProto} OneofDescriptorProto
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                OneofDescriptorProto.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies an OneofDescriptorProto message.
                 * @function verify
                 * @memberof google.protobuf.OneofDescriptorProto
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                OneofDescriptorProto.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.name != null && message.hasOwnProperty("name"))
                        if (!$util.isString(message.name))
                            return "name: string expected";
                    if (message.options != null && message.hasOwnProperty("options")) {
                        var error = $root.google.protobuf.OneofOptions.verify(message.options);
                        if (error)
                            return "options." + error;
                    }
                    return null;
                };
    
                /**
                 * Creates an OneofDescriptorProto message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof google.protobuf.OneofDescriptorProto
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {google.protobuf.OneofDescriptorProto} OneofDescriptorProto
                 */
                OneofDescriptorProto.fromObject = function fromObject(object) {
                    if (object instanceof $root.google.protobuf.OneofDescriptorProto)
                        return object;
                    var message = new $root.google.protobuf.OneofDescriptorProto();
                    if (object.name != null)
                        message.name = String(object.name);
                    if (object.options != null) {
                        if (typeof object.options !== "object")
                            throw TypeError(".google.protobuf.OneofDescriptorProto.options: object expected");
                        message.options = $root.google.protobuf.OneofOptions.fromObject(object.options);
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from an OneofDescriptorProto message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof google.protobuf.OneofDescriptorProto
                 * @static
                 * @param {google.protobuf.OneofDescriptorProto} message OneofDescriptorProto
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                OneofDescriptorProto.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.name = "";
                        object.options = null;
                    }
                    if (message.name != null && message.hasOwnProperty("name"))
                        object.name = message.name;
                    if (message.options != null && message.hasOwnProperty("options"))
                        object.options = $root.google.protobuf.OneofOptions.toObject(message.options, options);
                    return object;
                };
    
                /**
                 * Converts this OneofDescriptorProto to JSON.
                 * @function toJSON
                 * @memberof google.protobuf.OneofDescriptorProto
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                OneofDescriptorProto.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                /**
                 * Gets the default type url for OneofDescriptorProto
                 * @function getTypeUrl
                 * @memberof google.protobuf.OneofDescriptorProto
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                OneofDescriptorProto.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/google.protobuf.OneofDescriptorProto";
                };
    
                return OneofDescriptorProto;
            })();
    
            protobuf.EnumDescriptorProto = (function() {
    
                /**
                 * Properties of an EnumDescriptorProto.
                 * @memberof google.protobuf
                 * @interface IEnumDescriptorProto
                 * @property {string|null} [name] EnumDescriptorProto name
                 * @property {Array.<google.protobuf.IEnumValueDescriptorProto>|null} [value] EnumDescriptorProto value
                 * @property {google.protobuf.IEnumOptions|null} [options] EnumDescriptorProto options
                 */
    
                /**
                 * Constructs a new EnumDescriptorProto.
                 * @memberof google.protobuf
                 * @classdesc Represents an EnumDescriptorProto.
                 * @implements IEnumDescriptorProto
                 * @constructor
                 * @param {google.protobuf.IEnumDescriptorProto=} [properties] Properties to set
                 */
                function EnumDescriptorProto(properties) {
                    this.value = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * EnumDescriptorProto name.
                 * @member {string} name
                 * @memberof google.protobuf.EnumDescriptorProto
                 * @instance
                 */
                EnumDescriptorProto.prototype.name = "";
    
                /**
                 * EnumDescriptorProto value.
                 * @member {Array.<google.protobuf.IEnumValueDescriptorProto>} value
                 * @memberof google.protobuf.EnumDescriptorProto
                 * @instance
                 */
                EnumDescriptorProto.prototype.value = $util.emptyArray;
    
                /**
                 * EnumDescriptorProto options.
                 * @member {google.protobuf.IEnumOptions|null|undefined} options
                 * @memberof google.protobuf.EnumDescriptorProto
                 * @instance
                 */
                EnumDescriptorProto.prototype.options = null;
    
                /**
                 * Creates a new EnumDescriptorProto instance using the specified properties.
                 * @function create
                 * @memberof google.protobuf.EnumDescriptorProto
                 * @static
                 * @param {google.protobuf.IEnumDescriptorProto=} [properties] Properties to set
                 * @returns {google.protobuf.EnumDescriptorProto} EnumDescriptorProto instance
                 */
                EnumDescriptorProto.create = function create(properties) {
                    return new EnumDescriptorProto(properties);
                };
    
                /**
                 * Encodes the specified EnumDescriptorProto message. Does not implicitly {@link google.protobuf.EnumDescriptorProto.verify|verify} messages.
                 * @function encode
                 * @memberof google.protobuf.EnumDescriptorProto
                 * @static
                 * @param {google.protobuf.IEnumDescriptorProto} message EnumDescriptorProto message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                EnumDescriptorProto.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                    if (message.value != null && message.value.length)
                        for (var i = 0; i < message.value.length; ++i)
                            $root.google.protobuf.EnumValueDescriptorProto.encode(message.value[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    if (message.options != null && Object.hasOwnProperty.call(message, "options"))
                        $root.google.protobuf.EnumOptions.encode(message.options, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified EnumDescriptorProto message, length delimited. Does not implicitly {@link google.protobuf.EnumDescriptorProto.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof google.protobuf.EnumDescriptorProto
                 * @static
                 * @param {google.protobuf.IEnumDescriptorProto} message EnumDescriptorProto message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                EnumDescriptorProto.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes an EnumDescriptorProto message from the specified reader or buffer.
                 * @function decode
                 * @memberof google.protobuf.EnumDescriptorProto
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {google.protobuf.EnumDescriptorProto} EnumDescriptorProto
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                EnumDescriptorProto.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.EnumDescriptorProto();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1: {
                                message.name = reader.string();
                                break;
                            }
                        case 2: {
                                if (!(message.value && message.value.length))
                                    message.value = [];
                                message.value.push($root.google.protobuf.EnumValueDescriptorProto.decode(reader, reader.uint32()));
                                break;
                            }
                        case 3: {
                                message.options = $root.google.protobuf.EnumOptions.decode(reader, reader.uint32());
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes an EnumDescriptorProto message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof google.protobuf.EnumDescriptorProto
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {google.protobuf.EnumDescriptorProto} EnumDescriptorProto
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                EnumDescriptorProto.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies an EnumDescriptorProto message.
                 * @function verify
                 * @memberof google.protobuf.EnumDescriptorProto
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                EnumDescriptorProto.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.name != null && message.hasOwnProperty("name"))
                        if (!$util.isString(message.name))
                            return "name: string expected";
                    if (message.value != null && message.hasOwnProperty("value")) {
                        if (!Array.isArray(message.value))
                            return "value: array expected";
                        for (var i = 0; i < message.value.length; ++i) {
                            var error = $root.google.protobuf.EnumValueDescriptorProto.verify(message.value[i]);
                            if (error)
                                return "value." + error;
                        }
                    }
                    if (message.options != null && message.hasOwnProperty("options")) {
                        var error = $root.google.protobuf.EnumOptions.verify(message.options);
                        if (error)
                            return "options." + error;
                    }
                    return null;
                };
    
                /**
                 * Creates an EnumDescriptorProto message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof google.protobuf.EnumDescriptorProto
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {google.protobuf.EnumDescriptorProto} EnumDescriptorProto
                 */
                EnumDescriptorProto.fromObject = function fromObject(object) {
                    if (object instanceof $root.google.protobuf.EnumDescriptorProto)
                        return object;
                    var message = new $root.google.protobuf.EnumDescriptorProto();
                    if (object.name != null)
                        message.name = String(object.name);
                    if (object.value) {
                        if (!Array.isArray(object.value))
                            throw TypeError(".google.protobuf.EnumDescriptorProto.value: array expected");
                        message.value = [];
                        for (var i = 0; i < object.value.length; ++i) {
                            if (typeof object.value[i] !== "object")
                                throw TypeError(".google.protobuf.EnumDescriptorProto.value: object expected");
                            message.value[i] = $root.google.protobuf.EnumValueDescriptorProto.fromObject(object.value[i]);
                        }
                    }
                    if (object.options != null) {
                        if (typeof object.options !== "object")
                            throw TypeError(".google.protobuf.EnumDescriptorProto.options: object expected");
                        message.options = $root.google.protobuf.EnumOptions.fromObject(object.options);
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from an EnumDescriptorProto message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof google.protobuf.EnumDescriptorProto
                 * @static
                 * @param {google.protobuf.EnumDescriptorProto} message EnumDescriptorProto
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                EnumDescriptorProto.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.value = [];
                    if (options.defaults) {
                        object.name = "";
                        object.options = null;
                    }
                    if (message.name != null && message.hasOwnProperty("name"))
                        object.name = message.name;
                    if (message.value && message.value.length) {
                        object.value = [];
                        for (var j = 0; j < message.value.length; ++j)
                            object.value[j] = $root.google.protobuf.EnumValueDescriptorProto.toObject(message.value[j], options);
                    }
                    if (message.options != null && message.hasOwnProperty("options"))
                        object.options = $root.google.protobuf.EnumOptions.toObject(message.options, options);
                    return object;
                };
    
                /**
                 * Converts this EnumDescriptorProto to JSON.
                 * @function toJSON
                 * @memberof google.protobuf.EnumDescriptorProto
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                EnumDescriptorProto.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                /**
                 * Gets the default type url for EnumDescriptorProto
                 * @function getTypeUrl
                 * @memberof google.protobuf.EnumDescriptorProto
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                EnumDescriptorProto.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/google.protobuf.EnumDescriptorProto";
                };
    
                return EnumDescriptorProto;
            })();
    
            protobuf.EnumValueDescriptorProto = (function() {
    
                /**
                 * Properties of an EnumValueDescriptorProto.
                 * @memberof google.protobuf
                 * @interface IEnumValueDescriptorProto
                 * @property {string|null} [name] EnumValueDescriptorProto name
                 * @property {number|null} [number] EnumValueDescriptorProto number
                 * @property {google.protobuf.IEnumValueOptions|null} [options] EnumValueDescriptorProto options
                 */
    
                /**
                 * Constructs a new EnumValueDescriptorProto.
                 * @memberof google.protobuf
                 * @classdesc Represents an EnumValueDescriptorProto.
                 * @implements IEnumValueDescriptorProto
                 * @constructor
                 * @param {google.protobuf.IEnumValueDescriptorProto=} [properties] Properties to set
                 */
                function EnumValueDescriptorProto(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * EnumValueDescriptorProto name.
                 * @member {string} name
                 * @memberof google.protobuf.EnumValueDescriptorProto
                 * @instance
                 */
                EnumValueDescriptorProto.prototype.name = "";
    
                /**
                 * EnumValueDescriptorProto number.
                 * @member {number} number
                 * @memberof google.protobuf.EnumValueDescriptorProto
                 * @instance
                 */
                EnumValueDescriptorProto.prototype.number = 0;
    
                /**
                 * EnumValueDescriptorProto options.
                 * @member {google.protobuf.IEnumValueOptions|null|undefined} options
                 * @memberof google.protobuf.EnumValueDescriptorProto
                 * @instance
                 */
                EnumValueDescriptorProto.prototype.options = null;
    
                /**
                 * Creates a new EnumValueDescriptorProto instance using the specified properties.
                 * @function create
                 * @memberof google.protobuf.EnumValueDescriptorProto
                 * @static
                 * @param {google.protobuf.IEnumValueDescriptorProto=} [properties] Properties to set
                 * @returns {google.protobuf.EnumValueDescriptorProto} EnumValueDescriptorProto instance
                 */
                EnumValueDescriptorProto.create = function create(properties) {
                    return new EnumValueDescriptorProto(properties);
                };
    
                /**
                 * Encodes the specified EnumValueDescriptorProto message. Does not implicitly {@link google.protobuf.EnumValueDescriptorProto.verify|verify} messages.
                 * @function encode
                 * @memberof google.protobuf.EnumValueDescriptorProto
                 * @static
                 * @param {google.protobuf.IEnumValueDescriptorProto} message EnumValueDescriptorProto message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                EnumValueDescriptorProto.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                    if (message.number != null && Object.hasOwnProperty.call(message, "number"))
                        writer.uint32(/* id 2, wireType 0 =*/16).int32(message.number);
                    if (message.options != null && Object.hasOwnProperty.call(message, "options"))
                        $root.google.protobuf.EnumValueOptions.encode(message.options, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified EnumValueDescriptorProto message, length delimited. Does not implicitly {@link google.protobuf.EnumValueDescriptorProto.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof google.protobuf.EnumValueDescriptorProto
                 * @static
                 * @param {google.protobuf.IEnumValueDescriptorProto} message EnumValueDescriptorProto message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                EnumValueDescriptorProto.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes an EnumValueDescriptorProto message from the specified reader or buffer.
                 * @function decode
                 * @memberof google.protobuf.EnumValueDescriptorProto
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {google.protobuf.EnumValueDescriptorProto} EnumValueDescriptorProto
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                EnumValueDescriptorProto.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.EnumValueDescriptorProto();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1: {
                                message.name = reader.string();
                                break;
                            }
                        case 2: {
                                message.number = reader.int32();
                                break;
                            }
                        case 3: {
                                message.options = $root.google.protobuf.EnumValueOptions.decode(reader, reader.uint32());
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes an EnumValueDescriptorProto message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof google.protobuf.EnumValueDescriptorProto
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {google.protobuf.EnumValueDescriptorProto} EnumValueDescriptorProto
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                EnumValueDescriptorProto.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies an EnumValueDescriptorProto message.
                 * @function verify
                 * @memberof google.protobuf.EnumValueDescriptorProto
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                EnumValueDescriptorProto.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.name != null && message.hasOwnProperty("name"))
                        if (!$util.isString(message.name))
                            return "name: string expected";
                    if (message.number != null && message.hasOwnProperty("number"))
                        if (!$util.isInteger(message.number))
                            return "number: integer expected";
                    if (message.options != null && message.hasOwnProperty("options")) {
                        var error = $root.google.protobuf.EnumValueOptions.verify(message.options);
                        if (error)
                            return "options." + error;
                    }
                    return null;
                };
    
                /**
                 * Creates an EnumValueDescriptorProto message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof google.protobuf.EnumValueDescriptorProto
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {google.protobuf.EnumValueDescriptorProto} EnumValueDescriptorProto
                 */
                EnumValueDescriptorProto.fromObject = function fromObject(object) {
                    if (object instanceof $root.google.protobuf.EnumValueDescriptorProto)
                        return object;
                    var message = new $root.google.protobuf.EnumValueDescriptorProto();
                    if (object.name != null)
                        message.name = String(object.name);
                    if (object.number != null)
                        message.number = object.number | 0;
                    if (object.options != null) {
                        if (typeof object.options !== "object")
                            throw TypeError(".google.protobuf.EnumValueDescriptorProto.options: object expected");
                        message.options = $root.google.protobuf.EnumValueOptions.fromObject(object.options);
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from an EnumValueDescriptorProto message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof google.protobuf.EnumValueDescriptorProto
                 * @static
                 * @param {google.protobuf.EnumValueDescriptorProto} message EnumValueDescriptorProto
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                EnumValueDescriptorProto.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.name = "";
                        object.number = 0;
                        object.options = null;
                    }
                    if (message.name != null && message.hasOwnProperty("name"))
                        object.name = message.name;
                    if (message.number != null && message.hasOwnProperty("number"))
                        object.number = message.number;
                    if (message.options != null && message.hasOwnProperty("options"))
                        object.options = $root.google.protobuf.EnumValueOptions.toObject(message.options, options);
                    return object;
                };
    
                /**
                 * Converts this EnumValueDescriptorProto to JSON.
                 * @function toJSON
                 * @memberof google.protobuf.EnumValueDescriptorProto
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                EnumValueDescriptorProto.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                /**
                 * Gets the default type url for EnumValueDescriptorProto
                 * @function getTypeUrl
                 * @memberof google.protobuf.EnumValueDescriptorProto
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                EnumValueDescriptorProto.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/google.protobuf.EnumValueDescriptorProto";
                };
    
                return EnumValueDescriptorProto;
            })();
    
            protobuf.ServiceDescriptorProto = (function() {
    
                /**
                 * Properties of a ServiceDescriptorProto.
                 * @memberof google.protobuf
                 * @interface IServiceDescriptorProto
                 * @property {string|null} [name] ServiceDescriptorProto name
                 * @property {Array.<google.protobuf.IMethodDescriptorProto>|null} [method] ServiceDescriptorProto method
                 * @property {google.protobuf.IServiceOptions|null} [options] ServiceDescriptorProto options
                 */
    
                /**
                 * Constructs a new ServiceDescriptorProto.
                 * @memberof google.protobuf
                 * @classdesc Represents a ServiceDescriptorProto.
                 * @implements IServiceDescriptorProto
                 * @constructor
                 * @param {google.protobuf.IServiceDescriptorProto=} [properties] Properties to set
                 */
                function ServiceDescriptorProto(properties) {
                    this.method = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * ServiceDescriptorProto name.
                 * @member {string} name
                 * @memberof google.protobuf.ServiceDescriptorProto
                 * @instance
                 */
                ServiceDescriptorProto.prototype.name = "";
    
                /**
                 * ServiceDescriptorProto method.
                 * @member {Array.<google.protobuf.IMethodDescriptorProto>} method
                 * @memberof google.protobuf.ServiceDescriptorProto
                 * @instance
                 */
                ServiceDescriptorProto.prototype.method = $util.emptyArray;
    
                /**
                 * ServiceDescriptorProto options.
                 * @member {google.protobuf.IServiceOptions|null|undefined} options
                 * @memberof google.protobuf.ServiceDescriptorProto
                 * @instance
                 */
                ServiceDescriptorProto.prototype.options = null;
    
                /**
                 * Creates a new ServiceDescriptorProto instance using the specified properties.
                 * @function create
                 * @memberof google.protobuf.ServiceDescriptorProto
                 * @static
                 * @param {google.protobuf.IServiceDescriptorProto=} [properties] Properties to set
                 * @returns {google.protobuf.ServiceDescriptorProto} ServiceDescriptorProto instance
                 */
                ServiceDescriptorProto.create = function create(properties) {
                    return new ServiceDescriptorProto(properties);
                };
    
                /**
                 * Encodes the specified ServiceDescriptorProto message. Does not implicitly {@link google.protobuf.ServiceDescriptorProto.verify|verify} messages.
                 * @function encode
                 * @memberof google.protobuf.ServiceDescriptorProto
                 * @static
                 * @param {google.protobuf.IServiceDescriptorProto} message ServiceDescriptorProto message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ServiceDescriptorProto.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                    if (message.method != null && message.method.length)
                        for (var i = 0; i < message.method.length; ++i)
                            $root.google.protobuf.MethodDescriptorProto.encode(message.method[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    if (message.options != null && Object.hasOwnProperty.call(message, "options"))
                        $root.google.protobuf.ServiceOptions.encode(message.options, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified ServiceDescriptorProto message, length delimited. Does not implicitly {@link google.protobuf.ServiceDescriptorProto.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof google.protobuf.ServiceDescriptorProto
                 * @static
                 * @param {google.protobuf.IServiceDescriptorProto} message ServiceDescriptorProto message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ServiceDescriptorProto.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a ServiceDescriptorProto message from the specified reader or buffer.
                 * @function decode
                 * @memberof google.protobuf.ServiceDescriptorProto
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {google.protobuf.ServiceDescriptorProto} ServiceDescriptorProto
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ServiceDescriptorProto.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.ServiceDescriptorProto();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1: {
                                message.name = reader.string();
                                break;
                            }
                        case 2: {
                                if (!(message.method && message.method.length))
                                    message.method = [];
                                message.method.push($root.google.protobuf.MethodDescriptorProto.decode(reader, reader.uint32()));
                                break;
                            }
                        case 3: {
                                message.options = $root.google.protobuf.ServiceOptions.decode(reader, reader.uint32());
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a ServiceDescriptorProto message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof google.protobuf.ServiceDescriptorProto
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {google.protobuf.ServiceDescriptorProto} ServiceDescriptorProto
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ServiceDescriptorProto.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a ServiceDescriptorProto message.
                 * @function verify
                 * @memberof google.protobuf.ServiceDescriptorProto
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                ServiceDescriptorProto.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.name != null && message.hasOwnProperty("name"))
                        if (!$util.isString(message.name))
                            return "name: string expected";
                    if (message.method != null && message.hasOwnProperty("method")) {
                        if (!Array.isArray(message.method))
                            return "method: array expected";
                        for (var i = 0; i < message.method.length; ++i) {
                            var error = $root.google.protobuf.MethodDescriptorProto.verify(message.method[i]);
                            if (error)
                                return "method." + error;
                        }
                    }
                    if (message.options != null && message.hasOwnProperty("options")) {
                        var error = $root.google.protobuf.ServiceOptions.verify(message.options);
                        if (error)
                            return "options." + error;
                    }
                    return null;
                };
    
                /**
                 * Creates a ServiceDescriptorProto message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof google.protobuf.ServiceDescriptorProto
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {google.protobuf.ServiceDescriptorProto} ServiceDescriptorProto
                 */
                ServiceDescriptorProto.fromObject = function fromObject(object) {
                    if (object instanceof $root.google.protobuf.ServiceDescriptorProto)
                        return object;
                    var message = new $root.google.protobuf.ServiceDescriptorProto();
                    if (object.name != null)
                        message.name = String(object.name);
                    if (object.method) {
                        if (!Array.isArray(object.method))
                            throw TypeError(".google.protobuf.ServiceDescriptorProto.method: array expected");
                        message.method = [];
                        for (var i = 0; i < object.method.length; ++i) {
                            if (typeof object.method[i] !== "object")
                                throw TypeError(".google.protobuf.ServiceDescriptorProto.method: object expected");
                            message.method[i] = $root.google.protobuf.MethodDescriptorProto.fromObject(object.method[i]);
                        }
                    }
                    if (object.options != null) {
                        if (typeof object.options !== "object")
                            throw TypeError(".google.protobuf.ServiceDescriptorProto.options: object expected");
                        message.options = $root.google.protobuf.ServiceOptions.fromObject(object.options);
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a ServiceDescriptorProto message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof google.protobuf.ServiceDescriptorProto
                 * @static
                 * @param {google.protobuf.ServiceDescriptorProto} message ServiceDescriptorProto
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                ServiceDescriptorProto.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.method = [];
                    if (options.defaults) {
                        object.name = "";
                        object.options = null;
                    }
                    if (message.name != null && message.hasOwnProperty("name"))
                        object.name = message.name;
                    if (message.method && message.method.length) {
                        object.method = [];
                        for (var j = 0; j < message.method.length; ++j)
                            object.method[j] = $root.google.protobuf.MethodDescriptorProto.toObject(message.method[j], options);
                    }
                    if (message.options != null && message.hasOwnProperty("options"))
                        object.options = $root.google.protobuf.ServiceOptions.toObject(message.options, options);
                    return object;
                };
    
                /**
                 * Converts this ServiceDescriptorProto to JSON.
                 * @function toJSON
                 * @memberof google.protobuf.ServiceDescriptorProto
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                ServiceDescriptorProto.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                /**
                 * Gets the default type url for ServiceDescriptorProto
                 * @function getTypeUrl
                 * @memberof google.protobuf.ServiceDescriptorProto
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                ServiceDescriptorProto.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/google.protobuf.ServiceDescriptorProto";
                };
    
                return ServiceDescriptorProto;
            })();
    
            protobuf.MethodDescriptorProto = (function() {
    
                /**
                 * Properties of a MethodDescriptorProto.
                 * @memberof google.protobuf
                 * @interface IMethodDescriptorProto
                 * @property {string|null} [name] MethodDescriptorProto name
                 * @property {string|null} [inputType] MethodDescriptorProto inputType
                 * @property {string|null} [outputType] MethodDescriptorProto outputType
                 * @property {google.protobuf.IMethodOptions|null} [options] MethodDescriptorProto options
                 * @property {boolean|null} [clientStreaming] MethodDescriptorProto clientStreaming
                 * @property {boolean|null} [serverStreaming] MethodDescriptorProto serverStreaming
                 */
    
                /**
                 * Constructs a new MethodDescriptorProto.
                 * @memberof google.protobuf
                 * @classdesc Represents a MethodDescriptorProto.
                 * @implements IMethodDescriptorProto
                 * @constructor
                 * @param {google.protobuf.IMethodDescriptorProto=} [properties] Properties to set
                 */
                function MethodDescriptorProto(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * MethodDescriptorProto name.
                 * @member {string} name
                 * @memberof google.protobuf.MethodDescriptorProto
                 * @instance
                 */
                MethodDescriptorProto.prototype.name = "";
    
                /**
                 * MethodDescriptorProto inputType.
                 * @member {string} inputType
                 * @memberof google.protobuf.MethodDescriptorProto
                 * @instance
                 */
                MethodDescriptorProto.prototype.inputType = "";
    
                /**
                 * MethodDescriptorProto outputType.
                 * @member {string} outputType
                 * @memberof google.protobuf.MethodDescriptorProto
                 * @instance
                 */
                MethodDescriptorProto.prototype.outputType = "";
    
                /**
                 * MethodDescriptorProto options.
                 * @member {google.protobuf.IMethodOptions|null|undefined} options
                 * @memberof google.protobuf.MethodDescriptorProto
                 * @instance
                 */
                MethodDescriptorProto.prototype.options = null;
    
                /**
                 * MethodDescriptorProto clientStreaming.
                 * @member {boolean} clientStreaming
                 * @memberof google.protobuf.MethodDescriptorProto
                 * @instance
                 */
                MethodDescriptorProto.prototype.clientStreaming = false;
    
                /**
                 * MethodDescriptorProto serverStreaming.
                 * @member {boolean} serverStreaming
                 * @memberof google.protobuf.MethodDescriptorProto
                 * @instance
                 */
                MethodDescriptorProto.prototype.serverStreaming = false;
    
                /**
                 * Creates a new MethodDescriptorProto instance using the specified properties.
                 * @function create
                 * @memberof google.protobuf.MethodDescriptorProto
                 * @static
                 * @param {google.protobuf.IMethodDescriptorProto=} [properties] Properties to set
                 * @returns {google.protobuf.MethodDescriptorProto} MethodDescriptorProto instance
                 */
                MethodDescriptorProto.create = function create(properties) {
                    return new MethodDescriptorProto(properties);
                };
    
                /**
                 * Encodes the specified MethodDescriptorProto message. Does not implicitly {@link google.protobuf.MethodDescriptorProto.verify|verify} messages.
                 * @function encode
                 * @memberof google.protobuf.MethodDescriptorProto
                 * @static
                 * @param {google.protobuf.IMethodDescriptorProto} message MethodDescriptorProto message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MethodDescriptorProto.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                    if (message.inputType != null && Object.hasOwnProperty.call(message, "inputType"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.inputType);
                    if (message.outputType != null && Object.hasOwnProperty.call(message, "outputType"))
                        writer.uint32(/* id 3, wireType 2 =*/26).string(message.outputType);
                    if (message.options != null && Object.hasOwnProperty.call(message, "options"))
                        $root.google.protobuf.MethodOptions.encode(message.options, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                    if (message.clientStreaming != null && Object.hasOwnProperty.call(message, "clientStreaming"))
                        writer.uint32(/* id 5, wireType 0 =*/40).bool(message.clientStreaming);
                    if (message.serverStreaming != null && Object.hasOwnProperty.call(message, "serverStreaming"))
                        writer.uint32(/* id 6, wireType 0 =*/48).bool(message.serverStreaming);
                    return writer;
                };
    
                /**
                 * Encodes the specified MethodDescriptorProto message, length delimited. Does not implicitly {@link google.protobuf.MethodDescriptorProto.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof google.protobuf.MethodDescriptorProto
                 * @static
                 * @param {google.protobuf.IMethodDescriptorProto} message MethodDescriptorProto message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MethodDescriptorProto.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a MethodDescriptorProto message from the specified reader or buffer.
                 * @function decode
                 * @memberof google.protobuf.MethodDescriptorProto
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {google.protobuf.MethodDescriptorProto} MethodDescriptorProto
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MethodDescriptorProto.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.MethodDescriptorProto();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1: {
                                message.name = reader.string();
                                break;
                            }
                        case 2: {
                                message.inputType = reader.string();
                                break;
                            }
                        case 3: {
                                message.outputType = reader.string();
                                break;
                            }
                        case 4: {
                                message.options = $root.google.protobuf.MethodOptions.decode(reader, reader.uint32());
                                break;
                            }
                        case 5: {
                                message.clientStreaming = reader.bool();
                                break;
                            }
                        case 6: {
                                message.serverStreaming = reader.bool();
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a MethodDescriptorProto message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof google.protobuf.MethodDescriptorProto
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {google.protobuf.MethodDescriptorProto} MethodDescriptorProto
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MethodDescriptorProto.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a MethodDescriptorProto message.
                 * @function verify
                 * @memberof google.protobuf.MethodDescriptorProto
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                MethodDescriptorProto.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.name != null && message.hasOwnProperty("name"))
                        if (!$util.isString(message.name))
                            return "name: string expected";
                    if (message.inputType != null && message.hasOwnProperty("inputType"))
                        if (!$util.isString(message.inputType))
                            return "inputType: string expected";
                    if (message.outputType != null && message.hasOwnProperty("outputType"))
                        if (!$util.isString(message.outputType))
                            return "outputType: string expected";
                    if (message.options != null && message.hasOwnProperty("options")) {
                        var error = $root.google.protobuf.MethodOptions.verify(message.options);
                        if (error)
                            return "options." + error;
                    }
                    if (message.clientStreaming != null && message.hasOwnProperty("clientStreaming"))
                        if (typeof message.clientStreaming !== "boolean")
                            return "clientStreaming: boolean expected";
                    if (message.serverStreaming != null && message.hasOwnProperty("serverStreaming"))
                        if (typeof message.serverStreaming !== "boolean")
                            return "serverStreaming: boolean expected";
                    return null;
                };
    
                /**
                 * Creates a MethodDescriptorProto message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof google.protobuf.MethodDescriptorProto
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {google.protobuf.MethodDescriptorProto} MethodDescriptorProto
                 */
                MethodDescriptorProto.fromObject = function fromObject(object) {
                    if (object instanceof $root.google.protobuf.MethodDescriptorProto)
                        return object;
                    var message = new $root.google.protobuf.MethodDescriptorProto();
                    if (object.name != null)
                        message.name = String(object.name);
                    if (object.inputType != null)
                        message.inputType = String(object.inputType);
                    if (object.outputType != null)
                        message.outputType = String(object.outputType);
                    if (object.options != null) {
                        if (typeof object.options !== "object")
                            throw TypeError(".google.protobuf.MethodDescriptorProto.options: object expected");
                        message.options = $root.google.protobuf.MethodOptions.fromObject(object.options);
                    }
                    if (object.clientStreaming != null)
                        message.clientStreaming = Boolean(object.clientStreaming);
                    if (object.serverStreaming != null)
                        message.serverStreaming = Boolean(object.serverStreaming);
                    return message;
                };
    
                /**
                 * Creates a plain object from a MethodDescriptorProto message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof google.protobuf.MethodDescriptorProto
                 * @static
                 * @param {google.protobuf.MethodDescriptorProto} message MethodDescriptorProto
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                MethodDescriptorProto.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.name = "";
                        object.inputType = "";
                        object.outputType = "";
                        object.options = null;
                        object.clientStreaming = false;
                        object.serverStreaming = false;
                    }
                    if (message.name != null && message.hasOwnProperty("name"))
                        object.name = message.name;
                    if (message.inputType != null && message.hasOwnProperty("inputType"))
                        object.inputType = message.inputType;
                    if (message.outputType != null && message.hasOwnProperty("outputType"))
                        object.outputType = message.outputType;
                    if (message.options != null && message.hasOwnProperty("options"))
                        object.options = $root.google.protobuf.MethodOptions.toObject(message.options, options);
                    if (message.clientStreaming != null && message.hasOwnProperty("clientStreaming"))
                        object.clientStreaming = message.clientStreaming;
                    if (message.serverStreaming != null && message.hasOwnProperty("serverStreaming"))
                        object.serverStreaming = message.serverStreaming;
                    return object;
                };
    
                /**
                 * Converts this MethodDescriptorProto to JSON.
                 * @function toJSON
                 * @memberof google.protobuf.MethodDescriptorProto
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                MethodDescriptorProto.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                /**
                 * Gets the default type url for MethodDescriptorProto
                 * @function getTypeUrl
                 * @memberof google.protobuf.MethodDescriptorProto
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                MethodDescriptorProto.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/google.protobuf.MethodDescriptorProto";
                };
    
                return MethodDescriptorProto;
            })();
    
            protobuf.FileOptions = (function() {
    
                /**
                 * Properties of a FileOptions.
                 * @memberof google.protobuf
                 * @interface IFileOptions
                 * @property {string|null} [javaPackage] FileOptions javaPackage
                 * @property {string|null} [javaOuterClassname] FileOptions javaOuterClassname
                 * @property {boolean|null} [javaMultipleFiles] FileOptions javaMultipleFiles
                 * @property {boolean|null} [javaGenerateEqualsAndHash] FileOptions javaGenerateEqualsAndHash
                 * @property {boolean|null} [javaStringCheckUtf8] FileOptions javaStringCheckUtf8
                 * @property {google.protobuf.FileOptions.OptimizeMode|null} [optimizeFor] FileOptions optimizeFor
                 * @property {string|null} [goPackage] FileOptions goPackage
                 * @property {boolean|null} [ccGenericServices] FileOptions ccGenericServices
                 * @property {boolean|null} [javaGenericServices] FileOptions javaGenericServices
                 * @property {boolean|null} [pyGenericServices] FileOptions pyGenericServices
                 * @property {boolean|null} [deprecated] FileOptions deprecated
                 * @property {boolean|null} [ccEnableArenas] FileOptions ccEnableArenas
                 * @property {string|null} [objcClassPrefix] FileOptions objcClassPrefix
                 * @property {string|null} [csharpNamespace] FileOptions csharpNamespace
                 * @property {Array.<google.protobuf.IUninterpretedOption>|null} [uninterpretedOption] FileOptions uninterpretedOption
                 */
    
                /**
                 * Constructs a new FileOptions.
                 * @memberof google.protobuf
                 * @classdesc Represents a FileOptions.
                 * @implements IFileOptions
                 * @constructor
                 * @param {google.protobuf.IFileOptions=} [properties] Properties to set
                 */
                function FileOptions(properties) {
                    this.uninterpretedOption = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * FileOptions javaPackage.
                 * @member {string} javaPackage
                 * @memberof google.protobuf.FileOptions
                 * @instance
                 */
                FileOptions.prototype.javaPackage = "";
    
                /**
                 * FileOptions javaOuterClassname.
                 * @member {string} javaOuterClassname
                 * @memberof google.protobuf.FileOptions
                 * @instance
                 */
                FileOptions.prototype.javaOuterClassname = "";
    
                /**
                 * FileOptions javaMultipleFiles.
                 * @member {boolean} javaMultipleFiles
                 * @memberof google.protobuf.FileOptions
                 * @instance
                 */
                FileOptions.prototype.javaMultipleFiles = false;
    
                /**
                 * FileOptions javaGenerateEqualsAndHash.
                 * @member {boolean} javaGenerateEqualsAndHash
                 * @memberof google.protobuf.FileOptions
                 * @instance
                 */
                FileOptions.prototype.javaGenerateEqualsAndHash = false;
    
                /**
                 * FileOptions javaStringCheckUtf8.
                 * @member {boolean} javaStringCheckUtf8
                 * @memberof google.protobuf.FileOptions
                 * @instance
                 */
                FileOptions.prototype.javaStringCheckUtf8 = false;
    
                /**
                 * FileOptions optimizeFor.
                 * @member {google.protobuf.FileOptions.OptimizeMode} optimizeFor
                 * @memberof google.protobuf.FileOptions
                 * @instance
                 */
                FileOptions.prototype.optimizeFor = 1;
    
                /**
                 * FileOptions goPackage.
                 * @member {string} goPackage
                 * @memberof google.protobuf.FileOptions
                 * @instance
                 */
                FileOptions.prototype.goPackage = "";
    
                /**
                 * FileOptions ccGenericServices.
                 * @member {boolean} ccGenericServices
                 * @memberof google.protobuf.FileOptions
                 * @instance
                 */
                FileOptions.prototype.ccGenericServices = false;
    
                /**
                 * FileOptions javaGenericServices.
                 * @member {boolean} javaGenericServices
                 * @memberof google.protobuf.FileOptions
                 * @instance
                 */
                FileOptions.prototype.javaGenericServices = false;
    
                /**
                 * FileOptions pyGenericServices.
                 * @member {boolean} pyGenericServices
                 * @memberof google.protobuf.FileOptions
                 * @instance
                 */
                FileOptions.prototype.pyGenericServices = false;
    
                /**
                 * FileOptions deprecated.
                 * @member {boolean} deprecated
                 * @memberof google.protobuf.FileOptions
                 * @instance
                 */
                FileOptions.prototype.deprecated = false;
    
                /**
                 * FileOptions ccEnableArenas.
                 * @member {boolean} ccEnableArenas
                 * @memberof google.protobuf.FileOptions
                 * @instance
                 */
                FileOptions.prototype.ccEnableArenas = false;
    
                /**
                 * FileOptions objcClassPrefix.
                 * @member {string} objcClassPrefix
                 * @memberof google.protobuf.FileOptions
                 * @instance
                 */
                FileOptions.prototype.objcClassPrefix = "";
    
                /**
                 * FileOptions csharpNamespace.
                 * @member {string} csharpNamespace
                 * @memberof google.protobuf.FileOptions
                 * @instance
                 */
                FileOptions.prototype.csharpNamespace = "";
    
                /**
                 * FileOptions uninterpretedOption.
                 * @member {Array.<google.protobuf.IUninterpretedOption>} uninterpretedOption
                 * @memberof google.protobuf.FileOptions
                 * @instance
                 */
                FileOptions.prototype.uninterpretedOption = $util.emptyArray;
    
                /**
                 * Creates a new FileOptions instance using the specified properties.
                 * @function create
                 * @memberof google.protobuf.FileOptions
                 * @static
                 * @param {google.protobuf.IFileOptions=} [properties] Properties to set
                 * @returns {google.protobuf.FileOptions} FileOptions instance
                 */
                FileOptions.create = function create(properties) {
                    return new FileOptions(properties);
                };
    
                /**
                 * Encodes the specified FileOptions message. Does not implicitly {@link google.protobuf.FileOptions.verify|verify} messages.
                 * @function encode
                 * @memberof google.protobuf.FileOptions
                 * @static
                 * @param {google.protobuf.IFileOptions} message FileOptions message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                FileOptions.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.javaPackage != null && Object.hasOwnProperty.call(message, "javaPackage"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.javaPackage);
                    if (message.javaOuterClassname != null && Object.hasOwnProperty.call(message, "javaOuterClassname"))
                        writer.uint32(/* id 8, wireType 2 =*/66).string(message.javaOuterClassname);
                    if (message.optimizeFor != null && Object.hasOwnProperty.call(message, "optimizeFor"))
                        writer.uint32(/* id 9, wireType 0 =*/72).int32(message.optimizeFor);
                    if (message.javaMultipleFiles != null && Object.hasOwnProperty.call(message, "javaMultipleFiles"))
                        writer.uint32(/* id 10, wireType 0 =*/80).bool(message.javaMultipleFiles);
                    if (message.goPackage != null && Object.hasOwnProperty.call(message, "goPackage"))
                        writer.uint32(/* id 11, wireType 2 =*/90).string(message.goPackage);
                    if (message.ccGenericServices != null && Object.hasOwnProperty.call(message, "ccGenericServices"))
                        writer.uint32(/* id 16, wireType 0 =*/128).bool(message.ccGenericServices);
                    if (message.javaGenericServices != null && Object.hasOwnProperty.call(message, "javaGenericServices"))
                        writer.uint32(/* id 17, wireType 0 =*/136).bool(message.javaGenericServices);
                    if (message.pyGenericServices != null && Object.hasOwnProperty.call(message, "pyGenericServices"))
                        writer.uint32(/* id 18, wireType 0 =*/144).bool(message.pyGenericServices);
                    if (message.javaGenerateEqualsAndHash != null && Object.hasOwnProperty.call(message, "javaGenerateEqualsAndHash"))
                        writer.uint32(/* id 20, wireType 0 =*/160).bool(message.javaGenerateEqualsAndHash);
                    if (message.deprecated != null && Object.hasOwnProperty.call(message, "deprecated"))
                        writer.uint32(/* id 23, wireType 0 =*/184).bool(message.deprecated);
                    if (message.javaStringCheckUtf8 != null && Object.hasOwnProperty.call(message, "javaStringCheckUtf8"))
                        writer.uint32(/* id 27, wireType 0 =*/216).bool(message.javaStringCheckUtf8);
                    if (message.ccEnableArenas != null && Object.hasOwnProperty.call(message, "ccEnableArenas"))
                        writer.uint32(/* id 31, wireType 0 =*/248).bool(message.ccEnableArenas);
                    if (message.objcClassPrefix != null && Object.hasOwnProperty.call(message, "objcClassPrefix"))
                        writer.uint32(/* id 36, wireType 2 =*/290).string(message.objcClassPrefix);
                    if (message.csharpNamespace != null && Object.hasOwnProperty.call(message, "csharpNamespace"))
                        writer.uint32(/* id 37, wireType 2 =*/298).string(message.csharpNamespace);
                    if (message.uninterpretedOption != null && message.uninterpretedOption.length)
                        for (var i = 0; i < message.uninterpretedOption.length; ++i)
                            $root.google.protobuf.UninterpretedOption.encode(message.uninterpretedOption[i], writer.uint32(/* id 999, wireType 2 =*/7994).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified FileOptions message, length delimited. Does not implicitly {@link google.protobuf.FileOptions.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof google.protobuf.FileOptions
                 * @static
                 * @param {google.protobuf.IFileOptions} message FileOptions message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                FileOptions.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a FileOptions message from the specified reader or buffer.
                 * @function decode
                 * @memberof google.protobuf.FileOptions
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {google.protobuf.FileOptions} FileOptions
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                FileOptions.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.FileOptions();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1: {
                                message.javaPackage = reader.string();
                                break;
                            }
                        case 8: {
                                message.javaOuterClassname = reader.string();
                                break;
                            }
                        case 10: {
                                message.javaMultipleFiles = reader.bool();
                                break;
                            }
                        case 20: {
                                message.javaGenerateEqualsAndHash = reader.bool();
                                break;
                            }
                        case 27: {
                                message.javaStringCheckUtf8 = reader.bool();
                                break;
                            }
                        case 9: {
                                message.optimizeFor = reader.int32();
                                break;
                            }
                        case 11: {
                                message.goPackage = reader.string();
                                break;
                            }
                        case 16: {
                                message.ccGenericServices = reader.bool();
                                break;
                            }
                        case 17: {
                                message.javaGenericServices = reader.bool();
                                break;
                            }
                        case 18: {
                                message.pyGenericServices = reader.bool();
                                break;
                            }
                        case 23: {
                                message.deprecated = reader.bool();
                                break;
                            }
                        case 31: {
                                message.ccEnableArenas = reader.bool();
                                break;
                            }
                        case 36: {
                                message.objcClassPrefix = reader.string();
                                break;
                            }
                        case 37: {
                                message.csharpNamespace = reader.string();
                                break;
                            }
                        case 999: {
                                if (!(message.uninterpretedOption && message.uninterpretedOption.length))
                                    message.uninterpretedOption = [];
                                message.uninterpretedOption.push($root.google.protobuf.UninterpretedOption.decode(reader, reader.uint32()));
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a FileOptions message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof google.protobuf.FileOptions
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {google.protobuf.FileOptions} FileOptions
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                FileOptions.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a FileOptions message.
                 * @function verify
                 * @memberof google.protobuf.FileOptions
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                FileOptions.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.javaPackage != null && message.hasOwnProperty("javaPackage"))
                        if (!$util.isString(message.javaPackage))
                            return "javaPackage: string expected";
                    if (message.javaOuterClassname != null && message.hasOwnProperty("javaOuterClassname"))
                        if (!$util.isString(message.javaOuterClassname))
                            return "javaOuterClassname: string expected";
                    if (message.javaMultipleFiles != null && message.hasOwnProperty("javaMultipleFiles"))
                        if (typeof message.javaMultipleFiles !== "boolean")
                            return "javaMultipleFiles: boolean expected";
                    if (message.javaGenerateEqualsAndHash != null && message.hasOwnProperty("javaGenerateEqualsAndHash"))
                        if (typeof message.javaGenerateEqualsAndHash !== "boolean")
                            return "javaGenerateEqualsAndHash: boolean expected";
                    if (message.javaStringCheckUtf8 != null && message.hasOwnProperty("javaStringCheckUtf8"))
                        if (typeof message.javaStringCheckUtf8 !== "boolean")
                            return "javaStringCheckUtf8: boolean expected";
                    if (message.optimizeFor != null && message.hasOwnProperty("optimizeFor"))
                        switch (message.optimizeFor) {
                        default:
                            return "optimizeFor: enum value expected";
                        case 1:
                        case 2:
                        case 3:
                            break;
                        }
                    if (message.goPackage != null && message.hasOwnProperty("goPackage"))
                        if (!$util.isString(message.goPackage))
                            return "goPackage: string expected";
                    if (message.ccGenericServices != null && message.hasOwnProperty("ccGenericServices"))
                        if (typeof message.ccGenericServices !== "boolean")
                            return "ccGenericServices: boolean expected";
                    if (message.javaGenericServices != null && message.hasOwnProperty("javaGenericServices"))
                        if (typeof message.javaGenericServices !== "boolean")
                            return "javaGenericServices: boolean expected";
                    if (message.pyGenericServices != null && message.hasOwnProperty("pyGenericServices"))
                        if (typeof message.pyGenericServices !== "boolean")
                            return "pyGenericServices: boolean expected";
                    if (message.deprecated != null && message.hasOwnProperty("deprecated"))
                        if (typeof message.deprecated !== "boolean")
                            return "deprecated: boolean expected";
                    if (message.ccEnableArenas != null && message.hasOwnProperty("ccEnableArenas"))
                        if (typeof message.ccEnableArenas !== "boolean")
                            return "ccEnableArenas: boolean expected";
                    if (message.objcClassPrefix != null && message.hasOwnProperty("objcClassPrefix"))
                        if (!$util.isString(message.objcClassPrefix))
                            return "objcClassPrefix: string expected";
                    if (message.csharpNamespace != null && message.hasOwnProperty("csharpNamespace"))
                        if (!$util.isString(message.csharpNamespace))
                            return "csharpNamespace: string expected";
                    if (message.uninterpretedOption != null && message.hasOwnProperty("uninterpretedOption")) {
                        if (!Array.isArray(message.uninterpretedOption))
                            return "uninterpretedOption: array expected";
                        for (var i = 0; i < message.uninterpretedOption.length; ++i) {
                            var error = $root.google.protobuf.UninterpretedOption.verify(message.uninterpretedOption[i]);
                            if (error)
                                return "uninterpretedOption." + error;
                        }
                    }
                    return null;
                };
    
                /**
                 * Creates a FileOptions message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof google.protobuf.FileOptions
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {google.protobuf.FileOptions} FileOptions
                 */
                FileOptions.fromObject = function fromObject(object) {
                    if (object instanceof $root.google.protobuf.FileOptions)
                        return object;
                    var message = new $root.google.protobuf.FileOptions();
                    if (object.javaPackage != null)
                        message.javaPackage = String(object.javaPackage);
                    if (object.javaOuterClassname != null)
                        message.javaOuterClassname = String(object.javaOuterClassname);
                    if (object.javaMultipleFiles != null)
                        message.javaMultipleFiles = Boolean(object.javaMultipleFiles);
                    if (object.javaGenerateEqualsAndHash != null)
                        message.javaGenerateEqualsAndHash = Boolean(object.javaGenerateEqualsAndHash);
                    if (object.javaStringCheckUtf8 != null)
                        message.javaStringCheckUtf8 = Boolean(object.javaStringCheckUtf8);
                    switch (object.optimizeFor) {
                    default:
                        if (typeof object.optimizeFor === "number") {
                            message.optimizeFor = object.optimizeFor;
                            break;
                        }
                        break;
                    case "SPEED":
                    case 1:
                        message.optimizeFor = 1;
                        break;
                    case "CODE_SIZE":
                    case 2:
                        message.optimizeFor = 2;
                        break;
                    case "LITE_RUNTIME":
                    case 3:
                        message.optimizeFor = 3;
                        break;
                    }
                    if (object.goPackage != null)
                        message.goPackage = String(object.goPackage);
                    if (object.ccGenericServices != null)
                        message.ccGenericServices = Boolean(object.ccGenericServices);
                    if (object.javaGenericServices != null)
                        message.javaGenericServices = Boolean(object.javaGenericServices);
                    if (object.pyGenericServices != null)
                        message.pyGenericServices = Boolean(object.pyGenericServices);
                    if (object.deprecated != null)
                        message.deprecated = Boolean(object.deprecated);
                    if (object.ccEnableArenas != null)
                        message.ccEnableArenas = Boolean(object.ccEnableArenas);
                    if (object.objcClassPrefix != null)
                        message.objcClassPrefix = String(object.objcClassPrefix);
                    if (object.csharpNamespace != null)
                        message.csharpNamespace = String(object.csharpNamespace);
                    if (object.uninterpretedOption) {
                        if (!Array.isArray(object.uninterpretedOption))
                            throw TypeError(".google.protobuf.FileOptions.uninterpretedOption: array expected");
                        message.uninterpretedOption = [];
                        for (var i = 0; i < object.uninterpretedOption.length; ++i) {
                            if (typeof object.uninterpretedOption[i] !== "object")
                                throw TypeError(".google.protobuf.FileOptions.uninterpretedOption: object expected");
                            message.uninterpretedOption[i] = $root.google.protobuf.UninterpretedOption.fromObject(object.uninterpretedOption[i]);
                        }
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a FileOptions message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof google.protobuf.FileOptions
                 * @static
                 * @param {google.protobuf.FileOptions} message FileOptions
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                FileOptions.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.uninterpretedOption = [];
                    if (options.defaults) {
                        object.javaPackage = "";
                        object.javaOuterClassname = "";
                        object.optimizeFor = options.enums === String ? "SPEED" : 1;
                        object.javaMultipleFiles = false;
                        object.goPackage = "";
                        object.ccGenericServices = false;
                        object.javaGenericServices = false;
                        object.pyGenericServices = false;
                        object.javaGenerateEqualsAndHash = false;
                        object.deprecated = false;
                        object.javaStringCheckUtf8 = false;
                        object.ccEnableArenas = false;
                        object.objcClassPrefix = "";
                        object.csharpNamespace = "";
                    }
                    if (message.javaPackage != null && message.hasOwnProperty("javaPackage"))
                        object.javaPackage = message.javaPackage;
                    if (message.javaOuterClassname != null && message.hasOwnProperty("javaOuterClassname"))
                        object.javaOuterClassname = message.javaOuterClassname;
                    if (message.optimizeFor != null && message.hasOwnProperty("optimizeFor"))
                        object.optimizeFor = options.enums === String ? $root.google.protobuf.FileOptions.OptimizeMode[message.optimizeFor] === undefined ? message.optimizeFor : $root.google.protobuf.FileOptions.OptimizeMode[message.optimizeFor] : message.optimizeFor;
                    if (message.javaMultipleFiles != null && message.hasOwnProperty("javaMultipleFiles"))
                        object.javaMultipleFiles = message.javaMultipleFiles;
                    if (message.goPackage != null && message.hasOwnProperty("goPackage"))
                        object.goPackage = message.goPackage;
                    if (message.ccGenericServices != null && message.hasOwnProperty("ccGenericServices"))
                        object.ccGenericServices = message.ccGenericServices;
                    if (message.javaGenericServices != null && message.hasOwnProperty("javaGenericServices"))
                        object.javaGenericServices = message.javaGenericServices;
                    if (message.pyGenericServices != null && message.hasOwnProperty("pyGenericServices"))
                        object.pyGenericServices = message.pyGenericServices;
                    if (message.javaGenerateEqualsAndHash != null && message.hasOwnProperty("javaGenerateEqualsAndHash"))
                        object.javaGenerateEqualsAndHash = message.javaGenerateEqualsAndHash;
                    if (message.deprecated != null && message.hasOwnProperty("deprecated"))
                        object.deprecated = message.deprecated;
                    if (message.javaStringCheckUtf8 != null && message.hasOwnProperty("javaStringCheckUtf8"))
                        object.javaStringCheckUtf8 = message.javaStringCheckUtf8;
                    if (message.ccEnableArenas != null && message.hasOwnProperty("ccEnableArenas"))
                        object.ccEnableArenas = message.ccEnableArenas;
                    if (message.objcClassPrefix != null && message.hasOwnProperty("objcClassPrefix"))
                        object.objcClassPrefix = message.objcClassPrefix;
                    if (message.csharpNamespace != null && message.hasOwnProperty("csharpNamespace"))
                        object.csharpNamespace = message.csharpNamespace;
                    if (message.uninterpretedOption && message.uninterpretedOption.length) {
                        object.uninterpretedOption = [];
                        for (var j = 0; j < message.uninterpretedOption.length; ++j)
                            object.uninterpretedOption[j] = $root.google.protobuf.UninterpretedOption.toObject(message.uninterpretedOption[j], options);
                    }
                    return object;
                };
    
                /**
                 * Converts this FileOptions to JSON.
                 * @function toJSON
                 * @memberof google.protobuf.FileOptions
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                FileOptions.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                /**
                 * Gets the default type url for FileOptions
                 * @function getTypeUrl
                 * @memberof google.protobuf.FileOptions
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                FileOptions.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/google.protobuf.FileOptions";
                };
    
                /**
                 * OptimizeMode enum.
                 * @name google.protobuf.FileOptions.OptimizeMode
                 * @enum {number}
                 * @property {number} SPEED=1 SPEED value
                 * @property {number} CODE_SIZE=2 CODE_SIZE value
                 * @property {number} LITE_RUNTIME=3 LITE_RUNTIME value
                 */
                FileOptions.OptimizeMode = (function() {
                    var valuesById = {}, values = Object.create(valuesById);
                    values[valuesById[1] = "SPEED"] = 1;
                    values[valuesById[2] = "CODE_SIZE"] = 2;
                    values[valuesById[3] = "LITE_RUNTIME"] = 3;
                    return values;
                })();
    
                return FileOptions;
            })();
    
            protobuf.MessageOptions = (function() {
    
                /**
                 * Properties of a MessageOptions.
                 * @memberof google.protobuf
                 * @interface IMessageOptions
                 * @property {boolean|null} [messageSetWireFormat] MessageOptions messageSetWireFormat
                 * @property {boolean|null} [noStandardDescriptorAccessor] MessageOptions noStandardDescriptorAccessor
                 * @property {boolean|null} [deprecated] MessageOptions deprecated
                 * @property {boolean|null} [mapEntry] MessageOptions mapEntry
                 * @property {Array.<google.protobuf.IUninterpretedOption>|null} [uninterpretedOption] MessageOptions uninterpretedOption
                 */
    
                /**
                 * Constructs a new MessageOptions.
                 * @memberof google.protobuf
                 * @classdesc Represents a MessageOptions.
                 * @implements IMessageOptions
                 * @constructor
                 * @param {google.protobuf.IMessageOptions=} [properties] Properties to set
                 */
                function MessageOptions(properties) {
                    this.uninterpretedOption = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * MessageOptions messageSetWireFormat.
                 * @member {boolean} messageSetWireFormat
                 * @memberof google.protobuf.MessageOptions
                 * @instance
                 */
                MessageOptions.prototype.messageSetWireFormat = false;
    
                /**
                 * MessageOptions noStandardDescriptorAccessor.
                 * @member {boolean} noStandardDescriptorAccessor
                 * @memberof google.protobuf.MessageOptions
                 * @instance
                 */
                MessageOptions.prototype.noStandardDescriptorAccessor = false;
    
                /**
                 * MessageOptions deprecated.
                 * @member {boolean} deprecated
                 * @memberof google.protobuf.MessageOptions
                 * @instance
                 */
                MessageOptions.prototype.deprecated = false;
    
                /**
                 * MessageOptions mapEntry.
                 * @member {boolean} mapEntry
                 * @memberof google.protobuf.MessageOptions
                 * @instance
                 */
                MessageOptions.prototype.mapEntry = false;
    
                /**
                 * MessageOptions uninterpretedOption.
                 * @member {Array.<google.protobuf.IUninterpretedOption>} uninterpretedOption
                 * @memberof google.protobuf.MessageOptions
                 * @instance
                 */
                MessageOptions.prototype.uninterpretedOption = $util.emptyArray;
    
                /**
                 * Creates a new MessageOptions instance using the specified properties.
                 * @function create
                 * @memberof google.protobuf.MessageOptions
                 * @static
                 * @param {google.protobuf.IMessageOptions=} [properties] Properties to set
                 * @returns {google.protobuf.MessageOptions} MessageOptions instance
                 */
                MessageOptions.create = function create(properties) {
                    return new MessageOptions(properties);
                };
    
                /**
                 * Encodes the specified MessageOptions message. Does not implicitly {@link google.protobuf.MessageOptions.verify|verify} messages.
                 * @function encode
                 * @memberof google.protobuf.MessageOptions
                 * @static
                 * @param {google.protobuf.IMessageOptions} message MessageOptions message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MessageOptions.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.messageSetWireFormat != null && Object.hasOwnProperty.call(message, "messageSetWireFormat"))
                        writer.uint32(/* id 1, wireType 0 =*/8).bool(message.messageSetWireFormat);
                    if (message.noStandardDescriptorAccessor != null && Object.hasOwnProperty.call(message, "noStandardDescriptorAccessor"))
                        writer.uint32(/* id 2, wireType 0 =*/16).bool(message.noStandardDescriptorAccessor);
                    if (message.deprecated != null && Object.hasOwnProperty.call(message, "deprecated"))
                        writer.uint32(/* id 3, wireType 0 =*/24).bool(message.deprecated);
                    if (message.mapEntry != null && Object.hasOwnProperty.call(message, "mapEntry"))
                        writer.uint32(/* id 7, wireType 0 =*/56).bool(message.mapEntry);
                    if (message.uninterpretedOption != null && message.uninterpretedOption.length)
                        for (var i = 0; i < message.uninterpretedOption.length; ++i)
                            $root.google.protobuf.UninterpretedOption.encode(message.uninterpretedOption[i], writer.uint32(/* id 999, wireType 2 =*/7994).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified MessageOptions message, length delimited. Does not implicitly {@link google.protobuf.MessageOptions.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof google.protobuf.MessageOptions
                 * @static
                 * @param {google.protobuf.IMessageOptions} message MessageOptions message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MessageOptions.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a MessageOptions message from the specified reader or buffer.
                 * @function decode
                 * @memberof google.protobuf.MessageOptions
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {google.protobuf.MessageOptions} MessageOptions
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MessageOptions.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.MessageOptions();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1: {
                                message.messageSetWireFormat = reader.bool();
                                break;
                            }
                        case 2: {
                                message.noStandardDescriptorAccessor = reader.bool();
                                break;
                            }
                        case 3: {
                                message.deprecated = reader.bool();
                                break;
                            }
                        case 7: {
                                message.mapEntry = reader.bool();
                                break;
                            }
                        case 999: {
                                if (!(message.uninterpretedOption && message.uninterpretedOption.length))
                                    message.uninterpretedOption = [];
                                message.uninterpretedOption.push($root.google.protobuf.UninterpretedOption.decode(reader, reader.uint32()));
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a MessageOptions message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof google.protobuf.MessageOptions
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {google.protobuf.MessageOptions} MessageOptions
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MessageOptions.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a MessageOptions message.
                 * @function verify
                 * @memberof google.protobuf.MessageOptions
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                MessageOptions.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.messageSetWireFormat != null && message.hasOwnProperty("messageSetWireFormat"))
                        if (typeof message.messageSetWireFormat !== "boolean")
                            return "messageSetWireFormat: boolean expected";
                    if (message.noStandardDescriptorAccessor != null && message.hasOwnProperty("noStandardDescriptorAccessor"))
                        if (typeof message.noStandardDescriptorAccessor !== "boolean")
                            return "noStandardDescriptorAccessor: boolean expected";
                    if (message.deprecated != null && message.hasOwnProperty("deprecated"))
                        if (typeof message.deprecated !== "boolean")
                            return "deprecated: boolean expected";
                    if (message.mapEntry != null && message.hasOwnProperty("mapEntry"))
                        if (typeof message.mapEntry !== "boolean")
                            return "mapEntry: boolean expected";
                    if (message.uninterpretedOption != null && message.hasOwnProperty("uninterpretedOption")) {
                        if (!Array.isArray(message.uninterpretedOption))
                            return "uninterpretedOption: array expected";
                        for (var i = 0; i < message.uninterpretedOption.length; ++i) {
                            var error = $root.google.protobuf.UninterpretedOption.verify(message.uninterpretedOption[i]);
                            if (error)
                                return "uninterpretedOption." + error;
                        }
                    }
                    return null;
                };
    
                /**
                 * Creates a MessageOptions message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof google.protobuf.MessageOptions
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {google.protobuf.MessageOptions} MessageOptions
                 */
                MessageOptions.fromObject = function fromObject(object) {
                    if (object instanceof $root.google.protobuf.MessageOptions)
                        return object;
                    var message = new $root.google.protobuf.MessageOptions();
                    if (object.messageSetWireFormat != null)
                        message.messageSetWireFormat = Boolean(object.messageSetWireFormat);
                    if (object.noStandardDescriptorAccessor != null)
                        message.noStandardDescriptorAccessor = Boolean(object.noStandardDescriptorAccessor);
                    if (object.deprecated != null)
                        message.deprecated = Boolean(object.deprecated);
                    if (object.mapEntry != null)
                        message.mapEntry = Boolean(object.mapEntry);
                    if (object.uninterpretedOption) {
                        if (!Array.isArray(object.uninterpretedOption))
                            throw TypeError(".google.protobuf.MessageOptions.uninterpretedOption: array expected");
                        message.uninterpretedOption = [];
                        for (var i = 0; i < object.uninterpretedOption.length; ++i) {
                            if (typeof object.uninterpretedOption[i] !== "object")
                                throw TypeError(".google.protobuf.MessageOptions.uninterpretedOption: object expected");
                            message.uninterpretedOption[i] = $root.google.protobuf.UninterpretedOption.fromObject(object.uninterpretedOption[i]);
                        }
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a MessageOptions message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof google.protobuf.MessageOptions
                 * @static
                 * @param {google.protobuf.MessageOptions} message MessageOptions
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                MessageOptions.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.uninterpretedOption = [];
                    if (options.defaults) {
                        object.messageSetWireFormat = false;
                        object.noStandardDescriptorAccessor = false;
                        object.deprecated = false;
                        object.mapEntry = false;
                    }
                    if (message.messageSetWireFormat != null && message.hasOwnProperty("messageSetWireFormat"))
                        object.messageSetWireFormat = message.messageSetWireFormat;
                    if (message.noStandardDescriptorAccessor != null && message.hasOwnProperty("noStandardDescriptorAccessor"))
                        object.noStandardDescriptorAccessor = message.noStandardDescriptorAccessor;
                    if (message.deprecated != null && message.hasOwnProperty("deprecated"))
                        object.deprecated = message.deprecated;
                    if (message.mapEntry != null && message.hasOwnProperty("mapEntry"))
                        object.mapEntry = message.mapEntry;
                    if (message.uninterpretedOption && message.uninterpretedOption.length) {
                        object.uninterpretedOption = [];
                        for (var j = 0; j < message.uninterpretedOption.length; ++j)
                            object.uninterpretedOption[j] = $root.google.protobuf.UninterpretedOption.toObject(message.uninterpretedOption[j], options);
                    }
                    return object;
                };
    
                /**
                 * Converts this MessageOptions to JSON.
                 * @function toJSON
                 * @memberof google.protobuf.MessageOptions
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                MessageOptions.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                /**
                 * Gets the default type url for MessageOptions
                 * @function getTypeUrl
                 * @memberof google.protobuf.MessageOptions
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                MessageOptions.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/google.protobuf.MessageOptions";
                };
    
                return MessageOptions;
            })();
    
            protobuf.FieldOptions = (function() {
    
                /**
                 * Properties of a FieldOptions.
                 * @memberof google.protobuf
                 * @interface IFieldOptions
                 * @property {google.protobuf.FieldOptions.CType|null} [ctype] FieldOptions ctype
                 * @property {boolean|null} [packed] FieldOptions packed
                 * @property {google.protobuf.FieldOptions.JSType|null} [jstype] FieldOptions jstype
                 * @property {boolean|null} [lazy] FieldOptions lazy
                 * @property {boolean|null} [deprecated] FieldOptions deprecated
                 * @property {boolean|null} [weak] FieldOptions weak
                 * @property {Array.<google.protobuf.IUninterpretedOption>|null} [uninterpretedOption] FieldOptions uninterpretedOption
                 */
    
                /**
                 * Constructs a new FieldOptions.
                 * @memberof google.protobuf
                 * @classdesc Represents a FieldOptions.
                 * @implements IFieldOptions
                 * @constructor
                 * @param {google.protobuf.IFieldOptions=} [properties] Properties to set
                 */
                function FieldOptions(properties) {
                    this.uninterpretedOption = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * FieldOptions ctype.
                 * @member {google.protobuf.FieldOptions.CType} ctype
                 * @memberof google.protobuf.FieldOptions
                 * @instance
                 */
                FieldOptions.prototype.ctype = 0;
    
                /**
                 * FieldOptions packed.
                 * @member {boolean} packed
                 * @memberof google.protobuf.FieldOptions
                 * @instance
                 */
                FieldOptions.prototype.packed = false;
    
                /**
                 * FieldOptions jstype.
                 * @member {google.protobuf.FieldOptions.JSType} jstype
                 * @memberof google.protobuf.FieldOptions
                 * @instance
                 */
                FieldOptions.prototype.jstype = 0;
    
                /**
                 * FieldOptions lazy.
                 * @member {boolean} lazy
                 * @memberof google.protobuf.FieldOptions
                 * @instance
                 */
                FieldOptions.prototype.lazy = false;
    
                /**
                 * FieldOptions deprecated.
                 * @member {boolean} deprecated
                 * @memberof google.protobuf.FieldOptions
                 * @instance
                 */
                FieldOptions.prototype.deprecated = false;
    
                /**
                 * FieldOptions weak.
                 * @member {boolean} weak
                 * @memberof google.protobuf.FieldOptions
                 * @instance
                 */
                FieldOptions.prototype.weak = false;
    
                /**
                 * FieldOptions uninterpretedOption.
                 * @member {Array.<google.protobuf.IUninterpretedOption>} uninterpretedOption
                 * @memberof google.protobuf.FieldOptions
                 * @instance
                 */
                FieldOptions.prototype.uninterpretedOption = $util.emptyArray;
    
                /**
                 * Creates a new FieldOptions instance using the specified properties.
                 * @function create
                 * @memberof google.protobuf.FieldOptions
                 * @static
                 * @param {google.protobuf.IFieldOptions=} [properties] Properties to set
                 * @returns {google.protobuf.FieldOptions} FieldOptions instance
                 */
                FieldOptions.create = function create(properties) {
                    return new FieldOptions(properties);
                };
    
                /**
                 * Encodes the specified FieldOptions message. Does not implicitly {@link google.protobuf.FieldOptions.verify|verify} messages.
                 * @function encode
                 * @memberof google.protobuf.FieldOptions
                 * @static
                 * @param {google.protobuf.IFieldOptions} message FieldOptions message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                FieldOptions.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.ctype != null && Object.hasOwnProperty.call(message, "ctype"))
                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.ctype);
                    if (message.packed != null && Object.hasOwnProperty.call(message, "packed"))
                        writer.uint32(/* id 2, wireType 0 =*/16).bool(message.packed);
                    if (message.deprecated != null && Object.hasOwnProperty.call(message, "deprecated"))
                        writer.uint32(/* id 3, wireType 0 =*/24).bool(message.deprecated);
                    if (message.lazy != null && Object.hasOwnProperty.call(message, "lazy"))
                        writer.uint32(/* id 5, wireType 0 =*/40).bool(message.lazy);
                    if (message.jstype != null && Object.hasOwnProperty.call(message, "jstype"))
                        writer.uint32(/* id 6, wireType 0 =*/48).int32(message.jstype);
                    if (message.weak != null && Object.hasOwnProperty.call(message, "weak"))
                        writer.uint32(/* id 10, wireType 0 =*/80).bool(message.weak);
                    if (message.uninterpretedOption != null && message.uninterpretedOption.length)
                        for (var i = 0; i < message.uninterpretedOption.length; ++i)
                            $root.google.protobuf.UninterpretedOption.encode(message.uninterpretedOption[i], writer.uint32(/* id 999, wireType 2 =*/7994).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified FieldOptions message, length delimited. Does not implicitly {@link google.protobuf.FieldOptions.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof google.protobuf.FieldOptions
                 * @static
                 * @param {google.protobuf.IFieldOptions} message FieldOptions message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                FieldOptions.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a FieldOptions message from the specified reader or buffer.
                 * @function decode
                 * @memberof google.protobuf.FieldOptions
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {google.protobuf.FieldOptions} FieldOptions
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                FieldOptions.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.FieldOptions();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1: {
                                message.ctype = reader.int32();
                                break;
                            }
                        case 2: {
                                message.packed = reader.bool();
                                break;
                            }
                        case 6: {
                                message.jstype = reader.int32();
                                break;
                            }
                        case 5: {
                                message.lazy = reader.bool();
                                break;
                            }
                        case 3: {
                                message.deprecated = reader.bool();
                                break;
                            }
                        case 10: {
                                message.weak = reader.bool();
                                break;
                            }
                        case 999: {
                                if (!(message.uninterpretedOption && message.uninterpretedOption.length))
                                    message.uninterpretedOption = [];
                                message.uninterpretedOption.push($root.google.protobuf.UninterpretedOption.decode(reader, reader.uint32()));
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a FieldOptions message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof google.protobuf.FieldOptions
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {google.protobuf.FieldOptions} FieldOptions
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                FieldOptions.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a FieldOptions message.
                 * @function verify
                 * @memberof google.protobuf.FieldOptions
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                FieldOptions.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.ctype != null && message.hasOwnProperty("ctype"))
                        switch (message.ctype) {
                        default:
                            return "ctype: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                            break;
                        }
                    if (message.packed != null && message.hasOwnProperty("packed"))
                        if (typeof message.packed !== "boolean")
                            return "packed: boolean expected";
                    if (message.jstype != null && message.hasOwnProperty("jstype"))
                        switch (message.jstype) {
                        default:
                            return "jstype: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                            break;
                        }
                    if (message.lazy != null && message.hasOwnProperty("lazy"))
                        if (typeof message.lazy !== "boolean")
                            return "lazy: boolean expected";
                    if (message.deprecated != null && message.hasOwnProperty("deprecated"))
                        if (typeof message.deprecated !== "boolean")
                            return "deprecated: boolean expected";
                    if (message.weak != null && message.hasOwnProperty("weak"))
                        if (typeof message.weak !== "boolean")
                            return "weak: boolean expected";
                    if (message.uninterpretedOption != null && message.hasOwnProperty("uninterpretedOption")) {
                        if (!Array.isArray(message.uninterpretedOption))
                            return "uninterpretedOption: array expected";
                        for (var i = 0; i < message.uninterpretedOption.length; ++i) {
                            var error = $root.google.protobuf.UninterpretedOption.verify(message.uninterpretedOption[i]);
                            if (error)
                                return "uninterpretedOption." + error;
                        }
                    }
                    return null;
                };
    
                /**
                 * Creates a FieldOptions message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof google.protobuf.FieldOptions
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {google.protobuf.FieldOptions} FieldOptions
                 */
                FieldOptions.fromObject = function fromObject(object) {
                    if (object instanceof $root.google.protobuf.FieldOptions)
                        return object;
                    var message = new $root.google.protobuf.FieldOptions();
                    switch (object.ctype) {
                    default:
                        if (typeof object.ctype === "number") {
                            message.ctype = object.ctype;
                            break;
                        }
                        break;
                    case "STRING":
                    case 0:
                        message.ctype = 0;
                        break;
                    case "CORD":
                    case 1:
                        message.ctype = 1;
                        break;
                    case "STRING_PIECE":
                    case 2:
                        message.ctype = 2;
                        break;
                    }
                    if (object.packed != null)
                        message.packed = Boolean(object.packed);
                    switch (object.jstype) {
                    default:
                        if (typeof object.jstype === "number") {
                            message.jstype = object.jstype;
                            break;
                        }
                        break;
                    case "JS_NORMAL":
                    case 0:
                        message.jstype = 0;
                        break;
                    case "JS_STRING":
                    case 1:
                        message.jstype = 1;
                        break;
                    case "JS_NUMBER":
                    case 2:
                        message.jstype = 2;
                        break;
                    }
                    if (object.lazy != null)
                        message.lazy = Boolean(object.lazy);
                    if (object.deprecated != null)
                        message.deprecated = Boolean(object.deprecated);
                    if (object.weak != null)
                        message.weak = Boolean(object.weak);
                    if (object.uninterpretedOption) {
                        if (!Array.isArray(object.uninterpretedOption))
                            throw TypeError(".google.protobuf.FieldOptions.uninterpretedOption: array expected");
                        message.uninterpretedOption = [];
                        for (var i = 0; i < object.uninterpretedOption.length; ++i) {
                            if (typeof object.uninterpretedOption[i] !== "object")
                                throw TypeError(".google.protobuf.FieldOptions.uninterpretedOption: object expected");
                            message.uninterpretedOption[i] = $root.google.protobuf.UninterpretedOption.fromObject(object.uninterpretedOption[i]);
                        }
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a FieldOptions message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof google.protobuf.FieldOptions
                 * @static
                 * @param {google.protobuf.FieldOptions} message FieldOptions
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                FieldOptions.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.uninterpretedOption = [];
                    if (options.defaults) {
                        object.ctype = options.enums === String ? "STRING" : 0;
                        object.packed = false;
                        object.deprecated = false;
                        object.lazy = false;
                        object.jstype = options.enums === String ? "JS_NORMAL" : 0;
                        object.weak = false;
                    }
                    if (message.ctype != null && message.hasOwnProperty("ctype"))
                        object.ctype = options.enums === String ? $root.google.protobuf.FieldOptions.CType[message.ctype] === undefined ? message.ctype : $root.google.protobuf.FieldOptions.CType[message.ctype] : message.ctype;
                    if (message.packed != null && message.hasOwnProperty("packed"))
                        object.packed = message.packed;
                    if (message.deprecated != null && message.hasOwnProperty("deprecated"))
                        object.deprecated = message.deprecated;
                    if (message.lazy != null && message.hasOwnProperty("lazy"))
                        object.lazy = message.lazy;
                    if (message.jstype != null && message.hasOwnProperty("jstype"))
                        object.jstype = options.enums === String ? $root.google.protobuf.FieldOptions.JSType[message.jstype] === undefined ? message.jstype : $root.google.protobuf.FieldOptions.JSType[message.jstype] : message.jstype;
                    if (message.weak != null && message.hasOwnProperty("weak"))
                        object.weak = message.weak;
                    if (message.uninterpretedOption && message.uninterpretedOption.length) {
                        object.uninterpretedOption = [];
                        for (var j = 0; j < message.uninterpretedOption.length; ++j)
                            object.uninterpretedOption[j] = $root.google.protobuf.UninterpretedOption.toObject(message.uninterpretedOption[j], options);
                    }
                    return object;
                };
    
                /**
                 * Converts this FieldOptions to JSON.
                 * @function toJSON
                 * @memberof google.protobuf.FieldOptions
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                FieldOptions.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                /**
                 * Gets the default type url for FieldOptions
                 * @function getTypeUrl
                 * @memberof google.protobuf.FieldOptions
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                FieldOptions.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/google.protobuf.FieldOptions";
                };
    
                /**
                 * CType enum.
                 * @name google.protobuf.FieldOptions.CType
                 * @enum {number}
                 * @property {number} STRING=0 STRING value
                 * @property {number} CORD=1 CORD value
                 * @property {number} STRING_PIECE=2 STRING_PIECE value
                 */
                FieldOptions.CType = (function() {
                    var valuesById = {}, values = Object.create(valuesById);
                    values[valuesById[0] = "STRING"] = 0;
                    values[valuesById[1] = "CORD"] = 1;
                    values[valuesById[2] = "STRING_PIECE"] = 2;
                    return values;
                })();
    
                /**
                 * JSType enum.
                 * @name google.protobuf.FieldOptions.JSType
                 * @enum {number}
                 * @property {number} JS_NORMAL=0 JS_NORMAL value
                 * @property {number} JS_STRING=1 JS_STRING value
                 * @property {number} JS_NUMBER=2 JS_NUMBER value
                 */
                FieldOptions.JSType = (function() {
                    var valuesById = {}, values = Object.create(valuesById);
                    values[valuesById[0] = "JS_NORMAL"] = 0;
                    values[valuesById[1] = "JS_STRING"] = 1;
                    values[valuesById[2] = "JS_NUMBER"] = 2;
                    return values;
                })();
    
                return FieldOptions;
            })();
    
            protobuf.OneofOptions = (function() {
    
                /**
                 * Properties of an OneofOptions.
                 * @memberof google.protobuf
                 * @interface IOneofOptions
                 * @property {Array.<google.protobuf.IUninterpretedOption>|null} [uninterpretedOption] OneofOptions uninterpretedOption
                 */
    
                /**
                 * Constructs a new OneofOptions.
                 * @memberof google.protobuf
                 * @classdesc Represents an OneofOptions.
                 * @implements IOneofOptions
                 * @constructor
                 * @param {google.protobuf.IOneofOptions=} [properties] Properties to set
                 */
                function OneofOptions(properties) {
                    this.uninterpretedOption = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * OneofOptions uninterpretedOption.
                 * @member {Array.<google.protobuf.IUninterpretedOption>} uninterpretedOption
                 * @memberof google.protobuf.OneofOptions
                 * @instance
                 */
                OneofOptions.prototype.uninterpretedOption = $util.emptyArray;
    
                /**
                 * Creates a new OneofOptions instance using the specified properties.
                 * @function create
                 * @memberof google.protobuf.OneofOptions
                 * @static
                 * @param {google.protobuf.IOneofOptions=} [properties] Properties to set
                 * @returns {google.protobuf.OneofOptions} OneofOptions instance
                 */
                OneofOptions.create = function create(properties) {
                    return new OneofOptions(properties);
                };
    
                /**
                 * Encodes the specified OneofOptions message. Does not implicitly {@link google.protobuf.OneofOptions.verify|verify} messages.
                 * @function encode
                 * @memberof google.protobuf.OneofOptions
                 * @static
                 * @param {google.protobuf.IOneofOptions} message OneofOptions message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                OneofOptions.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.uninterpretedOption != null && message.uninterpretedOption.length)
                        for (var i = 0; i < message.uninterpretedOption.length; ++i)
                            $root.google.protobuf.UninterpretedOption.encode(message.uninterpretedOption[i], writer.uint32(/* id 999, wireType 2 =*/7994).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified OneofOptions message, length delimited. Does not implicitly {@link google.protobuf.OneofOptions.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof google.protobuf.OneofOptions
                 * @static
                 * @param {google.protobuf.IOneofOptions} message OneofOptions message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                OneofOptions.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes an OneofOptions message from the specified reader or buffer.
                 * @function decode
                 * @memberof google.protobuf.OneofOptions
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {google.protobuf.OneofOptions} OneofOptions
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                OneofOptions.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.OneofOptions();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 999: {
                                if (!(message.uninterpretedOption && message.uninterpretedOption.length))
                                    message.uninterpretedOption = [];
                                message.uninterpretedOption.push($root.google.protobuf.UninterpretedOption.decode(reader, reader.uint32()));
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes an OneofOptions message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof google.protobuf.OneofOptions
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {google.protobuf.OneofOptions} OneofOptions
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                OneofOptions.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies an OneofOptions message.
                 * @function verify
                 * @memberof google.protobuf.OneofOptions
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                OneofOptions.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.uninterpretedOption != null && message.hasOwnProperty("uninterpretedOption")) {
                        if (!Array.isArray(message.uninterpretedOption))
                            return "uninterpretedOption: array expected";
                        for (var i = 0; i < message.uninterpretedOption.length; ++i) {
                            var error = $root.google.protobuf.UninterpretedOption.verify(message.uninterpretedOption[i]);
                            if (error)
                                return "uninterpretedOption." + error;
                        }
                    }
                    return null;
                };
    
                /**
                 * Creates an OneofOptions message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof google.protobuf.OneofOptions
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {google.protobuf.OneofOptions} OneofOptions
                 */
                OneofOptions.fromObject = function fromObject(object) {
                    if (object instanceof $root.google.protobuf.OneofOptions)
                        return object;
                    var message = new $root.google.protobuf.OneofOptions();
                    if (object.uninterpretedOption) {
                        if (!Array.isArray(object.uninterpretedOption))
                            throw TypeError(".google.protobuf.OneofOptions.uninterpretedOption: array expected");
                        message.uninterpretedOption = [];
                        for (var i = 0; i < object.uninterpretedOption.length; ++i) {
                            if (typeof object.uninterpretedOption[i] !== "object")
                                throw TypeError(".google.protobuf.OneofOptions.uninterpretedOption: object expected");
                            message.uninterpretedOption[i] = $root.google.protobuf.UninterpretedOption.fromObject(object.uninterpretedOption[i]);
                        }
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from an OneofOptions message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof google.protobuf.OneofOptions
                 * @static
                 * @param {google.protobuf.OneofOptions} message OneofOptions
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                OneofOptions.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.uninterpretedOption = [];
                    if (message.uninterpretedOption && message.uninterpretedOption.length) {
                        object.uninterpretedOption = [];
                        for (var j = 0; j < message.uninterpretedOption.length; ++j)
                            object.uninterpretedOption[j] = $root.google.protobuf.UninterpretedOption.toObject(message.uninterpretedOption[j], options);
                    }
                    return object;
                };
    
                /**
                 * Converts this OneofOptions to JSON.
                 * @function toJSON
                 * @memberof google.protobuf.OneofOptions
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                OneofOptions.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                /**
                 * Gets the default type url for OneofOptions
                 * @function getTypeUrl
                 * @memberof google.protobuf.OneofOptions
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                OneofOptions.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/google.protobuf.OneofOptions";
                };
    
                return OneofOptions;
            })();
    
            protobuf.EnumOptions = (function() {
    
                /**
                 * Properties of an EnumOptions.
                 * @memberof google.protobuf
                 * @interface IEnumOptions
                 * @property {boolean|null} [allowAlias] EnumOptions allowAlias
                 * @property {boolean|null} [deprecated] EnumOptions deprecated
                 * @property {Array.<google.protobuf.IUninterpretedOption>|null} [uninterpretedOption] EnumOptions uninterpretedOption
                 */
    
                /**
                 * Constructs a new EnumOptions.
                 * @memberof google.protobuf
                 * @classdesc Represents an EnumOptions.
                 * @implements IEnumOptions
                 * @constructor
                 * @param {google.protobuf.IEnumOptions=} [properties] Properties to set
                 */
                function EnumOptions(properties) {
                    this.uninterpretedOption = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * EnumOptions allowAlias.
                 * @member {boolean} allowAlias
                 * @memberof google.protobuf.EnumOptions
                 * @instance
                 */
                EnumOptions.prototype.allowAlias = false;
    
                /**
                 * EnumOptions deprecated.
                 * @member {boolean} deprecated
                 * @memberof google.protobuf.EnumOptions
                 * @instance
                 */
                EnumOptions.prototype.deprecated = false;
    
                /**
                 * EnumOptions uninterpretedOption.
                 * @member {Array.<google.protobuf.IUninterpretedOption>} uninterpretedOption
                 * @memberof google.protobuf.EnumOptions
                 * @instance
                 */
                EnumOptions.prototype.uninterpretedOption = $util.emptyArray;
    
                /**
                 * Creates a new EnumOptions instance using the specified properties.
                 * @function create
                 * @memberof google.protobuf.EnumOptions
                 * @static
                 * @param {google.protobuf.IEnumOptions=} [properties] Properties to set
                 * @returns {google.protobuf.EnumOptions} EnumOptions instance
                 */
                EnumOptions.create = function create(properties) {
                    return new EnumOptions(properties);
                };
    
                /**
                 * Encodes the specified EnumOptions message. Does not implicitly {@link google.protobuf.EnumOptions.verify|verify} messages.
                 * @function encode
                 * @memberof google.protobuf.EnumOptions
                 * @static
                 * @param {google.protobuf.IEnumOptions} message EnumOptions message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                EnumOptions.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.allowAlias != null && Object.hasOwnProperty.call(message, "allowAlias"))
                        writer.uint32(/* id 2, wireType 0 =*/16).bool(message.allowAlias);
                    if (message.deprecated != null && Object.hasOwnProperty.call(message, "deprecated"))
                        writer.uint32(/* id 3, wireType 0 =*/24).bool(message.deprecated);
                    if (message.uninterpretedOption != null && message.uninterpretedOption.length)
                        for (var i = 0; i < message.uninterpretedOption.length; ++i)
                            $root.google.protobuf.UninterpretedOption.encode(message.uninterpretedOption[i], writer.uint32(/* id 999, wireType 2 =*/7994).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified EnumOptions message, length delimited. Does not implicitly {@link google.protobuf.EnumOptions.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof google.protobuf.EnumOptions
                 * @static
                 * @param {google.protobuf.IEnumOptions} message EnumOptions message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                EnumOptions.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes an EnumOptions message from the specified reader or buffer.
                 * @function decode
                 * @memberof google.protobuf.EnumOptions
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {google.protobuf.EnumOptions} EnumOptions
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                EnumOptions.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.EnumOptions();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 2: {
                                message.allowAlias = reader.bool();
                                break;
                            }
                        case 3: {
                                message.deprecated = reader.bool();
                                break;
                            }
                        case 999: {
                                if (!(message.uninterpretedOption && message.uninterpretedOption.length))
                                    message.uninterpretedOption = [];
                                message.uninterpretedOption.push($root.google.protobuf.UninterpretedOption.decode(reader, reader.uint32()));
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes an EnumOptions message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof google.protobuf.EnumOptions
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {google.protobuf.EnumOptions} EnumOptions
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                EnumOptions.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies an EnumOptions message.
                 * @function verify
                 * @memberof google.protobuf.EnumOptions
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                EnumOptions.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.allowAlias != null && message.hasOwnProperty("allowAlias"))
                        if (typeof message.allowAlias !== "boolean")
                            return "allowAlias: boolean expected";
                    if (message.deprecated != null && message.hasOwnProperty("deprecated"))
                        if (typeof message.deprecated !== "boolean")
                            return "deprecated: boolean expected";
                    if (message.uninterpretedOption != null && message.hasOwnProperty("uninterpretedOption")) {
                        if (!Array.isArray(message.uninterpretedOption))
                            return "uninterpretedOption: array expected";
                        for (var i = 0; i < message.uninterpretedOption.length; ++i) {
                            var error = $root.google.protobuf.UninterpretedOption.verify(message.uninterpretedOption[i]);
                            if (error)
                                return "uninterpretedOption." + error;
                        }
                    }
                    return null;
                };
    
                /**
                 * Creates an EnumOptions message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof google.protobuf.EnumOptions
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {google.protobuf.EnumOptions} EnumOptions
                 */
                EnumOptions.fromObject = function fromObject(object) {
                    if (object instanceof $root.google.protobuf.EnumOptions)
                        return object;
                    var message = new $root.google.protobuf.EnumOptions();
                    if (object.allowAlias != null)
                        message.allowAlias = Boolean(object.allowAlias);
                    if (object.deprecated != null)
                        message.deprecated = Boolean(object.deprecated);
                    if (object.uninterpretedOption) {
                        if (!Array.isArray(object.uninterpretedOption))
                            throw TypeError(".google.protobuf.EnumOptions.uninterpretedOption: array expected");
                        message.uninterpretedOption = [];
                        for (var i = 0; i < object.uninterpretedOption.length; ++i) {
                            if (typeof object.uninterpretedOption[i] !== "object")
                                throw TypeError(".google.protobuf.EnumOptions.uninterpretedOption: object expected");
                            message.uninterpretedOption[i] = $root.google.protobuf.UninterpretedOption.fromObject(object.uninterpretedOption[i]);
                        }
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from an EnumOptions message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof google.protobuf.EnumOptions
                 * @static
                 * @param {google.protobuf.EnumOptions} message EnumOptions
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                EnumOptions.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.uninterpretedOption = [];
                    if (options.defaults) {
                        object.allowAlias = false;
                        object.deprecated = false;
                    }
                    if (message.allowAlias != null && message.hasOwnProperty("allowAlias"))
                        object.allowAlias = message.allowAlias;
                    if (message.deprecated != null && message.hasOwnProperty("deprecated"))
                        object.deprecated = message.deprecated;
                    if (message.uninterpretedOption && message.uninterpretedOption.length) {
                        object.uninterpretedOption = [];
                        for (var j = 0; j < message.uninterpretedOption.length; ++j)
                            object.uninterpretedOption[j] = $root.google.protobuf.UninterpretedOption.toObject(message.uninterpretedOption[j], options);
                    }
                    return object;
                };
    
                /**
                 * Converts this EnumOptions to JSON.
                 * @function toJSON
                 * @memberof google.protobuf.EnumOptions
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                EnumOptions.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                /**
                 * Gets the default type url for EnumOptions
                 * @function getTypeUrl
                 * @memberof google.protobuf.EnumOptions
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                EnumOptions.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/google.protobuf.EnumOptions";
                };
    
                return EnumOptions;
            })();
    
            protobuf.EnumValueOptions = (function() {
    
                /**
                 * Properties of an EnumValueOptions.
                 * @memberof google.protobuf
                 * @interface IEnumValueOptions
                 * @property {boolean|null} [deprecated] EnumValueOptions deprecated
                 * @property {Array.<google.protobuf.IUninterpretedOption>|null} [uninterpretedOption] EnumValueOptions uninterpretedOption
                 * @property {string|null} [".networkConnectionToken"] EnumValueOptions .networkConnectionToken
                 */
    
                /**
                 * Constructs a new EnumValueOptions.
                 * @memberof google.protobuf
                 * @classdesc Represents an EnumValueOptions.
                 * @implements IEnumValueOptions
                 * @constructor
                 * @param {google.protobuf.IEnumValueOptions=} [properties] Properties to set
                 */
                function EnumValueOptions(properties) {
                    this.uninterpretedOption = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * EnumValueOptions deprecated.
                 * @member {boolean} deprecated
                 * @memberof google.protobuf.EnumValueOptions
                 * @instance
                 */
                EnumValueOptions.prototype.deprecated = false;
    
                /**
                 * EnumValueOptions uninterpretedOption.
                 * @member {Array.<google.protobuf.IUninterpretedOption>} uninterpretedOption
                 * @memberof google.protobuf.EnumValueOptions
                 * @instance
                 */
                EnumValueOptions.prototype.uninterpretedOption = $util.emptyArray;
    
                /**
                 * EnumValueOptions .networkConnectionToken.
                 * @member {string} .networkConnectionToken
                 * @memberof google.protobuf.EnumValueOptions
                 * @instance
                 */
                EnumValueOptions.prototype[".networkConnectionToken"] = "";
    
                /**
                 * Creates a new EnumValueOptions instance using the specified properties.
                 * @function create
                 * @memberof google.protobuf.EnumValueOptions
                 * @static
                 * @param {google.protobuf.IEnumValueOptions=} [properties] Properties to set
                 * @returns {google.protobuf.EnumValueOptions} EnumValueOptions instance
                 */
                EnumValueOptions.create = function create(properties) {
                    return new EnumValueOptions(properties);
                };
    
                /**
                 * Encodes the specified EnumValueOptions message. Does not implicitly {@link google.protobuf.EnumValueOptions.verify|verify} messages.
                 * @function encode
                 * @memberof google.protobuf.EnumValueOptions
                 * @static
                 * @param {google.protobuf.IEnumValueOptions} message EnumValueOptions message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                EnumValueOptions.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.deprecated != null && Object.hasOwnProperty.call(message, "deprecated"))
                        writer.uint32(/* id 1, wireType 0 =*/8).bool(message.deprecated);
                    if (message.uninterpretedOption != null && message.uninterpretedOption.length)
                        for (var i = 0; i < message.uninterpretedOption.length; ++i)
                            $root.google.protobuf.UninterpretedOption.encode(message.uninterpretedOption[i], writer.uint32(/* id 999, wireType 2 =*/7994).fork()).ldelim();
                    if (message[".networkConnectionToken"] != null && Object.hasOwnProperty.call(message, ".networkConnectionToken"))
                        writer.uint32(/* id 50500, wireType 2 =*/404002).string(message[".networkConnectionToken"]);
                    return writer;
                };
    
                /**
                 * Encodes the specified EnumValueOptions message, length delimited. Does not implicitly {@link google.protobuf.EnumValueOptions.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof google.protobuf.EnumValueOptions
                 * @static
                 * @param {google.protobuf.IEnumValueOptions} message EnumValueOptions message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                EnumValueOptions.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes an EnumValueOptions message from the specified reader or buffer.
                 * @function decode
                 * @memberof google.protobuf.EnumValueOptions
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {google.protobuf.EnumValueOptions} EnumValueOptions
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                EnumValueOptions.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.EnumValueOptions();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1: {
                                message.deprecated = reader.bool();
                                break;
                            }
                        case 999: {
                                if (!(message.uninterpretedOption && message.uninterpretedOption.length))
                                    message.uninterpretedOption = [];
                                message.uninterpretedOption.push($root.google.protobuf.UninterpretedOption.decode(reader, reader.uint32()));
                                break;
                            }
                        case 50500: {
                                message[".networkConnectionToken"] = reader.string();
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes an EnumValueOptions message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof google.protobuf.EnumValueOptions
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {google.protobuf.EnumValueOptions} EnumValueOptions
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                EnumValueOptions.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies an EnumValueOptions message.
                 * @function verify
                 * @memberof google.protobuf.EnumValueOptions
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                EnumValueOptions.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.deprecated != null && message.hasOwnProperty("deprecated"))
                        if (typeof message.deprecated !== "boolean")
                            return "deprecated: boolean expected";
                    if (message.uninterpretedOption != null && message.hasOwnProperty("uninterpretedOption")) {
                        if (!Array.isArray(message.uninterpretedOption))
                            return "uninterpretedOption: array expected";
                        for (var i = 0; i < message.uninterpretedOption.length; ++i) {
                            var error = $root.google.protobuf.UninterpretedOption.verify(message.uninterpretedOption[i]);
                            if (error)
                                return "uninterpretedOption." + error;
                        }
                    }
                    if (message[".networkConnectionToken"] != null && message.hasOwnProperty(".networkConnectionToken"))
                        if (!$util.isString(message[".networkConnectionToken"]))
                            return ".networkConnectionToken: string expected";
                    return null;
                };
    
                /**
                 * Creates an EnumValueOptions message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof google.protobuf.EnumValueOptions
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {google.protobuf.EnumValueOptions} EnumValueOptions
                 */
                EnumValueOptions.fromObject = function fromObject(object) {
                    if (object instanceof $root.google.protobuf.EnumValueOptions)
                        return object;
                    var message = new $root.google.protobuf.EnumValueOptions();
                    if (object.deprecated != null)
                        message.deprecated = Boolean(object.deprecated);
                    if (object.uninterpretedOption) {
                        if (!Array.isArray(object.uninterpretedOption))
                            throw TypeError(".google.protobuf.EnumValueOptions.uninterpretedOption: array expected");
                        message.uninterpretedOption = [];
                        for (var i = 0; i < object.uninterpretedOption.length; ++i) {
                            if (typeof object.uninterpretedOption[i] !== "object")
                                throw TypeError(".google.protobuf.EnumValueOptions.uninterpretedOption: object expected");
                            message.uninterpretedOption[i] = $root.google.protobuf.UninterpretedOption.fromObject(object.uninterpretedOption[i]);
                        }
                    }
                    if (object[".networkConnectionToken"] != null)
                        message[".networkConnectionToken"] = String(object[".networkConnectionToken"]);
                    return message;
                };
    
                /**
                 * Creates a plain object from an EnumValueOptions message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof google.protobuf.EnumValueOptions
                 * @static
                 * @param {google.protobuf.EnumValueOptions} message EnumValueOptions
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                EnumValueOptions.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.uninterpretedOption = [];
                    if (options.defaults) {
                        object.deprecated = false;
                        object[".networkConnectionToken"] = "";
                    }
                    if (message.deprecated != null && message.hasOwnProperty("deprecated"))
                        object.deprecated = message.deprecated;
                    if (message.uninterpretedOption && message.uninterpretedOption.length) {
                        object.uninterpretedOption = [];
                        for (var j = 0; j < message.uninterpretedOption.length; ++j)
                            object.uninterpretedOption[j] = $root.google.protobuf.UninterpretedOption.toObject(message.uninterpretedOption[j], options);
                    }
                    if (message[".networkConnectionToken"] != null && message.hasOwnProperty(".networkConnectionToken"))
                        object[".networkConnectionToken"] = message[".networkConnectionToken"];
                    return object;
                };
    
                /**
                 * Converts this EnumValueOptions to JSON.
                 * @function toJSON
                 * @memberof google.protobuf.EnumValueOptions
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                EnumValueOptions.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                /**
                 * Gets the default type url for EnumValueOptions
                 * @function getTypeUrl
                 * @memberof google.protobuf.EnumValueOptions
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                EnumValueOptions.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/google.protobuf.EnumValueOptions";
                };
    
                return EnumValueOptions;
            })();
    
            protobuf.ServiceOptions = (function() {
    
                /**
                 * Properties of a ServiceOptions.
                 * @memberof google.protobuf
                 * @interface IServiceOptions
                 * @property {boolean|null} [deprecated] ServiceOptions deprecated
                 * @property {Array.<google.protobuf.IUninterpretedOption>|null} [uninterpretedOption] ServiceOptions uninterpretedOption
                 */
    
                /**
                 * Constructs a new ServiceOptions.
                 * @memberof google.protobuf
                 * @classdesc Represents a ServiceOptions.
                 * @implements IServiceOptions
                 * @constructor
                 * @param {google.protobuf.IServiceOptions=} [properties] Properties to set
                 */
                function ServiceOptions(properties) {
                    this.uninterpretedOption = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * ServiceOptions deprecated.
                 * @member {boolean} deprecated
                 * @memberof google.protobuf.ServiceOptions
                 * @instance
                 */
                ServiceOptions.prototype.deprecated = false;
    
                /**
                 * ServiceOptions uninterpretedOption.
                 * @member {Array.<google.protobuf.IUninterpretedOption>} uninterpretedOption
                 * @memberof google.protobuf.ServiceOptions
                 * @instance
                 */
                ServiceOptions.prototype.uninterpretedOption = $util.emptyArray;
    
                /**
                 * Creates a new ServiceOptions instance using the specified properties.
                 * @function create
                 * @memberof google.protobuf.ServiceOptions
                 * @static
                 * @param {google.protobuf.IServiceOptions=} [properties] Properties to set
                 * @returns {google.protobuf.ServiceOptions} ServiceOptions instance
                 */
                ServiceOptions.create = function create(properties) {
                    return new ServiceOptions(properties);
                };
    
                /**
                 * Encodes the specified ServiceOptions message. Does not implicitly {@link google.protobuf.ServiceOptions.verify|verify} messages.
                 * @function encode
                 * @memberof google.protobuf.ServiceOptions
                 * @static
                 * @param {google.protobuf.IServiceOptions} message ServiceOptions message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ServiceOptions.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.deprecated != null && Object.hasOwnProperty.call(message, "deprecated"))
                        writer.uint32(/* id 33, wireType 0 =*/264).bool(message.deprecated);
                    if (message.uninterpretedOption != null && message.uninterpretedOption.length)
                        for (var i = 0; i < message.uninterpretedOption.length; ++i)
                            $root.google.protobuf.UninterpretedOption.encode(message.uninterpretedOption[i], writer.uint32(/* id 999, wireType 2 =*/7994).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified ServiceOptions message, length delimited. Does not implicitly {@link google.protobuf.ServiceOptions.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof google.protobuf.ServiceOptions
                 * @static
                 * @param {google.protobuf.IServiceOptions} message ServiceOptions message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ServiceOptions.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a ServiceOptions message from the specified reader or buffer.
                 * @function decode
                 * @memberof google.protobuf.ServiceOptions
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {google.protobuf.ServiceOptions} ServiceOptions
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ServiceOptions.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.ServiceOptions();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 33: {
                                message.deprecated = reader.bool();
                                break;
                            }
                        case 999: {
                                if (!(message.uninterpretedOption && message.uninterpretedOption.length))
                                    message.uninterpretedOption = [];
                                message.uninterpretedOption.push($root.google.protobuf.UninterpretedOption.decode(reader, reader.uint32()));
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a ServiceOptions message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof google.protobuf.ServiceOptions
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {google.protobuf.ServiceOptions} ServiceOptions
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ServiceOptions.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a ServiceOptions message.
                 * @function verify
                 * @memberof google.protobuf.ServiceOptions
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                ServiceOptions.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.deprecated != null && message.hasOwnProperty("deprecated"))
                        if (typeof message.deprecated !== "boolean")
                            return "deprecated: boolean expected";
                    if (message.uninterpretedOption != null && message.hasOwnProperty("uninterpretedOption")) {
                        if (!Array.isArray(message.uninterpretedOption))
                            return "uninterpretedOption: array expected";
                        for (var i = 0; i < message.uninterpretedOption.length; ++i) {
                            var error = $root.google.protobuf.UninterpretedOption.verify(message.uninterpretedOption[i]);
                            if (error)
                                return "uninterpretedOption." + error;
                        }
                    }
                    return null;
                };
    
                /**
                 * Creates a ServiceOptions message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof google.protobuf.ServiceOptions
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {google.protobuf.ServiceOptions} ServiceOptions
                 */
                ServiceOptions.fromObject = function fromObject(object) {
                    if (object instanceof $root.google.protobuf.ServiceOptions)
                        return object;
                    var message = new $root.google.protobuf.ServiceOptions();
                    if (object.deprecated != null)
                        message.deprecated = Boolean(object.deprecated);
                    if (object.uninterpretedOption) {
                        if (!Array.isArray(object.uninterpretedOption))
                            throw TypeError(".google.protobuf.ServiceOptions.uninterpretedOption: array expected");
                        message.uninterpretedOption = [];
                        for (var i = 0; i < object.uninterpretedOption.length; ++i) {
                            if (typeof object.uninterpretedOption[i] !== "object")
                                throw TypeError(".google.protobuf.ServiceOptions.uninterpretedOption: object expected");
                            message.uninterpretedOption[i] = $root.google.protobuf.UninterpretedOption.fromObject(object.uninterpretedOption[i]);
                        }
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a ServiceOptions message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof google.protobuf.ServiceOptions
                 * @static
                 * @param {google.protobuf.ServiceOptions} message ServiceOptions
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                ServiceOptions.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.uninterpretedOption = [];
                    if (options.defaults)
                        object.deprecated = false;
                    if (message.deprecated != null && message.hasOwnProperty("deprecated"))
                        object.deprecated = message.deprecated;
                    if (message.uninterpretedOption && message.uninterpretedOption.length) {
                        object.uninterpretedOption = [];
                        for (var j = 0; j < message.uninterpretedOption.length; ++j)
                            object.uninterpretedOption[j] = $root.google.protobuf.UninterpretedOption.toObject(message.uninterpretedOption[j], options);
                    }
                    return object;
                };
    
                /**
                 * Converts this ServiceOptions to JSON.
                 * @function toJSON
                 * @memberof google.protobuf.ServiceOptions
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                ServiceOptions.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                /**
                 * Gets the default type url for ServiceOptions
                 * @function getTypeUrl
                 * @memberof google.protobuf.ServiceOptions
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                ServiceOptions.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/google.protobuf.ServiceOptions";
                };
    
                return ServiceOptions;
            })();
    
            protobuf.MethodOptions = (function() {
    
                /**
                 * Properties of a MethodOptions.
                 * @memberof google.protobuf
                 * @interface IMethodOptions
                 * @property {boolean|null} [deprecated] MethodOptions deprecated
                 * @property {Array.<google.protobuf.IUninterpretedOption>|null} [uninterpretedOption] MethodOptions uninterpretedOption
                 */
    
                /**
                 * Constructs a new MethodOptions.
                 * @memberof google.protobuf
                 * @classdesc Represents a MethodOptions.
                 * @implements IMethodOptions
                 * @constructor
                 * @param {google.protobuf.IMethodOptions=} [properties] Properties to set
                 */
                function MethodOptions(properties) {
                    this.uninterpretedOption = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * MethodOptions deprecated.
                 * @member {boolean} deprecated
                 * @memberof google.protobuf.MethodOptions
                 * @instance
                 */
                MethodOptions.prototype.deprecated = false;
    
                /**
                 * MethodOptions uninterpretedOption.
                 * @member {Array.<google.protobuf.IUninterpretedOption>} uninterpretedOption
                 * @memberof google.protobuf.MethodOptions
                 * @instance
                 */
                MethodOptions.prototype.uninterpretedOption = $util.emptyArray;
    
                /**
                 * Creates a new MethodOptions instance using the specified properties.
                 * @function create
                 * @memberof google.protobuf.MethodOptions
                 * @static
                 * @param {google.protobuf.IMethodOptions=} [properties] Properties to set
                 * @returns {google.protobuf.MethodOptions} MethodOptions instance
                 */
                MethodOptions.create = function create(properties) {
                    return new MethodOptions(properties);
                };
    
                /**
                 * Encodes the specified MethodOptions message. Does not implicitly {@link google.protobuf.MethodOptions.verify|verify} messages.
                 * @function encode
                 * @memberof google.protobuf.MethodOptions
                 * @static
                 * @param {google.protobuf.IMethodOptions} message MethodOptions message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MethodOptions.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.deprecated != null && Object.hasOwnProperty.call(message, "deprecated"))
                        writer.uint32(/* id 33, wireType 0 =*/264).bool(message.deprecated);
                    if (message.uninterpretedOption != null && message.uninterpretedOption.length)
                        for (var i = 0; i < message.uninterpretedOption.length; ++i)
                            $root.google.protobuf.UninterpretedOption.encode(message.uninterpretedOption[i], writer.uint32(/* id 999, wireType 2 =*/7994).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified MethodOptions message, length delimited. Does not implicitly {@link google.protobuf.MethodOptions.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof google.protobuf.MethodOptions
                 * @static
                 * @param {google.protobuf.IMethodOptions} message MethodOptions message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MethodOptions.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a MethodOptions message from the specified reader or buffer.
                 * @function decode
                 * @memberof google.protobuf.MethodOptions
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {google.protobuf.MethodOptions} MethodOptions
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MethodOptions.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.MethodOptions();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 33: {
                                message.deprecated = reader.bool();
                                break;
                            }
                        case 999: {
                                if (!(message.uninterpretedOption && message.uninterpretedOption.length))
                                    message.uninterpretedOption = [];
                                message.uninterpretedOption.push($root.google.protobuf.UninterpretedOption.decode(reader, reader.uint32()));
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a MethodOptions message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof google.protobuf.MethodOptions
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {google.protobuf.MethodOptions} MethodOptions
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MethodOptions.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a MethodOptions message.
                 * @function verify
                 * @memberof google.protobuf.MethodOptions
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                MethodOptions.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.deprecated != null && message.hasOwnProperty("deprecated"))
                        if (typeof message.deprecated !== "boolean")
                            return "deprecated: boolean expected";
                    if (message.uninterpretedOption != null && message.hasOwnProperty("uninterpretedOption")) {
                        if (!Array.isArray(message.uninterpretedOption))
                            return "uninterpretedOption: array expected";
                        for (var i = 0; i < message.uninterpretedOption.length; ++i) {
                            var error = $root.google.protobuf.UninterpretedOption.verify(message.uninterpretedOption[i]);
                            if (error)
                                return "uninterpretedOption." + error;
                        }
                    }
                    return null;
                };
    
                /**
                 * Creates a MethodOptions message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof google.protobuf.MethodOptions
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {google.protobuf.MethodOptions} MethodOptions
                 */
                MethodOptions.fromObject = function fromObject(object) {
                    if (object instanceof $root.google.protobuf.MethodOptions)
                        return object;
                    var message = new $root.google.protobuf.MethodOptions();
                    if (object.deprecated != null)
                        message.deprecated = Boolean(object.deprecated);
                    if (object.uninterpretedOption) {
                        if (!Array.isArray(object.uninterpretedOption))
                            throw TypeError(".google.protobuf.MethodOptions.uninterpretedOption: array expected");
                        message.uninterpretedOption = [];
                        for (var i = 0; i < object.uninterpretedOption.length; ++i) {
                            if (typeof object.uninterpretedOption[i] !== "object")
                                throw TypeError(".google.protobuf.MethodOptions.uninterpretedOption: object expected");
                            message.uninterpretedOption[i] = $root.google.protobuf.UninterpretedOption.fromObject(object.uninterpretedOption[i]);
                        }
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a MethodOptions message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof google.protobuf.MethodOptions
                 * @static
                 * @param {google.protobuf.MethodOptions} message MethodOptions
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                MethodOptions.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.uninterpretedOption = [];
                    if (options.defaults)
                        object.deprecated = false;
                    if (message.deprecated != null && message.hasOwnProperty("deprecated"))
                        object.deprecated = message.deprecated;
                    if (message.uninterpretedOption && message.uninterpretedOption.length) {
                        object.uninterpretedOption = [];
                        for (var j = 0; j < message.uninterpretedOption.length; ++j)
                            object.uninterpretedOption[j] = $root.google.protobuf.UninterpretedOption.toObject(message.uninterpretedOption[j], options);
                    }
                    return object;
                };
    
                /**
                 * Converts this MethodOptions to JSON.
                 * @function toJSON
                 * @memberof google.protobuf.MethodOptions
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                MethodOptions.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                /**
                 * Gets the default type url for MethodOptions
                 * @function getTypeUrl
                 * @memberof google.protobuf.MethodOptions
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                MethodOptions.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/google.protobuf.MethodOptions";
                };
    
                return MethodOptions;
            })();
    
            protobuf.UninterpretedOption = (function() {
    
                /**
                 * Properties of an UninterpretedOption.
                 * @memberof google.protobuf
                 * @interface IUninterpretedOption
                 * @property {Array.<google.protobuf.UninterpretedOption.INamePart>|null} [name] UninterpretedOption name
                 * @property {string|null} [identifierValue] UninterpretedOption identifierValue
                 * @property {number|Long|null} [positiveIntValue] UninterpretedOption positiveIntValue
                 * @property {number|Long|null} [negativeIntValue] UninterpretedOption negativeIntValue
                 * @property {number|null} [doubleValue] UninterpretedOption doubleValue
                 * @property {Uint8Array|null} [stringValue] UninterpretedOption stringValue
                 * @property {string|null} [aggregateValue] UninterpretedOption aggregateValue
                 */
    
                /**
                 * Constructs a new UninterpretedOption.
                 * @memberof google.protobuf
                 * @classdesc Represents an UninterpretedOption.
                 * @implements IUninterpretedOption
                 * @constructor
                 * @param {google.protobuf.IUninterpretedOption=} [properties] Properties to set
                 */
                function UninterpretedOption(properties) {
                    this.name = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * UninterpretedOption name.
                 * @member {Array.<google.protobuf.UninterpretedOption.INamePart>} name
                 * @memberof google.protobuf.UninterpretedOption
                 * @instance
                 */
                UninterpretedOption.prototype.name = $util.emptyArray;
    
                /**
                 * UninterpretedOption identifierValue.
                 * @member {string} identifierValue
                 * @memberof google.protobuf.UninterpretedOption
                 * @instance
                 */
                UninterpretedOption.prototype.identifierValue = "";
    
                /**
                 * UninterpretedOption positiveIntValue.
                 * @member {number|Long} positiveIntValue
                 * @memberof google.protobuf.UninterpretedOption
                 * @instance
                 */
                UninterpretedOption.prototype.positiveIntValue = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
                /**
                 * UninterpretedOption negativeIntValue.
                 * @member {number|Long} negativeIntValue
                 * @memberof google.protobuf.UninterpretedOption
                 * @instance
                 */
                UninterpretedOption.prototype.negativeIntValue = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
                /**
                 * UninterpretedOption doubleValue.
                 * @member {number} doubleValue
                 * @memberof google.protobuf.UninterpretedOption
                 * @instance
                 */
                UninterpretedOption.prototype.doubleValue = 0;
    
                /**
                 * UninterpretedOption stringValue.
                 * @member {Uint8Array} stringValue
                 * @memberof google.protobuf.UninterpretedOption
                 * @instance
                 */
                UninterpretedOption.prototype.stringValue = $util.newBuffer([]);
    
                /**
                 * UninterpretedOption aggregateValue.
                 * @member {string} aggregateValue
                 * @memberof google.protobuf.UninterpretedOption
                 * @instance
                 */
                UninterpretedOption.prototype.aggregateValue = "";
    
                /**
                 * Creates a new UninterpretedOption instance using the specified properties.
                 * @function create
                 * @memberof google.protobuf.UninterpretedOption
                 * @static
                 * @param {google.protobuf.IUninterpretedOption=} [properties] Properties to set
                 * @returns {google.protobuf.UninterpretedOption} UninterpretedOption instance
                 */
                UninterpretedOption.create = function create(properties) {
                    return new UninterpretedOption(properties);
                };
    
                /**
                 * Encodes the specified UninterpretedOption message. Does not implicitly {@link google.protobuf.UninterpretedOption.verify|verify} messages.
                 * @function encode
                 * @memberof google.protobuf.UninterpretedOption
                 * @static
                 * @param {google.protobuf.IUninterpretedOption} message UninterpretedOption message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                UninterpretedOption.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.name != null && message.name.length)
                        for (var i = 0; i < message.name.length; ++i)
                            $root.google.protobuf.UninterpretedOption.NamePart.encode(message.name[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    if (message.identifierValue != null && Object.hasOwnProperty.call(message, "identifierValue"))
                        writer.uint32(/* id 3, wireType 2 =*/26).string(message.identifierValue);
                    if (message.positiveIntValue != null && Object.hasOwnProperty.call(message, "positiveIntValue"))
                        writer.uint32(/* id 4, wireType 0 =*/32).uint64(message.positiveIntValue);
                    if (message.negativeIntValue != null && Object.hasOwnProperty.call(message, "negativeIntValue"))
                        writer.uint32(/* id 5, wireType 0 =*/40).int64(message.negativeIntValue);
                    if (message.doubleValue != null && Object.hasOwnProperty.call(message, "doubleValue"))
                        writer.uint32(/* id 6, wireType 1 =*/49).double(message.doubleValue);
                    if (message.stringValue != null && Object.hasOwnProperty.call(message, "stringValue"))
                        writer.uint32(/* id 7, wireType 2 =*/58).bytes(message.stringValue);
                    if (message.aggregateValue != null && Object.hasOwnProperty.call(message, "aggregateValue"))
                        writer.uint32(/* id 8, wireType 2 =*/66).string(message.aggregateValue);
                    return writer;
                };
    
                /**
                 * Encodes the specified UninterpretedOption message, length delimited. Does not implicitly {@link google.protobuf.UninterpretedOption.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof google.protobuf.UninterpretedOption
                 * @static
                 * @param {google.protobuf.IUninterpretedOption} message UninterpretedOption message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                UninterpretedOption.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes an UninterpretedOption message from the specified reader or buffer.
                 * @function decode
                 * @memberof google.protobuf.UninterpretedOption
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {google.protobuf.UninterpretedOption} UninterpretedOption
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                UninterpretedOption.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.UninterpretedOption();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 2: {
                                if (!(message.name && message.name.length))
                                    message.name = [];
                                message.name.push($root.google.protobuf.UninterpretedOption.NamePart.decode(reader, reader.uint32()));
                                break;
                            }
                        case 3: {
                                message.identifierValue = reader.string();
                                break;
                            }
                        case 4: {
                                message.positiveIntValue = reader.uint64();
                                break;
                            }
                        case 5: {
                                message.negativeIntValue = reader.int64();
                                break;
                            }
                        case 6: {
                                message.doubleValue = reader.double();
                                break;
                            }
                        case 7: {
                                message.stringValue = reader.bytes();
                                break;
                            }
                        case 8: {
                                message.aggregateValue = reader.string();
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes an UninterpretedOption message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof google.protobuf.UninterpretedOption
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {google.protobuf.UninterpretedOption} UninterpretedOption
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                UninterpretedOption.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies an UninterpretedOption message.
                 * @function verify
                 * @memberof google.protobuf.UninterpretedOption
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                UninterpretedOption.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.name != null && message.hasOwnProperty("name")) {
                        if (!Array.isArray(message.name))
                            return "name: array expected";
                        for (var i = 0; i < message.name.length; ++i) {
                            var error = $root.google.protobuf.UninterpretedOption.NamePart.verify(message.name[i]);
                            if (error)
                                return "name." + error;
                        }
                    }
                    if (message.identifierValue != null && message.hasOwnProperty("identifierValue"))
                        if (!$util.isString(message.identifierValue))
                            return "identifierValue: string expected";
                    if (message.positiveIntValue != null && message.hasOwnProperty("positiveIntValue"))
                        if (!$util.isInteger(message.positiveIntValue) && !(message.positiveIntValue && $util.isInteger(message.positiveIntValue.low) && $util.isInteger(message.positiveIntValue.high)))
                            return "positiveIntValue: integer|Long expected";
                    if (message.negativeIntValue != null && message.hasOwnProperty("negativeIntValue"))
                        if (!$util.isInteger(message.negativeIntValue) && !(message.negativeIntValue && $util.isInteger(message.negativeIntValue.low) && $util.isInteger(message.negativeIntValue.high)))
                            return "negativeIntValue: integer|Long expected";
                    if (message.doubleValue != null && message.hasOwnProperty("doubleValue"))
                        if (typeof message.doubleValue !== "number")
                            return "doubleValue: number expected";
                    if (message.stringValue != null && message.hasOwnProperty("stringValue"))
                        if (!(message.stringValue && typeof message.stringValue.length === "number" || $util.isString(message.stringValue)))
                            return "stringValue: buffer expected";
                    if (message.aggregateValue != null && message.hasOwnProperty("aggregateValue"))
                        if (!$util.isString(message.aggregateValue))
                            return "aggregateValue: string expected";
                    return null;
                };
    
                /**
                 * Creates an UninterpretedOption message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof google.protobuf.UninterpretedOption
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {google.protobuf.UninterpretedOption} UninterpretedOption
                 */
                UninterpretedOption.fromObject = function fromObject(object) {
                    if (object instanceof $root.google.protobuf.UninterpretedOption)
                        return object;
                    var message = new $root.google.protobuf.UninterpretedOption();
                    if (object.name) {
                        if (!Array.isArray(object.name))
                            throw TypeError(".google.protobuf.UninterpretedOption.name: array expected");
                        message.name = [];
                        for (var i = 0; i < object.name.length; ++i) {
                            if (typeof object.name[i] !== "object")
                                throw TypeError(".google.protobuf.UninterpretedOption.name: object expected");
                            message.name[i] = $root.google.protobuf.UninterpretedOption.NamePart.fromObject(object.name[i]);
                        }
                    }
                    if (object.identifierValue != null)
                        message.identifierValue = String(object.identifierValue);
                    if (object.positiveIntValue != null)
                        if ($util.Long)
                            (message.positiveIntValue = $util.Long.fromValue(object.positiveIntValue)).unsigned = true;
                        else if (typeof object.positiveIntValue === "string")
                            message.positiveIntValue = parseInt(object.positiveIntValue, 10);
                        else if (typeof object.positiveIntValue === "number")
                            message.positiveIntValue = object.positiveIntValue;
                        else if (typeof object.positiveIntValue === "object")
                            message.positiveIntValue = new $util.LongBits(object.positiveIntValue.low >>> 0, object.positiveIntValue.high >>> 0).toNumber(true);
                    if (object.negativeIntValue != null)
                        if ($util.Long)
                            (message.negativeIntValue = $util.Long.fromValue(object.negativeIntValue)).unsigned = false;
                        else if (typeof object.negativeIntValue === "string")
                            message.negativeIntValue = parseInt(object.negativeIntValue, 10);
                        else if (typeof object.negativeIntValue === "number")
                            message.negativeIntValue = object.negativeIntValue;
                        else if (typeof object.negativeIntValue === "object")
                            message.negativeIntValue = new $util.LongBits(object.negativeIntValue.low >>> 0, object.negativeIntValue.high >>> 0).toNumber();
                    if (object.doubleValue != null)
                        message.doubleValue = Number(object.doubleValue);
                    if (object.stringValue != null)
                        if (typeof object.stringValue === "string")
                            $util.base64.decode(object.stringValue, message.stringValue = $util.newBuffer($util.base64.length(object.stringValue)), 0);
                        else if (object.stringValue.length >= 0)
                            message.stringValue = object.stringValue;
                    if (object.aggregateValue != null)
                        message.aggregateValue = String(object.aggregateValue);
                    return message;
                };
    
                /**
                 * Creates a plain object from an UninterpretedOption message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof google.protobuf.UninterpretedOption
                 * @static
                 * @param {google.protobuf.UninterpretedOption} message UninterpretedOption
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                UninterpretedOption.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.name = [];
                    if (options.defaults) {
                        object.identifierValue = "";
                        if ($util.Long) {
                            var long = new $util.Long(0, 0, true);
                            object.positiveIntValue = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.positiveIntValue = options.longs === String ? "0" : 0;
                        if ($util.Long) {
                            var long = new $util.Long(0, 0, false);
                            object.negativeIntValue = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.negativeIntValue = options.longs === String ? "0" : 0;
                        object.doubleValue = 0;
                        if (options.bytes === String)
                            object.stringValue = "";
                        else {
                            object.stringValue = [];
                            if (options.bytes !== Array)
                                object.stringValue = $util.newBuffer(object.stringValue);
                        }
                        object.aggregateValue = "";
                    }
                    if (message.name && message.name.length) {
                        object.name = [];
                        for (var j = 0; j < message.name.length; ++j)
                            object.name[j] = $root.google.protobuf.UninterpretedOption.NamePart.toObject(message.name[j], options);
                    }
                    if (message.identifierValue != null && message.hasOwnProperty("identifierValue"))
                        object.identifierValue = message.identifierValue;
                    if (message.positiveIntValue != null && message.hasOwnProperty("positiveIntValue"))
                        if (typeof message.positiveIntValue === "number")
                            object.positiveIntValue = options.longs === String ? String(message.positiveIntValue) : message.positiveIntValue;
                        else
                            object.positiveIntValue = options.longs === String ? $util.Long.prototype.toString.call(message.positiveIntValue) : options.longs === Number ? new $util.LongBits(message.positiveIntValue.low >>> 0, message.positiveIntValue.high >>> 0).toNumber(true) : message.positiveIntValue;
                    if (message.negativeIntValue != null && message.hasOwnProperty("negativeIntValue"))
                        if (typeof message.negativeIntValue === "number")
                            object.negativeIntValue = options.longs === String ? String(message.negativeIntValue) : message.negativeIntValue;
                        else
                            object.negativeIntValue = options.longs === String ? $util.Long.prototype.toString.call(message.negativeIntValue) : options.longs === Number ? new $util.LongBits(message.negativeIntValue.low >>> 0, message.negativeIntValue.high >>> 0).toNumber() : message.negativeIntValue;
                    if (message.doubleValue != null && message.hasOwnProperty("doubleValue"))
                        object.doubleValue = options.json && !isFinite(message.doubleValue) ? String(message.doubleValue) : message.doubleValue;
                    if (message.stringValue != null && message.hasOwnProperty("stringValue"))
                        object.stringValue = options.bytes === String ? $util.base64.encode(message.stringValue, 0, message.stringValue.length) : options.bytes === Array ? Array.prototype.slice.call(message.stringValue) : message.stringValue;
                    if (message.aggregateValue != null && message.hasOwnProperty("aggregateValue"))
                        object.aggregateValue = message.aggregateValue;
                    return object;
                };
    
                /**
                 * Converts this UninterpretedOption to JSON.
                 * @function toJSON
                 * @memberof google.protobuf.UninterpretedOption
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                UninterpretedOption.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                /**
                 * Gets the default type url for UninterpretedOption
                 * @function getTypeUrl
                 * @memberof google.protobuf.UninterpretedOption
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                UninterpretedOption.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/google.protobuf.UninterpretedOption";
                };
    
                UninterpretedOption.NamePart = (function() {
    
                    /**
                     * Properties of a NamePart.
                     * @memberof google.protobuf.UninterpretedOption
                     * @interface INamePart
                     * @property {string} namePart NamePart namePart
                     * @property {boolean} isExtension NamePart isExtension
                     */
    
                    /**
                     * Constructs a new NamePart.
                     * @memberof google.protobuf.UninterpretedOption
                     * @classdesc Represents a NamePart.
                     * @implements INamePart
                     * @constructor
                     * @param {google.protobuf.UninterpretedOption.INamePart=} [properties] Properties to set
                     */
                    function NamePart(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * NamePart namePart.
                     * @member {string} namePart
                     * @memberof google.protobuf.UninterpretedOption.NamePart
                     * @instance
                     */
                    NamePart.prototype.namePart = "";
    
                    /**
                     * NamePart isExtension.
                     * @member {boolean} isExtension
                     * @memberof google.protobuf.UninterpretedOption.NamePart
                     * @instance
                     */
                    NamePart.prototype.isExtension = false;
    
                    /**
                     * Creates a new NamePart instance using the specified properties.
                     * @function create
                     * @memberof google.protobuf.UninterpretedOption.NamePart
                     * @static
                     * @param {google.protobuf.UninterpretedOption.INamePart=} [properties] Properties to set
                     * @returns {google.protobuf.UninterpretedOption.NamePart} NamePart instance
                     */
                    NamePart.create = function create(properties) {
                        return new NamePart(properties);
                    };
    
                    /**
                     * Encodes the specified NamePart message. Does not implicitly {@link google.protobuf.UninterpretedOption.NamePart.verify|verify} messages.
                     * @function encode
                     * @memberof google.protobuf.UninterpretedOption.NamePart
                     * @static
                     * @param {google.protobuf.UninterpretedOption.INamePart} message NamePart message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    NamePart.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.namePart);
                        writer.uint32(/* id 2, wireType 0 =*/16).bool(message.isExtension);
                        return writer;
                    };
    
                    /**
                     * Encodes the specified NamePart message, length delimited. Does not implicitly {@link google.protobuf.UninterpretedOption.NamePart.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof google.protobuf.UninterpretedOption.NamePart
                     * @static
                     * @param {google.protobuf.UninterpretedOption.INamePart} message NamePart message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    NamePart.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };
    
                    /**
                     * Decodes a NamePart message from the specified reader or buffer.
                     * @function decode
                     * @memberof google.protobuf.UninterpretedOption.NamePart
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {google.protobuf.UninterpretedOption.NamePart} NamePart
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    NamePart.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.UninterpretedOption.NamePart();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1: {
                                    message.namePart = reader.string();
                                    break;
                                }
                            case 2: {
                                    message.isExtension = reader.bool();
                                    break;
                                }
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        if (!message.hasOwnProperty("namePart"))
                            throw $util.ProtocolError("missing required 'namePart'", { instance: message });
                        if (!message.hasOwnProperty("isExtension"))
                            throw $util.ProtocolError("missing required 'isExtension'", { instance: message });
                        return message;
                    };
    
                    /**
                     * Decodes a NamePart message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof google.protobuf.UninterpretedOption.NamePart
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {google.protobuf.UninterpretedOption.NamePart} NamePart
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    NamePart.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };
    
                    /**
                     * Verifies a NamePart message.
                     * @function verify
                     * @memberof google.protobuf.UninterpretedOption.NamePart
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    NamePart.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (!$util.isString(message.namePart))
                            return "namePart: string expected";
                        if (typeof message.isExtension !== "boolean")
                            return "isExtension: boolean expected";
                        return null;
                    };
    
                    /**
                     * Creates a NamePart message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof google.protobuf.UninterpretedOption.NamePart
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {google.protobuf.UninterpretedOption.NamePart} NamePart
                     */
                    NamePart.fromObject = function fromObject(object) {
                        if (object instanceof $root.google.protobuf.UninterpretedOption.NamePart)
                            return object;
                        var message = new $root.google.protobuf.UninterpretedOption.NamePart();
                        if (object.namePart != null)
                            message.namePart = String(object.namePart);
                        if (object.isExtension != null)
                            message.isExtension = Boolean(object.isExtension);
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a NamePart message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof google.protobuf.UninterpretedOption.NamePart
                     * @static
                     * @param {google.protobuf.UninterpretedOption.NamePart} message NamePart
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    NamePart.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            object.namePart = "";
                            object.isExtension = false;
                        }
                        if (message.namePart != null && message.hasOwnProperty("namePart"))
                            object.namePart = message.namePart;
                        if (message.isExtension != null && message.hasOwnProperty("isExtension"))
                            object.isExtension = message.isExtension;
                        return object;
                    };
    
                    /**
                     * Converts this NamePart to JSON.
                     * @function toJSON
                     * @memberof google.protobuf.UninterpretedOption.NamePart
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    NamePart.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    /**
                     * Gets the default type url for NamePart
                     * @function getTypeUrl
                     * @memberof google.protobuf.UninterpretedOption.NamePart
                     * @static
                     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                     * @returns {string} The default type url
                     */
                    NamePart.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                        if (typeUrlPrefix === undefined) {
                            typeUrlPrefix = "type.googleapis.com";
                        }
                        return typeUrlPrefix + "/google.protobuf.UninterpretedOption.NamePart";
                    };
    
                    return NamePart;
                })();
    
                return UninterpretedOption;
            })();
    
            protobuf.SourceCodeInfo = (function() {
    
                /**
                 * Properties of a SourceCodeInfo.
                 * @memberof google.protobuf
                 * @interface ISourceCodeInfo
                 * @property {Array.<google.protobuf.SourceCodeInfo.ILocation>|null} [location] SourceCodeInfo location
                 */
    
                /**
                 * Constructs a new SourceCodeInfo.
                 * @memberof google.protobuf
                 * @classdesc Represents a SourceCodeInfo.
                 * @implements ISourceCodeInfo
                 * @constructor
                 * @param {google.protobuf.ISourceCodeInfo=} [properties] Properties to set
                 */
                function SourceCodeInfo(properties) {
                    this.location = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * SourceCodeInfo location.
                 * @member {Array.<google.protobuf.SourceCodeInfo.ILocation>} location
                 * @memberof google.protobuf.SourceCodeInfo
                 * @instance
                 */
                SourceCodeInfo.prototype.location = $util.emptyArray;
    
                /**
                 * Creates a new SourceCodeInfo instance using the specified properties.
                 * @function create
                 * @memberof google.protobuf.SourceCodeInfo
                 * @static
                 * @param {google.protobuf.ISourceCodeInfo=} [properties] Properties to set
                 * @returns {google.protobuf.SourceCodeInfo} SourceCodeInfo instance
                 */
                SourceCodeInfo.create = function create(properties) {
                    return new SourceCodeInfo(properties);
                };
    
                /**
                 * Encodes the specified SourceCodeInfo message. Does not implicitly {@link google.protobuf.SourceCodeInfo.verify|verify} messages.
                 * @function encode
                 * @memberof google.protobuf.SourceCodeInfo
                 * @static
                 * @param {google.protobuf.ISourceCodeInfo} message SourceCodeInfo message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                SourceCodeInfo.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.location != null && message.location.length)
                        for (var i = 0; i < message.location.length; ++i)
                            $root.google.protobuf.SourceCodeInfo.Location.encode(message.location[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified SourceCodeInfo message, length delimited. Does not implicitly {@link google.protobuf.SourceCodeInfo.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof google.protobuf.SourceCodeInfo
                 * @static
                 * @param {google.protobuf.ISourceCodeInfo} message SourceCodeInfo message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                SourceCodeInfo.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a SourceCodeInfo message from the specified reader or buffer.
                 * @function decode
                 * @memberof google.protobuf.SourceCodeInfo
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {google.protobuf.SourceCodeInfo} SourceCodeInfo
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                SourceCodeInfo.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.SourceCodeInfo();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1: {
                                if (!(message.location && message.location.length))
                                    message.location = [];
                                message.location.push($root.google.protobuf.SourceCodeInfo.Location.decode(reader, reader.uint32()));
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a SourceCodeInfo message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof google.protobuf.SourceCodeInfo
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {google.protobuf.SourceCodeInfo} SourceCodeInfo
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                SourceCodeInfo.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a SourceCodeInfo message.
                 * @function verify
                 * @memberof google.protobuf.SourceCodeInfo
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                SourceCodeInfo.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.location != null && message.hasOwnProperty("location")) {
                        if (!Array.isArray(message.location))
                            return "location: array expected";
                        for (var i = 0; i < message.location.length; ++i) {
                            var error = $root.google.protobuf.SourceCodeInfo.Location.verify(message.location[i]);
                            if (error)
                                return "location." + error;
                        }
                    }
                    return null;
                };
    
                /**
                 * Creates a SourceCodeInfo message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof google.protobuf.SourceCodeInfo
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {google.protobuf.SourceCodeInfo} SourceCodeInfo
                 */
                SourceCodeInfo.fromObject = function fromObject(object) {
                    if (object instanceof $root.google.protobuf.SourceCodeInfo)
                        return object;
                    var message = new $root.google.protobuf.SourceCodeInfo();
                    if (object.location) {
                        if (!Array.isArray(object.location))
                            throw TypeError(".google.protobuf.SourceCodeInfo.location: array expected");
                        message.location = [];
                        for (var i = 0; i < object.location.length; ++i) {
                            if (typeof object.location[i] !== "object")
                                throw TypeError(".google.protobuf.SourceCodeInfo.location: object expected");
                            message.location[i] = $root.google.protobuf.SourceCodeInfo.Location.fromObject(object.location[i]);
                        }
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a SourceCodeInfo message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof google.protobuf.SourceCodeInfo
                 * @static
                 * @param {google.protobuf.SourceCodeInfo} message SourceCodeInfo
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                SourceCodeInfo.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.location = [];
                    if (message.location && message.location.length) {
                        object.location = [];
                        for (var j = 0; j < message.location.length; ++j)
                            object.location[j] = $root.google.protobuf.SourceCodeInfo.Location.toObject(message.location[j], options);
                    }
                    return object;
                };
    
                /**
                 * Converts this SourceCodeInfo to JSON.
                 * @function toJSON
                 * @memberof google.protobuf.SourceCodeInfo
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                SourceCodeInfo.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                /**
                 * Gets the default type url for SourceCodeInfo
                 * @function getTypeUrl
                 * @memberof google.protobuf.SourceCodeInfo
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                SourceCodeInfo.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/google.protobuf.SourceCodeInfo";
                };
    
                SourceCodeInfo.Location = (function() {
    
                    /**
                     * Properties of a Location.
                     * @memberof google.protobuf.SourceCodeInfo
                     * @interface ILocation
                     * @property {Array.<number>|null} [path] Location path
                     * @property {Array.<number>|null} [span] Location span
                     * @property {string|null} [leadingComments] Location leadingComments
                     * @property {string|null} [trailingComments] Location trailingComments
                     * @property {Array.<string>|null} [leadingDetachedComments] Location leadingDetachedComments
                     */
    
                    /**
                     * Constructs a new Location.
                     * @memberof google.protobuf.SourceCodeInfo
                     * @classdesc Represents a Location.
                     * @implements ILocation
                     * @constructor
                     * @param {google.protobuf.SourceCodeInfo.ILocation=} [properties] Properties to set
                     */
                    function Location(properties) {
                        this.path = [];
                        this.span = [];
                        this.leadingDetachedComments = [];
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * Location path.
                     * @member {Array.<number>} path
                     * @memberof google.protobuf.SourceCodeInfo.Location
                     * @instance
                     */
                    Location.prototype.path = $util.emptyArray;
    
                    /**
                     * Location span.
                     * @member {Array.<number>} span
                     * @memberof google.protobuf.SourceCodeInfo.Location
                     * @instance
                     */
                    Location.prototype.span = $util.emptyArray;
    
                    /**
                     * Location leadingComments.
                     * @member {string} leadingComments
                     * @memberof google.protobuf.SourceCodeInfo.Location
                     * @instance
                     */
                    Location.prototype.leadingComments = "";
    
                    /**
                     * Location trailingComments.
                     * @member {string} trailingComments
                     * @memberof google.protobuf.SourceCodeInfo.Location
                     * @instance
                     */
                    Location.prototype.trailingComments = "";
    
                    /**
                     * Location leadingDetachedComments.
                     * @member {Array.<string>} leadingDetachedComments
                     * @memberof google.protobuf.SourceCodeInfo.Location
                     * @instance
                     */
                    Location.prototype.leadingDetachedComments = $util.emptyArray;
    
                    /**
                     * Creates a new Location instance using the specified properties.
                     * @function create
                     * @memberof google.protobuf.SourceCodeInfo.Location
                     * @static
                     * @param {google.protobuf.SourceCodeInfo.ILocation=} [properties] Properties to set
                     * @returns {google.protobuf.SourceCodeInfo.Location} Location instance
                     */
                    Location.create = function create(properties) {
                        return new Location(properties);
                    };
    
                    /**
                     * Encodes the specified Location message. Does not implicitly {@link google.protobuf.SourceCodeInfo.Location.verify|verify} messages.
                     * @function encode
                     * @memberof google.protobuf.SourceCodeInfo.Location
                     * @static
                     * @param {google.protobuf.SourceCodeInfo.ILocation} message Location message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Location.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.path != null && message.path.length) {
                            writer.uint32(/* id 1, wireType 2 =*/10).fork();
                            for (var i = 0; i < message.path.length; ++i)
                                writer.int32(message.path[i]);
                            writer.ldelim();
                        }
                        if (message.span != null && message.span.length) {
                            writer.uint32(/* id 2, wireType 2 =*/18).fork();
                            for (var i = 0; i < message.span.length; ++i)
                                writer.int32(message.span[i]);
                            writer.ldelim();
                        }
                        if (message.leadingComments != null && Object.hasOwnProperty.call(message, "leadingComments"))
                            writer.uint32(/* id 3, wireType 2 =*/26).string(message.leadingComments);
                        if (message.trailingComments != null && Object.hasOwnProperty.call(message, "trailingComments"))
                            writer.uint32(/* id 4, wireType 2 =*/34).string(message.trailingComments);
                        if (message.leadingDetachedComments != null && message.leadingDetachedComments.length)
                            for (var i = 0; i < message.leadingDetachedComments.length; ++i)
                                writer.uint32(/* id 6, wireType 2 =*/50).string(message.leadingDetachedComments[i]);
                        return writer;
                    };
    
                    /**
                     * Encodes the specified Location message, length delimited. Does not implicitly {@link google.protobuf.SourceCodeInfo.Location.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof google.protobuf.SourceCodeInfo.Location
                     * @static
                     * @param {google.protobuf.SourceCodeInfo.ILocation} message Location message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Location.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };
    
                    /**
                     * Decodes a Location message from the specified reader or buffer.
                     * @function decode
                     * @memberof google.protobuf.SourceCodeInfo.Location
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {google.protobuf.SourceCodeInfo.Location} Location
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Location.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.SourceCodeInfo.Location();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1: {
                                    if (!(message.path && message.path.length))
                                        message.path = [];
                                    if ((tag & 7) === 2) {
                                        var end2 = reader.uint32() + reader.pos;
                                        while (reader.pos < end2)
                                            message.path.push(reader.int32());
                                    } else
                                        message.path.push(reader.int32());
                                    break;
                                }
                            case 2: {
                                    if (!(message.span && message.span.length))
                                        message.span = [];
                                    if ((tag & 7) === 2) {
                                        var end2 = reader.uint32() + reader.pos;
                                        while (reader.pos < end2)
                                            message.span.push(reader.int32());
                                    } else
                                        message.span.push(reader.int32());
                                    break;
                                }
                            case 3: {
                                    message.leadingComments = reader.string();
                                    break;
                                }
                            case 4: {
                                    message.trailingComments = reader.string();
                                    break;
                                }
                            case 6: {
                                    if (!(message.leadingDetachedComments && message.leadingDetachedComments.length))
                                        message.leadingDetachedComments = [];
                                    message.leadingDetachedComments.push(reader.string());
                                    break;
                                }
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Decodes a Location message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof google.protobuf.SourceCodeInfo.Location
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {google.protobuf.SourceCodeInfo.Location} Location
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Location.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };
    
                    /**
                     * Verifies a Location message.
                     * @function verify
                     * @memberof google.protobuf.SourceCodeInfo.Location
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    Location.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.path != null && message.hasOwnProperty("path")) {
                            if (!Array.isArray(message.path))
                                return "path: array expected";
                            for (var i = 0; i < message.path.length; ++i)
                                if (!$util.isInteger(message.path[i]))
                                    return "path: integer[] expected";
                        }
                        if (message.span != null && message.hasOwnProperty("span")) {
                            if (!Array.isArray(message.span))
                                return "span: array expected";
                            for (var i = 0; i < message.span.length; ++i)
                                if (!$util.isInteger(message.span[i]))
                                    return "span: integer[] expected";
                        }
                        if (message.leadingComments != null && message.hasOwnProperty("leadingComments"))
                            if (!$util.isString(message.leadingComments))
                                return "leadingComments: string expected";
                        if (message.trailingComments != null && message.hasOwnProperty("trailingComments"))
                            if (!$util.isString(message.trailingComments))
                                return "trailingComments: string expected";
                        if (message.leadingDetachedComments != null && message.hasOwnProperty("leadingDetachedComments")) {
                            if (!Array.isArray(message.leadingDetachedComments))
                                return "leadingDetachedComments: array expected";
                            for (var i = 0; i < message.leadingDetachedComments.length; ++i)
                                if (!$util.isString(message.leadingDetachedComments[i]))
                                    return "leadingDetachedComments: string[] expected";
                        }
                        return null;
                    };
    
                    /**
                     * Creates a Location message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof google.protobuf.SourceCodeInfo.Location
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {google.protobuf.SourceCodeInfo.Location} Location
                     */
                    Location.fromObject = function fromObject(object) {
                        if (object instanceof $root.google.protobuf.SourceCodeInfo.Location)
                            return object;
                        var message = new $root.google.protobuf.SourceCodeInfo.Location();
                        if (object.path) {
                            if (!Array.isArray(object.path))
                                throw TypeError(".google.protobuf.SourceCodeInfo.Location.path: array expected");
                            message.path = [];
                            for (var i = 0; i < object.path.length; ++i)
                                message.path[i] = object.path[i] | 0;
                        }
                        if (object.span) {
                            if (!Array.isArray(object.span))
                                throw TypeError(".google.protobuf.SourceCodeInfo.Location.span: array expected");
                            message.span = [];
                            for (var i = 0; i < object.span.length; ++i)
                                message.span[i] = object.span[i] | 0;
                        }
                        if (object.leadingComments != null)
                            message.leadingComments = String(object.leadingComments);
                        if (object.trailingComments != null)
                            message.trailingComments = String(object.trailingComments);
                        if (object.leadingDetachedComments) {
                            if (!Array.isArray(object.leadingDetachedComments))
                                throw TypeError(".google.protobuf.SourceCodeInfo.Location.leadingDetachedComments: array expected");
                            message.leadingDetachedComments = [];
                            for (var i = 0; i < object.leadingDetachedComments.length; ++i)
                                message.leadingDetachedComments[i] = String(object.leadingDetachedComments[i]);
                        }
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a Location message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof google.protobuf.SourceCodeInfo.Location
                     * @static
                     * @param {google.protobuf.SourceCodeInfo.Location} message Location
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    Location.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.arrays || options.defaults) {
                            object.path = [];
                            object.span = [];
                            object.leadingDetachedComments = [];
                        }
                        if (options.defaults) {
                            object.leadingComments = "";
                            object.trailingComments = "";
                        }
                        if (message.path && message.path.length) {
                            object.path = [];
                            for (var j = 0; j < message.path.length; ++j)
                                object.path[j] = message.path[j];
                        }
                        if (message.span && message.span.length) {
                            object.span = [];
                            for (var j = 0; j < message.span.length; ++j)
                                object.span[j] = message.span[j];
                        }
                        if (message.leadingComments != null && message.hasOwnProperty("leadingComments"))
                            object.leadingComments = message.leadingComments;
                        if (message.trailingComments != null && message.hasOwnProperty("trailingComments"))
                            object.trailingComments = message.trailingComments;
                        if (message.leadingDetachedComments && message.leadingDetachedComments.length) {
                            object.leadingDetachedComments = [];
                            for (var j = 0; j < message.leadingDetachedComments.length; ++j)
                                object.leadingDetachedComments[j] = message.leadingDetachedComments[j];
                        }
                        return object;
                    };
    
                    /**
                     * Converts this Location to JSON.
                     * @function toJSON
                     * @memberof google.protobuf.SourceCodeInfo.Location
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    Location.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    /**
                     * Gets the default type url for Location
                     * @function getTypeUrl
                     * @memberof google.protobuf.SourceCodeInfo.Location
                     * @static
                     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                     * @returns {string} The default type url
                     */
                    Location.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                        if (typeUrlPrefix === undefined) {
                            typeUrlPrefix = "type.googleapis.com";
                        }
                        return typeUrlPrefix + "/google.protobuf.SourceCodeInfo.Location";
                    };
    
                    return Location;
                })();
    
                return SourceCodeInfo;
            })();
    
            protobuf.GeneratedCodeInfo = (function() {
    
                /**
                 * Properties of a GeneratedCodeInfo.
                 * @memberof google.protobuf
                 * @interface IGeneratedCodeInfo
                 * @property {Array.<google.protobuf.GeneratedCodeInfo.IAnnotation>|null} [annotation] GeneratedCodeInfo annotation
                 */
    
                /**
                 * Constructs a new GeneratedCodeInfo.
                 * @memberof google.protobuf
                 * @classdesc Represents a GeneratedCodeInfo.
                 * @implements IGeneratedCodeInfo
                 * @constructor
                 * @param {google.protobuf.IGeneratedCodeInfo=} [properties] Properties to set
                 */
                function GeneratedCodeInfo(properties) {
                    this.annotation = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * GeneratedCodeInfo annotation.
                 * @member {Array.<google.protobuf.GeneratedCodeInfo.IAnnotation>} annotation
                 * @memberof google.protobuf.GeneratedCodeInfo
                 * @instance
                 */
                GeneratedCodeInfo.prototype.annotation = $util.emptyArray;
    
                /**
                 * Creates a new GeneratedCodeInfo instance using the specified properties.
                 * @function create
                 * @memberof google.protobuf.GeneratedCodeInfo
                 * @static
                 * @param {google.protobuf.IGeneratedCodeInfo=} [properties] Properties to set
                 * @returns {google.protobuf.GeneratedCodeInfo} GeneratedCodeInfo instance
                 */
                GeneratedCodeInfo.create = function create(properties) {
                    return new GeneratedCodeInfo(properties);
                };
    
                /**
                 * Encodes the specified GeneratedCodeInfo message. Does not implicitly {@link google.protobuf.GeneratedCodeInfo.verify|verify} messages.
                 * @function encode
                 * @memberof google.protobuf.GeneratedCodeInfo
                 * @static
                 * @param {google.protobuf.IGeneratedCodeInfo} message GeneratedCodeInfo message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                GeneratedCodeInfo.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.annotation != null && message.annotation.length)
                        for (var i = 0; i < message.annotation.length; ++i)
                            $root.google.protobuf.GeneratedCodeInfo.Annotation.encode(message.annotation[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified GeneratedCodeInfo message, length delimited. Does not implicitly {@link google.protobuf.GeneratedCodeInfo.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof google.protobuf.GeneratedCodeInfo
                 * @static
                 * @param {google.protobuf.IGeneratedCodeInfo} message GeneratedCodeInfo message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                GeneratedCodeInfo.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a GeneratedCodeInfo message from the specified reader or buffer.
                 * @function decode
                 * @memberof google.protobuf.GeneratedCodeInfo
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {google.protobuf.GeneratedCodeInfo} GeneratedCodeInfo
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                GeneratedCodeInfo.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.GeneratedCodeInfo();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1: {
                                if (!(message.annotation && message.annotation.length))
                                    message.annotation = [];
                                message.annotation.push($root.google.protobuf.GeneratedCodeInfo.Annotation.decode(reader, reader.uint32()));
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a GeneratedCodeInfo message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof google.protobuf.GeneratedCodeInfo
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {google.protobuf.GeneratedCodeInfo} GeneratedCodeInfo
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                GeneratedCodeInfo.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a GeneratedCodeInfo message.
                 * @function verify
                 * @memberof google.protobuf.GeneratedCodeInfo
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                GeneratedCodeInfo.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.annotation != null && message.hasOwnProperty("annotation")) {
                        if (!Array.isArray(message.annotation))
                            return "annotation: array expected";
                        for (var i = 0; i < message.annotation.length; ++i) {
                            var error = $root.google.protobuf.GeneratedCodeInfo.Annotation.verify(message.annotation[i]);
                            if (error)
                                return "annotation." + error;
                        }
                    }
                    return null;
                };
    
                /**
                 * Creates a GeneratedCodeInfo message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof google.protobuf.GeneratedCodeInfo
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {google.protobuf.GeneratedCodeInfo} GeneratedCodeInfo
                 */
                GeneratedCodeInfo.fromObject = function fromObject(object) {
                    if (object instanceof $root.google.protobuf.GeneratedCodeInfo)
                        return object;
                    var message = new $root.google.protobuf.GeneratedCodeInfo();
                    if (object.annotation) {
                        if (!Array.isArray(object.annotation))
                            throw TypeError(".google.protobuf.GeneratedCodeInfo.annotation: array expected");
                        message.annotation = [];
                        for (var i = 0; i < object.annotation.length; ++i) {
                            if (typeof object.annotation[i] !== "object")
                                throw TypeError(".google.protobuf.GeneratedCodeInfo.annotation: object expected");
                            message.annotation[i] = $root.google.protobuf.GeneratedCodeInfo.Annotation.fromObject(object.annotation[i]);
                        }
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a GeneratedCodeInfo message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof google.protobuf.GeneratedCodeInfo
                 * @static
                 * @param {google.protobuf.GeneratedCodeInfo} message GeneratedCodeInfo
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                GeneratedCodeInfo.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.annotation = [];
                    if (message.annotation && message.annotation.length) {
                        object.annotation = [];
                        for (var j = 0; j < message.annotation.length; ++j)
                            object.annotation[j] = $root.google.protobuf.GeneratedCodeInfo.Annotation.toObject(message.annotation[j], options);
                    }
                    return object;
                };
    
                /**
                 * Converts this GeneratedCodeInfo to JSON.
                 * @function toJSON
                 * @memberof google.protobuf.GeneratedCodeInfo
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                GeneratedCodeInfo.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                /**
                 * Gets the default type url for GeneratedCodeInfo
                 * @function getTypeUrl
                 * @memberof google.protobuf.GeneratedCodeInfo
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                GeneratedCodeInfo.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/google.protobuf.GeneratedCodeInfo";
                };
    
                GeneratedCodeInfo.Annotation = (function() {
    
                    /**
                     * Properties of an Annotation.
                     * @memberof google.protobuf.GeneratedCodeInfo
                     * @interface IAnnotation
                     * @property {Array.<number>|null} [path] Annotation path
                     * @property {string|null} [sourceFile] Annotation sourceFile
                     * @property {number|null} [begin] Annotation begin
                     * @property {number|null} [end] Annotation end
                     */
    
                    /**
                     * Constructs a new Annotation.
                     * @memberof google.protobuf.GeneratedCodeInfo
                     * @classdesc Represents an Annotation.
                     * @implements IAnnotation
                     * @constructor
                     * @param {google.protobuf.GeneratedCodeInfo.IAnnotation=} [properties] Properties to set
                     */
                    function Annotation(properties) {
                        this.path = [];
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * Annotation path.
                     * @member {Array.<number>} path
                     * @memberof google.protobuf.GeneratedCodeInfo.Annotation
                     * @instance
                     */
                    Annotation.prototype.path = $util.emptyArray;
    
                    /**
                     * Annotation sourceFile.
                     * @member {string} sourceFile
                     * @memberof google.protobuf.GeneratedCodeInfo.Annotation
                     * @instance
                     */
                    Annotation.prototype.sourceFile = "";
    
                    /**
                     * Annotation begin.
                     * @member {number} begin
                     * @memberof google.protobuf.GeneratedCodeInfo.Annotation
                     * @instance
                     */
                    Annotation.prototype.begin = 0;
    
                    /**
                     * Annotation end.
                     * @member {number} end
                     * @memberof google.protobuf.GeneratedCodeInfo.Annotation
                     * @instance
                     */
                    Annotation.prototype.end = 0;
    
                    /**
                     * Creates a new Annotation instance using the specified properties.
                     * @function create
                     * @memberof google.protobuf.GeneratedCodeInfo.Annotation
                     * @static
                     * @param {google.protobuf.GeneratedCodeInfo.IAnnotation=} [properties] Properties to set
                     * @returns {google.protobuf.GeneratedCodeInfo.Annotation} Annotation instance
                     */
                    Annotation.create = function create(properties) {
                        return new Annotation(properties);
                    };
    
                    /**
                     * Encodes the specified Annotation message. Does not implicitly {@link google.protobuf.GeneratedCodeInfo.Annotation.verify|verify} messages.
                     * @function encode
                     * @memberof google.protobuf.GeneratedCodeInfo.Annotation
                     * @static
                     * @param {google.protobuf.GeneratedCodeInfo.IAnnotation} message Annotation message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Annotation.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.path != null && message.path.length) {
                            writer.uint32(/* id 1, wireType 2 =*/10).fork();
                            for (var i = 0; i < message.path.length; ++i)
                                writer.int32(message.path[i]);
                            writer.ldelim();
                        }
                        if (message.sourceFile != null && Object.hasOwnProperty.call(message, "sourceFile"))
                            writer.uint32(/* id 2, wireType 2 =*/18).string(message.sourceFile);
                        if (message.begin != null && Object.hasOwnProperty.call(message, "begin"))
                            writer.uint32(/* id 3, wireType 0 =*/24).int32(message.begin);
                        if (message.end != null && Object.hasOwnProperty.call(message, "end"))
                            writer.uint32(/* id 4, wireType 0 =*/32).int32(message.end);
                        return writer;
                    };
    
                    /**
                     * Encodes the specified Annotation message, length delimited. Does not implicitly {@link google.protobuf.GeneratedCodeInfo.Annotation.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof google.protobuf.GeneratedCodeInfo.Annotation
                     * @static
                     * @param {google.protobuf.GeneratedCodeInfo.IAnnotation} message Annotation message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Annotation.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };
    
                    /**
                     * Decodes an Annotation message from the specified reader or buffer.
                     * @function decode
                     * @memberof google.protobuf.GeneratedCodeInfo.Annotation
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {google.protobuf.GeneratedCodeInfo.Annotation} Annotation
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Annotation.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.GeneratedCodeInfo.Annotation();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1: {
                                    if (!(message.path && message.path.length))
                                        message.path = [];
                                    if ((tag & 7) === 2) {
                                        var end2 = reader.uint32() + reader.pos;
                                        while (reader.pos < end2)
                                            message.path.push(reader.int32());
                                    } else
                                        message.path.push(reader.int32());
                                    break;
                                }
                            case 2: {
                                    message.sourceFile = reader.string();
                                    break;
                                }
                            case 3: {
                                    message.begin = reader.int32();
                                    break;
                                }
                            case 4: {
                                    message.end = reader.int32();
                                    break;
                                }
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Decodes an Annotation message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof google.protobuf.GeneratedCodeInfo.Annotation
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {google.protobuf.GeneratedCodeInfo.Annotation} Annotation
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Annotation.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };
    
                    /**
                     * Verifies an Annotation message.
                     * @function verify
                     * @memberof google.protobuf.GeneratedCodeInfo.Annotation
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    Annotation.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.path != null && message.hasOwnProperty("path")) {
                            if (!Array.isArray(message.path))
                                return "path: array expected";
                            for (var i = 0; i < message.path.length; ++i)
                                if (!$util.isInteger(message.path[i]))
                                    return "path: integer[] expected";
                        }
                        if (message.sourceFile != null && message.hasOwnProperty("sourceFile"))
                            if (!$util.isString(message.sourceFile))
                                return "sourceFile: string expected";
                        if (message.begin != null && message.hasOwnProperty("begin"))
                            if (!$util.isInteger(message.begin))
                                return "begin: integer expected";
                        if (message.end != null && message.hasOwnProperty("end"))
                            if (!$util.isInteger(message.end))
                                return "end: integer expected";
                        return null;
                    };
    
                    /**
                     * Creates an Annotation message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof google.protobuf.GeneratedCodeInfo.Annotation
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {google.protobuf.GeneratedCodeInfo.Annotation} Annotation
                     */
                    Annotation.fromObject = function fromObject(object) {
                        if (object instanceof $root.google.protobuf.GeneratedCodeInfo.Annotation)
                            return object;
                        var message = new $root.google.protobuf.GeneratedCodeInfo.Annotation();
                        if (object.path) {
                            if (!Array.isArray(object.path))
                                throw TypeError(".google.protobuf.GeneratedCodeInfo.Annotation.path: array expected");
                            message.path = [];
                            for (var i = 0; i < object.path.length; ++i)
                                message.path[i] = object.path[i] | 0;
                        }
                        if (object.sourceFile != null)
                            message.sourceFile = String(object.sourceFile);
                        if (object.begin != null)
                            message.begin = object.begin | 0;
                        if (object.end != null)
                            message.end = object.end | 0;
                        return message;
                    };
    
                    /**
                     * Creates a plain object from an Annotation message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof google.protobuf.GeneratedCodeInfo.Annotation
                     * @static
                     * @param {google.protobuf.GeneratedCodeInfo.Annotation} message Annotation
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    Annotation.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.arrays || options.defaults)
                            object.path = [];
                        if (options.defaults) {
                            object.sourceFile = "";
                            object.begin = 0;
                            object.end = 0;
                        }
                        if (message.path && message.path.length) {
                            object.path = [];
                            for (var j = 0; j < message.path.length; ++j)
                                object.path[j] = message.path[j];
                        }
                        if (message.sourceFile != null && message.hasOwnProperty("sourceFile"))
                            object.sourceFile = message.sourceFile;
                        if (message.begin != null && message.hasOwnProperty("begin"))
                            object.begin = message.begin;
                        if (message.end != null && message.hasOwnProperty("end"))
                            object.end = message.end;
                        return object;
                    };
    
                    /**
                     * Converts this Annotation to JSON.
                     * @function toJSON
                     * @memberof google.protobuf.GeneratedCodeInfo.Annotation
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    Annotation.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    /**
                     * Gets the default type url for Annotation
                     * @function getTypeUrl
                     * @memberof google.protobuf.GeneratedCodeInfo.Annotation
                     * @static
                     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                     * @returns {string} The default type url
                     */
                    Annotation.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                        if (typeUrlPrefix === undefined) {
                            typeUrlPrefix = "type.googleapis.com";
                        }
                        return typeUrlPrefix + "/google.protobuf.GeneratedCodeInfo.Annotation";
                    };
    
                    return Annotation;
                })();
    
                return GeneratedCodeInfo;
            })();
    
            return protobuf;
        })();
    
        return google;
    })();

    return $root;
});
